<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: Sequencable, Re-timable Animated &quot;Value Clips&quot;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_usd__page__value_clips.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Sequencable, Re-timable Animated "Value Clips" </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Usd_ValueClips_Overview"></a>
Overview</h1>
<p>USD's <a href="http://openusd.org/docs/USD-Glossary.html#USDGlossary-CompositionArcs">composition arcs</a> allow timeSampled animation to be assembled from a variety of sources into a single composition. However, because stage composition must not (for scalability) take time into account when "indexing" layers, the value resolution behavior we are able to provide for layers reached through composition arcs stipulates that the first (strongest) layer that contains <em>any</em> timeSample for an attribute is the source of <em>all</em> timeSamples for the attribute. For many uses of USD this is sufficient, and additionally flexible because each Reference and SubLayer can specify a constant <a class="el" href="class_sdf_layer_offset.html">time offset and scale</a> to be applied to the referenced or sublayered timeSamples. However, sometimes more flexibility is required!</p>
<p>The USD Value Clips feature allows users to decompose time-varying data across many layers that can then be sequenced and re-sequenced back together in flexible ways. This feature is purely a <a class="el" href="_usd__page__properties_of_scene_description.html#Usd_ValueResolution">value resolution</a> -level feature, not a composition-level feature. Value clips allow users to retime sequences in various ways. This allows users to reuse a set of value clips in different scenarios, with only the sequencing metadata changing. At Pixar, we have found value clips useful for efficiently animating medium to large crowds, and for representing very large, simulated effects. For more detail on these use cases, see the <a href="http://openusd.org/docs/USD-Glossary.html#USDGlossary-ValueClips">glossary entry for Value Clips</a>.</p>
<p>At a very high level, value clips consume special metadata on a <a class="el" href="class_usd_prim.html">prim</a>, indicating:</p><ul>
<li>the targeted "clip" layers (which are <a href="http://openusd.org/docs/USD-Glossary.html#USDGlossary-Asset">assets</a>) to be sequenced</li>
<li>the intervals over which each clip is active</li>
<li>how "stage time" maps into each clip</li>
</ul>
<h1><a class="anchor" id="Usd_ValueClips_Terminology"></a>
Terminology</h1>
<p>Before going further, let's establish some terminology:</p>
<ul>
<li><b>Value Clip</b>: An individual <a class="el" href="class_sdf_layer.html">layer</a> containing time varying data over some interval. <b>All metadata, relationships, and <a href="http://openusd.org/docs/USD-Glossary.html#USDGlossary-DefaultValue">default values</a> present in a layer are ignored when the layer is consumed as a Value Clip.</b></li>
<li><b>Clip Set</b>: A named set of value clips defined by a group of clip metadata. A prim may have multiple clip sets.</li>
<li><b>Clip Metadata</b>: A set of prim-level metadata which control USD's value resolution semantics.</li>
<li><b>Clip Manifest</b>: An individual layer that declares the attributes that have time samples in a clip set's value clips. An attribute must be declared in the manifest in order for value clips to be considered when resolving values for that attribute.</li>
<li><a class="anchor" id="Usd_ValueClips_AnchorPoint"></a><b>Anchor Point</b>: The strongest layer in which either <em>assetPaths</em> or <em>templateAssetPath</em> is authored for a given clip set. This determines the strength of clips with respect to value resolution, see <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_ClipValueResolution">Value Resolution Semantics</a> for details.</li>
</ul>
<h1><a class="anchor" id="Usd_ValueClips_ClipSets"></a>
Clip Sets</h1>
<p>A "clip set" is a named group of value clips. The set of value clips along with sequencing and timing information and other value resolution behaviors are specified in the clip set's definition metadata.</p>
<p>In this example, the prim "Prim" has two clip sets, "clip_set_1" and "clip_set_2", each with a different definition:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Prim&quot;</span> (</div><div class="line">    clips = {</div><div class="line">        dictionary clip_set_1 = {</div><div class="line">            double2[] active = [(101, 0), (102, 1), (103, 2)] </div><div class="line">            asset[] assetPaths = [@./clip1.usda@, @./clip2.usda@, @./clip3.usda@]</div><div class="line">            asset manifestAssetPath = @./clipset1.manifest.usda@</div><div class="line">            <span class="keywordtype">string</span> primPath = <span class="stringliteral">&quot;/ClipSet1&quot;</span></div><div class="line">            double2[] times = [(101, 101), (102, 102), (103, 103)]</div><div class="line">        }</div><div class="line">        dictionary clip_set_2 = {</div><div class="line">            <span class="keywordtype">string</span> templateAssetPath = <span class="stringliteral">&quot;clipset2.#.usd&quot;</span></div><div class="line">            <span class="keywordtype">double</span> templateStartTime = 101</div><div class="line">            <span class="keywordtype">double</span> templateEndTime = 103</div><div class="line">            <span class="keywordtype">double</span> templateStride = 1</div><div class="line">            asset manifestAssetPath = @./clipset2.manifest.usda@</div><div class="line">            <span class="keywordtype">string</span> primPath = <span class="stringliteral">&quot;/ClipSet2&quot;</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    clipSets = [<span class="stringliteral">&quot;clip_set_2&quot;</span>, <span class="stringliteral">&quot;clip_set_1&quot;</span>]</div><div class="line">)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p>The clip set definitions are stored in a dictionary-valued metadata field named "clips", which is composed according to the rules in <a class="el" href="_usd__page__datatypes.html#Usd_Dictionary_Type">Dictionary-valued Metadata</a>. This allows users to define clip sets in various layers and have them compose together, or sparsely override metadata in clip sets non-destructively.</p>
<p>Users can specify the clip set to author to when using the <a class="el" href="class_usd_clips_a_p_i.html" title="UsdClipsAPI is an API schema that provides an interface to a prim&#39;s clip metadata.">UsdClipsAPI</a> schema to author clip metadata. If no clip set is specified, <a class="el" href="class_usd_clips_a_p_i.html" title="UsdClipsAPI is an API schema that provides an interface to a prim&#39;s clip metadata.">UsdClipsAPI</a> will author to a clip set named "default".</p>
<h2><a class="anchor" id="Usd_ValueClips_ClipSetOrdering"></a>
Strength Ordering</h2>
<p>Clip sets authored on multiple prims are ordered by distance from the attribute. Clip sets authored on an attribute's owning prim are strongest, followed by those authored on the owning prim's parent, and so on.</p>
<p>Clip sets authored on a single prim are ordered lexicographically by name. However, users can control the strength ordering or even remove a clip set from consideration by specifying the ordering/membership in the <em>clipSets</em> list-op metadata field via <a class="el" href="class_usd_clips_a_p_i.html#ac37319b58182e22e3839308377cf9155">UsdClipsAPI::SetClipSets</a>.</p>
<h1><a class="anchor" id="Usd_ValueClips_Metadata"></a>
Clip Set Definitions</h1>
<p>Clip sets may be defined using one of two possible forms: <em>template</em> and <em>explicit</em> metadata. Explicit metadata encodes the exact assets and sequence timings. Template metadata, on the other hand, authors a regex-style asset path template, and infers the explicit metadata when a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> is opened. Template metadata is strictly less powerful than explicit metadata (it can't achieve behaviors such as looping, reversing, or holding clip data), but provides an extremely compact and easy to debug encoding for situations in which animation is broken up into a large number of regularly named files. Regardless of which form a value clip application takes, there are also a set of "universal" metadata common to both.</p>
<ul>
<li>Universal Clip Metadata<ul>
<li><em>primPath</em> <ul>
<li>A prim path (<a class="el" href="class_sdf_path.html">SdfPath</a>) that will be substituted for the stage prim's path when querying data in the clips. For instance, let's say clip metadata is authored on prim '/Prim_1', and <em>primPath</em> is '/Prim'. If we want to get values for the attribute '/Prim_1.size', we will substitute '/Prim' for '/Prim_1', yielding '/Prim.size'. This is the path that will be used to look for values in each clip.</li>
</ul>
</li>
<li><em>manifestAssetPath</em> <ul>
<li>An asset path (<a class="el" href="class_sdf_asset_path.html">SdfAssetPath</a>) representing the path to a layer that contains an index of the attributes with time samples authored in the set of clips. See <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_ClipManifest">Clip Manifest</a> for more details.</li>
</ul>
</li>
<li><em>interpolateMissingClipValues</em> <ul>
<li>A boolean flag indicating whether values for clips that do not have authored time samples for attributes in the manifest should be interpolated from surrounding clips. See <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_ClipValueResolution_InterpolatingGaps">Interpolating Missing Values in Clip Set</a> for more details.</li>
</ul>
</li>
</ul>
</li>
<li>Explicit Clip Metadata<ul>
<li><em>assetPaths</em> <ul>
<li>An ordered list of asset paths to the clips holding time varying data.</li>
</ul>
</li>
<li><em>active</em> <ul>
<li>A list of pairs of the form (stageTime, assetIndex) representing when a particular clip in <em>assetPaths</em> is active and should be considered during value resolution. See <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_ActiveClips">Active Clips</a> for more details.</li>
</ul>
</li>
<li><em>times</em> <ul>
<li>A list of pairs of the form (stageTime, clipTime) representing the mapping from stage time to clip time, for whichever clip is active at the given stage time. Note that every unique stageTime in this list will be in the list of time samples obtained by calling <a class="el" href="class_usd_attribute.html#a0aba275933a77f28ab44b750964aa9a2">UsdAttribute::GetTimeSamples()</a> . See <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_TimeMapping">Stage Times and Clip Times</a> for more details.</li>
</ul>
</li>
</ul>
</li>
<li>Template Clip Metadata<ul>
<li><em>templateAssetPath</em> <ul>
<li>A regex-esque template string representing the form of our asset paths' names. This can be of two forms: 'path/basename.###.usd' and 'path/basename.###.###.usd'. These represent integer stage times and sub-integer stage times respectively. In both cases the number of hashes in each section is variable, and indicates to USD how much padding to apply when looking for asset paths. Note that USD is strict about the format of this string: there must be exactly one or two groups of hashes, and if there are two, they must be adjacent, separated by a dot.</li>
</ul>
</li>
<li><em>templateStartTime</em> <ul>
<li>The (double precision float) first number to substitute into our template asset path. For example, given 'path/basename.###.usd' as a template string, and 12 as a template start time, USD will populate the internal asset path list with 'path/basename.012.usd' as its first element, if it resolves to a valid identifier through the active <a class="el" href="class_ar_resolver.html">ArResolver</a> . If the template asset path represents integer frames and the start time has a fractional component, USD will truncate this to an integer.</li>
</ul>
</li>
<li><em>templateEndTime</em> <ul>
<li>The (double precision float) last number to substitute into our template string. If the template asset path represents integer frames and the end time has a fractional component, USD will truncate this to an integer.</li>
</ul>
</li>
<li><em>templateStride</em> <ul>
<li>A (double precision float) number indicating the stride at which USD will increment when looking for files to resolve. For example, given a start time of 12, an end time of 25, a template string of 'path/basename.#.usd', and a stride of 6, USD will look to resolve the following paths: 'path/basename.12.usd', 'path/basename.18.usd' and 'path/basename.24.usd'.</li>
</ul>
</li>
<li><em>templateActiveOffset</em> <ul>
<li>An optional (double precision float) number indicating the offset USD will use when calculating the clipActive value.</li>
<li>Given a start time of 101, an endTime of 103, a stride of 1, and an offset of 0.5, USD will generate the following:<ul>
<li>times = [(100.5,100.5), (101,101), (102,102), (103,103), (103.5,103.5)]</li>
<li>active = [(101.5, 0), (102.5, 1), (103.5, 2)]</li>
</ul>
</li>
<li>Note that USD generates two additional clip time 'knots' on the ends of the clipTime array. This allows users to query time samples outside the start/end range based on the absolute value of their offset.</li>
<li>Note that templateActiveOffset cannot exceed the absolute value of templateStride.</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>In the case where both explicit clip metadata and template clip metadata are authored, USD will prefer the explicit metadata for composition.</dd></dl>
<p>USD provides schema level support for authoring this metadata via <a class="el" href="class_usd_clips_a_p_i.html">UsdClipsAPI</a>. This gives a typesafe way to interact with the relevant metadata as well as various helper functions.</p>
<h2><a class="anchor" id="Usd_ValueClips_Metadata_TemplateClips"></a>
Template Clip Metadata</h2>
<p>If a clip set is defined using template clip metadata, USD will use that data to derive the explicit clip metadata with the following logic:</p>
<ul>
<li>The set of explicit asset paths (<em>assetPaths</em>) is derived by taking the template pattern (<em>templateAssetPath</em>) and substituting times from <em>templateStartTime</em> to <em>templateEndTime</em>, incrementing by <em>templateStride</em>.</li>
<li>Once the set of relevant asset paths has been determined. The <em>times</em> and <em>active</em> metadata can be derived. For each time t specified in each derived assetPath, the time (t, t) will be authored; similarly, the active (t, n) will be authored, where n represents the index of the derived assetPath. If <em>templateActiveOffset</em> is specified, it will be applied to the <em>times</em> and <em>active</em> derivation as described in the previous section.</li>
</ul>
<h1><a class="anchor" id="Usd_ValueClips_ActiveClips"></a>
Active Clips</h1>
<p>The entries in the <em>active</em> metadata determine when a particular clip is active. Value resolution will retrieve values from the active clip at a given time.</p>
<p>A (stageTime, assetIndex) entry indicates that the clip in the <em>assetPaths</em> metadata at position <em>assetIndex</em> is active from time <em>stageTime</em> up to the <em>stageTime</em> of the next entry in the list. As special cases, the first clip in the <em>active</em> metadata is also considered active for all earlier times, and the last clip is considered active for all later times.</p>
<p>For example, given: </p><div class="fragment"><div class="line">asset[] assetPaths = [ \@foo.usd\@, \@bar.usd\@, \@baz.usd\@ ]</div><div class="line">double2[] active = [ (101, 0), (105, 1), (110, 2) ]</div></div><!-- fragment --><p>Clip "foo.usd" is considered active in the time range [-inf, 105), "bar.usd" is active in the time range [105, 110), and baz.usd is active in the time range [110, +inf).</p>
<h1><a class="anchor" id="Usd_ValueClips_TimeMapping"></a>
Stage Times and Clip Times</h1>
<p>Conceptually, the (stageTime, clipTime) entries in the <em>times</em> metadata define a timing curve that specifies the time in the active clip to retrieve samples from when requesting an attribute's value at a given stage time. This timing curve is made up of linear segments whose endpoints are specified by the entries in <em>times</em>, sorted by stageTime. (see <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_TimeOrdering">Ordering</a>)</p>
<p>For example, given this <em>times</em> metadata:</p>
<div class="fragment"><div class="line">double2[] times = [(0, 5), (10, 15)]</div></div><!-- fragment --><p>When an attribute value at time 0 is requested, <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> will retrieve the time sample value authored at time 5 in the active clip, and at time 10 <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> will ask for the value authored at time 15. As mentioned above, these entries are the endpoints for a linear segment in the timing curve, so times between these entries will be linearly interpolated. For example, requesting an attribute value at time 3 will cause <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> to ask for the value authored at time 8 in the active clip.</p>
<p>The <em>times</em> metadata can be used to offset and scale animation from clips, providing flexibility in how they are applied to the stage.</p>
<h2><a class="anchor" id="Usd_ValueClips_Discontinuities"></a>
Jump Discontinuities</h2>
<p>Jump discontinuities in the timing curve can be represented in the <em>times</em> metadata by authoring two entries with the same stage time, but different clip times. The clip time in the left-most entry is used for time mappings up to the specified stage time, while the clip time in the right-most entry is used for time mappings at that stage time and afterwards.</p>
<p>For example, let's say you had two clips and wanted to use animation from times 0 to 10 in the first clip followed by times 25 to 35 in the second clip. This could be specified with the <em>active</em> and <em>times</em> metadata like this:</p>
<div class="fragment"><div class="line">double2[] active = [(0, 0), (10, 1)]</div><div class="line">double2[] times = [(0, 0), (10, 10), (10, 25), (20, 35)]</div></div><!-- fragment --><p>A jump discontinuity has been specified at stage time 10. For times in the range [0, 10), <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> will retrieve values from the first clip at times [0, 10). For times in the range [10, 20], <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> will retrieve values from the second clip at times [25, 35].</p>
<p>See <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_ClipBehaviorsLooping">Looping</a> for a common use-case for this functionality.</p>
<h2><a class="anchor" id="Usd_ValueClips_TimeOrdering"></a>
Ordering</h2>
<p>A given stageTime may appear at most twice in the <em>times</em> metadata. In the typical case, a stageTime will only appear once; the only time it may appear twice is to specify a jump discontinuity (see <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_Discontinuities">Jump Discontinuities</a>).</p>
<p>USD will perform a stable sort of the <em>times</em> metadata by stageTime to establish the timing curve described above. This means the order of the entries authored in <em>times</em> does not matter, except for jump discontinuities: the left-most entry with a given stageTime represents the left side of the discontinuity and the right-most entry represents the right side.</p>
<h1><a class="anchor" id="Usd_ValueClips_ClipManifest"></a>
Clip Manifest</h1>
<p>The clip manifest is a <a class="el" href="class_sdf_layer.html">layer</a> that declares the attributes that have time samples in the value clips for the associated clip set. This serves as an index that allows value resolution to determine whether an attribute has time samples in a clip set without having to examine every value clip.</p>
<p>If a clip set's value clips contain data for an attribute, that attribute <em>must</em> be declared in the manifest. Otherwise, that data will be ignored.</p>
<p>Each clip set has one manifest which may be specified via the <em>manifestAssetPath</em> metadata. If no manifest is specified, USD will generate one automatically at runtime. See <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_GeneratingManifest">Generating a Manifest</a> for more details.</p>
<h2><a class="anchor" id="Usd_ValueClips_ManifestFormat"></a>
What Data Is In a Manifest?</h2>
<p>In its simplest form, the clip manifest just contains declarations for attributes. For example,</p>
<table class="doxtable">
<tr>
<th>Clip 1 </th><th>Clip 2  </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Model&quot;</span></div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> attr.timeSamples = {</div><div class="line">        0: 100</div><div class="line">    }</div><div class="line"></div><div class="line">    def <span class="stringliteral">&quot;Child&quot;</span></div><div class="line">    {</div><div class="line">        <span class="keywordtype">double</span> childAttr.timeSamples = {</div><div class="line">            0: 200</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment -->  </td><td><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Model&quot;</span></div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> attr.timeSamples = {</div><div class="line">        1: 200</div><div class="line">    }</div><div class="line"></div><div class="line">    def <span class="stringliteral">&quot;Child&quot;</span></div><div class="line">    {</div><div class="line">        <span class="keywordtype">double</span> childAttr.timeSamples = {</div><div class="line">            1: 300</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment -->   </td></tr>
<tr>
<th colspan="2">Manifest  </th></tr>
<tr>
<td colspan="2"><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Model&quot;</span></div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> attr</div><div class="line"></div><div class="line">    def <span class="stringliteral">&quot;Child&quot;</span></div><div class="line">    {</div><div class="line">        <span class="keywordtype">double</span> childAttr</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment -->  <p class="endtd"></p>
</td></tr>
</table>
<p>Like value clips, metadata, relationships, and composition arcs in the manifest are ignored. Attributes in the manifest may have default values or time samples containing value blocks. See <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_ClipValueResolution">Value Resolution Semantics</a> for how these values may be used.</p>
<h2><a class="anchor" id="Usd_ValueClips_GeneratingManifest"></a>
Generating a Manifest</h2>
<p>The Usd and Sdf authoring APIs can be used to manually create a manifest. For convenience, clients can use <a class="el" href="class_usd_clips_a_p_i.html#a308ef3fe936c3a5ac968082041c10370">UsdClipsAPI::GenerateClipManifest</a> or <a class="el" href="class_usd_clips_a_p_i.html#a674432c0e7a2771436d5f4c55aa5e45d">UsdClipsAPI::GenerateClipManifestFromLayers</a> to generate a manifest from a given clip set or set of clip layers.</p>
<p>If a clip set does not have a manifest specified, USD will automatically generate a manifest at runtime from the value clips in the clip set using the methods described above. This is convenient but imposes the extra cost of opening and traversing every clip layer. To avoid this cost, you can use the <a class="el" href="class_usd_clips_a_p_i.html" title="UsdClipsAPI is an API schema that provides an interface to a prim&#39;s clip metadata.">UsdClipsAPI</a> methods above to generate a clip manifest, save it out, and then set that as the clip set's manifest via UsdClipsAPI::SetManifestAssetPath.</p>
<h1><a class="anchor" id="Usd_ValueClips_ClipValueResolution"></a>
Value Resolution Semantics</h1>
<p>A clip set may provide values for attributes on the prim on which the clip set is defined and any attributes on descendants of that prim. It is important to note that value clips do <em>not</em> define attributes on a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>, they just provide values. If a clip set has values for an attribute but that attribute is not defined on the <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> (for example, the attribute is not a built-in attribute of a schema), the clip set will not cause the attribute to come into existence.</p>
<p>The <em>strength</em> of data in a set of value clips is based on the <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_AnchorPoint">anchor point</a>. The clip data is just weaker than the "Local" (L in <a href="http://openusd.org/docs/USD-Glossary.html#USDGlossary-LIVRPSStrengthOrdering">LIVRPS</a>) data of the anchoring layer. Clip data can be overridden by adding overrides to a stronger layer or in a local opinion, just as for any other kind of data.</p>
<p>During attribute value resolution, if clip sets are defined on the attribute's owning prim or any ancestors, USD will do the following:</p>
<ul>
<li>Determine the path we will consult within clip layers when looking for values. The path will be constructed using the attribute's path within the local LayerStack, with a prefix substitution based on the clipset's <em>primPath</em> metadata. <b>Please note that this implies that composition arcs are ignored within clip files, i.e. all data must be recorded directly, not inside variants or across reference arcs.</b></li>
<li>Find the strongest clip set that has the attribute at the above path declared in the manifest. This involves looking at the clip sets authored on the attribute's owning prim as well as that prim's ancestors. See <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_ClipSetOrdering">Strength Ordering</a> for more details.</li>
<li>If no clip set is found, end clip value resolution and move to the next data source in the LIVRPS strength ordering.</li>
<li>Query the clip set for the attribute value at the specified time. This "external" time will be mapped to the "internal" time of the clip set using the <em>times</em> metadata. The active clip will be opened and queried using this "internal" time. See <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_ActiveClips">Active Clips</a> and <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_TimeMapping">Stage Times and Clip Times</a> for more details.</li>
<li>If an authored time sample at the "internal" time is found in the active clip, that is the final value. If there is no sample at that time, but there are other samples in the active time range of the clip, the final value will be interpolated from those samples. See <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_ClipValueResolution_Gaps">Missing Values in Clip Set</a> and <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_ClipValueResolution_InterpolatingGaps">Interpolating Missing Values in Clip Set</a> for the behavior when the active clip does not have any authored time samples.</li>
</ul>
<h2><a class="anchor" id="Usd_ValueClips_ClipValueResolution_Gaps"></a>
Missing Values in Clip Set</h2>
<p>A clip set has "gaps" if some of the value clips in the set do not contain authored time samples for an attribute that has been declared in the manifest.</p>
<p>By default, if a value clip does not contain time samples for an attribute, a time sample at the clip's <em>active</em> time will be generated using the default value for the attribute authored in the clip manifest. If no default value has been authored, the fallback value for the attribute's data type will be a value block.</p>
<p>In the example below, the value for /TestModel.a at time 2 will be 10.0 since clip2.usd does not have time samples for this attribute and 10.0 is the default value authored in the manifest. The value for /TestModel.b at time 2 will be a value block, since no default is authored in the manifest.</p>
<table class="doxtable">
<tr>
<th>clip1.usd </th><th>clip2.usd </th><th>clip3.usd  </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Model&quot;</span></div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> a.timeSamples = {</div><div class="line">        1: 1</div><div class="line">    }</div><div class="line">    <span class="keywordtype">double</span> b.timeSamples = {</div><div class="line">        1: 1</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment -->  </td><td><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Model&quot;</span></div><div class="line">{</div><div class="line">}</div></div><!-- fragment -->  </td><td><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Model&quot;</span></div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> a.timeSamples = {</div><div class="line">        3: 3</div><div class="line">    }</div><div class="line">    <span class="keywordtype">double</span> b.timeSamples = {</div><div class="line">        3: 3</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment -->   </td></tr>
<tr>
<th colspan="3">manifest.usd  </th></tr>
<tr>
<td colspan="3"><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Model&quot;</span></div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> a = 10.0</div><div class="line">    <span class="keywordtype">double</span> b</div><div class="line">}</div></div><!-- fragment -->   </td></tr>
<tr>
<th colspan="3">stage.usd  </th></tr>
<tr>
<td colspan="3"><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;TestModel&quot;</span> (</div><div class="line">    clips = {</div><div class="line">        dictionary <span class="keywordflow">default</span> = {</div><div class="line">            double2[] active = [(1, 0), (2, 1), (3, 2)]</div><div class="line">            asset[] assetPaths = [@./clip1.usd@, @./clip2.usd@, @./clip3.usd@]</div><div class="line">            asset manifestAssetPath = @./manifest.usd@</div><div class="line">            <span class="keywordtype">string</span> primPath = <span class="stringliteral">&quot;/Model&quot;</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">)</div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> a</div><div class="line">    <span class="keywordtype">double</span> b</div><div class="line">}</div></div><!-- fragment -->   </td></tr>
</table>
<h2><a class="anchor" id="Usd_ValueClips_ClipValueResolution_InterpolatingGaps"></a>
Interpolating Missing Values in Clip Set</h2>
<p>The above behavior allows USD to avoid opening an arbitrary number of clips if a gap is encountered in the clip set and can be useful in some situations. For example, see <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_AnimatedVisibility">Animated Visibility</a>. However, in these cases USD can also optionally interpolate values based on the surrounding clips. This makes value clips behave like time samples split up into different files, which is more intuitive but comes at a performance cost.</p>
<p>This feature can be enabled for a clip set by setting <em>interpolateMissingClipValues</em> to true in a clip set definition. When enabled, if a query is made at a time when the clip set has a gap, and the attribute does not have a default value specified in the manifest, USD will search forward and backwards from the active clip at that time to find the nearest clips that contain authored time sample values. The final value will be interpolated from these time samples.</p>
<p>Note that in the pessimal case, this may wind up opening and querying all clips in the set. To accelerate this search, users can author time sample blocks in the manifest at the active time for each clip that does not have time samples for a given attribute. Value resolution will use this information to determine what clips have time samples without actually opening the clips themselves.</p>
<p>In the example below, the value for /TestModel.a at time 2 will be 2.0, which is interpolated from the time sample in clip1.usd at time 1 and the time sample in clip4.usd at time 4. Similarly, the value at time 3 will be 3.0. If <em>interpolateMissingClipValues</em> was not set to true, these values would be a value block instead.</p>
<table class="doxtable">
<tr>
<th>clip1.usd </th><th>clip2.usd / clip3.usd </th><th>clip4.usd  </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Model&quot;</span></div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> a.timeSamples = {</div><div class="line">        1: 1</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment -->  </td><td><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Model&quot;</span></div><div class="line">{</div><div class="line">}</div></div><!-- fragment -->  </td><td><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Model&quot;</span></div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> a.timeSamples = {</div><div class="line">        4: 4</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment -->   </td></tr>
<tr>
<th colspan="3">manifest.usd  </th></tr>
<tr>
<td colspan="3"><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Model&quot;</span></div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> a.timeSamples = {</div><div class="line">        2: None,</div><div class="line">        3: None</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment -->   </td></tr>
<tr>
<th colspan="3">stage.usd  </th></tr>
<tr>
<td colspan="3"><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;TestModel&quot;</span> (</div><div class="line">    clips = {</div><div class="line">        dictionary <span class="keywordflow">default</span> = {</div><div class="line">            double2[] active = [(1, 0), (2, 1), (3, 2), (4, 3)]</div><div class="line">            asset[] assetPaths = [@./clip1.usd@, @./clip2.usd@, @./clip3.usd@, @./clip4.usd@]</div><div class="line">            asset manifestAssetPath = @./manifest.usd@</div><div class="line">            <span class="keywordtype">string</span> primPath = <span class="stringliteral">&quot;/Model&quot;</span></div><div class="line">            <span class="keywordtype">bool</span> interpolateMissingClipValues = <span class="keyword">true</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">)</div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> a</div><div class="line">}</div></div><!-- fragment -->   </td></tr>
</table>
<h2><a class="anchor" id="Usd_ValueClips_ClipValueResolution_LayerOffsets"></a>
Layer Offsets</h2>
<p>Layer offsets affect value clips in the following ways:</p>
<ul>
<li>If using template metadata encoding:<ul>
<li>Layer offsets are applied to generated times and active metadata relative to the <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_AnchorPoint">anchor point</a>. Note that layer offsets will <em>not</em> affect the generated set of asset paths, as they are not applied to <em>templateStartTime</em>, <em>templateEndTime</em> and <em>templateStride</em>.</li>
</ul>
</li>
<li>If using explicit metadata encoding:<ul>
<li>Layer offsets are applied to <em>times</em> and <em>active</em> metadata relative to the strongest layer in which they were authored. Note that this layer may be different from the <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_AnchorPoint">anchor point</a>.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="Usd_ValueClips_AdditionalNotes"></a>
Additional Notes</h1>
<p>The flexibility and reuse of animated data that clips provides does come with some performance characteristics with which pipeline builders may want to be familiar.</p>
<h2><a class="anchor" id="Usd_ValueClips_ClipDeferredLoading"></a>
Clip Layers Opened On-Demand</h2>
<p>In Pixar use of clips, it is not uncommon for a single <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> to consume thousands to tens of thousands of clip layers. If the act of opening a stage were to discover and open all of the layers consumed by clips, it would, in these cases, add considerable time and memory to the cost. Further, many clients of the stage (such as a single-frame render) only require data from a small time range, which generally translates to a small fraction of the total number of clip layers. Therefore, clip layers are opened lazily, <em>only</em> when value resolution must interrogate a particular clip. Of course, since USD supports value resolution in multiple threads concurrently, it means that resolving attributes affected by clips may require acquiring a lock that is unnecessary during "normal" value resolution, so there is some performance penalty.</p>
<p>Further, the broader the time interval over which an application extracts attribute values, the more layers that will be opened and cached (until the stage is closed). We deem this an acceptable cost since it is in keeping with our general principle of paying for what you use. The alternative would be adding a more sophisticated caching strategy to clip-layer retention that limits the number of cached layers; however, since the most memory-conscious clients (renderers) are generally unaffected, and the applications that do want to stream through time generally prioritize highest performance over memory consumption, we are satisfied with the caching strategy for now.</p>
<h2><a class="anchor" id="Usd_ValueClips_Flattening"></a>
Flattening</h2>
<p>Flattening a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> with value clips will merge the appropriate time samples from the value clips into the time samples on the attribute on the flattened stage and remove the clip set definitions. Querying for time samples and values on the flattened stage should always give the same result as on the unflattened stage.</p>
<h2><a class="anchor" id="Usd_ValueClips_usdview"></a>
usdview</h2>
<ul>
<li>Usdview supports value clip debugging through the layer stack viewer(lower left). When a particular attribute(who's value is held in a clip layer) is highlighted, the layer stack viewer will show which clip the value is coming from.</li>
<li>The metadata tab will display the value of each piece of metadata authored on the prim introducing clips.</li>
</ul>
<h2><a class="anchor" id="Usd_ValueClips_usdstitchclips"></a>
usdstitchclips</h2>
<p>The usdstitchclips utility will generate a stage that uses value clips to stitch together the time samples in a given set of clip layers. This utility will generate the necessary clip set definitions (using either explicit or template metadata) and also generate a topology layer defining the attributes and a manifest layer.</p>
<p>For example, given a directory containing three clip files clip.101.usd, clip.102.usd and clip.103.usd:</p>
<div class="fragment"><div class="line">$ usdstitchclips --clipPath /World/model --out result.usda clip*</div></div><!-- fragment --><p>Will generate the following result.usda: </p><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line">(</div><div class="line">    endTimeCode = 103</div><div class="line">    startTimeCode = 101</div><div class="line">    subLayers = [</div><div class="line">        @./result.topology.usda@</div><div class="line">    ]</div><div class="line">)</div><div class="line"></div><div class="line">over <span class="stringliteral">&quot;World&quot;</span> </div><div class="line">{</div><div class="line">    over <span class="stringliteral">&quot;model&quot;</span> (</div><div class="line">        clips = {</div><div class="line">            dictionary <span class="keywordflow">default</span> = {</div><div class="line">                double2[] active = [(101, 0), (102, 1), (103, 2)]</div><div class="line">                asset[] assetPaths = [@./101.usd@, @./102.usd@, @./103.usd@]</div><div class="line">                asset manifestAssetPath = @./result.topology.usda@</div><div class="line">                <span class="keywordtype">string</span> primPath = <span class="stringliteral">&quot;/World/model&quot;</span></div><div class="line">                double2[] times = [(101, 101), (102, 102), (103, 103)]</div><div class="line">            }</div><div class="line">        }</div><div class="line">    )</div><div class="line">    {</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>and the following result.topology.usd: </p><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line">(</div><div class="line">    endTimeCode = 103</div><div class="line">    startTimeCode = 101</div><div class="line">    upAxis = <span class="stringliteral">&quot;Z&quot;</span></div><div class="line">)</div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;World&quot;</span></div><div class="line">{</div><div class="line">    def <span class="stringliteral">&quot;model&quot;</span></div><div class="line">    {</div><div class="line">        <span class="keywordtype">int</span> x</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>For generating template metadata:</p>
<div class="fragment"><div class="line">$ usdstitchclips --clipPath /World/model </div><div class="line">                 --templateMetadata</div><div class="line">                 --startTimeCode 101</div><div class="line">                 --endTimeCode 103</div><div class="line">                 --stride 1</div><div class="line">                 --templatePath clip.#.usd</div><div class="line">                 --out result.usda clip* </div></div><!-- fragment --><p>Will generate the following result.usda: </p><div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line">(</div><div class="line">    endTimeCode = 103</div><div class="line">    startTimeCode = 101</div><div class="line">    subLayers = [</div><div class="line">        @./result.topology.usda@</div><div class="line">    ]</div><div class="line">)</div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;World&quot;</span> </div><div class="line">{</div><div class="line">    over <span class="stringliteral">&quot;model&quot;</span> (</div><div class="line">        clips = {</div><div class="line">            dictionary <span class="keywordflow">default</span> = {</div><div class="line">                <span class="keywordtype">string</span> templateAssetPath = <span class="stringliteral">&quot;clip.#.usd&quot;</span></div><div class="line">                <span class="keywordtype">double</span> templateStartTime = 101</div><div class="line">                <span class="keywordtype">double</span> templateEndTime = 103</div><div class="line">                <span class="keywordtype">double</span> templateStride = 1</div><div class="line">                asset manifestAssetPath = @./result.topology.usda@</div><div class="line">                <span class="keywordtype">string</span> primPath = <span class="stringliteral">&quot;/World/model&quot;</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    )</div><div class="line">    {</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Usd_ValueClips_UsdUtils"></a>
UsdUtils Utility Functions</h2>
<p>The UsdUtils library contains several utility functions for stitching together multiple layers using value clips in <a class="el" href="stitch_clips_8h.html" title="Collection of utilities for sequencing multiple layers each holding sequential time-varying data into...">usdUtils/stitchClips.h</a>.</p>
<h1><a class="anchor" id="Usd_ValueClips_Examples"></a>
Examples</h1>
<h2><a class="anchor" id="Usd_ValueClips_ClipBehaviorsLooping"></a>
Looping</h2>
<p>A common use case is to loop over animation authored in a clip or set of clips. For example, at Pixar clips containing a handful of frames of keep-alive animation are applied to background characters with looping so they remain in motion throughout an entire shot.</p>
<p>Looping can be specified using the <em>times</em> metadata and jump discontinuities (see <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_TimeMapping">Stage Times and Clip Times</a>) This example shows 25 frames of animation from a clip being looped on the <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> from time 0 to 25, then 25 to 50.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line">(</div><div class="line">    endTimeCode = 50</div><div class="line">    startTimeCode = 1</div><div class="line">    subLayers = [</div><div class="line">        @./shot.topology.usd@</div><div class="line">    ]</div><div class="line">)</div><div class="line"></div><div class="line">over <span class="stringliteral">&quot;World&quot;</span> </div><div class="line">{</div><div class="line">    over <span class="stringliteral">&quot;Model&quot;</span> (</div><div class="line">        clips = {</div><div class="line">            dictionary <span class="keywordflow">default</span> = {</div><div class="line">                asset manifestAssetPath = @./shot.manifest.usd@</div><div class="line">                <span class="keywordtype">string</span> primPath = <span class="stringliteral">&quot;/World/Model&quot;</span></div><div class="line">                asset[] assetPaths = [@./clip1.usd@]</div><div class="line">                double2[] active = [(0, 0]</div><div class="line">                double2[] times = [(0, 0), (25, 25), (25, 0), (50, 25)]</div><div class="line">            }</div><div class="line">        }</div><div class="line">    )</div><div class="line">    {</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>For proper looping, we want the <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> to retrieve animation at all times in the range [0, 25) from the clip at times [0, 25). However, at exactly time 25 we want the <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> to jump back to using animation in the clip at time 0. This is represented by a jump discontinuity at time 25. (See <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_Discontinuities">Jump Discontinuities</a> for more details.)</p>
<p>Note that we were able to achieve this solely through the metadata. No additional asset loads or restructuring needed to happen.</p>
<dl class="section warning"><dt>Warning</dt><dd>Note that this supposes that the final frame and the first frame of the clip transitions smoothly.</dd></dl>
<h2><a class="anchor" id="Usd_ValueClips_AnimatedVisibility"></a>
Animated Visibility</h2>
<p>Value clips are used at Pixar to stitch together the results of simulators or procedural generation tools like Houdini that are run in parallel for each frame of a shot or effect. There are often situations where geometry data (e.g. points) are generated for some of the frames but not others. In these cases we would like to set the "visibility" attribute to "invisible" at the times where no geometry was generated. However, since the processes for these times didn't generate any geometry and are being run independently from the other times, they don't know where to author the "visibility" attribute to achieve this.</p>
<p>To solve this, we use the fact that value clips will use the default value authored in the manifest if no value is authored in a clip. (See <a class="el" href="_usd__page__value_clips.html#Usd_ValueClips_ClipValueResolution_Gaps">Missing Values in Clip Set</a>). In the manifest, we author a default value of "invisible" for the "visibility" attribute. Then, if the processes that generate the value clips write out any geometry data, they also write out a time sample for the "visibility" attribute making the prim visible at that time. If they do not write out geometry, they don't write out the "visibility" attribute. This makes value resolution use the "invisible" value for "visibility" at times when the clips have no geometry. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="usd_page_front.html">Usd : Universal Scene Description (Core)</a></li><li class="navelem"><a class="el" href="_usd__page__advanced_features.html">Advanced Scenegraph Scalability Features</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:57 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>