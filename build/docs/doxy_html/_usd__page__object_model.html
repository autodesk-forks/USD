<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: Object Model and How the Classes Work Together</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_usd__page__object_model.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Object Model and How the Classes Work Together </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Usd_OM_SdfLayer"></a>
SdfLayer: Shared Data Files</h1>
<p>An <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> provides the interface to a persistent (in a file) or in-memory only (via "anonymous" layers) container of scene description. The scene description contained in a layer consists of prims, attributes, relationships, user-metadata on all of the above, and composition operators that specify how the contained scene description should be composed with scene description in other files.</p>
<p>If working directly with an <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a>, clients should be aware that Sdf maintains an internal registry of layers that clients have requested to be opened via <a class="el" href="class_sdf_layer.html#aa01062bf4dde3f28c1fc617a1acaf35e" title="Return an existing layer with the given identifier and args, or else load it.">SdfLayer::FindOrOpen()</a>, <a class="el" href="class_sdf_layer.html#aad57cd44403a4f95a2bb6c730fa1b0f5" title="Creates a new empty layer with the given identifier.">SdfLayer::CreateNew()</a> or <a class="el" href="class_sdf_layer.html#a863d3cfd8e7c4bbee08f067978e9738e" title="Creates a new anonymous layer with an optional tag.">SdfLayer::CreateAnonymous()</a>. The registry holds only weak pointers (SdfLayerHandle) to the layers it caches, so it is the client's responsibility to retain the strong SdfLayerRefPtr that the above methods return, if they expect the layer to persist. <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> takes care of this for the layer for which the stage was opened, and all layers reached during the process of population the stage by traversing composition arcs; the set of "reached" layers may be different for different variant selections on the stage, different activation opinions, and different load-states.</p>
<dl class="section note"><dt>Note</dt><dd><b>USDeeper: Layer-related plugins</b> Sdf also defines the <a class="el" href="class_sdf_file_format.html" title="Base class for file format implementations.">SdfFileFormat</a> plugin mechanism that provides a file-extension-based extensible registry of plugins that can either generate a layer's worth of scene description procedurally, or translate a different file format into USD's data model and relevant schemas "on the fly". Sdf also uses the Ar Asset Resolution plugin API to resolve layer identifiers to external (e.g. file) assets. The Ar plugin API lets USD clients provide customized behavior for resolving "asset identifiers" and querying asset metadata.</dd></dl>
<h1><a class="anchor" id="Usd_OM_UsdStage"></a>
UsdStage: Composed View of an SdfLayer</h1>
<p>As described in its class documentation, a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> is the interface to a specific <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> (known as its <em>rootLayer</em>), interpreting the data it contains through the composition rules provided by Pcp. Pcp informs the <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> about which <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> s should be populated on the stage, and provides <a class="el" href="class_pcp_prim_index.html" title="PcpPrimIndex is an index of the all sites of scene description that contribute opinions to a specific...">PcpPrimIndex</a> objects, per-prim, which allow usd to perform efficient <a class="el" href="_usd__page__properties_of_scene_description.html#Usd_ValueResolution">value resolution</a>.</p>
<p>The primary client-facing aspect and purpose of a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> is that it creates and maintains (as new scene description is authored or mutated) a scenegraph of <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> s that enables efficient scene traversal, data extraction and authoring. A <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> can contain any number of "root level" prims, each of which represents a different tree/graph (which may be related to each other via composition operators or <a class="el" href="_usd__page__object_model.html#Usd_OM_UsdRelationship">relationships</a>). To facilitate traversals that visit all root prims, every <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> has an un-named "pseudo-root" prim that is the parent of all root prims; it can be accessed via <a class="el" href="class_usd_stage.html#a5567a555616cd3bf5fd2fc787f31accc" title="Return the stage&#39;s &quot;pseudo-root&quot; prim, whose name is defined by Usd.">UsdStage::GetPseudoRoot()</a>.</p>
<p>An important property of the stage is that it always presents the accurate, fully-composed view of the data in its underlying <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> s. This has impact on <a class="el" href="_usd__page__authoring_editing.html">Authoring and Editing Scene Description</a> , and implies that a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> may perform a potentially substantial amount of work in "recomposing" a scene in response to certain kinds of authoring operations, namely the authoring of composition operators. For example, when one adds a reference to a prim using <a class="el" href="class_usd_references.html" title="UsdReferences provides an interface to authoring and introspecting references in Usd.">UsdReferences</a>, the stage on which the prim sits will immediately pull in the scene topology information from the referenced <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a>, and repopulate the affected parts of the stage. Something similar occurs even when one changes a variant selection on an existing <a class="el" href="class_usd_variant_set.html" title="A UsdVariantSet represents a single VariantSet in USD (e.g.">UsdVariantSet</a>.</p>
<dl class="section note"><dt>Note</dt><dd><b>USDeeper: Editing Layers Updates Stage.</b> <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> recomposes in response to mutations of <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> 's that are composed into the stage. Thus, a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> will remain accurate even if one uses the lower-level Sdf API's to mutate layers, rather than the USD object API's.</dd></dl>
<h2><a class="anchor" id="Usd_OM_UsdStage_Management"></a>
UsdStage Lifetime and Management</h2>
<p><a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> and <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> are the only objects in USD whose lifetime matters. <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> is the true data container in USD, and if a layer is destroyed before its contents are explicitly serialized (<a class="el" href="class_sdf_layer.html#ad5a54175a9d67b72094f8fdf3e83c9d9" title="Returns true if successful, false if an error occurred.">SdfLayer::Save()</a>, <a class="el" href="class_sdf_layer.html#aef819927fc1ad0d6fc5ad5fefb58dcdf" title="Exports this layer to a file.">SdfLayer::Export()</a>), then data may be lost. If a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> is destroyed, it will drop its retention of all of the <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> s it composes; if that results in a layer-with-changes' refcount to drop to zero, the layer will be destroyed.</p>
<p>Like <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a>, <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> is also managed by strong and weak pointers; all stage-creation methods return a UsdStageRefPtr for the client to retain. UsdStages <em>can</em> also be managed in a registry, known as a <a class="el" href="class_usd_stage_cache.html" title="A strongly concurrency safe collection of UsdStageRefPtr s, enabling sharing across multiple clients ...">UsdStageCache</a>. Unlike the <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> registry, however:</p>
<ul>
<li>There isn't a core, global singleton registry - clients can make as many <a class="el" href="class_usd_stage_cache.html" title="A strongly concurrency safe collection of UsdStageRefPtr s, enabling sharing across multiple clients ...">UsdStageCache</a> registries as they need. UsdUtils does provide a singleton that clients can opt to use, if a single, known registry is appropriate. This is useful in scenarios where multiple, collaborating subsystems in a process each need to access data directly from USD, but have estabished API that cannot be perturbed to pass a UsdStagePtr back and forth.</li>
</ul>
<ul>
<li><a class="el" href="class_usd_stage_cache.html" title="A strongly concurrency safe collection of UsdStageRefPtr s, enabling sharing across multiple clients ...">UsdStageCache</a> <em>does</em> retain a strong reference to each of the stages it collects, and the cache can be explicitly cleared.</li>
</ul>
<h1><a class="anchor" id="Usd_OM_UsdPrim"></a>
UsdPrim: Nestable Namespace Containers</h1>
<p><a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> is the primary object used to interact with composed scene description, and has the largest API of any of the core objects. A <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> represents a <b>unique</b> "namespace location" in a hierarchical composition on a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>.</p>
<p>Each <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> can contain <a class="el" href="_usd__page__object_model.html#Usd_OM_UsdProperty">properties</a> and child <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a>'s, which is what allows us to build hierarchies. If the following usd example were opened on a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>: </p><div class="fragment"><div class="line">#usda 1.0</div><div class="line"></div><div class="line">def &quot;World&quot;</div><div class="line">{</div><div class="line">    def &quot;Sets&quot;</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">    over &quot;Fx&quot;</div><div class="line">    {</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> then we would be able to access the <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a>'s on the stage, like so: </p><div class="fragment"><div class="line"><span class="comment">// SdfPath identifiers can be constructed most efficiently by using SdfPath</span></div><div class="line"><span class="comment">// API to build up the path incrementally; however, they can always also </span></div><div class="line"><span class="comment">// be constructed from a full string representation; we demonstrate both forms.</span></div><div class="line"><a class="code" href="class_sdf_path.html">SdfPath</a> worldPath = <a class="code" href="class_sdf_path.html">SdfPath</a>(<span class="stringliteral">&quot;/World&quot;</span>);</div><div class="line"><a class="code" href="class_usd_prim.html">UsdPrim</a> world = stage-&gt;<a class="code" href="class_usd_prim.html#a6ceb556070804b712c01a7968f925735">GetPrimAtPath</a>(worldPath);</div><div class="line"><a class="code" href="class_usd_prim.html">UsdPrim</a> sets  = stage-&gt;<a class="code" href="class_usd_prim.html#a6ceb556070804b712c01a7968f925735">GetPrimAtPath</a>(worldPath.<a class="code" href="class_sdf_path.html#ab38c801f846f5eda9934f7306a0ba229">AppendChild</a>(<a class="code" href="class_tf_token.html">TfToken</a>(<span class="stringliteral">&quot;Sets&quot;</span>)));</div><div class="line"><a class="code" href="class_usd_prim.html">UsdPrim</a> fx    = stage-&gt;<a class="code" href="class_usd_prim.html#a6ceb556070804b712c01a7968f925735">GetPrimAtPath</a>(worldPath.<a class="code" href="class_sdf_path.html#ab38c801f846f5eda9934f7306a0ba229">AppendChild</a>(<a class="code" href="class_tf_token.html">TfToken</a>(<span class="stringliteral">&quot;Fx&quot;</span>)));</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><b>USDeeper: def vs over?</b> You may have noticed in the example above that the prims &lt;/World&gt; and &lt;/World/Sets&gt; were declared as <b>def</b>, while &lt;/World/Fx&gt; was declared as <b>over</b>. "def" and "over" are two of the three possible "prim specifiers" that inform USD of the intended purpose of the data authored for a prim in a particular layer. For a deeper explanation, please see <a class="el" href="_usd__page__properties_of_scene_description.html#Usd_PrimSpecifiers">Defs, Overs, Classes, and Prim Types</a> .</dd></dl>
<h2><a class="anchor" id="Usd_OM_UsdPrim_Retention"></a>
Retaining and Using UsdPrims Safely</h2>
<h1><a class="anchor" id="Usd_OM_UsdProperty"></a>
UsdProperty: Common Interface for Attributes and Relationships</h1>
<h1><a class="anchor" id="Usd_OM_UsdAttribute"></a>
UsdAttribute: Typed, Sampled, Data</h1>
<h2><a class="anchor" id="Usd_OM_UsdTimeCode"></a>
Time and Timing in USD</h2>
<h1><a class="anchor" id="Usd_OM_UsdRelationship"></a>
UsdRelationship: Targetting Namespace Objects</h1>
<h1><a class="anchor" id="Usd_OM_Metadata"></a>
General Metadata in USD</h1>
<p>All of the objects we have described so far, <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a>, <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>, <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a>, and both subclasses of <a class="el" href="class_usd_property.html" title="Base class for UsdAttribute and UsdRelationship scenegraph objects.">UsdProperty</a>, can possess <em>metadata</em>. In USD, metadata serves several critical roles for describing object behavior and meaning, and is defined by the following properties:</p>
<ul>
<li><em>Metadata is strongly typed</em>, and can possess a fallback value. Both of these pieces of information can be retrieved, using the metadatum's name, from the <a class="el" href="class_sdf_schema.html" title="Class that provides information about the various scene description fields.">SdfSchema</a> singleton. Metadata can have any of the types described in <a class="el" href="_usd__page__datatypes.html">Basic Datatypes for Scene Description Provided by Sdf</a>.</li>
</ul>
<ul>
<li><em>Metadata is extensible.</em> The implication of the <a class="el" href="class_sdf_schema.html" title="Class that provides information about the various scene description fields.">SdfSchema</a> providing type information about metadata is that all metadata must be registered with USD/Sdf. The <a class="el" href="class_sdf_schema.html" title="Class that provides information about the various scene description fields.">SdfSchema</a> itself registers a set of metadata meaningful to the Sdf data model, but any module discoverable by USD's <a class="el" href="plug_page_front.html">plugin system</a> can extend the known set of metadata, as described in the <a class="el" href="sdf_page_front.html#sdf_plugin_metadata">Plugin Metadata</a> documentation. Core USD, and most of the higher-level schema modules use this mechanism to good effect.</li>
</ul>
<ul>
<li><em>Metadata is unvarying.</em> Although metadata values can be overridden in any layer just as <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> values can be, <em>within</em> a given layer, a metadatum can have only a single value - i.e. it cannot be sampled over time. Removing time as an axis of variation allows metadata to be evaluated and stored more efficiently than attribute values, and also means that metadata authored in <a class="el" href="_usd__page__value_clips.html">Value Clips</a> will be ignored by USD.</li>
</ul>
<ul>
<li><em>Core metadata resolution rules vary.</em> <a class="el" href="_usd__page__properties_of_scene_description.html#Usd_ValueResolution">Attribute Value Resolution</a> is fixed for all attributes, core and custom. Certain of the "core metadata", however, have value resolution behavior other than "strongest opinion wins." A class of metadata used to specify composition behavior (as well as relationships) subscribe to <a class="el" href="_usd__page__object_model.html#Usd_OM_ListOps">list-editing composition</a>. Other metadata, like attribute <em>typeName</em>, adhere to "weakest opinion wins". The prim metadata <em>specifier</em> has a highly specialized resolution behavior owing to the way in which overs, defs, and classes combine. <em>Value resolution behavior may not be changed for extension metadata,</em> however - all extension metadata will be resolved based on its datatype: strongest wins for primitive datatypes, element-wise strongest wins for dictionaries.</li>
</ul>
<h1><a class="anchor" id="Usd_OM_SchemaDefinitionRegistry"></a>
Schema and Prim Definition Registry</h1>
<p>The singleton class <a class="el" href="class_usd_schema_registry.html" title="Singleton registry that provides access to schema type information and the prim definitions for regis...">UsdSchemaRegistry</a> exists to provide access to all available schemas. It queries plugins to find all registered schema types and generates prim definitions from the processed generatedSchema.usda files (generated when a schema.usda file is processed by <em>usdGenSchema</em>).</p>
<p>A prim definition, provided by the <a class="el" href="class_usd_prim_definition.html" title="Class representing the builtin definition of a prim given the schemas registered in the schema regist...">UsdPrimDefinition</a> class, is an encapsulation of the built-in data that is imparted on a prim by the schemas for the prim's complete type signature. The built-in data accessible from a prim definition includes the list of built-in properties, an <a class="el" href="class_sdf_spec.html" title="Base class for all Sdf spec classes.">SdfSpec</a> defining each property, the list of built-in metadata fields, and fallback values for attributes and metadata fields.</p>
<p>The schema registry creates and provides access to prim definitions for each individual "IsA" and applied API schema. It also provides API to build a composite prim definition for a combination of an "IsA" type with a list of applied API schemas. The prim definition that a prim uses is determined by the combination of its type name and the list of any applied API schemas applied to the prim and is generally what we are referring to when we talk about a <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a>'s "prim definition".</p>
<h1><a class="anchor" id="Usd_OM_FallbackPrimTypes"></a>
Fallback Prim Types</h1>
<p>When you create a new "IsA" schema to use as a prim type, there may be an expectation that stages containing prims of your new type will be opened using a version of USD that does not have the new schema. You may want to provide these other, typically older, versions of USD with one or more reasonable alternative prim types to use instead of your type when its schema is not available. We provide the following mechanism for this.</p>
<p>You can specify an array of <em>fallbackTypes</em> tokens as <a class="el" href="_usd__page__generating_schemas.html#Usd_PerClassProperties">customData</a> for your class in the schema.usda. Schema generation will process this list of fallback types and add it to the dictionary of all prim fallback types that the <a class="el" href="_usd__page__object_model.html#Usd_OM_SchemaDefinitionRegistry">schema registry</a> provides.</p>
<p>To provide the currently registered prim type fallbacks to a version of USD that does not have some of these schemas, they must be recorded into any stages that may want to be opened in one of these versions. At any point before saving or exporting a stage, this can be done by calling the function <a class="el" href="class_usd_stage.html#a14897ca124a0fb4a62e6ed2ccbbdbf4f" title="Writes the fallback prim types defined in the schema registry to the stage as dictionary valued fallb...">UsdStage::WriteFallbackPrimTypes</a> to write the schema registry's dictionary of fallback prim types to the stage's root layer metadata.</p>
<p>When a stage is opened and a prim with an unrecognized type name is encountered, the stage's fallback prim types metadata is consulted. If the unrecognized type has a fallback types list in the metadata, all prims with the unrecognized type name will be treated as having the effective schema type of the first recognized type in the list.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_prim.html#ab99c37ba85f4c45d558138ca3b604ec5" title="Return the prim&#39;s full type info composed from its type name, applied API schemas,...">UsdPrim::GetPrimTypeInfo</a>, <a class="el" href="class_usd_prim.html#a6cc1b146723c266ae69fb873bcb2df67" title="Return true if the prim&#39;s schema type, is or inherits from the TfType of the schema class type Schema...">UsdPrim::IsA</a>, <a class="el" href="class_usd_schema_registry.html#a93921d1510b463b9eea85de97ea45271" title="Returns a dictionary mapping concrete schema prim type names to a VtTokenArray of fallback prim type ...">UsdSchemaRegistry::GetFallbackPrimTypes</a></dd></dl>
<h1><a class="anchor" id="Usd_OM_OtherObjects"></a>
Composition Operator Interfaces: UsdReferences, UsdInherits, UsdVariantSets</h1>
<h2><a class="anchor" id="Usd_OM_ListOps"></a>
ListOps and List Editing</h2>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="usd_page_front.html">Usd : Universal Scene Description (Core)</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:57 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>