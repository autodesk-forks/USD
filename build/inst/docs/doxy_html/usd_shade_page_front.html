<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: UsdShade : USD Shading Schema</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('usd_shade_page_front.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">UsdShade : USD Shading Schema </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#UsdShadeNetworks">UsdShade Networks</a></li>
<li class="level1"><a href="#UsdShadeEncapsulation">Encapsulation and Sharing</a><ul><li class="level2"><a href="#UsdShadeContainers">Containers vs Primitive Shading Nodes</a></li>
<li class="level2"><a href="#UsdShadePublicUI">Exposing parameters on containers</a></li>
</ul>
</li>
<li class="level1"><a href="#UsdShadeConnectability">Connectability Rules for UsdShade Types</a></li>
<li class="level1"><a href="#UsdShadeConnections">Connections and Dataflow in UsdShade</a><ul><li class="level2"><a href="#UsdShadeConnectOverInput">Valid Shader Connections Win Over Input Values</a></li>
<li class="level2"><a href="#UsdShadeResolvingInterface">Resolving Interface Connections</a></li>
<li class="level2"><a href="#UsdShadeAttributeResolution">Connection Resolution Utilities</a></li>
</ul>
</li>
<li class="level1"><a href="#UsdShadeShaderDefinition">UsdShade Based Shader Definition</a></li>
</ul>
</div>
<div class="textblock"><p>UsdShade provides schemas and behaviors for creating and binding materials, which encapsulate shading networks.</p>
<h1><a class="anchor" id="UsdShadeNetworks"></a>
UsdShade Networks</h1>
<p>UsdShade provides schemas and behaviors for creating shading networks (<a class="el" href="class_usd_shade_node_graph.html" title="A node-graph is a container for shading nodes, as well as other node-graphs.">UsdShadeNodeGraph</a>) and materials (<a class="el" href="class_usd_shade_material.html" title="A Material provides a container into which multiple &quot;render contexts&quot; can add data that defines a &quot;sh...">UsdShadeMaterial</a>). The networks are composed of <a class="el" href="class_usd_shade_shader.html" title="Base class for all USD shaders.">UsdShadeShader</a> objects, as well as other <a class="el" href="class_usd_shade_node_graph.html" title="A node-graph is a container for shading nodes, as well as other node-graphs.">UsdShadeNodeGraph</a>.</p>
<p>Objects in a network are connected together and to their encapsulating Material using the <a class="el" href="class_usd_shade_connectable_a_p_i.html" title="UsdShadeConnectableAPI is an API schema that provides a common interface for creating outputs and mak...">UsdShadeConnectableAPI</a> schema, which allows one to create <a class="el" href="class_usd_shade_input.html" title="This class encapsulates a shader or node-graph input, which is a connectable attribute representing a...">UsdShadeInput</a> and <a class="el" href="class_usd_shade_output.html" title="This class encapsulates a shader or node-graph output, which is a connectable attribute representing ...">UsdShadeOutput</a> (which are <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> schemas), and <em>connect</em> them using <a href="http://openusd.org/docs/api/class_usd_attribute.html#af8eaf3216d67a143923b65465eac881a">UsdAttribute connections</a>.</p>
<p>Here's a python example.</p>
<div class="fragment"><div class="line"><span class="comment"># create material</span></div><div class="line">materialPath = Sdf.Path(<span class="stringliteral">&#39;/Model/Materials/MyMaterial&#39;</span>)</div><div class="line">material = UsdShade.Material.Define(stage, materialPath)</div><div class="line"></div><div class="line"><span class="comment"># create shaders</span></div><div class="line">downstreamShader = UsdShade.Shader.Define(</div><div class="line">    stage, materialPath.AppendChild(<span class="stringliteral">&#39;Downstream&#39;</span>))</div><div class="line">upstreamShader = UsdShade.Shader.Define(</div><div class="line">    stage, materialPath.AppendChild(<span class="stringliteral">&#39;Upstream&#39;</span>))</div><div class="line"></div><div class="line"><span class="comment"># Connect</span></div><div class="line">inputPort = downstreamShader.CreateInput(</div><div class="line">    <span class="stringliteral">&#39;DownstreamInput&#39;</span>, Sdf.ValueTypeNames.Float)</div><div class="line">inputPort.ConnectToSource(upstreamShader, <span class="stringliteral">&#39;UpstreamOutput&#39;</span>)</div></div><!-- fragment --><p>This will yield a material with two connected nodes.</p>
<div class="fragment"><div class="line">#usda 1.0</div><div class="line"></div><div class="line">def &quot;Model&quot;</div><div class="line">{</div><div class="line">    def &quot;Materials&quot;</div><div class="line">    {</div><div class="line">        def Material &quot;MyMaterial&quot;</div><div class="line">        {</div><div class="line">            def Shader &quot;Downstream&quot;</div><div class="line">            {</div><div class="line">                float inputs:DownstreamInput.connect = </div><div class="line">                    &lt;/Model/Materials/MyMaterial/Upstream.outputs:UpstreamOutput&gt;</div><div class="line">            }</div><div class="line"></div><div class="line">            def Shader &quot;Upstream&quot;</div><div class="line">            {</div><div class="line">                float outputs:UpstreamOutput</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="UsdShadeEncapsulation"></a>
Encapsulation and Sharing</h1>
<dl class="section note"><dt>Note</dt><dd>In UsdShade, all shaders are UsdPrims or just "prims". However, in deference to the larger body of technical discourse on shading, we will refer to them as "nodes" in this discussion.</dd></dl>
<p>Shading nodes should be encapsulated in a containing object, and are not generally used in isolation.</p>
<p>Shading networks can be organized into coherent packaged units (<a class="el" href="class_usd_shade_node_graph.html" title="A node-graph is a container for shading nodes, as well as other node-graphs.">UsdShadeNodeGraph</a>), with their own public parameters exposed and connected to the internal nodes. In this scenario, the <a class="el" href="class_usd_shade_node_graph.html" title="A node-graph is a container for shading nodes, as well as other node-graphs.">UsdShadeNodeGraph</a> is a parent or ancestor prim (<a class="el" href="class_usd_shade_node_graph.html" title="A node-graph is a container for shading nodes, as well as other node-graphs.">UsdShadeNodeGraph</a> can be nested) to all of the <a class="el" href="class_usd_shade_shader.html" title="Base class for all USD shaders.">UsdShadeShader</a> prims in the network, and serves as the point of encapsulation - the <a class="el" href="class_usd_shade_node_graph.html" title="A node-graph is a container for shading nodes, as well as other node-graphs.">UsdShadeNodeGraph</a> prim can then be <b>referenced</b> into other, larger networks as a building block, with its entire network intact. When referenced into larger networks, NodeGraphs can also be <a href="http://openusd.org/docs/USD-Glossary.html#USDGlossary-Instancing">instanced</a> so that they appear as a single prim in the network, and can be processed more efficiently when referenced from multiple locations.</p>
<p>If the network of shading nodes is directly consumable as a "shader" of a type known to some client renderer (e.g. a <b>surface shader</b>), then the encapsulating parent/ancestor should be declared as a <a class="el" href="class_usd_shade_material.html" title="A Material provides a container into which multiple &quot;render contexts&quot; can add data that defines a &quot;sh...">UsdShadeMaterial</a>, which is a <b>container</b> that can also be bound to geometries or collections. Materials can also be reused and instanced, retaining the same network but allowing top-level "Material Interface" parameters to be authored uniquely.</p>
<h2><a class="anchor" id="UsdShadeContainers"></a>
Containers vs Primitive Shading Nodes</h2>
<p>Containers are prims that are designed to have child prims, like <a class="el" href="class_usd_shade_material.html" title="A Material provides a container into which multiple &quot;render contexts&quot; can add data that defines a &quot;sh...">UsdShadeMaterial</a> and <a class="el" href="class_usd_shade_node_graph.html" title="A node-graph is a container for shading nodes, as well as other node-graphs.">UsdShadeNodeGraph</a>, and that encapsulate parts or a whole network. These containers are differentiated against non-containers, which are are shader nodes like <a class="el" href="class_usd_shade_shader.html" title="Base class for all USD shaders.">UsdShadeShader</a> prims.</p>
<p>Container types are identified by their <a class="el" href="class_usd_shade_connectable_a_p_i.html#af34679e35e7a95b65817347ab2b94b38" title="Returns true if the prim is a container.">UsdShadeConnectableAPI::IsContainer()</a> implementation, which is an extensible API, such that other types can work as containers with the other UsdShade APIs, by implementing the <a class="el" href="class_usd_shade_connectable_a_p_i_behavior.html" title="UsdShadeConnectableAPIBehavior defines the compatibilty and behavior UsdShadeConnectableAPIof when ap...">UsdShadeConnectableAPIBehavior</a> plugin interface. Refer: <a class="el" href="connectable_a_p_i_behavior_8h.html#af020d3f2d1c9f65f75dc08434a1d0b20">UsdShadeRegisterConnectableAPIBehavior</a> for more details on registering a <a class="el" href="class_usd_shade_connectable_a_p_i_behavior.html" title="UsdShadeConnectableAPIBehavior defines the compatibilty and behavior UsdShadeConnectableAPIof when ap...">UsdShadeConnectableAPIBehavior</a> for a Type.</p>
<p>Containers usually define an interface that establishes input and output attributes, which allows exposing functionality of the encapsulated part of the network. With such an interface definition they can be treated in many ways like a primitive shading node, but have an implementation that can be inspected in Usd.</p>
<h2><a class="anchor" id="UsdShadePublicUI"></a>
Exposing parameters on containers</h2>
<p>To expose a parameter to the container, we use the same mechanism that connects nodes.</p>
<div class="fragment"><div class="line"><span class="comment"># Expose a parameter to the public interface</span></div><div class="line">internalPort = upstreamShader.CreateInput(</div><div class="line">    <span class="stringliteral">&#39;internalPort&#39;</span>, Sdf.ValueTypeNames.Float)</div><div class="line">exposedPort = material.CreateInput(</div><div class="line">    <span class="stringliteral">&#39;ExposedPort&#39;</span>, Sdf.ValueTypeNames.Float)</div><div class="line">exposedPort.Set(1.0)</div><div class="line">internalPort.ConnectToSource(exposedPort)</div></div><!-- fragment --><p>Which will yield a public interface parameter called 'ExposedPort' on the <a class="el" href="class_usd_shade_material.html" title="A Material provides a container into which multiple &quot;render contexts&quot; can add data that defines a &quot;sh...">UsdShadeMaterial</a> called 'MyMaterial', and set its default value to 1.0</p>
<div class="fragment"><div class="line">#usda 1.0</div><div class="line"></div><div class="line">def &quot;Model&quot;</div><div class="line">{</div><div class="line">    def &quot;Materials&quot;</div><div class="line">    {</div><div class="line">        def Material &quot;MyMaterial&quot;</div><div class="line">        {</div><div class="line">            float inputs:ExposedPort = 1</div><div class="line"></div><div class="line">            def Shader &quot;Downstream&quot;</div><div class="line">            {</div><div class="line">                float inputs:DownstreamInput.connect = </div><div class="line">                    &lt;/Model/Materials/MyMaterial/Upstream.outputs:UpstreamOutput&gt;</div><div class="line">            }</div><div class="line"></div><div class="line">            def Shader &quot;Upstream&quot;</div><div class="line">            {</div><div class="line">                float inputs:internalPort.connect = </div><div class="line">                    &lt;/Model/Materials/MyMaterial.inputs:ExposedPort&gt;</div><div class="line">                float outputs:UpstreamOutput</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>To expose an output of a node network as an output of a NodeGraph, or as a "terminal output" of a Material, we again use the same connection API, except that now we are connecting an Output to another Output (in effect, <em>forwarding</em> the Output from a node to its encapsulating container):</p>
<div class="fragment"><div class="line"><span class="comment"># The output represents the result of the shader&#39;s computation. For</span></div><div class="line"><span class="comment"># complex types like &quot;surface illumination&quot; we use the type Token as</span></div><div class="line"><span class="comment"># a standin for the type specific to the renderer</span></div><div class="line">outPort = surfaceShader.CreateOutput(</div><div class="line">    <span class="stringliteral">&#39;out&#39;</span>, Sdf.ValueTypeNames.Token)</div><div class="line">surfaceTerminal = material.CreateOutput(</div><div class="line">    <span class="stringliteral">&#39;surface&#39;</span>, Sdf.ValueTypeNames.Token)</div><div class="line"><span class="comment"># For outputs, it is the container&#39;s Output that connect&#39;s to the Node&#39;s</span></div><div class="line"><span class="comment"># output</span></div><div class="line">surfaceTerminal.ConnectToSource(outPort)</div></div><!-- fragment --><p>Which will yield a public interface parameter called 'ExposedPort' on the <a class="el" href="class_usd_shade_material.html" title="A Material provides a container into which multiple &quot;render contexts&quot; can add data that defines a &quot;sh...">UsdShadeMaterial</a> called 'MyMaterial', and set its default value to 1.0</p>
<div class="fragment"><div class="line">#usda 1.0</div><div class="line"></div><div class="line">def &quot;Model&quot;</div><div class="line">{</div><div class="line">    def &quot;Materials&quot;</div><div class="line">    {</div><div class="line">        def Material &quot;MyMaterial&quot;</div><div class="line">        {</div><div class="line">            token outputs:surface.connect = </div><div class="line">                &lt;/Model/Materials/MyMaterial/Surface.outputs:out&gt;</div><div class="line"></div><div class="line">            def Shader &quot;Surface&quot;</div><div class="line">            {</div><div class="line">                token outputs:out</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="UsdShadeConnectability"></a>
Connectability Rules for UsdShade Types</h1>
<p>As noted above, encapsulation is critical to UsdShade connectability rules, with different UsdShade nodes providing appropriate connectivity rules described below:</p>
<ul>
<li><a class="el" href="class_usd_shade_shader.html" title="Base class for all USD shaders.">UsdShadeShader</a>: Inputs can be connected to any Input or Output of any other shader or NodeGraph encapsulated by the same nearest-in-namespace encapsulating NodeGraph or Nodegraph-derived container. Outputs cannot be connected.</li>
<li><a class="el" href="class_usd_shade_node_graph.html" title="A node-graph is a container for shading nodes, as well as other node-graphs.">UsdShadeNodeGraph</a>: Inputs follow the same rule as Shaders. Outputs can be connected to any Output on a prim (Shader or NodeGraph) encapsulated by the NodeGraph itself, or to an Input of the same NodeGraph itself, creating a "pass through" connection.</li>
<li>Default behavior for NodeGraph-derived Types (e.g. <a class="el" href="class_usd_shade_material.html" title="A Material provides a container into which multiple &quot;render contexts&quot; can add data that defines a &quot;sh...">UsdShadeMaterial</a>) Inputs and Outputs follow the same rule, which is that they can be connected to any Output on a prim (Shader or NodeGraph) encapsulated by the Material itself. Note that "pass through" connections are not allowed for Nodegraph-derived container nodes.</li>
<li>Any new or derived Typed or single-apply API schema can register its own <a class="el" href="class_usd_shade_connectable_a_p_i_behavior.html" title="UsdShadeConnectableAPIBehavior defines the compatibilty and behavior UsdShadeConnectableAPIof when ap...">UsdShadeConnectableAPIBehavior</a> to customize connectivity rules. It can also specify, in its extraPlugInfo customData, the isUsdShadeContainer and requiresUsdShadeEncapsulation booleans to customize those aspects of behavior without needing to provide a <a class="el" href="class_usd_shade_connectable_a_p_i_behavior.html" title="UsdShadeConnectableAPIBehavior defines the compatibilty and behavior UsdShadeConnectableAPIof when ap...">UsdShadeConnectableAPIBehavior</a> implementation.</li>
</ul>
<p><a class="anchor" id="UsdShadeConnectableAPIBehavior_ResolutionOrder"></a>Resolution order for when multiple types and apiSchemas provide a <a class="el" href="class_usd_shade_connectable_a_p_i_behavior.html" title="UsdShadeConnectableAPIBehavior defines the compatibilty and behavior UsdShadeConnectableAPIof when ap...">UsdShadeConnectableAPIBehavior</a>:</p><ol type="1">
<li>Behavior defined on an authored API schemas, wins over</li>
<li>Behavior defined for a prim type, wins over</li>
<li>Behavior defined for the prim's ancestor types, wins over</li>
<li>Behavior defined for any built-in API schemas.</li>
<li>If no Behavior is found but an api schema adds providesUsdShadeConnectableAPIBehavior plug metadata then a default behavior is registered for the primTypeId, with its isContainer and requiresEncapsulation driven by extraPlugInfo metadata</li>
</ol>
<p>Note that interface-only connections can only happen between inputs and source which have "interfaceOnly" connectivity.</p>
<h1><a class="anchor" id="UsdShadeConnections"></a>
Connections and Dataflow in UsdShade</h1>
<p>UsdShade uses <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> connections both to indicate dataflow from shading node outputs to inputs, <b>and</b> to indicate pre-rendering propagation of values authored on <a class="el" href="class_usd_shade_node_graph.html" title="A node-graph is a container for shading nodes, as well as other node-graphs.">UsdShadeNodeGraph</a> and <a class="el" href="class_usd_shade_material.html" title="A Material provides a container into which multiple &quot;render contexts&quot; can add data that defines a &quot;sh...">UsdShadeMaterial</a> inputs to shader node inputs. In USD, connections (and relationships) are authored on the <b>consumer</b>, and target the source or <b>producer</b>. Therefore, data in a UsdShade network flows from a connection's target to its anchor. To reliably translate UsdShade networks for consumption by renderers, we need to establish a few rules about how values propagate in the face of connections.</p>
<h2><a class="anchor" id="UsdShadeConnectOverInput"></a>
Valid Shader Connections Win Over Input Values</h2>
<p>When an input on a shading node has <b>both</b> an authored value (default or timeSamples), <b>and</b> a connection to an output on another shading node, then the connection alone is transmitted to the renderer - the authored value is irrelevant. Connections that target an output that <b>does not exist in the containing Material</b> are ignored; if the connected input has an authored value, then in this case, and this case alone, we pass the value to the renderer and ignore the connection.</p>
<p>In the following example, we will provide values to the renderer for inputs <em>valueOnly</em> (2) and <em>brokenConnection</em> (4), while informing the renderer of a connection between <em>validOutput</em> and <em>connected</em>, ignoring the value authored of 42 on <em>connected</em>.</p>
<div class="fragment"><div class="line">#usda 1.0</div><div class="line"></div><div class="line">def &quot;Model&quot;</div><div class="line">{</div><div class="line">    def &quot;Materials&quot;</div><div class="line">    {</div><div class="line">        def Material &quot;MyMaterial&quot;</div><div class="line">        {</div><div class="line">            def Shader &quot;Downstream&quot;</div><div class="line">            {</div><div class="line">                float inputs:brokenConnection = 4</div><div class="line">                float inputs:brokenConnection.connect = </div><div class="line">                    &lt;/Model/Materials/MyMaterial/MissingShader.outputs:MissingOutput&gt;</div><div class="line"></div><div class="line">                float inputs:connected = 42</div><div class="line">                float inputs:connected.connect = </div><div class="line">                    &lt;/Model/Materials/MyMaterial/Upstream.outputs:UpstreamOutput&gt;</div><div class="line"></div><div class="line">                float inputs:valueOnly = 2</div><div class="line"></div><div class="line">            }</div><div class="line"></div><div class="line">            def Shader &quot;Upstream&quot;</div><div class="line">            {</div><div class="line">                float outputs:UpstreamOutput</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="UsdShadeResolvingInterface"></a>
Resolving Interface Connections</h2>
<p>When we create inputs on NodeGraphs or Materials to serve as "public interface" for shading properties, it is common to <em>create</em> an appropriately-typed attribute, but <b>not provide a default value for it</b>. When USD is the document for a material shading network, this "uninitialized interface attribute" allows the Material to continue to receive updates to published shaders made available through the <a class="el" href="class_sdr_registry.html" title="The shading-specialized version of NdrRegistry.">SdrRegistry</a> long after the Material has been created. Why? Because of the first rule of interface value propagation:</p>
<ul>
<li>If a Material or NodeGraph input provides no value, and one or more of its shader's inputs connects to the interface attribute, then the value supplied to the renderer for that shading input should be whatever value is authored on the shader input, or if none is authored, then we emit <b>no value</b> to the renderer, indicating it should simply follow the shader implementation's own default value.</li>
</ul>
<p>NodeGraphs can be embedded inside Materials, and also as nested components inside other NodeGraphs. Because of this nestability, it is posible that a deeply embedded shader node input may need to travel several connection hops to find an interface attribute that provides a value for it to use. This leads to the second and final rule of interface value propagation:</p>
<ul>
<li>If a shader node input is connected to a containing NodeGraph input that is in turn connected to an outer-containing NodeGraph or Material, it is the <b>outermost authored input default in the connection chain</b> that provides the shader input's value. This allows the "user" of a NodeGraph to always be able to drive its inputs from its own public interface.</li>
</ul>
<p>Putting these two rules together, in the example below, we expect the following values to be passed to the renderer for each shader input:</p>
<ul>
<li><em>spOne</em> = 4, because neither of the interface attributes in its connection chain supply a value.</li>
<li><em>spTwo</em> = 14, because <em>matInterfaceTwo</em> provides the strongest opinion, as the outermost value-provider in the connection chain.</li>
<li><em>spThree</em> = 64, because only its directly-embedding NodeGraph's interface attribute provides a value stronger than its own default.</li>
</ul>
<div class="fragment"><div class="line">#usda 1.0</div><div class="line"></div><div class="line">def &quot;Model&quot;</div><div class="line">{</div><div class="line">    def &quot;Materials&quot;</div><div class="line">    {</div><div class="line">        def Material &quot;MyMaterial&quot;</div><div class="line">        {</div><div class="line">            float inputs:matInterfaceOne</div><div class="line">            float inputs:matInterfaceTwo = 14</div><div class="line">            float inputs:matInterfaceThree</div><div class="line"></div><div class="line">            def NodeGraph &quot;Package&quot;</div><div class="line">            {</div><div class="line">                float inputs:ngInterfaceOne.connect = </div><div class="line">                    &lt;/Model/Materials/MyMaterial.inputs:matInterfaceOne&gt;</div><div class="line"></div><div class="line">                float inputs:ngInterfaceTwo = 28</div><div class="line">                float inputs:ngInterfaceTwo.connect =</div><div class="line">                    &lt;/Model/Materials/MyMaterial.inputs:matInterfaceTwo&gt;</div><div class="line"></div><div class="line">                float inputs:ngInterfaceThree = 64</div><div class="line">                float inputs:ngInterfaceThree.connect =</div><div class="line">                    &lt;/Model/Materials/MyMaterial.inputs:matInterfaceThree&gt;</div><div class="line"></div><div class="line">                def Shader &quot;EmbeddedInNG&quot;</div><div class="line">                {</div><div class="line">                    float inputs:spOne = 4</div><div class="line">                    float inputs:spOne.connect = </div><div class="line">                        &lt;/Model/Materials/MyMaterial/Package.inputs:ngInterfaceOne&gt;</div><div class="line"></div><div class="line">                    float inputs:spTwo = 5</div><div class="line">                    float inputs:spTwo.connect = </div><div class="line">                        &lt;/Model/Materials/MyMaterial/Package.inputs:ngInterfaceTwo&gt;</div><div class="line"></div><div class="line">                    float inputs:spThree = 6</div><div class="line">                    float inputs:spThree.connect = </div><div class="line">                        &lt;/Model/Materials/MyMaterial/Package.inputs:ngInterfaceThree&gt;</div><div class="line"></div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>NodeGraphs also define outputs to declare the signals that are provided for the rest of the network. From the outside, which is where the NodeGraph is connected to other shading nodes or NodeGraphs, the outputs behave conceptually like those on shading nodes. On the inside of the NodeGraph the outputs are connected to outputs of nested shading nodes or nested NodeGraphs <em>or</em> they can be connected to input attributes on the same NodeGraph as a pass through mechanism.</p>
<p>In the example below we have a NodGraph with two inputs (<em>ngPassThruIn</em> and <em>ngToModifyIn</em>) and two outputs (<em>ngPassThruOut</em> and <em>ngModifiedOut</em>). <em>ngPassThruIn</em> is sent straight to <em>ngPassThruOut</em> without modification, which means it is essentially forwarding connections and effectively <em>result1</em> is connected to <em>input1</em> directly. The input of <em>ngToModifyIn</em> is fed to the <em>Modifier</em> shading node, which sends a modified result to <em>ngModifiedOut</em>, which effectively models <em>result2</em> -&gt; <em>toModify</em> (on <em>Modifier</em>) and <em>modified</em> -&gt; <em>input2</em>.</p>
<div class="fragment"><div class="line">#usda 1.0</div><div class="line"></div><div class="line">def &quot;Model&quot;</div><div class="line">{</div><div class="line">    def &quot;Materials&quot;</div><div class="line">    {</div><div class="line">        def Material &quot;MyMaterial&quot;</div><div class="line">        {</div><div class="line"></div><div class="line">            def Shader &quot;Generator&quot;</div><div class="line">            {</div><div class="line">                float outputs:result1</div><div class="line">                float outputs:result2</div><div class="line">            }</div><div class="line"></div><div class="line">            def NodeGraph &quot;Package&quot;</div><div class="line">            {</div><div class="line">                float inputs:ngPassThruIn.connect = </div><div class="line">                    &lt;/Model/Materials/MyMaterial/Generator.outputs:result1&gt;</div><div class="line">                float inputs:ngToModifyIn.connect =</div><div class="line">                    &lt;/Model/Materials/MyMaterial/Generator.outputs:result2&gt;</div><div class="line"></div><div class="line">                float outputs:ngPassThruOut.connect =</div><div class="line">                    &lt;/Model/Materials/MyMaterial/Package.inputs:ngPassThruIn&gt;</div><div class="line">                float outputs:ngModifiedOut.connect =</div><div class="line">                    &lt;/Model/Materials/MyMaterial/Package/Modifier.outputs:modified&gt;</div><div class="line"></div><div class="line">                def Shader &quot;Modifier&quot;</div><div class="line">                {</div><div class="line">                    float inputs:toModify.connect = </div><div class="line">                        &lt;/Model/Materials/MyMaterial/Package.inputs:ngToModifyIn&gt;</div><div class="line"></div><div class="line">                    float outputs:modified</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            def Shader &quot;Consumer&quot;</div><div class="line">            {</div><div class="line">                float inputs:input1.connect =</div><div class="line">                    &lt;/Model/Materials/MyMaterial/Package.outputs:ngPassThruOut&gt;</div><div class="line">                float inputs:input2.connect =</div><div class="line">                    &lt;/Model/Materials/MyMaterial/Package.outputs:ngModifiedOut&gt;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="UsdShadeAttributeResolution"></a>
Connection Resolution Utilities</h2>
<p>The resolution of the rules described above are implemented in a helper function called <a class="el" href="class_usd_shade_utils.html#ad1f99058557167a9282c2531f2332bd6">UsdShadeUtils::GetValueProducingAttributes</a>, which takes either a <a class="el" href="class_usd_shade_input.html" title="This class encapsulates a shader or node-graph input, which is a connectable attribute representing a...">UsdShadeInput</a> or <a class="el" href="class_usd_shade_output.html" title="This class encapsulates a shader or node-graph output, which is a connectable attribute representing ...">UsdShadeOutput</a> and computes the <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute(s)</a> that either carry the default value(s) that should be sent to the renderer or the <a class="el" href="class_usd_shade_output.html" title="This class encapsulates a shader or node-graph output, which is a connectable attribute representing ...">UsdShadeOutput(s)</a> of nodes to which connections should be established. For convenience and discoverability this method is also available on Inputs and Outputs directly as <a class="el" href="class_usd_shade_input.html#a2850314096019df0a017b321719b3c70">UsdShadeInput::GetValueProducingAttributes</a> and <a class="el" href="class_usd_shade_output.html#a2850314096019df0a017b321719b3c70">UsdShadeOutput::GetValueProducingAttributes</a>.</p>
<p>This handles both the rules that connections win over default values and the forwarding logic to the interfaces of containers, like Materials or NodeGraphs. This utility function can be seen as a way to turn physical connections into logical ones. This can be useful for renderers ingesting a Material network because generally the logical connections are their only concern. This conversion "flattens" the network into a simple network that only contains Shaders with their respective input values and connections.</p>
<p>There are situations where only valid output attributes of shading nodes are desired and hence we have a mode, where it will not report input or output attributes on containers that carry default values. This mode can be activated by the optional <em>shaderOutputsOnly</em> flag.</p>
<p>Attributes in Usd can have not just a single connection target, but potentially multiple attributes they target. UsdShade supports having multiple connections for Inputs and Outputs (of containers, only), which means that <a class="el" href="class_usd_shade_utils.html#ad1f99058557167a9282c2531f2332bd6">UsdShadeUtils::GetValueProducingAttributes</a> also handles these scenarios. The function is essentially performing a depth first connection tracing, which means that when a multi-connection is encountered along the path the tracing splits and potentially multiple source attributes are found. Note that invalid connections targets are skipped. The function will report all valid upstream attributes, which can be a mix of Inputs with default values and Outputs of Shader nodes. It is up to the client to resolve and report any inconsistencies based on what is supported in the target rendering system.</p>
<h1><a class="anchor" id="UsdShadeShaderDefinition"></a>
UsdShade Based Shader Definition</h1>
<p>UsdShade has an <a class="el" href="class_ndr_parser_plugin.html" title="Interface for parser plugins.">NdrParserPlugin</a> (<a class="el" href="class_usd_shade_shader_def_parser_plugin.html">UsdShadeShaderDefParserPlugin</a>) that enables shader definitions to be encoded as USD scene description using the schemas available in UsdShade. A discovery plugin can open a USD stage containing shader definitions and populate the shader registry with nodes using the API <a class="el" href="class_usd_shade_shader_def_utils.html#a769e7fcf038cb078b2419735759630be">UsdShadeShaderDefUtils::GetNodeDiscoveryResults()</a>.</p>
<p>A USD file containing UsdShade-based shader definitions must adhere to the following rules, in order to produce valid <a class="el" href="class_sdr_shader_node.html" title="A specialized version of NdrNode which holds shading information.">SdrShaderNode</a> s in the shader registry:</p><ul>
<li>Every concrete shader prim at the root of the composed <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> should represent a new and complete shader definition. Inherits, references and other composition arcs may be used to avoid redundant scene description.</li>
<li>The shader prim's name becomes the unique <em>identifier</em> of the corresponding shader node in the registry. A shader's identifier is a concatenation of the<ol type="1">
<li>family name of the shader,</li>
<li>any type variations pertaining to the shader and</li>
<li>the shader version, which can contain one or two ints representing the major number and an optional minor number. The type variations and shader version are optional parts of a shader identifier (i.e. not all shader identifiers may include them). If present, the different parts of the identifier are delimited by an underscore. Using UsdShadeShaderDefUtils::SplitShaderIdentifier, a shader's identifier can be split into the family name, implementation-name of the shader node (which includes the family name and the type information) and the shader version. For example,</li>
</ol>
<ul>
<li>if the shader prim is named "MultiTexture", the family name of the <a class="el" href="class_sdr_shader_node.html" title="A specialized version of NdrNode which holds shading information.">SdrShaderNode</a> will be "MultiTexture". The corresponding shader-node's <b>implementation name</b> will also be "MultiTexture" and its version will be empty.</li>
<li>if the shader prim is named "MultiTexture_float2", the family name of the shader will be "MultiTexture" and its implementation name will be "MultiTexture_float2". Its version will be empty.</li>
<li>if the shader prim is named "MultiTexture_3", the family name of the shader will be "MultiTexture". It's implementation name will also be "MultiTexture" and its version will be 3.</li>
<li>if the shader prim is named "MultiTexture_float2_3_1", the family name of the shader will be "MultiTexture". The <em>implementation name</em> will include the type information and be set to "Primvar_float2".</li>
</ul>
</li>
<li>The info:id attribute value of the shader, if authored, must match the name of the shader prim (i.e. the identifier of the <a class="el" href="class_sdr_shader_node.html" title="A specialized version of NdrNode which holds shading information.">SdrShaderNode</a>).</li>
<li>The info:implementationSource of the shader must be UsdShadeTokens-&gt; sourceAsset. There must be one or more <em>"info:SOURCE_TYPE:sourceAsset"</em> attributes that point to resolvable shader implementations for different source types (eg, glslfx, OSL etc.).</li>
<li>Shader prims, their inputs and outputs can contain sdrMetadata values meant to be recorded in the shader registry. The keys in the sdrMetadata dictionary correspond to the keys in SdrNodeMetadata and SdrPropertyMetadata. The only exceptions are as follows:<ul>
<li><b>defaultInput</b> metadatum on shader inputs gets translated to a more obscure key value of <b>__SDR__defaultInput</b> (which is the value of SdrPropertyMetadata-&gt;DefaultInput) in the metadata dictionary recorded by <a class="el" href="class_sdr_registry.html" title="The shading-specialized version of NdrRegistry.">SdrRegistry</a>.</li>
<li>Setting <b>sdrMetadata["primvarProperty"]="1"</b> on a shader input implies that the input names a primvar to be consumed by the shader. This causes '$' + inputName to be included in the <em>SdrShaderNode-&gt;Primvars</em> metadata on the <b><a class="el" href="class_sdr_shader_node.html" title="A specialized version of NdrNode which holds shading information.">SdrShaderNode</a></b>. Note that it's not translated to metadata on the property itself.</li>
<li><b>connectability</b> metadata authored on UsdShadeInputs gets translated to SdrPropertyMetadata-&gt;Connectable. Connectability value of "interfaceOnly" is converted to <em>connectable="0"</em>. Connectability value of "full" is converted to <em>connectable="1"</em>.</li>
<li><a class="el" href="class_sdf_asset_path.html" title="Contains an asset path and an optional resolved path.">SdfAssetPath</a> (or asset) valued shader inputs are automatically tagged with sdr metadata <em>SdrPropertyMetadata-&gt;IsAssetIdentifier="1"</em>.</li>
<li><b>sdrMetadata["swizzle"]</b> is metadata that can be specified for properties in <a class="el" href="class_sdr_shader_property.html" title="A specialized version of NdrProperty which holds shading information.">SdrShaderProperty</a> <b>output</b> definitions that describes the component(s) of the full color/vector output value produced by the shader property, and is necessary for shading systems that rely on dynamic code generation rather than self-contained shader-objects/closures. <b>swizzle</b> metadata is not meant to ever appear in user documents, and does not provide the ability to swizzle data on input connections.</li>
<li><b>sdrMetadata["implementationName"]</b> specifies the name that will be returned by <a class="el" href="class_sdr_shader_property.html#aa6091590dd3e86ae4643f24c4b00a250" title="Returns the implementation name of this property.">SdrShaderProperty::GetImplementationName()</a>.</li>
</ul>
</li>
</ul>
<p>Here's an example shader definition file with comments explaining the various bits.</p>
<div class="fragment"><div class="line">#usda 1.0</div><div class="line"></div><div class="line"># The prim name becomes the SdrShaderNode&#39;s identifier.</div><div class="line">def Shader &quot;Primvar_float_2&quot; (</div><div class="line">    doc = &quot;Version 2 of a Primvar node that outputs a float&quot;</div><div class="line">    sdrMetadata = {</div><div class="line">        # This identifies the shader&#39;s role in the shading network as being </div><div class="line">        # a primvar reader.</div><div class="line">        token role = &quot;primvar&quot;</div><div class="line"></div><div class="line">        # The following sdr-metadatum could be authored on the node directly </div><div class="line">        # &lt;b&gt;in lieu of&lt;/b&gt; authoring primvarProperty=&quot;1&quot; on </div><div class="line">        # inputs:primvarName.</div><div class="line">        # string primvars = &quot;$primvarName&quot;</div><div class="line">    }</div><div class="line">)</div><div class="line">{</div><div class="line">    uniform token info:implementationSource = &quot;sourceAsset&quot;</div><div class="line"></div><div class="line">    # If primvarReader.oso can be resolved to an existent asset, then a </div><div class="line">    # SdrShaderNode is created with sourceType=OSL and sourceUri pointing</div><div class="line">    # to the resolved primvarReader.oso file.</div><div class="line">    uniform asset info:OSL:sourceAsset = @primvarReader.oso@</div><div class="line"></div><div class="line">    # If primvarReader.glslfx can be resolved to an existent asset, then </div><div class="line">    # another SdrShaderNode is created with sourceType=glslfx and sourceUri </div><div class="line">    # pointing to the resolved primvarReader.glslfx file.</div><div class="line">    uniform asset info:glslfx:sourceAsset = @primvarReader.glslfx@</div><div class="line"></div><div class="line">    token inputs:primvarName (</div><div class="line">        connectability = &quot;interfaceOnly&quot;</div><div class="line">        sdrMetadata = {</div><div class="line">            # This causes &#39;$primvarName&#39; to be appended to the </div><div class="line">            # SdrNodeMetadata-&gt;Primvars metadata on the SdrShaderNode.</div><div class="line">            string primvarProperty = &quot;1&quot;</div><div class="line">        }</div><div class="line">        doc = &quot;&quot;&quot;Name of the primvar to be fetched from the geometry.&quot;&quot;&quot;</div><div class="line">    )</div><div class="line"></div><div class="line">    # Asset valued inputs are automatically tagged with </div><div class="line">    # sdrMetadata[SdrPropertyMetadata-&gt;IsAssetIdentifier] = &quot;1&quot;.</div><div class="line">    asset inputs:primvarFile = @@ (</div><div class="line">        connectability = &quot;interfaceOnly&quot;</div><div class="line">        doc = &quot;&quot;&quot;File containing some primvar info.&quot;&quot;&quot;</div><div class="line">    )</div><div class="line"></div><div class="line">    float inputs:fallback = 0.0 (</div><div class="line">        doc = &quot;&quot;&quot;Fallback value to be returned when fetch failed.&quot;&quot;&quot;</div><div class="line">        sdrMetadata = {</div><div class="line">            # This gets translated to SdrPropertyMetadata-&gt;DefaultInput=&quot;1&quot;</div><div class="line">            # on the &quot;fallback&quot; SdrShaderProperty.</div><div class="line">            token defaultInput = &quot;1&quot;</div><div class="line">        }</div><div class="line">    )</div><div class="line">    </div><div class="line">    float outputs:result</div><div class="line"></div><div class="line">}</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:57 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>