<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="_usd_skel__a_p_i__intro" kind="page">
    <compoundname>UsdSkel_API_Intro</compoundname>
    <title>API Introduction</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>This page gives a brief introduction to using the UsdSkel API to read skel data encoded in USD.</para>
<sect1 id="_usd_skel__a_p_i__intro_1UsdSkel_API_SkeletonQuery">
<title>Querying Skeleton Structure And Animation</title>
<para>Given a scene that contains a <ref refid="class_usd_skel_skeleton" kindref="compound">UsdSkelSkeleton</ref>, a consuming application is free to access that primitive and reason about its structure on its own, if it chooses to do so. But UsdSkel also provides a more convenient API for querying data on a Skeleton: <ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref>. A <ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref> is created through a <ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref>, using a <ref refid="class_usd_skel_skeleton" kindref="compound">UsdSkelSkeleton</ref> primitive, as in the following example:</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref><sp/>skelCache;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_usd_skel_skeleton" kindref="compound">UsdSkelSkeleton</ref><sp/>skel<sp/>=<sp/><ref refid="class_usd_skel_skeleton" kindref="compound">UsdSkelSkeleton</ref>.<ref refid="class_usd_skel_skeleton_1a2f6dddaf7a197b14f9834af074445889" kindref="member">Get</ref>((stage,<sp/><ref refid="class_sdf_path" kindref="compound">SdfPath</ref>(</highlight><highlight class="stringliteral">&quot;/Path/To/Skel&quot;</highlight><highlight class="normal">)));</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref><sp/>skelQuery<sp/>=<sp/>skelCache.<ref refid="class_usd_skel_cache_1aaef141286813bfeb6998a8f0ac08b43b" kindref="member">GetSkelQuery</ref>(skel);</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">skelCache<sp/>=<sp/>UsdSkel.Cache()</highlight></codeline>
<codeline><highlight class="normal">skel<sp/>=<sp/><ref refid="class_usd_skel_skeleton_1a2f6dddaf7a197b14f9834af074445889" kindref="member">UsdSkelSkeleton.Get</ref>(stage,<sp/></highlight><highlight class="stringliteral">&quot;/Path/To/Skel&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">skelQuery<sp/>=<sp/>skelCache.GetSkelQuery(skel)</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>As with other cache structures in Usd <ndash/> <ref refid="class_usd_geom_xform_cache" kindref="compound">UsdGeomXformCache</ref>, <ref refid="class_usd_geom_b_box_cache" kindref="compound">UsdGeomBBoxCache</ref>, etc. <ndash/> the <ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref> that was constructed here is meant to be a persistent cache. The cache is thread-safe, and can be re-used for any numbers of primitives. When reading a USD file, it is best to create a single <ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref> to reuse for each new <ref refid="class_usd_skel_skeleton" kindref="compound">UsdSkelSkeleton</ref> that is encountered.</para>
<para>A <ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref> provides convenience methods for extracting joint transforms, in a variety of spaces.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Local-space<sp/>joint<sp/>transforms</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VtMatrix4dArray<sp/>localSpaceXforms;</highlight></codeline>
<codeline><highlight class="normal">skelQuery.<ref refid="class_usd_skel_skeleton_query_1a64035a9d2af1f6e3efe4ea06707beb30" kindref="member">ComputeJointLocalTransforms</ref>(&amp;localSpaceXforms,<sp/>time);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Joint<sp/>transforms<sp/>in<sp/>the<sp/>space<sp/>of<sp/>the<sp/>Skeleton.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VtMatrix4dArray<sp/>skelSpaceXforms;</highlight></codeline>
<codeline><highlight class="normal">skelQuery.<ref refid="class_usd_skel_skeleton_query_1a8655e2695cc5196046fb9ecba497a6a3" kindref="member">ComputeJointSkelTransforms</ref>(&amp;skelSpaceXforms,<sp/>time);</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="comment">#<sp/>Local-space<sp/>joint<sp/>transforms</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">localSpaceXforms<sp/>=<sp/>skelQuery.ComputeJointLocalTransforms(time)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">#<sp/>Joint<sp/>transforms<sp/>in<sp/>the<sp/>space<sp/>of<sp/>the<sp/>Skeleton.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">skelSpaceXforms<sp/>=<sp/>skelQuery.ComputeJointSkelTransforms(time)</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>Note that this allows the animated transforms of a Skeleton to be extracted without having to deal with some of the more complicated aspects of the Skeleton encoding, such as the inheritance of the <emphasis>skel:animationSource</emphasis> relationship.</para>
<sect2 id="_usd_skel__a_p_i__intro_1UsdSkel_API_JointPathsAndNames">
<title>Joint Paths and Names</title>
<para>Each joint in a Skeleton is identified by a token, which represents the path to a joint in a hierarchy. For example:</para>
<para><programlisting><codeline><highlight class="normal">def<sp/>Skeleton<sp/>&quot;Skel&quot;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>joints<sp/>=<sp/>[</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;Shoulder&quot;,<sp/>&quot;Shoulder/Elbow&quot;,<sp/>&quot;Shoulder/Elbow/Hand&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Each of these tokens can be converted to an <emphasis><ref refid="class_sdf_path" kindref="compound">SdfPath</ref></emphasis>, after which the <ref refid="class_sdf_path" kindref="compound">SdfPath</ref> methods can be used to extract different components of the path. For instance, to extract just the <emphasis>name</emphasis> component of each path (<computeroutput>Shoulder/Elbow</computeroutput> -&gt; <computeroutput>Elbow</computeroutput>), do the following:</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>skelQuery.<ref refid="class_usd_skel_skeleton_query_1aab38abf001974901d97c0d9e07006262" kindref="member">GetJointOrder</ref>().size();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="class_sdf_path" kindref="compound">SdfPath</ref><sp/>jointPath(skelQuery.<ref refid="class_usd_skel_skeleton_query_1aab38abf001974901d97c0d9e07006262" kindref="member">GetJointOrder</ref>()[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Name<sp/>of<sp/>joint<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>is<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>jointPath.<ref refid="class_sdf_path_1a204344d110d2bb74928f43d2c1fe0047" kindref="member">GetName</ref>()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>i,jointToken<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>enumerate(skelQuery.GetJointOrder()):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>jointPath<sp/>=<sp/>Sdf.Path(jointToken)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">print</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;Name<sp/>of<sp/>joint&quot;</highlight><highlight class="normal">,<sp/>i,<sp/></highlight><highlight class="stringliteral">&quot;is&quot;</highlight><highlight class="normal">,<sp/>jointPath.name</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>For the schema example above, this code will print:</para>
<para><verbatim>Name of joint 0 is Shoulder
Name of joint 1 is Elbow
Name of joint 2 is Hand
</verbatim></para>
<para>It should be noted that, if extracting the <emphasis>name</emphasis> of a joint in this manner, joint names are not guaranteed to be unique. For example, suppose a Skeleton has two arms. That may be encoded as:</para>
<para><programlisting><codeline><highlight class="normal">def<sp/>Skeleton<sp/>&quot;Skel&quot;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>joints<sp/>=<sp/>[</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;LeftShoulder&quot;,<sp/>&quot;LeftShoulder/Elbow&quot;,<sp/>&quot;LeftShoulder/Elbow/Hand&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;RighShoulder&quot;,<sp/>&quot;RightShoulder/Elbow&quot;,<sp/>&quot;RightShoulder/Elbow/Hand&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Although the <emphasis>path</emphasis> of every joint is unique, there is no guarantee over the uniqueness of the <emphasis>name</emphasis>. This is true of primitives in USD in general: Names need not be globally unique, but rather only need to be unique amongst their sibling primitives.</para>
</sect2>
<sect2 id="_usd_skel__a_p_i__intro_1UsdSkel_API_JointHierarchy">
<title>Querying the Joint Hierarchy</title>
<para>The structure of the joint hierarchy itself can also be queried through the <ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref>. For example, suppose that in an application, every joint is described as a <emphasis>Joint</emphasis> object, which has a pointer to its parent <emphasis>Joint</emphasis>. Code for creating a <emphasis>Joint</emphasis> object for every joint in a Skeleton might look something like the following:</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>The<sp/>ordered<sp/>set<sp/>of<sp/>Joint<sp/>objects<sp/>of<sp/>an<sp/>imaginary<sp/>application.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::vector&lt;Joint&gt;<sp/>joints;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>GetTopology()<sp/>returns<sp/>a<sp/>UsdSkelTopology<sp/>object,<sp/>which<sp/>describes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>parent&lt;-&gt;child<sp/>relationships.<sp/>It<sp/>also<sp/>gives<sp/>the<sp/>number<sp/>of<sp/>joints.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>numJoints<sp/>=<sp/>skelQuery.<ref refid="class_usd_skel_skeleton_query_1a0da8b34f1a4041f64579cdcc6547a042" kindref="member">GetTopology</ref>().GetNumJoints();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>numJoints;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::string<sp/>name<sp/>=<sp/><ref refid="class_sdf_path" kindref="compound">SdfPath</ref>(skelQuery.<ref refid="class_usd_skel_skeleton_query_1aab38abf001974901d97c0d9e07006262" kindref="member">GetJointOrder</ref>()[i]).GetName();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>parent<sp/>=<sp/>skelQuery.<ref refid="class_usd_skel_skeleton_query_1a0da8b34f1a4041f64579cdcc6547a042" kindref="member">GetTopology</ref>().<ref refid="class_usd_skel_topology_1a779e634a4070d93af1e4b82bfe6c9149" kindref="member">GetParent</ref>(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(parent<sp/>&gt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Joint<sp/>parentJoint<sp/>=<sp/>joints[parent];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>joints.push_back(Joint(name,<sp/>parentJoint));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Root<sp/>joint</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>joints.push_back(Joint(name));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="comment">#<sp/>The<sp/>ordered<sp/>set<sp/>of<sp/>Joint<sp/>objects<sp/>of<sp/>an<sp/>imaginary<sp/>application.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">joints<sp/>=<sp/>[]</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">#<sp/>GetTopology()<sp/>returns<sp/>a<sp/>UsdSkel.Topology<sp/>object,<sp/>which<sp/>describes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">#<sp/>the<sp/>parent&lt;-&gt;child<sp/>relationships.<sp/>It<sp/>also<sp/>gives<sp/>the<sp/>number<sp/>of<sp/>joints.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">numJoints<sp/>=<sp/>len(skelQuery.GetTopology())</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>i<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(numJoints):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>name<sp/>=<sp/>Sdf.Path(skelQuery.GetJointOrder()[i]).name</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>parent<sp/>=<sp/>skelQuery.GetTopology().GetParent(i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>parent<sp/>&gt;=<sp/>0:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>parentJoint<sp/>=<sp/>joints[parent]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>joints.append(Joint(name,<sp/>parentJoint))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>joints.append(Joint(name))</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>In the above code snippet, indexing into the <emphasis>joints</emphasis> array with the parent index of a joint might appear unsafe, since it might not be clear whether or not the parent joint had been constructed yet. However, it is a schema <bold>requirement</bold> that the set of joints is ordered, with parent joints coming before child joints. That is, linearly iterating through the ordered set of joints on a Skeleton must always describe a top-down hierarchy traversal. When a <ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref> is constructed, its topology is validated, and the resulting query object is only valid if that topology check passes. So given a valid <ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref>, the above code snippet will be safe.</para>
<para>To further expand on that point, the <emphasis>topology</emphasis> of a Skeleton may be directly validated as follows:</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="class_usd_skel_skeleton" kindref="compound">UsdSkelSkeleton</ref><sp/>skel(skelPrim);</highlight></codeline>
<codeline><highlight class="normal">VtTokenArray<sp/>joints;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(skel.<ref refid="class_usd_skel_skeleton_1aa6bf8297f4aae6de9fbf1b784c524d30" kindref="member">GetJointsAttr</ref>().<ref refid="class_usd_attribute_1a9d41bc223be86408ba7d7f74df7c35a9" kindref="member">Get</ref>(&amp;joints))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="class_usd_skel_topology" kindref="compound">UsdSkelTopology</ref><sp/>topology(joints);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::string<sp/>whyNot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>valid<sp/>=<sp/>topology.Validate(&amp;whyNot);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">skel<sp/>=<sp/>UsdSkel.Skeleton(skelPrim)</highlight></codeline>
<codeline><highlight class="normal">joints<sp/>=<sp/>skel.GetJointsAttr().Get(joints)</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>joints:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>topology<sp/>=<sp/>UsdSkel.Topology(joints)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>valid,whyNot<sp/>=<sp/>topology.Validate()</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>But again, if data is being queried through a <ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref>, this validation occurs <emphasis>automatically</emphasis>.</para>
</sect2>
</sect1>
<sect1 id="_usd_skel__a_p_i__intro_1UsdSkel_API_SkeletonBindings">
<title>Skeleton Bindings</title>
<para>Before applying skinning to primitives, we need to first identify which primitives are skinnable, and which Skeleton affects them. It is also desired that this discovery process helps facilitate data sharing. For instance, suppose a model consists of 1000 individual meshes. In order to skin those meshes on a GPU, we would need to first compute appropriate skinning transforms to upload to the GPU. It would be awfully inefficient to do that for each individual mesh <ndash/> I.e., to perform redundant computations, and upload the same set of transforms for each mesh.</para>
<para>The following snippet demonstrates how this can be addressed efficiently through UsdSkel. We will show the complete code first, before describing the individual parts in more detail:</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref><sp/>skelCache;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Traverse<sp/>through<sp/>the<sp/>prims<sp/>on<sp/>the<sp/>stage<sp/>to<sp/>find<sp/>where<sp/>we<sp/>might</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>have<sp/>prims<sp/>to<sp/>skin.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>stage-&gt;Traverse();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_usd_prim" kindref="compound">UsdPrim</ref>&amp;<sp/>prim<sp/>:<sp/>it)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prim.IsA&lt;<ref refid="class_usd_skel_root" kindref="compound">UsdSkelRoot</ref>&gt;())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it.PruneChilren();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="class_usd_skel_root" kindref="compound">UsdSkelRoot</ref><sp/>skelRoot(prim);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skelCache.<ref refid="class_usd_skel_cache_1abe0fe7ed06f122fda9ffd7924c231d3f" kindref="member">Populate</ref>(skelRoot,<sp/><ref refid="prim_flags_8h_1a0d604565b22c13d66365b04be5a8da12" kindref="member">UsdTraverseInstanceProxies</ref>()));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;UsdSkelBinding&gt;<sp/>bindings;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skelCache.<ref refid="class_usd_skel_cache_1a4637404879063e53d1c0187b2d336d06" kindref="member">ComputeSkelBindings</ref>(skelRoot,<sp/>&amp;bindings,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="prim_flags_8h_1a0d604565b22c13d66365b04be5a8da12" kindref="member">UsdTraverseInstanceProxies</ref>());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Iterate<sp/>over<sp/>the<sp/>bindings<sp/>related<sp/>to<sp/>this<sp/>SkelRoot</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_usd_skel_binding" kindref="compound">UsdSkelBinding</ref>&amp;<sp/>binding<sp/>:<sp/>bindings)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>Skeleton<sp/>for<sp/>this<sp/>binding.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UsdSkelQuery<sp/>skelQuery<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skelCache.<ref refid="class_usd_skel_cache_1aaef141286813bfeb6998a8f0ac08b43b" kindref="member">GetSkelQuery</ref>(binding.GetSkeleton());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VtMatrix4dArray<sp/>skinningXforms;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(skelQuery.ComputeSkinningTransforms(&amp;skinningXforms,<sp/>time))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Iterate<sp/>over<sp/>the<sp/>prims<sp/>that<sp/>are<sp/>skinned<sp/>by<sp/>this<sp/>Skeleton.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_usd_skel_skinning_query" kindref="compound">UsdSkelSkinningQuery</ref>&amp;<sp/>skinningQuery<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>binding.GetSkinningTargets())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_usd_prim" kindref="compound">UsdPrim</ref>&amp;<sp/>primToSkin<sp/>=<sp/>skinningQuery.<ref refid="class_usd_object_1a4ba10e023e7f3f3c93131bc7fc3146b7" kindref="member">GetPrim</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Process<sp/>prim<sp/>/<sp/>apply<sp/>skinning</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">skelCache<sp/>=<sp/>UsdSkel.Cache()</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">#<sp/>Traverse<sp/>through<sp/>the<sp/>prims<sp/>on<sp/>the<sp/>stage<sp/>to<sp/>find<sp/>where<sp/>we<sp/>might</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">#<sp/>have<sp/>prims<sp/>to<sp/>skin.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">it<sp/>=<sp/>iter(stage.Traverse())</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>prim<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>it:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>prim.IsA(UsdSkel.Root):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it.PruneChildren()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skelRoot<sp/>=<sp/>UsdSkel.Root(prim)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skelCache.Populate(skelRoot,<sp/>Usd.TraverseInstanceProxies()))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bindings<sp/>=<sp/>skelCache.ComputeSkelBindings(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skelRoot,<sp/>Usd.TraverseInstanceProxies())</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Iterate<sp/>over<sp/>the<sp/>bindings<sp/>related<sp/>to<sp/>this<sp/>SkelRoot</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>binding<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>bindings:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Get<sp/>the<sp/>Skeleton<sp/>for<sp/>this<sp/>binding.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skelQuery<sp/>=<sp/>skelCache.GetSkelQuery(binding.GetSkeleton())</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skinningXforms<sp/>=<sp/>skelQuery.ComputeSkinningTransforms(time)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>skinningXforms:</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Iterate<sp/>over<sp/>the<sp/>prims<sp/>that<sp/>are<sp/>skinned<sp/>by<sp/>this<sp/>Skeleton.<sp/><sp/><sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>skinningQuery<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>binding.GetSkinningTargets():</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>primToSkin<sp/>=<sp/>skinningQuery.GetPrim()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Process<sp/>prim<sp/>/<sp/>apply<sp/>skinning</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>The first part of this should be familiar:</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref><sp/>skelCache;</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">skelCache<sp/>=<sp/>UsdSkel.Cache()</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>When accessing a <ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref> for a Skeleton, we constructed a <ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref>. Again, in a context where data is being read from USD, this cache is intended to persist and be reused across multiple prims (or multiple stages, for that matter). This code example actually makes for a good example of how the cache can be shared across multiple primitives.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>stage-&gt;Traverse();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_usd_prim" kindref="compound">UsdPrim</ref>&amp;<sp/>prim<sp/>:<sp/>it)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prim.IsA&lt;<ref refid="class_usd_skel_root" kindref="compound">UsdSkelRoot</ref>&gt;())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it.PruneChilren();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">it<sp/>=<sp/>iter(stage.Traverse())</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>prim<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>it:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>prim.IsA(UsdSkel.Root):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it.PruneChildren()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>Here, we traverse through the primitives on the stage. When we encounter a <ref refid="class_usd_skel_root" kindref="compound">UsdSkelRoot</ref> primitive, we know that we have discovered a branch of the scene graph that <emphasis>might</emphasis> contain skeletally-posed models.</para>
<para>Being able to identify subsets of the scene graph that contain skeletal characters is part of the motivation behind the existence of SkelRoot primitives. It is common in IO contexts to use the SkelRoot as a point for dispatching common computations needed when translating Skeletons.</para>
<para>Both when calling Populate() as well as when computing bindings, a predicate is passed that enables traversal of instances. This code is assuming that it is reasonably to process instanced, skinned primitives. If that is not the case, we could instead pass UsdPrimDefaultPredicate.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="class_usd_skel_root" kindref="compound">UsdSkelRoot</ref><sp/>skelRoot(prim);</highlight></codeline>
<codeline><highlight class="normal">skelCache.<ref refid="class_usd_skel_cache_1abe0fe7ed06f122fda9ffd7924c231d3f" kindref="member">Populate</ref>(skelRoot,<sp/><ref refid="prim_flags_8h_1a0d604565b22c13d66365b04be5a8da12" kindref="member">UsdTraverseInstanceProxies</ref>());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::vector&lt;UsdSkelBinding&gt;<sp/>bindings;</highlight></codeline>
<codeline><highlight class="normal">skelCache.<ref refid="class_usd_skel_cache_1a4637404879063e53d1c0187b2d336d06" kindref="member">ComputeSkelBindings</ref>(skelRoot,<sp/>&amp;bindings,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="prim_flags_8h_1a0d604565b22c13d66365b04be5a8da12" kindref="member">UsdTraverseInstanceProxies</ref>());</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">skelRoot<sp/>=<sp/>UsdSkel.Root(prim)</highlight></codeline>
<codeline><highlight class="normal">skelCache.Populate(skelRoot,<sp/>Usd.TraverseInstanceProxies())</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">bindings<sp/>=<sp/>skelCache.ComputeSkelBindings(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>skelRoot,<sp/>Usd.TraverseInstanceProxies())</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>A <ref refid="class_usd_skel_binding" kindref="compound">UsdSkelBinding</ref> object is a simply a mapping of some Skeleton to a set of skinnable primitives. We can compute those mappings by way of the <ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref>, but must first <computeroutput>Populate()</computeroutput> that section of the scene graph on the cache.</para>
<para>What we gain from using this API is that the <ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref> is doing all the work of properly resolving inherited binding properties for us, allowing us to get at the question we&apos;re really interested: What prims are we skinning, and with which Skeletons?</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_usd_skel_binding" kindref="compound">UsdSkelBinding</ref>&amp;<sp/>binding<sp/>:<sp/>bindings)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>Skeleton<sp/>for<sp/>this<sp/>binding.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UsdSkelQuery<sp/>skelQuery<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skelCache.<ref refid="class_usd_skel_cache_1aaef141286813bfeb6998a8f0ac08b43b" kindref="member">GetSkelQuery</ref>(binding.GetSkeleton());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="comment">#<sp/>Iterate<sp/>over<sp/>the<sp/>bindings<sp/>related<sp/>to<sp/>this<sp/>SkelRoot</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>binding<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>bindings:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Get<sp/>the<sp/>Skeleton<sp/>for<sp/>this<sp/>binding.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>skelQuery<sp/>=<sp/>skelCache.GetSkelQuery(binding.GetSkeleton())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>There could be any number of Skeletons beneath a SkelRoot. There will be a <ref refid="class_usd_skel_binding" kindref="compound">UsdSkelBinding</ref> associated with each uniquely bound Skeleton. So we must iterate over all of them.</para>
<para>The binding holds a reference to the Skeleton. As we saw earlier, we can extract a <ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref> from the <ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref> using that Skeleton, which provides a more convenient API for extracting data from the Skeleton.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal">VtMatrix4dArray<sp/>skinningXforms;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(skelQuery.ComputeSkinningTransforms(&amp;skinningXforms,<sp/>time))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">skinningXforms<sp/>=<sp/>skelQuery.ComputeSkinningTransforms(time)</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>skinningXforms:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>...</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>The skinning transforms have been included at this point only as an example, to emphasize the point that this serves as a common code site at which properties related to a Skeleton can be computed, which are subsequently shared across all of the primitives that are skinned by that Skeleton.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Iterate<sp/>over<sp/>the<sp/>prims<sp/>that<sp/>are<sp/>skinned<sp/>by<sp/>this<sp/>Skeleton.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_usd_skel_skinning_query" kindref="compound">UsdSkelSkinningQuery</ref>&amp;<sp/>skinningQuery<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>binding.GetSkinningTargets())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_usd_prim" kindref="compound">UsdPrim</ref>&amp;<sp/>primToSkin<sp/>=<sp/>skinningQuery.<ref refid="class_usd_object_1a4ba10e023e7f3f3c93131bc7fc3146b7" kindref="member">GetPrim</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="comment">#<sp/>Iterate<sp/>over<sp/>the<sp/>prims<sp/>that<sp/>are<sp/>skinned<sp/>by<sp/>this<sp/>Skeleton.<sp/><sp/><sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>skinningQuery<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>binding.GetSkinningTargets():</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>primToSkin<sp/>=<sp/>skinningQuery.GetPrim()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>At this point, we have a Skeleton <ndash/> or better yet, a <ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref> <ndash/> and can traverse over the &apos;skinning targets&apos;, which are the set of primitives that are skinned by that Skeleton.</para>
<para>The set of skinned primitives are returned as <ref refid="class_usd_skel_skinning_query" kindref="compound">UsdSkelSkinningQuery</ref> objects. Just as <ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref> objects provide convenient API for querying data related to a Skeleton, a <ref refid="class_usd_skel_skinning_query" kindref="compound">UsdSkelSkinningQuery</ref> provides convenient API for reading data related to primitives that are skinned, such as joint influences. See the <ref refid="_usd_skel__a_p_i__intro_1UsdSkel_API_SkinningQuery" kindref="member">skinning query</ref> section for more information.</para>
<sect2 id="_usd_skel__a_p_i__intro_1UsdSkel_API_DiscoveringBindings">
<title>Discovering Bindings On Skinnable Primitives</title>
<para>In the <ref refid="_usd_skel__a_p_i__intro_1UsdSkel_API_SkeletonBindings" kindref="member">Skeleton Bindings</ref> section, we explored a top-down traversal of a stage, which allowed us to efficiently associate a Skeleton with multiple prims that are affected by that Skeleton. Sometimes, such top-down traversal patterns are not possible, and we need to discover bindings the other way around: That is, given a primitive, discover the Skeleton that affects it, and begin computing data required to skin it.</para>
<para>As with the previous section, we will start with a complete coding example, before breaking down the individual parts.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref><sp/>skelCache;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="class_usd_skel_root" kindref="compound">UsdSkelRoot</ref><sp/>skelRoot<sp/>=<sp/><ref refid="class_usd_skel_root_1abae051db9db8423b62b5f4e86cdc2ee5" kindref="member">UsdSkelRoot::Find</ref>(prim))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>skelCache.<ref refid="class_usd_skel_cache_1abe0fe7ed06f122fda9ffd7924c231d3f" kindref="member">Populate</ref>(skelRoot,<sp/><ref refid="prim_flags_8h_1a0d604565b22c13d66365b04be5a8da12" kindref="member">UsdTraverseInstanceProxies</ref>());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="class_usd_skel_skinning_query" kindref="compound">UsdSkelSkinningQuery</ref><sp/>skinningQuery<sp/>=<sp/>skelCache.<ref refid="class_usd_skel_cache_1a182cd014ee50683dc1774e1b2a1d0db1" kindref="member">GetSkinningQuery</ref>(prim))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>the<sp/>Skeleton<sp/>that<sp/>should<sp/>affect<sp/>this<sp/>prim.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="class_usd_skel_skeleton" kindref="compound">UsdSkelSkeleton</ref><sp/>skel<sp/>=<sp/><ref refid="class_usd_skel_binding_a_p_i" kindref="compound">UsdSkelBindingAPI</ref>(prim).<ref refid="class_usd_skel_binding_a_p_i_1a781a5a151d35fd6f9f1773f5755d261d" kindref="member">GetInheritedSkeleton</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref><sp/>skelQuery<sp/>=<sp/>skelCache.<ref refid="class_usd_skel_cache_1aaef141286813bfeb6998a8f0ac08b43b" kindref="member">GetSkelQuery</ref>(skel))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Apply<sp/>skinning?</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">skelCache<sp/>=<sp/>UsdSkel.Cache()</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">skelRoot<sp/>=<sp/>UsdSkel.Root.Find(prim)</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>skelRoot:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>skelCache.Populate(skelRoot,<sp/>Usd.TraverseInstanceProxies())</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>skinningQuery<sp/>=<sp/>skelCache.GetSkinningQuery(prim)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>skinningQuery:</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Find<sp/>the<sp/>Skeleton<sp/>that<sp/>should<sp/>affect<sp/>this<sp/>prim.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skel<sp/>=<sp/>UsdSkel.BindingAPI(prim).GetInheritedSkeleton()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skelQuery<sp/>=<sp/>skelCache.GetSkelQuery(skel);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>skelQuery:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Apply<sp/>skinning?</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>Once more, the first line should seem familiar:</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref><sp/>skelCache;</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">skelCache<sp/>=<sp/>UsdSkel.Cache()</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>As with previous examples, we utilize a <ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref>. Again, we emphasize that such caches should persist, and be shared across multiple prims.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="class_usd_skel_root" kindref="compound">UsdSkelRoot</ref><sp/>skelRoot<sp/>=<sp/><ref refid="class_usd_skel_root_1abae051db9db8423b62b5f4e86cdc2ee5" kindref="member">UsdSkelRoot::Find</ref>(prim))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>skelCache.<ref refid="class_usd_skel_cache_1abe0fe7ed06f122fda9ffd7924c231d3f" kindref="member">Populate</ref>(skelRoot,<sp/><ref refid="prim_flags_8h_1a0d604565b22c13d66365b04be5a8da12" kindref="member">UsdTraverseInstanceProxies</ref>());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="class_usd_skel_skinning_query" kindref="compound">UsdSkelSkinningQuery</ref><sp/>skinningQuery<sp/>=<sp/>skelCache.<ref refid="class_usd_skel_cache_1a182cd014ee50683dc1774e1b2a1d0db1" kindref="member">GetSkinningQuery</ref>(prim))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">skelRoot<sp/>=<sp/>UsdSkel.Root.Find(prim)</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>skelRoot:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>skelCache.Populate(skelRoot,<sp/>Usd.TraverseInstanceProxies())</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>skinningQuery<sp/>=<sp/>skelCache.GetSkinningQuery(prim)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>skinningQuery:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>We want to be able to extract a <ref refid="class_usd_skel_skinning_query" kindref="compound">UsdSkelSkinningQuery</ref>, which provides useful utilities for working with skinnable primitives. As with <ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref> objects, skinning queries are accessed through the <ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref>. But before they are accessed, we need to <computeroutput>Populate()</computeroutput> the <ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref> with the section of the scene graph that contains the skinnable primitive. Cache population causes the cache to be pre-populated with information about inherited bindings, which is necessary when accessing skinning queries. All prims which have authored UsdSkel attributes must also have the SkelBindingAPI schema applied at time of cache population.</para>
<para>Passing the predicate produced by <ref refid="prim_flags_8h_1a0d604565b22c13d66365b04be5a8da12" kindref="member">UsdTraverseInstanceProxies()</ref> ensures that instanced, skinnable prims are populated on the cache. If there is no need to consider instanced primitives, then a predicate that does not traverse instance proxies <ndash/> such as UsdPrimDefaultPredicate <ndash/> may be used instead.</para>
<para>The SkelRoot that encapsulates a primitive can be found using <ref refid="class_usd_skel_root_1abae051db9db8423b62b5f4e86cdc2ee5" kindref="member">UsdSkelRoot::Find</ref>. If no SkelRoot is found, that means that the primitive is not encapsulated within a SkelRoot, and so any properties on the prim related to skinning should be ignored.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="class_usd_skel_skinning_query" kindref="compound">UsdSkelSkinningQuery</ref><sp/>skinningQuery<sp/>=<sp/>skelCache.<ref refid="class_usd_skel_cache_1a182cd014ee50683dc1774e1b2a1d0db1" kindref="member">GetSkinningQuery</ref>(prim))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">skinningQuery<sp/>=<sp/>skelCache.GetSkinningQuery(prim)</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>skinningQuery:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>...</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>Having found a SkelRoot and populated the <ref refid="class_usd_skel_cache" kindref="compound">UsdSkelCache</ref>, we can access a <ref refid="class_usd_skel_skinning_query" kindref="compound">UsdSkelSkinningQuery</ref> object for the primitive that is being skinned. If the resulting <ref refid="class_usd_skel_skinning_query" kindref="compound">UsdSkelSkinningQuery</ref> is invalid, that means that either the primitive is not considered to be skinnable, or the skinning properties are malformed in some way. If the latter, appropriate warning messages will have been posted.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Find<sp/>the<sp/>Skeleton<sp/>that<sp/>should<sp/>affect<sp/>this<sp/>prim.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_usd_skel_skeleton" kindref="compound">UsdSkelSkeleton</ref><sp/>skel<sp/>=<sp/><ref refid="class_usd_skel_binding_a_p_i" kindref="compound">UsdSkelBindingAPI</ref>(prim).<ref refid="class_usd_skel_binding_a_p_i_1a781a5a151d35fd6f9f1773f5755d261d" kindref="member">GetInheritedSkeleton</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref><sp/>skelQuery<sp/>=<sp/>skelCache.<ref refid="class_usd_skel_cache_1aaef141286813bfeb6998a8f0ac08b43b" kindref="member">GetSkelQuery</ref>(skel))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Apply<sp/>skinning?</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="comment">#<sp/>Find<sp/>the<sp/>Skeleton<sp/>that<sp/>should<sp/>affect<sp/>this<sp/>prim.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">skel<sp/>=<sp/>UsdSkel.BindingAPI(prim).GetInheritedSkeleton()</highlight></codeline>
<codeline><highlight class="normal">skelQuery<sp/>=<sp/>skelCache.GetSkelQuery(skel);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>skelQuery:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Apply<sp/>skinning?</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>If we&apos;ve acquired a valid <ref refid="class_usd_skel_skinning_query" kindref="compound">UsdSkelSkinningQuery</ref>, we know that a primitive is a valid candidate for skinning. The next logical step might be to determine which Skeleton affects skinning. <ref refid="class_usd_skel_binding_a_p_i_1a781a5a151d35fd6f9f1773f5755d261d" kindref="member">UsdSkelBindingAPI::GetInheritedSkeleton</ref> can be used to discover the bound Skeleton, based on the inherited <emphasis>skel:skeleton</emphasis> binding properties. As before, once we have a Skeleton, we can get access to a <ref refid="class_usd_skel_skeleton_query" kindref="compound">UsdSkelSkeletonQuery</ref> to assist value extraction.</para>
</sect2>
<sect2 id="_usd_skel__a_p_i__intro_1UsdSkel_API_SkinningQuery">
<title>UsdSkelSkinningQuery: Extracting joint influences</title>
<para>Coding examples from the previous sections demonstrated how to find skinnable primitives and gain access to a <ref refid="class_usd_skel_skinning_query" kindref="compound">UsdSkelSkinningQuery</ref> object for a skinnable primitive. Here we briefly demonstrate some of the basic queries that can be used to extract joint influences from skinning queries:</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal">VtIntArray<sp/>jointIndices;</highlight></codeline>
<codeline><highlight class="normal">VtFloatArray<sp/>jointWeights;</highlight></codeline>
<codeline><highlight class="normal">skinningQuery.ComputeJointInfluences(&amp;jointIndices,<sp/>&amp;jointWeights);</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">influences<sp/>=<sp/>skinningQuery.ComputeJointInfluences()</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>influences:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>jointIndices,jointWeights<sp/>=<sp/>influences</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>Use <ref refid="class_usd_skel_skinning_query_1a55b3d590dfab71d7d108f09d138d3351" kindref="member">UsdSkelSkinningQuery::IsRigidlyDeformed</ref> to determine whether or not these arrays represent rigid influences, or varying (per-point) influences.</para>
<para>If the skinnable primitive is <emphasis>not</emphasis> rigidly deforming, then these arrays store a fixed number of influences per point. The full set of influences for the first point come first, followed by the influences for the second point, and so forth. <ref refid="class_usd_skel_skinning_query_1ae9c6fae1e6724c31e15f04295da5e976" kindref="member">UsdSkelSkinningQuery::ComputeVaryingJointInfluences</ref></para>
<para>returns the number of influences that map to each point.</para>
<para>If the skinnable primitive is rigidly deforming, then all of the resulting influences apply to <emphasis>every point</emphasis>. Such a deformation can also be applied by altering a primitive&apos;s transform <ndash/> hence, a rigid deformation. It is up to the client to determine how to deal with rigid influences.</para>
<para>Not all applications are capable of dealing with rigid transformations. If that&apos;s the case, <ref refid="class_usd_skel_skinning_query_1ae9c6fae1e6724c31e15f04295da5e976" kindref="member">UsdSkelSkinningQuery::ComputeVaryingJointInfluences</ref> can be used instead:</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal">VtIntArray<sp/>jointIndices;</highlight></codeline>
<codeline><highlight class="normal">VtFloatArray<sp/>jointWeights;</highlight></codeline>
<codeline><highlight class="normal">skinningQuery.ComputeVaryingJointInfluences(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>numPoints,<sp/>&amp;jointIndices,<sp/>&amp;jointWeights);</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">influences<sp/>=<sp/>skinningQuery.ComputeVaryingJointInfluences(numPoints)</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>influences:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>jointIndices,jointWeights<sp/>=<sp/>influences</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>When calling <ref refid="class_usd_skel_skinning_query_1ae9c6fae1e6724c31e15f04295da5e976" kindref="member">UsdSkelSkinningQuery::ComputeVaryingJointInfluences</ref>, rigid influences are automatically expanded out to define per-point influences.</para>
<para>Another restriction encountered in some applications is that they have a limit on the number of influences that may be specified per point. We do not feel that it is appropriate to enforce such application-specific limitations on the storage encoding, so UsdSkel defines no limit on the number of influences.</para>
<para>However, UsdSkel does provide utility methods to allow influence arrays to be resized, which such applications may use:</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>numInfluencesPerComponent<sp/>=<sp/>skinningQuery.GetNumInfluencesPerComponent();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(numInfluencesPerComponent<sp/>&gt;<sp/>4)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><ref refid="group___usd_skel___joint_influence_utils_1ga062c9743f1bfb73b8274098c3349c4ef" kindref="member">UsdSkelResizeInfluences</ref>(&amp;jointIndices,<sp/>numInfluencesPerComponent,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><ref refid="group___usd_skel___joint_influence_utils_1ga062c9743f1bfb73b8274098c3349c4ef" kindref="member">UsdSkelResizeInfluences</ref>(&amp;jointWeights,<sp/>numInfluencesPerComponent,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">numInfluencesPerComponent<sp/>=<sp/>skinningQuery.GetNumInfluencesPerComponent()</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>numInfluencesPerComponent<sp/>&gt;<sp/>4:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>UsdSkel.ResizeInfluences(jointIndices,<sp/>numInfluencesPerComponent,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>UsdSkel.ResizeInfluences(jointWeights,<sp/>numInfluencesPerComponent,<sp/>4);</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
</sect2>
</sect1>
<sect1 id="_usd_skel__a_p_i__intro_1UsdSkel_API_BakeSkinning">
<title>Testing Skinning with UsdSkelBakeSkinning</title>
<para>UsdSkel provides a UsdSkelBakeSkinning method that bakes the results of skinning directly into points and transforms, effectively converting skeletally posed primitives into normal geometry caches, with no special skeletal behaviors.</para>
<para>UsdSkelBakeSkinning is intended both to serve as a reference implementation for skinning, and to help facilitate testing. <simplesect kind="warning"><para>UsdSkelBakeSkinning is intended for testing and debugging, and emphasizes correctness over performance. It should not be used in performance-sensitive contexts.</para>
</simplesect>
Skinning can be baked on a stage as follows:</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal">UsdSkelBakeSkinning(stage-&gt;Traverse());</highlight></codeline>
<codeline><highlight class="normal">stage-&gt;Save();</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">UsdSkel.BakeSkinning(stage.Traverse());</highlight></codeline>
<codeline><highlight class="normal">stage.Save();</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="_usd_skel__a_p_i__intro_1UsdSkel_API_WritingSkels">
<title>Writing Skeletons</title>
<para>The following code demonstrates the full USD/UsdSkel API, showing how an animated Skeleton might be authored by a DCC application. It is not meant to be a definitive example on the <emphasis>right</emphasis> way to author a Skeleton, but merely serves as a simple example to start from.</para>
<para>For simplicity, this example focuses solely on encoding a Skeleton, and does not including bindings for skinnable primitives.</para>
<para>As with previous examples, we begin with complete code, and then break it down into its component parts.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">WriteAnimatedSkel(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>UsdStagePtr&amp;<sp/>stage,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_sdf_path" kindref="compound">SdfPath</ref>&amp;<sp/>skelPath,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SdfPathVector&amp;<sp/>jointPaths,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;GfMatrix4d&gt;&amp;<sp/>rootTransformsPerFrame,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;VtMatrix4dArray&gt;&amp;<sp/>jointWorldSpaceTransformsPerFrame,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;UsdTimeCode&gt;&amp;<sp/>times,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VtMatrix4dArray&amp;<sp/>bindTransforms,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VtMatrix4dArray*<sp/>restTransforms=</highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(rootTransformsPerFrame.size()<sp/>!=<sp/>times.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(jointWorldSpaceTransformsPerFrame.size()<sp/>!=<sp/>times.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bindTransforms.size()<sp/>!=<sp/>jointPaths.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="class_usd_skel_skeleton" kindref="compound">UsdSkelSkeleton</ref><sp/>skel<sp/>=<sp/><ref refid="class_usd_skel_skeleton_1a24c1eea74c3316635f1105a4b76f1315" kindref="member">UsdSkelSkeleton::Define</ref>(stage,<sp/>skelPath);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!skel)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__tf___diagnostic_1gaba2e638edaae9e9c6e5180e020f12ccf" kindref="member">TF_WARN</ref>(</highlight><highlight class="stringliteral">&quot;Failed<sp/>creating<sp/>a<sp/>Skeleton<sp/>prim<sp/>at<sp/>&lt;%s&gt;.&quot;</highlight><highlight class="normal">,<sp/>skelPath.<ref refid="class_sdf_path_1a31225e07892b847e3e98473f7f04dbf4" kindref="member">GetText</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>numJoints<sp/>=<sp/>jointPaths.size();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="class_usd_skel_topology" kindref="compound">UsdSkelTopology</ref><sp/>topo(jointPaths);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::string<sp/>reason;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!topo.Validate(&amp;reason))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__tf___diagnostic_1gaba2e638edaae9e9c6e5180e020f12ccf" kindref="member">TF_WARN</ref>(</highlight><highlight class="stringliteral">&quot;Invalid<sp/>topology:<sp/>%s&quot;</highlight><highlight class="normal">,<sp/>reason.c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>VtTokenArray<sp/>jointTokens(numJoints);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>jointPaths.size();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jointTokens[i]<sp/>=<sp/><ref refid="class_tf_token" kindref="compound">TfToken</ref>(jointPaths[i].GetString());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>skel.<ref refid="class_usd_skel_skeleton_1aa6bf8297f4aae6de9fbf1b784c524d30" kindref="member">GetJointsAttr</ref>().<ref refid="class_usd_attribute_1a7fd0957eecddb7cfcd222cccd51e23e6" kindref="member">Set</ref>(jointTokens);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>skel.<ref refid="class_usd_skel_skeleton_1a0762be4742010c4943912c4c428624dc" kindref="member">GetBindTransformsAttr</ref>().<ref refid="class_usd_attribute_1a7fd0957eecddb7cfcd222cccd51e23e6" kindref="member">Set</ref>(bindTransforms);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(restTransforms<sp/>&amp;&amp;<sp/>restTransforms-&gt;size()<sp/>==<sp/>numJoints)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skel.<ref refid="class_usd_skel_skeleton_1af1fb07ad318db8d810a3afd7925b31ee" kindref="member">GetRestTransformsAttr</ref>().<ref refid="class_usd_attribute_1a7fd0957eecddb7cfcd222cccd51e23e6" kindref="member">Set</ref>(*restTransforms);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="class_usd_attribute" kindref="compound">UsdAttribute</ref><sp/>rootTransformAttr<sp/>=<sp/>skel.<ref refid="class_usd_geom_xformable_1a97e5c56a739490600e4e7e37b3953a08" kindref="member">MakeMatrixXform</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>times.size();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rootTransformAttr.<ref refid="class_usd_attribute_1a7fd0957eecddb7cfcd222cccd51e23e6" kindref="member">Set</ref>(rootTransformsPerFrame[i],<sp/>times[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="class_usd_skel_animation" kindref="compound">UsdSkelAnimation</ref><sp/>anim<sp/>=<sp/><ref refid="class_usd_skel_animation_1a81230ba662e765774cc2a956c1820c95" kindref="member">UsdSkelAnimation::Define</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stage,<sp/>skelPath.<ref refid="class_sdf_path_1ab38c801f846f5eda9934f7306a0ba229" kindref="member">AppendChild</ref>(<ref refid="class_tf_token" kindref="compound">TfToken</ref>(</highlight><highlight class="stringliteral">&quot;Anim&quot;</highlight><highlight class="normal">)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="class_usd_skel_binding_a_p_i" kindref="compound">UsdSkelBindingAPI</ref><sp/>binding<sp/>=<sp/><ref refid="class_usd_skel_binding_a_p_i_1a82e008f7c638888bea48d2e6f5172fdb" kindref="member">UsdSkelBindingAPI::Apply</ref>(skel.<ref refid="class_usd_schema_base_1a4ba10e023e7f3f3c93131bc7fc3146b7" kindref="member">GetPrim</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>binding.<ref refid="class_usd_skel_binding_a_p_i_1a3a26d9df3fddd642e023779fe355b113" kindref="member">CreateSkeletonRel</ref>().<ref refid="class_usd_relationship_1a459108ba8902c4bf7ba4dbe55b9f3416" kindref="member">SetTargets</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SdfPathVector({anim.<ref refid="class_usd_schema_base_1a4ba10e023e7f3f3c93131bc7fc3146b7" kindref="member">GetPrim</ref>().<ref refid="class_usd_object_1a936bfb1e341cc81184c64af44763c433" kindref="member">GetPath</ref>()}));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>anim.<ref refid="class_usd_skel_animation_1aa6bf8297f4aae6de9fbf1b784c524d30" kindref="member">GetJointsAttr</ref>().<ref refid="class_usd_attribute_1a7fd0957eecddb7cfcd222cccd51e23e6" kindref="member">Set</ref>(jointTokens);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>root<sp/>transforms<sp/>and<sp/>joint<sp/>transforms<sp/>per<sp/>frame.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>times.size();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_gf_matrix4d" kindref="compound">GfMatrix4d</ref>&amp;<sp/>rootTransform<sp/>=<sp/>rootTransformsPerFrame[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VtMatrix4dArray&amp;<sp/>jointWorldSpaceTransforms<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jointWorldSpaceTransformsPerFrame[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(jointWorldSpaceTransforms.size()<sp/>==<sp/>numJoints)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VtMatrix4dArray<sp/>jointLocalSpaceTransforms;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group___usd_skel___joint_transform_utils_1ga3864a18b6185a003ab1ee0f004cf5735" kindref="member">UsdSkelComputeJointLocalTransforms</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topo,<sp/>jointWorldSpaceTransforms,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;jointLocalSpaceTransforms,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;rootTransform))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>anim.<ref refid="class_usd_skel_animation_1a0bdf0f733d58eefc30787a0721e1c889" kindref="member">SetTransforms</ref>(jointLocalSpaceTransforms,<sp/>times[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Don&apos;t<sp/>forget<sp/>to<sp/>call<sp/>Save()<sp/>on<sp/>the<sp/>stage!</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="keyword">def<sp/></highlight><highlight class="normal">WriteAnimatedSkel(stage,<sp/>skelPath,<sp/>jointPaths,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rootTransformsPerFrame,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jointWorldSpaceTransformsPerFrame,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>times,<sp/>bindTransforms,<sp/>restTransforms=None):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>len(rootTransformsPerFrame)<sp/>==<sp/>len(times):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">False</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>len(jointWorldSpaceTransformsPerFrame)<sp/>==<sp/>len(times):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">False</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>len(bindTransforms)<sp/>==<sp/>len(jointPaths):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">False</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>skel<sp/>=<sp/>UsdSkel.Skeleton.Define(stage,<sp/>skelPath)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>skel:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tf.Warn(</highlight><highlight class="stringliteral">&quot;Failed<sp/>defining<sp/>a<sp/>Skeleton<sp/>at<sp/>&lt;%s&gt;.&quot;</highlight><highlight class="normal">,<sp/>skelPath)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">False</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>numJoints<sp/>=<sp/>len(jointPaths)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>topo<sp/>=<sp/>UsdSkel.Topology(jointPaths)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>valid,whyNot<sp/>=<sp/>topo.Validate()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>valid:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tf.Warn(</highlight><highlight class="stringliteral">&quot;Invalid<sp/>topology:<sp/>%s&quot;</highlight><highlight class="normal">%reason)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">False</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>jointTokens<sp/>=<sp/>Vt.TokenArray([jointPath.pathString<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>jointPath<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>jointPaths])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>skel.GetJointsAttr().Set(jointTokens)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>skel.GetBindTransformsAttr().Set(bindTransforms)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>restTransforms<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>len(restTransforms)<sp/>==<sp/>numJoints:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skel.GetRestTransformsAttr().Set(restTransforms)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rootTransformAttr<sp/>=<sp/>skel.MakeMatrixXform()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>i,time<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>enumerate(times):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rootTransformAttr.Set(rootTransformsPerFrame[i],<sp/>time)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>anim<sp/>=<sp/>UsdSkel.Animation.Define(stage,<sp/>skelPath.AppendChild(</highlight><highlight class="stringliteral">&quot;Anim&quot;</highlight><highlight class="normal">))</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>binding<sp/>=<sp/>UsdSkel.BindingAPI.Apply(skel.GetPrim())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>binding.CreateSkeletonRel().SetTargets([anim.GetPrim().GetPath()])</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>anim.GetJointsAttr().Set(jointTokens)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>i,time<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>enumerate(times):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rootTransform<sp/>=<sp/>rootTransformsPerFrame[i]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jointWorldSpaceTransforms<sp/>=<sp/>jointWorldSpaceTransformsPerFrame[i]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>len(jointWorldSpaceTransforms)<sp/>==<sp/>numJoints:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>jointLocalSpaceTransforms<sp/>=\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UsdSkel.ComputeJointLocalTransforms(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topo,<sp/>jointWorldSpaceTransforms,<sp/>rootTransform)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>jointLocalSpaceTransforms:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>anim.SetTransforms(jointLocalSpaceTransforms,<sp/>time)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Don&apos;t<sp/>forget<sp/>to<sp/>call<sp/>Save()<sp/>on<sp/>the<sp/>stage!</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">True</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(rootTransformsPerFrame.size()<sp/>!=<sp/>times.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(jointWorldSpaceTransformsPerFrame.size()<sp/>!=<sp/>times.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bindTransforms.size()<sp/>!=<sp/>jointPaths.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>len(rootTransformsPerFrame)<sp/>==<sp/>len(times):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">False</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>len(jointWorldSpaceTransformsPerFrame)<sp/>==<sp/>len(times):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">False</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>len(bindTransforms)<sp/>==<sp/>len(jointPaths):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">False</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>For this method, we expect <emphasis>rootTransformsPerFrame</emphasis> to be an array holding a <ref refid="class_gf_matrix4d" kindref="compound">GfMatrix4d</ref> for each time in <emphasis>times</emphasis>. Similarly, <emphasis>jointWorldSpaceTransformsPerFrame</emphasis> holds a VtMatrix4dArray for each time in <emphasis>times</emphasis>, providing the full set of joint transforms for the corresponding time. Finally, the <emphasis>jointPaths</emphasis> input is an array of <ref refid="class_sdf_path" kindref="compound">SdfPath</ref> objects giving the path of each joint, and establishing the <ref refid="_usd_skel__schemas_1UsdSkel_JointOrder" kindref="member">Joint Order</ref> of the skeleton. The required bindTransforms array must be the same size.</para>
<para>A more complete implementation would provide useful warning messages, rather than simply returning <emphasis>false</emphasis>.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="class_usd_skel_skeleton" kindref="compound">UsdSkelSkeleton</ref><sp/>skel<sp/>=<sp/><ref refid="class_usd_skel_skeleton_1a24c1eea74c3316635f1105a4b76f1315" kindref="member">UsdSkelSkeleton::Define</ref>(stage,<sp/>skelPath);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!skel)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__tf___diagnostic_1gaba2e638edaae9e9c6e5180e020f12ccf" kindref="member">TF_WARN</ref>(</highlight><highlight class="stringliteral">&quot;Failed<sp/>creating<sp/>a<sp/>Skeleton<sp/>prim<sp/>at<sp/>&lt;%s&gt;.&quot;</highlight><highlight class="normal">,<sp/>skelPath.<ref refid="class_sdf_path_1a31225e07892b847e3e98473f7f04dbf4" kindref="member">GetText</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">skel<sp/>=<sp/>UsdSkel.Skeleton.Define(stage,<sp/>skelPath)</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>skel:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Tf.Warn(</highlight><highlight class="stringliteral">&quot;Failed<sp/>defining<sp/>a<sp/>Skeleton<sp/>at<sp/>&lt;%s&gt;.&quot;</highlight><highlight class="normal">,<sp/>skelPath)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">False</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>We start by defining a Skeleton primitive on the stage at the given path. It is good practice to check that the resulting prim is valid. Some reasons why we may be unable to create the prim include:<itemizedlist>
<listitem><para>The provided <emphasis>skelPath</emphasis> is not a valid, absolute prim path.</para>
</listitem><listitem><para>An ancestor of the prim at <emphasis>skelPath</emphasis> is already inactive on the stage. It is not possible to acquire a <ref refid="class_usd_prim" kindref="compound">UsdPrim</ref> for a descendant of an inactive prim.</para>
</listitem></itemizedlist>
</para>
<para>A more complete implementation would likely at least validate that the <emphasis>skelPath</emphasis> is not invalid.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="class_usd_skel_topology" kindref="compound">UsdSkelTopology</ref><sp/>topo(jointPaths);</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/>reason;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!topo.Validate(&amp;reason))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__tf___diagnostic_1gaba2e638edaae9e9c6e5180e020f12ccf" kindref="member">TF_WARN</ref>(</highlight><highlight class="stringliteral">&quot;Invalid<sp/>topology:<sp/>%s&quot;</highlight><highlight class="normal">,<sp/>reason.c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">topo<sp/>=<sp/>UsdSkel.Topology(jointPaths)</highlight></codeline>
<codeline><highlight class="normal">valid,whyNot<sp/>=<sp/>topo.Validate()</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>valid:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Tf.Warn(</highlight><highlight class="stringliteral">&quot;Invalid<sp/>topology:<sp/>%s&quot;</highlight><highlight class="normal">%reason)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">False</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>The input <emphasis>jointPaths</emphasis> specify the topology of the Skeleton. We construct a <ref refid="class_usd_skel_topology" kindref="compound">UsdSkelTopology</ref> object at this point primarily for use in subsequent transform computations. But this is also a good point to verify that our topology is valid.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal">VtTokenArray<sp/>jointTokens(numJoints);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>jointPaths.size();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>jointTokens[i]<sp/>=<sp/><ref refid="class_tf_token" kindref="compound">TfToken</ref>(jointPaths[i].GetString());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">skel.<ref refid="class_usd_skel_skeleton_1aa6bf8297f4aae6de9fbf1b784c524d30" kindref="member">GetJointsAttr</ref>().<ref refid="class_usd_attribute_1a7fd0957eecddb7cfcd222cccd51e23e6" kindref="member">Set</ref>(jointTokens);</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">jointTokens<sp/>=<sp/>Vt.TokenArray([jointPath.pathString<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>jointPath<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>jointPaths])</highlight></codeline>
<codeline><highlight class="normal">skel.GetJointsAttr().Set(jointTokens)</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>The actual joint topology is stored on the Skeleton primitive as an array of tokens (VtTokenArray). We convert the input paths to tokens, and write the result to the Skeleton.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal">skel.<ref refid="class_usd_skel_skeleton_1a0762be4742010c4943912c4c428624dc" kindref="member">GetBindTransformsAttr</ref>().<ref refid="class_usd_attribute_1a7fd0957eecddb7cfcd222cccd51e23e6" kindref="member">Set</ref>(bindTransforms);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(restTransforms<sp/>&amp;&amp;<sp/>restTransforms-&gt;size()<sp/>==<sp/>numJoints)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>skel.<ref refid="class_usd_skel_skeleton_1af1fb07ad318db8d810a3afd7925b31ee" kindref="member">GetRestTransformsAttr</ref>().<ref refid="class_usd_attribute_1a7fd0957eecddb7cfcd222cccd51e23e6" kindref="member">Set</ref>(*restTransforms);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">skel.GetBindTransformsAttr().Set(bindTransforms)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>restTransforms<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>len(restTransforms)<sp/>==<sp/>numJoints:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>skel.GetRestTransformsAttr().Set(restTransforms)</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>Here we author the <emphasis>bindTransforms</emphasis> property of the Skeleton. The <emphasis>restTransforms</emphasis> property has been treated as optional. But if <emphasis>restTransforms</emphasis> are not authored, then a <ref refid="class_usd_skel_animation" kindref="compound">UsdSkelAnimation</ref> must be bound to the Skeleton (which we will do shortly), and that animation must include the full set of joints. See <ref refid="_usd_skel__schemas_1UsdSkel_BindingAPI_Skeletons" kindref="member">BindingAPI: Binding Skeletons</ref> for more information on binding animations.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="class_usd_attribute" kindref="compound">UsdAttribute</ref><sp/>rootTransformAttr<sp/>=<sp/>skel.<ref refid="class_usd_geom_xformable_1a97e5c56a739490600e4e7e37b3953a08" kindref="member">MakeMatrixXform</ref>();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>times.size();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rootTransformAttr.<ref refid="class_usd_attribute_1a7fd0957eecddb7cfcd222cccd51e23e6" kindref="member">Set</ref>(rootTransformsPerFrame[i],<sp/>times[i]);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">rootTransformAttr<sp/>=<sp/>skel.MakeMatrixXform()</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>i,time<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>enumerate(times):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rootTransformAttr.Set(rootTransformsPerFrame[i],<sp/>time)</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>This demonstrates use of <ref refid="class_usd_geom_xformable" kindref="compound">UsdGeomXformable</ref> API (a base class of <ref refid="class_usd_skel_skeleton" kindref="compound">UsdSkelSkeleton</ref>) for applying transforms on primitives. For this example, the root transform has been written out directly on the Skeleton. In actual production cases, it is not uncommon for the full root transform to instead be set on an ancestor of the Skeleton.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="class_usd_skel_animation" kindref="compound">UsdSkelAnimation</ref><sp/>anim<sp/>=<sp/><ref refid="class_usd_skel_animation_1a81230ba662e765774cc2a956c1820c95" kindref="member">UsdSkelAnimation::Define</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>stage,<sp/>skelPath.<ref refid="class_sdf_path_1ab38c801f846f5eda9934f7306a0ba229" kindref="member">AppendChild</ref>(<ref refid="class_tf_token" kindref="compound">TfToken</ref>(</highlight><highlight class="stringliteral">&quot;Anim&quot;</highlight><highlight class="normal">)));</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">anim<sp/>=<sp/>UsdSkel.Animation.Define(stage,<sp/>skelPath.AppendChild(</highlight><highlight class="stringliteral">&quot;Anim&quot;</highlight><highlight class="normal">))</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>For reasons that are covered in-depth <ref refid="_usd_skel__schemas_1UsdSkel_SkelAnimation" kindref="member">elsewhere</ref>, a Skeleton&apos;s joint animations are encoded on a separate primitive.</para>
<para>Note that <emphasis>where</emphasis> on the stage we choose to place the <ref refid="class_usd_skel_animation" kindref="compound">UsdSkelAnimation</ref> primitive really only starts to matter when using <ref refid="_usd_skel__instancing" kindref="compound">instancing.</ref> In the simple case of encoding a small number of skeletons, adding the animation as a child of the Skeleton, as above, is the most straight-forward approach. But when defining skeletons that take advantage of instancing, a SkelAnimation will not be a descendant of the Skeleton.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="class_usd_skel_binding_a_p_i" kindref="compound">UsdSkelBindingAPI</ref><sp/>binding<sp/>=<sp/><ref refid="class_usd_skel_binding_a_p_i_1a82e008f7c638888bea48d2e6f5172fdb" kindref="member">UsdSkelBindingAPI::Apply</ref>(skel.<ref refid="class_usd_schema_base_1a4ba10e023e7f3f3c93131bc7fc3146b7" kindref="member">GetPrim</ref>());</highlight></codeline>
<codeline><highlight class="normal">binding.<ref refid="class_usd_skel_binding_a_p_i_1a3a26d9df3fddd642e023779fe355b113" kindref="member">CreateSkeletonRel</ref>().<ref refid="class_usd_relationship_1a459108ba8902c4bf7ba4dbe55b9f3416" kindref="member">SetTargets</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SdfPathVector({anim.<ref refid="class_usd_schema_base_1a4ba10e023e7f3f3c93131bc7fc3146b7" kindref="member">GetPrim</ref>().<ref refid="class_usd_object_1a936bfb1e341cc81184c64af44763c433" kindref="member">GetPath</ref>()}));</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">binding<sp/>=<sp/>UsdSkel.BindingAPI.Apply(skel.GetPrim())</highlight></codeline>
<codeline><highlight class="normal">binding.CreateSkeletonRel().SetTargets([anim.GetPrim().GetPath()])</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>Here we apply the <ref refid="class_usd_skel_binding_a_p_i" kindref="compound">UsdSkelBindingAPI</ref> to the Skeleton, and use it to bind the animation directly to the Skeleton. In more complex <ref refid="_usd_skel__instancing" kindref="compound">instancing</ref> scenarios, we might instead choose to bind the animation to an ancestor of the Skeleton.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal">anim.<ref refid="class_usd_skel_animation_1aa6bf8297f4aae6de9fbf1b784c524d30" kindref="member">GetJointsAttr</ref>().<ref refid="class_usd_attribute_1a7fd0957eecddb7cfcd222cccd51e23e6" kindref="member">Set</ref>(jointTokens);</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">anim.GetJointsAttr().Set(jointTokens)</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>Previously, we stored <emphasis>jointTokens</emphasis> on the Skeleton, to encode topology. When creating a <ref refid="class_usd_skel_animation" kindref="compound">UsdSkelAnimation</ref>, we need to once again store the joint tokens. The <emphasis>jointTokens</emphasis> set on the animation define the <ref refid="_usd_skel__schemas_1UsdSkel_JointOrder" kindref="member">Joint Order</ref> of the animation. In this case, the joint order of the animation is identical to that of the Skeleton, but note that that need not be the case (for example, if the Skeleton includes joints for fingers, our animation could exclude the fingers).</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal">VtMatrix4dArray<sp/>jointLocalSpaceTransforms;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group___usd_skel___joint_transform_utils_1ga3864a18b6185a003ab1ee0f004cf5735" kindref="member">UsdSkelComputeJointLocalTransforms</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topo,<sp/>jointWorldSpaceTransforms,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;jointLocalSpaceTransforms,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;rootTransform))<sp/>{</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">jointLocalSpaceTransforms<sp/>=\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UsdSkel.ComputeJointLocalTransforms(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topo,<sp/>jointWorldSpaceTransforms,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rootTransform)</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>This method has been written to allow joint transforms to be provided in world space, because it is often easier for applications to reliably translate world space transform, rather than local transforms <ndash/> for example, because an application may need to skip intermediate joints, or because an application may have weird transform inheritance rules (oddities abound related to inheritance of <emphasis>scale</emphasis>!). Previously we created a <ref refid="class_usd_skel_topology" kindref="compound">UsdSkelTopology</ref> object, primarily so that it can be used at this point to convert world space joint transforms into local space, as required by the <ref refid="class_usd_skel_animation" kindref="compound">UsdSkelAnimation</ref> schema.</para>
<para>Of course, if it is easy for an application to provide transforms directly in local space, this conversion would be unnecessary.</para>
<para><itemizedlist>
<listitem><para>C++: <programlisting filename=".cpp"><codeline><highlight class="normal">anim.<ref refid="class_usd_skel_animation_1a0bdf0f733d58eefc30787a0721e1c889" kindref="member">SetTransforms</ref>(jointLocalSpaceTransforms,<sp/>times[i]);</highlight></codeline>
</programlisting></para>
</listitem><listitem><para>Python: <programlisting filename=".py"><codeline><highlight class="normal">anim.SetTransforms(jointLocalSpaceTransforms,<sp/>time)</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
<para>Finally, we write joint transforms on the <ref refid="class_usd_skel_animation" kindref="compound">UsdSkelAnimation</ref> primitive. </para>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
