<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="class_hgi_g_l" kind="class" language="C++" prot="public" final="yes">
    <compoundname>HgiGL</compoundname>
    <basecompoundref refid="class_hgi" prot="public" virt="non-virtual">Hgi</basecompoundref>
    <includes refid="_l_2hgi_8h" local="no">hgi.h</includes>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_hgi_g_l_1ad4cb1651c4b80bde1e91335ecee9a22e" prot="private" static="no" mutable="no">
        <type><ref refid="class_hgi_g_l_device" kindref="compound">HgiGLDevice</ref> *</type>
        <definition>HgiGLDevice* _device</definition>
        <argsstring></argsstring>
        <name>_device</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="222" column="1" bodyfile="pxr/imaging/hgiGL/hgi.h" bodystart="222" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_hgi_g_l_1ae65e8247504604876b198a8e9e039dec" prot="private" static="no" mutable="no">
        <type>std::unique_ptr&lt; <ref refid="class_hgi_g_l_capabilities" kindref="compound">HgiGLCapabilities</ref> &gt;</type>
        <definition>std::unique_ptr&lt;HgiGLCapabilities&gt; _capabilities</definition>
        <argsstring></argsstring>
        <name>_capabilities</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="223" column="1" bodyfile="pxr/imaging/hgiGL/hgi.h" bodystart="223" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_hgi_g_l_1aceecb650e4413830fa3bdb066cca3966" prot="private" static="no" mutable="no">
        <type><ref refid="class_hgi_g_l_garbage_collector" kindref="compound">HgiGLGarbageCollector</ref></type>
        <definition>HgiGLGarbageCollector _garbageCollector</definition>
        <argsstring></argsstring>
        <name>_garbageCollector</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="224" column="1" bodyfile="pxr/imaging/hgiGL/hgi.h" bodystart="224" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_hgi_g_l_1a7892214a5bc51480360a14b02d10bdaa" prot="private" static="no" mutable="no">
        <type>int</type>
        <definition>int _frameDepth</definition>
        <argsstring></argsstring>
        <name>_frameDepth</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="225" column="1" bodyfile="pxr/imaging/hgiGL/hgi.h" bodystart="225" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="class_hgi_g_l_1a24ebbbdf99975bf4bfacf43481348718" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>HGIGL_API</type>
        <definition>HGIGL_API HgiGL</definition>
        <argsstring>()</argsstring>
        <name>HgiGL</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="75" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1af974d54b48346827827933902ba9c79c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>HGIGL_API</type>
        <definition>HGIGL_API ~HgiGL</definition>
        <argsstring>() override</argsstring>
        <name>~HgiGL</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="78" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a1a4bcb48912d5588e4182f6840281145" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API bool</type>
        <definition>HGIGL_API bool IsBackendSupported</definition>
        <argsstring>() const override</argsstring>
        <name>IsBackendSupported</name>
        <reimplements refid="class_hgi_1a407d8e78d04e6dd96f3ade45514d20c8">IsBackendSupported</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><hruler/>
 <heading level="2">Virtual API </heading>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="85" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a077e0f6839b485c1b3a55be66f3c5f01" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API HgiGraphicsCmdsUniquePtr</type>
        <definition>HGIGL_API HgiGraphicsCmdsUniquePtr CreateGraphicsCmds</definition>
        <argsstring>(HgiGraphicsCmdsDesc const &amp;desc) override</argsstring>
        <name>CreateGraphicsCmds</name>
        <reimplements refid="class_hgi_1a7bcca31b306a8e305d782af95cc18b32">CreateGraphicsCmds</reimplements>
        <param>
          <type><ref refid="struct_hgi_graphics_cmds_desc" kindref="compound">HgiGraphicsCmdsDesc</ref> const &amp;</type>
          <declname>desc</declname>
        </param>
        <briefdescription>
<para>Returns a GraphicsCmds object (for temporary use) that is ready to record draw commands. </para>
        </briefdescription>
        <detaileddescription>
<para>GraphicsCmds is a lightweight object that should be re-acquired each frame (don&apos;t hold onto it after EndEncoding). Thread safety: Each <ref refid="class_hgi" kindref="compound">Hgi</ref> backend must ensure that a Cmds object can be created on the main thread, recorded into (exclusively) by one secondary thread and be submitted on the main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="88" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a879677caf90451945e84826187ee2441" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API HgiBlitCmdsUniquePtr</type>
        <definition>HGIGL_API HgiBlitCmdsUniquePtr CreateBlitCmds</definition>
        <argsstring>() override</argsstring>
        <name>CreateBlitCmds</name>
        <reimplements refid="class_hgi_1ac2b2da7d952d0f750ed48695fc9a61eb">CreateBlitCmds</reimplements>
        <briefdescription>
<para>Returns a BlitCmds object (for temporary use) that is ready to execute resource copy commands. </para>
        </briefdescription>
        <detaileddescription>
<para>BlitCmds is a lightweight object that should be re-acquired each frame (don&apos;t hold onto it after EndEncoding). Thread safety: Each <ref refid="class_hgi" kindref="compound">Hgi</ref> backend must ensure that a Cmds object can be created on the main thread, recorded into (exclusively) by one secondary thread and be submitted on the main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="92" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1aa96795934ae3a3a23528f3d7f9e1b2e6" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API HgiComputeCmdsUniquePtr</type>
        <definition>HGIGL_API HgiComputeCmdsUniquePtr CreateComputeCmds</definition>
        <argsstring>(HgiComputeCmdsDesc const &amp;desc) override</argsstring>
        <name>CreateComputeCmds</name>
        <reimplements refid="class_hgi_1ab90de4e93cf496894b0d4ba81434140d">CreateComputeCmds</reimplements>
        <param>
          <type><ref refid="struct_hgi_compute_cmds_desc" kindref="compound">HgiComputeCmdsDesc</ref> const &amp;</type>
          <declname>desc</declname>
        </param>
        <briefdescription>
<para>Returns a ComputeCmds object (for temporary use) that is ready to record dispatch commands. </para>
        </briefdescription>
        <detaileddescription>
<para>ComputeCmds is a lightweight object that should be re-acquired each frame (don&apos;t hold onto it after EndEncoding). Thread safety: Each <ref refid="class_hgi" kindref="compound">Hgi</ref> backend must ensure that a Cmds object can be created on the main thread, recorded into (exclusively) by one secondary thread and be submitted on the main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="95" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1ae7df62d096c0a12f92a36bf1c4a24076" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API HgiTextureHandle</type>
        <definition>HGIGL_API HgiTextureHandle CreateTexture</definition>
        <argsstring>(HgiTextureDesc const &amp;desc) override</argsstring>
        <name>CreateTexture</name>
        <reimplements refid="class_hgi_1a203cd5ef883f0ba41ce00831af6e96cd">CreateTexture</reimplements>
        <param>
          <type><ref refid="struct_hgi_texture_desc" kindref="compound">HgiTextureDesc</ref> const &amp;</type>
          <declname>desc</declname>
        </param>
        <briefdescription>
<para>Create a texture in rendering backend. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Creation must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="99" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a55028233d46438a5704cd25c89443862" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API void</type>
        <definition>HGIGL_API void DestroyTexture</definition>
        <argsstring>(HgiTextureHandle *texHandle) override</argsstring>
        <name>DestroyTexture</name>
        <reimplements refid="class_hgi_1a74ebd666f2aa6f3d65db3b97dd1ee509">DestroyTexture</reimplements>
        <param>
          <type>HgiTextureHandle *</type>
          <declname>texHandle</declname>
        </param>
        <briefdescription>
<para>Destroy a texture in rendering backend. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Destruction must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="102" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a6f121d477ce2a60073b72481a7f2e166" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API <ref refid="class_hgi_handle" kindref="compound">HgiTextureViewHandle</ref></type>
        <definition>HGIGL_API HgiTextureViewHandle CreateTextureView</definition>
        <argsstring>(HgiTextureViewDesc const &amp;desc) override</argsstring>
        <name>CreateTextureView</name>
        <reimplements refid="class_hgi_1ab15f3473097b06ba3313a4d68993292f">CreateTextureView</reimplements>
        <param>
          <type><ref refid="struct_hgi_texture_view_desc" kindref="compound">HgiTextureViewDesc</ref> const &amp;</type>
          <declname>desc</declname>
        </param>
        <briefdescription>
<para>Create a texture view in rendering backend. </para>
        </briefdescription>
        <detaileddescription>
<para>A texture view aliases another texture&apos;s data. It is the responsibility of the client to ensure that the sourceTexture is not destroyed while the texture view is in use. Thread safety: Creation must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="105" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a5b07fdbdfe6a80212287ba4e0cf57cf6" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API void</type>
        <definition>HGIGL_API void DestroyTextureView</definition>
        <argsstring>(HgiTextureViewHandle *viewHandle) override</argsstring>
        <name>DestroyTextureView</name>
        <reimplements refid="class_hgi_1a68755a4beb78a7ef33e81f80cbbee3e1">DestroyTextureView</reimplements>
        <param>
          <type><ref refid="class_hgi_handle" kindref="compound">HgiTextureViewHandle</ref> *</type>
          <declname>viewHandle</declname>
        </param>
        <briefdescription>
<para>Destroy a texture view in rendering backend. </para>
        </briefdescription>
        <detaileddescription>
<para>This will destroy the view&apos;s texture, but not the sourceTexture that was aliased by the view. The sourceTexture data remains unchanged. Thread safety: Destruction must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="109" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1aa585ae902a63d02ae654fb57050ef440" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API <ref refid="class_hgi_handle" kindref="compound">HgiSamplerHandle</ref></type>
        <definition>HGIGL_API HgiSamplerHandle CreateSampler</definition>
        <argsstring>(HgiSamplerDesc const &amp;desc) override</argsstring>
        <name>CreateSampler</name>
        <reimplements refid="class_hgi_1a1e30e202c0bae3a120840545e90567ce">CreateSampler</reimplements>
        <param>
          <type><ref refid="struct_hgi_sampler_desc" kindref="compound">HgiSamplerDesc</ref> const &amp;</type>
          <declname>desc</declname>
        </param>
        <briefdescription>
<para>Create a sampler in rendering backend. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Creation must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="112" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1adb33e671e013bd474ccf035ebe7ea0a0" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API void</type>
        <definition>HGIGL_API void DestroySampler</definition>
        <argsstring>(HgiSamplerHandle *smpHandle) override</argsstring>
        <name>DestroySampler</name>
        <reimplements refid="class_hgi_1a5c049e81f4c28bd10ec8be6c8f9561f1">DestroySampler</reimplements>
        <param>
          <type><ref refid="class_hgi_handle" kindref="compound">HgiSamplerHandle</ref> *</type>
          <declname>smpHandle</declname>
        </param>
        <briefdescription>
<para>Destroy a sampler in rendering backend. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Destruction must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="115" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a4d1fee2a6d894d15e88667d1d670bd23" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API <ref refid="class_hgi_handle" kindref="compound">HgiBufferHandle</ref></type>
        <definition>HGIGL_API HgiBufferHandle CreateBuffer</definition>
        <argsstring>(HgiBufferDesc const &amp;desc) override</argsstring>
        <name>CreateBuffer</name>
        <reimplements refid="class_hgi_1aa7d3ce4a8fd78ac6850c04fc0a8c52c0">CreateBuffer</reimplements>
        <param>
          <type><ref refid="struct_hgi_buffer_desc" kindref="compound">HgiBufferDesc</ref> const &amp;</type>
          <declname>desc</declname>
        </param>
        <briefdescription>
<para>Create a buffer in rendering backend. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Creation must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="118" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1ac1a8becc86a0cb2195140e4cf07e1391" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API void</type>
        <definition>HGIGL_API void DestroyBuffer</definition>
        <argsstring>(HgiBufferHandle *bufHandle) override</argsstring>
        <name>DestroyBuffer</name>
        <reimplements refid="class_hgi_1a090ed0465f1f25cac321c95e3800f603">DestroyBuffer</reimplements>
        <param>
          <type><ref refid="class_hgi_handle" kindref="compound">HgiBufferHandle</ref> *</type>
          <declname>bufHandle</declname>
        </param>
        <briefdescription>
<para>Destroy a buffer in rendering backend. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Destruction must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="121" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1aa278d5c0cb57fa63fb18f64a0eaada65" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API <ref refid="class_hgi_handle" kindref="compound">HgiShaderFunctionHandle</ref></type>
        <definition>HGIGL_API HgiShaderFunctionHandle CreateShaderFunction</definition>
        <argsstring>(HgiShaderFunctionDesc const &amp;desc) override</argsstring>
        <name>CreateShaderFunction</name>
        <reimplements refid="class_hgi_1a4445f60d4aca3de8abafb03e61c6fa4c">CreateShaderFunction</reimplements>
        <param>
          <type><ref refid="struct_hgi_shader_function_desc" kindref="compound">HgiShaderFunctionDesc</ref> const &amp;</type>
          <declname>desc</declname>
        </param>
        <briefdescription>
<para>Create a new shader function. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Creation must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="124" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a7063bf56dc01441d3485d8aa641b2d3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API void</type>
        <definition>HGIGL_API void DestroyShaderFunction</definition>
        <argsstring>(HgiShaderFunctionHandle *shaderFunctionHandle) override</argsstring>
        <name>DestroyShaderFunction</name>
        <reimplements refid="class_hgi_1afcd358204f65ef003f768129a4644da2">DestroyShaderFunction</reimplements>
        <param>
          <type><ref refid="class_hgi_handle" kindref="compound">HgiShaderFunctionHandle</ref> *</type>
          <declname>shaderFunctionHandle</declname>
        </param>
        <briefdescription>
<para>Destroy a shader function. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Destruction must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="128" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a9c777c5a8110db4162e07fdb6d7626a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API <ref refid="class_hgi_handle" kindref="compound">HgiShaderProgramHandle</ref></type>
        <definition>HGIGL_API HgiShaderProgramHandle CreateShaderProgram</definition>
        <argsstring>(HgiShaderProgramDesc const &amp;desc) override</argsstring>
        <name>CreateShaderProgram</name>
        <reimplements refid="class_hgi_1a8527715ce5ac3e5db61fd55388e9f8a3">CreateShaderProgram</reimplements>
        <param>
          <type><ref refid="struct_hgi_shader_program_desc" kindref="compound">HgiShaderProgramDesc</ref> const &amp;</type>
          <declname>desc</declname>
        </param>
        <briefdescription>
<para>Create a new shader program. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Creation must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="132" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1ab4e70427a3348bb63c8a81e7ac6a16a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API void</type>
        <definition>HGIGL_API void DestroyShaderProgram</definition>
        <argsstring>(HgiShaderProgramHandle *shaderProgramHandle) override</argsstring>
        <name>DestroyShaderProgram</name>
        <reimplements refid="class_hgi_1a1ef9164eb5095b3fa321ad9e9b575857">DestroyShaderProgram</reimplements>
        <param>
          <type><ref refid="class_hgi_handle" kindref="compound">HgiShaderProgramHandle</ref> *</type>
          <declname>shaderProgramHandle</declname>
        </param>
        <briefdescription>
<para>Destroy a shader program. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that this does NOT automatically destroy the shader functions in the program since shader functions may be used by more than one program. Thread safety: Destruction must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="136" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1ab94a9fcc15cf745afc7815fa232c2a15" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API <ref refid="class_hgi_handle" kindref="compound">HgiResourceBindingsHandle</ref></type>
        <definition>HGIGL_API HgiResourceBindingsHandle CreateResourceBindings</definition>
        <argsstring>(HgiResourceBindingsDesc const &amp;desc) override</argsstring>
        <name>CreateResourceBindings</name>
        <reimplements refid="class_hgi_1a6867acd350c95dd3aed86957e496d7a4">CreateResourceBindings</reimplements>
        <param>
          <type><ref refid="struct_hgi_resource_bindings_desc" kindref="compound">HgiResourceBindingsDesc</ref> const &amp;</type>
          <declname>desc</declname>
        </param>
        <briefdescription>
<para>Create a new resource binding object. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Creation must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="140" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1aa73b6f626acaf60c1b97886d2a788c1b" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API void</type>
        <definition>HGIGL_API void DestroyResourceBindings</definition>
        <argsstring>(HgiResourceBindingsHandle *resHandle) override</argsstring>
        <name>DestroyResourceBindings</name>
        <reimplements refid="class_hgi_1a2cd18da57c12382c596be3977374e057">DestroyResourceBindings</reimplements>
        <param>
          <type><ref refid="class_hgi_handle" kindref="compound">HgiResourceBindingsHandle</ref> *</type>
          <declname>resHandle</declname>
        </param>
        <briefdescription>
<para>Destroy a resource binding object. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Destruction must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="144" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1ad0a2bdb9f006596286727468d5daa1c0" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API <ref refid="class_hgi_handle" kindref="compound">HgiGraphicsPipelineHandle</ref></type>
        <definition>HGIGL_API HgiGraphicsPipelineHandle CreateGraphicsPipeline</definition>
        <argsstring>(HgiGraphicsPipelineDesc const &amp;pipeDesc) override</argsstring>
        <name>CreateGraphicsPipeline</name>
        <reimplements refid="class_hgi_1ae0abd210c1ff3e2af894980036a28a92">CreateGraphicsPipeline</reimplements>
        <param>
          <type><ref refid="struct_hgi_graphics_pipeline_desc" kindref="compound">HgiGraphicsPipelineDesc</ref> const &amp;</type>
          <declname>pipeDesc</declname>
        </param>
        <briefdescription>
<para>Create a new graphics pipeline state object. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Creation must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="147" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1ac0d94f7418119e7d50ffacd9848fba8b" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API void</type>
        <definition>HGIGL_API void DestroyGraphicsPipeline</definition>
        <argsstring>(HgiGraphicsPipelineHandle *pipeHandle) override</argsstring>
        <name>DestroyGraphicsPipeline</name>
        <reimplements refid="class_hgi_1a257e66ab19a5e46a611a7510be1bfffe">DestroyGraphicsPipeline</reimplements>
        <param>
          <type><ref refid="class_hgi_handle" kindref="compound">HgiGraphicsPipelineHandle</ref> *</type>
          <declname>pipeHandle</declname>
        </param>
        <briefdescription>
<para>Destroy a graphics pipeline state object. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Destruction must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="151" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1acf9d41a6dc327e517e282469462c3b7a" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API <ref refid="class_hgi_handle" kindref="compound">HgiComputePipelineHandle</ref></type>
        <definition>HGIGL_API HgiComputePipelineHandle CreateComputePipeline</definition>
        <argsstring>(HgiComputePipelineDesc const &amp;pipeDesc) override</argsstring>
        <name>CreateComputePipeline</name>
        <reimplements refid="class_hgi_1ab63e7495a66fa99ee9e97ed0636efba4">CreateComputePipeline</reimplements>
        <param>
          <type><ref refid="struct_hgi_compute_pipeline_desc" kindref="compound">HgiComputePipelineDesc</ref> const &amp;</type>
          <declname>pipeDesc</declname>
        </param>
        <briefdescription>
<para>Create a new compute pipeline state object. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Creation must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="155" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1ae41ac3af5745a8ed6affb41348286c6e" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API void</type>
        <definition>HGIGL_API void DestroyComputePipeline</definition>
        <argsstring>(HgiComputePipelineHandle *pipeHandle) override</argsstring>
        <name>DestroyComputePipeline</name>
        <reimplements refid="class_hgi_1a3b715a7d2f70d63f664d4b5eb1cafb61">DestroyComputePipeline</reimplements>
        <param>
          <type><ref refid="class_hgi_handle" kindref="compound">HgiComputePipelineHandle</ref> *</type>
          <declname>pipeHandle</declname>
        </param>
        <briefdescription>
<para>Destroy a compute pipeline state object. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: Destruction must happen on main thread. See notes above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="159" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a77eb552daca05a50517554ad6db7a667" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API <ref refid="class_tf_token" kindref="compound">TfToken</ref> const  &amp;</type>
        <definition>HGIGL_API TfToken const&amp; GetAPIName</definition>
        <argsstring>() const override</argsstring>
        <name>GetAPIName</name>
        <reimplements refid="class_hgi_1a58bea8d97a464d6ec05ea1bf274d3afc">GetAPIName</reimplements>
        <briefdescription>
<para>Return the name of the api (e.g. </para>
        </briefdescription>
        <detaileddescription>
<para>&quot;OpenGL&quot;). Thread safety: This call is thread safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="162" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1af0db806efb2d7b1705e197a9defacfd3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API <ref refid="class_hgi_g_l_capabilities" kindref="compound">HgiGLCapabilities</ref> const  *</type>
        <definition>HGIGL_API HgiGLCapabilities const* GetCapabilities</definition>
        <argsstring>() const override</argsstring>
        <name>GetCapabilities</name>
        <reimplements refid="class_hgi_1ad5370e56339cd64e3ac8a3698b09b15a">GetCapabilities</reimplements>
        <briefdescription>
<para>Returns the device-specific capabilities structure. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: This call is thread safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="165" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a3748c86cb5f463c287b12344a0c520fd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API <ref refid="class_hgi_indirect_command_encoder" kindref="compound">HgiIndirectCommandEncoder</ref> *</type>
        <definition>HGIGL_API HgiIndirectCommandEncoder* GetIndirectCommandEncoder</definition>
        <argsstring>() const override</argsstring>
        <name>GetIndirectCommandEncoder</name>
        <reimplements refid="class_hgi_1ab698c954480429033695a7be8b92875e">GetIndirectCommandEncoder</reimplements>
        <briefdescription>
<para>Returns the device-specific indirect command buffer encoder or nullptr if not supported. </para>
        </briefdescription>
        <detaileddescription>
<para>Thread safety: This call is thread safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="168" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a1958a6177445c0e91467331741969817" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API void</type>
        <definition>HGIGL_API void StartFrame</definition>
        <argsstring>() override</argsstring>
        <name>StartFrame</name>
        <reimplements refid="class_hgi_1a727feb37caf78ea630818b679335381b">StartFrame</reimplements>
        <briefdescription>
<para>Optionally called by client app at the start of a new rendering frame. </para>
        </briefdescription>
        <detaileddescription>
<para>We can&apos;t rely on StartFrame for anything important, because it is up to the external client to (optionally) call this and they may never do. Hydra doesn&apos;t have a clearly defined start or end frame. This can be helpful to insert GPU frame debug markers. Thread safety: Not thread safe. Should be called on the main thread. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="171" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1ac1f3d5fdefc6cd377e49ac6499d1fea3" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API void</type>
        <definition>HGIGL_API void EndFrame</definition>
        <argsstring>() override</argsstring>
        <name>EndFrame</name>
        <reimplements refid="class_hgi_1a21a113ab8e7de0102774860f867ce39f">EndFrame</reimplements>
        <briefdescription>
<para>Optionally called at the end of a rendering frame. </para>
        </briefdescription>
        <detaileddescription>
<para>Please read the comments in StartFrame. Thread safety: Not thread safe. Should be called on the main thread. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="174" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a15b3dfaf1aff5dbc2af4032a1bd55eb0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>HGIGL_API <ref refid="class_hgi_g_l_device" kindref="compound">HgiGLDevice</ref> *</type>
        <definition>HGIGL_API HgiGLDevice* GetPrimaryDevice</definition>
        <argsstring>() const</argsstring>
        <name>GetPrimaryDevice</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><hruler/>
<hruler/>
 </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="182" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1abf8bf8e4a679d9c6867f0b3165ebfc4f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>HGIGL_API <ref refid="class_hgi_handle" kindref="compound">HgiGLContextArenaHandle</ref></type>
        <definition>HGIGL_API HgiGLContextArenaHandle CreateContextArena</definition>
        <argsstring>()</argsstring>
        <name>CreateContextArena</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><hruler/>
 Context arena API Please refer to &quot;GL Context Management&quot; for usage expectations.</para>
<para>Creates and return a context arena object handle. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="190" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a0fa76064995004b7602a0bd798dfa5e1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>HGIGL_API void</type>
        <definition>HGIGL_API void DestroyContextArena</definition>
        <argsstring>(HgiGLContextArenaHandle *arenaHandle)</argsstring>
        <name>DestroyContextArena</name>
        <param>
          <type><ref refid="class_hgi_handle" kindref="compound">HgiGLContextArenaHandle</ref> *</type>
          <declname>arenaHandle</declname>
        </param>
        <briefdescription>
<para>Destroy a context arena. </para>
        </briefdescription>
        <detaileddescription>
<para>Note: The context arena must be unset (by calling SetContextArena with an empty handle) prior to destruction. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="196" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a39f0f71734c408778970c346fece6837" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>HGIGL_API void</type>
        <definition>HGIGL_API void SetContextArena</definition>
        <argsstring>(HgiGLContextArenaHandle const &amp;arenaHandle)</argsstring>
        <name>SetContextArena</name>
        <param>
          <type><ref refid="class_hgi_handle" kindref="compound">HgiGLContextArenaHandle</ref> const &amp;</type>
          <declname>arenaHandle</declname>
        </param>
        <briefdescription>
<para>Set the context arena to manage container resources (currently limited to framebuffer objects) for graphics commands submitted subsequently. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="201" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-func">
      <memberdef kind="function" id="class_hgi_g_l_1acc2cf7300c5501079d31126aba9f5ec8" prot="protected" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>HGIGL_API bool</type>
        <definition>HGIGL_API bool _SubmitCmds</definition>
        <argsstring>(HgiCmds *cmds, HgiSubmitWaitType wait) override</argsstring>
        <name>_SubmitCmds</name>
        <reimplements refid="class_hgi_1a82b1bd6860c347f73d5fa4a50bf32e9f">_SubmitCmds</reimplements>
        <param>
          <type><ref refid="class_hgi_cmds" kindref="compound">HgiCmds</ref> *</type>
          <declname>cmds</declname>
        </param>
        <param>
          <type>HgiSubmitWaitType</type>
          <declname>wait</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="206" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="class_hgi_g_l_1a5baa4acfd96bc10964fe1c1719f8563f" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="class_hgi_g_l" kindref="compound">HgiGL</ref> &amp;</type>
        <definition>HgiGL&amp; operator=</definition>
        <argsstring>(const HgiGL &amp;)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="class_hgi_g_l" kindref="compound">HgiGL</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="209" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1aa9db2a2545739845689c00fffbda3d72" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>HgiGL</definition>
        <argsstring>(const HgiGL &amp;)=delete</argsstring>
        <name>HgiGL</name>
        <param>
          <type>const <ref refid="class_hgi_g_l" kindref="compound">HgiGL</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="210" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_hgi_g_l_1a05063f99258bb7bf0bf9e5c787217448" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void _TrashObject</definition>
        <argsstring>(HgiHandle&lt; T &gt; *handle, std::vector&lt; HgiHandle&lt; T &gt;&gt; *collector)</argsstring>
        <name>_TrashObject</name>
        <param>
          <type><ref refid="class_hgi_handle" kindref="compound">HgiHandle</ref>&lt; T &gt; *</type>
          <declname>handle</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="class_hgi_handle" kindref="compound">HgiHandle</ref>&lt; T &gt;&gt; *</type>
          <declname>collector</declname>
        </param>
        <briefdescription>
<para>Invalidates the resource handle and places the object in the garbage collector vector for future destruction. </para>
        </briefdescription>
        <detaileddescription>
<para>This is helpful to avoid destroying GPU resources still in-flight. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/imaging/hgiGL/hgi.h" line="216" column="1" bodyfile="pxr/imaging/hgiGL/hgi.h" bodystart="216" bodyend="220"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>OpenGL implementation of the Hydra Graphics Interface. </para>
    </briefdescription>
    <detaileddescription>
<sect1 id="class_hgi_g_l_1GL">
<title>Context Management</title>
<para><ref refid="class_hgi_g_l" kindref="compound">HgiGL</ref> expects any GL context(s) to be externally managed. When <ref refid="class_hgi_g_l" kindref="compound">HgiGL</ref> is constructed and during any of its resource create / destroy calls and during command recording operations, it expects that an OpenGL context is valid and current.</para>
<para>When an application uses the same <ref refid="class_hgi_g_l" kindref="compound">HgiGL</ref> instance from multiple GL contexts, the expectations are that:<orderedlist>
<listitem><para>The application has set up sharing amongst the various GL contexts. This ensures that any non-container resources created may be shared amongst the contexts. These shared resources may be safely deleted from any context in the share group.</para>
</listitem><listitem><para>A context arena (see relevant API below) is used per GL context to manage container resources that can&apos;t be shared amongst GL contexts. Currently, <ref refid="class_hgi_g_l" kindref="compound">HgiGL</ref>&apos;s support is limited to framebuffer objects.</para>
</listitem></orderedlist>
</para>
<para>In the absence of an application provided context arena, the default arena is used with the implied expectation that the same GL context is valid and current for the lifetime of the <ref refid="class_hgi_g_l" kindref="compound">HgiGL</ref> instance. </para>
</sect1>
    </detaileddescription>
    <inheritancegraph>
      <node id="3784">
        <label>Hgi</label>
        <link refid="class_hgi"/>
      </node>
      <node id="3783">
        <label>HgiGL</label>
        <link refid="class_hgi_g_l"/>
        <childnode refid="3784" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="3786">
        <label>Hgi</label>
        <link refid="class_hgi"/>
      </node>
      <node id="3785">
        <label>HgiGL</label>
        <link refid="class_hgi_g_l"/>
        <childnode refid="3786" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="pxr/imaging/hgiGL/hgi.h" line="72" column="1" bodyfile="pxr/imaging/hgiGL/hgi.h" bodystart="71" bodyend="226"/>
    <listofallmembers>
      <member refid="class_hgi_g_l_1ae65e8247504604876b198a8e9e039dec" prot="private" virt="non-virtual"><scope>HgiGL</scope><name>_capabilities</name></member>
      <member refid="class_hgi_g_l_1ad4cb1651c4b80bde1e91335ecee9a22e" prot="private" virt="non-virtual"><scope>HgiGL</scope><name>_device</name></member>
      <member refid="class_hgi_g_l_1a7892214a5bc51480360a14b02d10bdaa" prot="private" virt="non-virtual"><scope>HgiGL</scope><name>_frameDepth</name></member>
      <member refid="class_hgi_g_l_1aceecb650e4413830fa3bdb066cca3966" prot="private" virt="non-virtual"><scope>HgiGL</scope><name>_garbageCollector</name></member>
      <member refid="class_hgi_g_l_1acc2cf7300c5501079d31126aba9f5ec8" prot="protected" virt="virtual"><scope>HgiGL</scope><name>_SubmitCmds</name></member>
      <member refid="class_hgi_g_l_1a05063f99258bb7bf0bf9e5c787217448" prot="private" virt="non-virtual"><scope>HgiGL</scope><name>_TrashObject</name></member>
      <member refid="class_hgi_g_l_1a879677caf90451945e84826187ee2441" prot="public" virt="virtual"><scope>HgiGL</scope><name>CreateBlitCmds</name></member>
      <member refid="class_hgi_g_l_1a4d1fee2a6d894d15e88667d1d670bd23" prot="public" virt="virtual"><scope>HgiGL</scope><name>CreateBuffer</name></member>
      <member refid="class_hgi_g_l_1aa96795934ae3a3a23528f3d7f9e1b2e6" prot="public" virt="virtual"><scope>HgiGL</scope><name>CreateComputeCmds</name></member>
      <member refid="class_hgi_g_l_1acf9d41a6dc327e517e282469462c3b7a" prot="public" virt="virtual"><scope>HgiGL</scope><name>CreateComputePipeline</name></member>
      <member refid="class_hgi_g_l_1abf8bf8e4a679d9c6867f0b3165ebfc4f" prot="public" virt="non-virtual"><scope>HgiGL</scope><name>CreateContextArena</name></member>
      <member refid="class_hgi_g_l_1a077e0f6839b485c1b3a55be66f3c5f01" prot="public" virt="virtual"><scope>HgiGL</scope><name>CreateGraphicsCmds</name></member>
      <member refid="class_hgi_g_l_1ad0a2bdb9f006596286727468d5daa1c0" prot="public" virt="virtual"><scope>HgiGL</scope><name>CreateGraphicsPipeline</name></member>
      <member refid="class_hgi_1a69e7633873a0f1689ae01610a659a294" prot="public" virt="non-virtual"><scope>HgiGL</scope><name>CreatePlatformDefaultHgi</name></member>
      <member refid="class_hgi_g_l_1ab94a9fcc15cf745afc7815fa232c2a15" prot="public" virt="virtual"><scope>HgiGL</scope><name>CreateResourceBindings</name></member>
      <member refid="class_hgi_g_l_1aa585ae902a63d02ae654fb57050ef440" prot="public" virt="virtual"><scope>HgiGL</scope><name>CreateSampler</name></member>
      <member refid="class_hgi_g_l_1aa278d5c0cb57fa63fb18f64a0eaada65" prot="public" virt="virtual"><scope>HgiGL</scope><name>CreateShaderFunction</name></member>
      <member refid="class_hgi_g_l_1a9c777c5a8110db4162e07fdb6d7626a9" prot="public" virt="virtual"><scope>HgiGL</scope><name>CreateShaderProgram</name></member>
      <member refid="class_hgi_g_l_1ae7df62d096c0a12f92a36bf1c4a24076" prot="public" virt="virtual"><scope>HgiGL</scope><name>CreateTexture</name></member>
      <member refid="class_hgi_g_l_1a6f121d477ce2a60073b72481a7f2e166" prot="public" virt="virtual"><scope>HgiGL</scope><name>CreateTextureView</name></member>
      <member refid="class_hgi_g_l_1ac1a8becc86a0cb2195140e4cf07e1391" prot="public" virt="virtual"><scope>HgiGL</scope><name>DestroyBuffer</name></member>
      <member refid="class_hgi_g_l_1ae41ac3af5745a8ed6affb41348286c6e" prot="public" virt="virtual"><scope>HgiGL</scope><name>DestroyComputePipeline</name></member>
      <member refid="class_hgi_g_l_1a0fa76064995004b7602a0bd798dfa5e1" prot="public" virt="non-virtual"><scope>HgiGL</scope><name>DestroyContextArena</name></member>
      <member refid="class_hgi_g_l_1ac0d94f7418119e7d50ffacd9848fba8b" prot="public" virt="virtual"><scope>HgiGL</scope><name>DestroyGraphicsPipeline</name></member>
      <member refid="class_hgi_g_l_1aa73b6f626acaf60c1b97886d2a788c1b" prot="public" virt="virtual"><scope>HgiGL</scope><name>DestroyResourceBindings</name></member>
      <member refid="class_hgi_g_l_1adb33e671e013bd474ccf035ebe7ea0a0" prot="public" virt="virtual"><scope>HgiGL</scope><name>DestroySampler</name></member>
      <member refid="class_hgi_g_l_1a7063bf56dc01441d3485d8aa641b2d3f" prot="public" virt="virtual"><scope>HgiGL</scope><name>DestroyShaderFunction</name></member>
      <member refid="class_hgi_g_l_1ab4e70427a3348bb63c8a81e7ac6a16a4" prot="public" virt="virtual"><scope>HgiGL</scope><name>DestroyShaderProgram</name></member>
      <member refid="class_hgi_g_l_1a55028233d46438a5704cd25c89443862" prot="public" virt="virtual"><scope>HgiGL</scope><name>DestroyTexture</name></member>
      <member refid="class_hgi_g_l_1a5b07fdbdfe6a80212287ba4e0cf57cf6" prot="public" virt="virtual"><scope>HgiGL</scope><name>DestroyTextureView</name></member>
      <member refid="class_hgi_g_l_1ac1f3d5fdefc6cd377e49ac6499d1fea3" prot="public" virt="virtual"><scope>HgiGL</scope><name>EndFrame</name></member>
      <member refid="class_hgi_g_l_1a77eb552daca05a50517554ad6db7a667" prot="public" virt="virtual"><scope>HgiGL</scope><name>GetAPIName</name></member>
      <member refid="class_hgi_g_l_1af0db806efb2d7b1705e197a9defacfd3" prot="public" virt="virtual"><scope>HgiGL</scope><name>GetCapabilities</name></member>
      <member refid="class_hgi_g_l_1a3748c86cb5f463c287b12344a0c520fd" prot="public" virt="virtual"><scope>HgiGL</scope><name>GetIndirectCommandEncoder</name></member>
      <member refid="class_hgi_1a40ab24a195f87c0b377ee0705f6a1775" prot="public" virt="non-virtual"><scope>HgiGL</scope><name>GetPlatformDefaultHgi</name></member>
      <member refid="class_hgi_g_l_1a15b3dfaf1aff5dbc2af4032a1bd55eb0" prot="public" virt="non-virtual"><scope>HgiGL</scope><name>GetPrimaryDevice</name></member>
      <member refid="class_hgi_1afdb85b10705cedea17ccc1e56b232427" prot="protected" virt="non-virtual"><scope>HgiGL</scope><name>GetUniqueId</name></member>
      <member refid="class_hgi_1a168c9be9f4721a54a3086809b9e03347" prot="public" virt="non-virtual"><scope>HgiGL</scope><name>Hgi</name></member>
      <member refid="class_hgi_g_l_1a24ebbbdf99975bf4bfacf43481348718" prot="public" virt="non-virtual"><scope>HgiGL</scope><name>HgiGL</name></member>
      <member refid="class_hgi_g_l_1aa9db2a2545739845689c00fffbda3d72" prot="private" virt="non-virtual"><scope>HgiGL</scope><name>HgiGL</name></member>
      <member refid="class_hgi_g_l_1a1a4bcb48912d5588e4182f6840281145" prot="public" virt="virtual"><scope>HgiGL</scope><name>IsBackendSupported</name></member>
      <member refid="class_hgi_1add27034f36108f73c06d94b600b61a74" prot="public" virt="non-virtual"><scope>HgiGL</scope><name>IsSupported</name></member>
      <member refid="class_hgi_g_l_1a5baa4acfd96bc10964fe1c1719f8563f" prot="private" virt="non-virtual"><scope>HgiGL</scope><name>operator=</name></member>
      <member refid="class_hgi_g_l_1a39f0f71734c408778970c346fece6837" prot="public" virt="non-virtual"><scope>HgiGL</scope><name>SetContextArena</name></member>
      <member refid="class_hgi_g_l_1a1958a6177445c0e91467331741969817" prot="public" virt="virtual"><scope>HgiGL</scope><name>StartFrame</name></member>
      <member refid="class_hgi_1aed132723e59980a774aa58da9d2c3ff9" prot="public" virt="non-virtual"><scope>HgiGL</scope><name>SubmitCmds</name></member>
      <member refid="class_hgi_1a2a4b0145a502bf7fe878191c0365d5cc" prot="public" virt="virtual"><scope>HgiGL</scope><name>~Hgi</name></member>
      <member refid="class_hgi_g_l_1af974d54b48346827827933902ba9c79c" prot="public" virt="non-virtual"><scope>HgiGL</scope><name>~HgiGL</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
