<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="group__group__arch___strings" kind="group">
    <compoundname>group_arch_Strings</compoundname>
    <title>Strings</title>
    <innerfile refid="demangle_8h">demangle.h</innerfile>
    <innerfile refid="vsnprintf_8h">vsnprintf.h</innerfile>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__group__arch___strings_1ga207e2a4166a53e1d7d387b65c5d1cc0b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ARCH_API bool</type>
        <definition>ARCH_API bool ArchDemangle</definition>
        <argsstring>(std::string *typeName)</argsstring>
        <name>ArchDemangle</name>
        <param>
          <type>std::string *</type>
          <declname>typeName</declname>
        </param>
        <briefdescription>
<para>Demangle RTTI-generated type name. </para>
        </briefdescription>
        <detaileddescription>
<para>Given a variable <computeroutput>v</computeroutput>, the construct <computeroutput>typeid(v)</computeroutput>.name() returns the type-name of <computeroutput>v</computeroutput>; unfortunately, the returned type-name is sometimes extremely encoded (otherwise known as &quot;mangled&quot;). <computeroutput>ArchDemangle</computeroutput> parses the passed in type-name <computeroutput>typeName</computeroutput> into a readable form, and overwrites <computeroutput>typeName</computeroutput>. If <computeroutput>typeName</computeroutput> cannot be unmangled, the function returns <computeroutput>false</computeroutput> without altering <computeroutput>typeName</computeroutput>. Otherwise <computeroutput>true</computeroutput> is returned. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/arch/demangle.h" line="55" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__group__arch___strings_1ga0b63aee5bf45530bc1b0ceb51411bc7d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ARCH_API std::string</type>
        <definition>ARCH_API std::string ArchGetDemangled</definition>
        <argsstring>(const std::string &amp;typeName)</argsstring>
        <name>ArchGetDemangled</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>typeName</declname>
        </param>
        <briefdescription>
<para>Return demangled RTTI-generated type name. </para>
        </briefdescription>
        <detaileddescription>
<para>If <computeroutput>typeName</computeroutput> can be demangled, the function returns the demangled string; otherwise, the function returns the empty string.</para>
<para><simplesect kind="see"><para><ref refid="group__group__arch___strings_1ga207e2a4166a53e1d7d387b65c5d1cc0b" kindref="member">ArchDemangle()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/arch/demangle.h" line="64" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__group__arch___strings_1ga35b89fe6abf09a1634a7670f20bda81e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ARCH_API std::string</type>
        <definition>ARCH_API std::string ArchGetDemangled</definition>
        <argsstring>(const char *typeName)</argsstring>
        <name>ArchGetDemangled</name>
        <param>
          <type>const char *</type>
          <declname>typeName</declname>
        </param>
        <briefdescription>
<para>Return demangled RTTI-generated type name. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ref refid="group__group__arch___strings_1ga207e2a4166a53e1d7d387b65c5d1cc0b" kindref="member">ArchDemangle()</ref> This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/arch/demangle.h" line="71" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__group__arch___strings_1ga6cc865b9c9c6005a0fea3805e5907d2b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string ArchGetDemangled</definition>
        <argsstring>(const std::type_info &amp;typeInfo)</argsstring>
        <name>ArchGetDemangled</name>
        <param>
          <type>const std::type_info &amp;</type>
          <declname>typeInfo</declname>
        </param>
        <briefdescription>
<para>Return demangled RTTI-generated type name. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns the demangled name associated with typeInfo (i.e. typeInfo.name()).</para>
<para><simplesect kind="see"><para><ref refid="group__group__arch___strings_1ga207e2a4166a53e1d7d387b65c5d1cc0b" kindref="member">ArchDemangle()</ref> This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/arch/demangle.h" line="80" column="1" bodyfile="pxr/base/arch/demangle.h" bodystart="80" bodyend="82"/>
      </memberdef>
      <memberdef kind="function" id="group__group__arch___strings_1gac82e5db7298c68bc3793b490ea508827" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string ArchGetDemangled</definition>
        <argsstring>(const std::type_index &amp;typeIndex)</argsstring>
        <name>ArchGetDemangled</name>
        <param>
          <type>const std::type_index &amp;</type>
          <declname>typeIndex</declname>
        </param>
        <briefdescription>
<para>Return demangled RTTI-generated type name. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns the demangled name associated with typeIndex (i.e. typeIndex.name()).</para>
<para><simplesect kind="see"><para><ref refid="group__group__arch___strings_1ga207e2a4166a53e1d7d387b65c5d1cc0b" kindref="member">ArchDemangle()</ref> This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/arch/demangle.h" line="91" column="1" bodyfile="pxr/base/arch/demangle.h" bodystart="91" bodyend="93"/>
      </memberdef>
      <memberdef kind="function" id="group__group__arch___strings_1ga2000f9b0767f17cf1b8463b0ff081a85" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string ArchGetDemangled</definition>
        <argsstring>()</argsstring>
        <name>ArchGetDemangled</name>
        <briefdescription>
<para>Return demangled RTTI generated-type name. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns the demangled name of type T.</para>
<para><simplesect kind="see"><para><ref refid="group__group__arch___strings_1ga207e2a4166a53e1d7d387b65c5d1cc0b" kindref="member">ArchDemangle()</ref> This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/arch/demangle.h" line="103" column="1" bodyfile="pxr/base/arch/demangle.h" bodystart="103" bodyend="105"/>
      </memberdef>
      <memberdef kind="function" id="group__group__arch___strings_1ga81f5f95d5b6c9b11f413c26f540dcdee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ARCH_API int</type>
        <definition>ARCH_API int ArchVsnprintf</definition>
        <argsstring>(char *str, size_t size, const char *format, va_list ap)</argsstring>
        <name>ArchVsnprintf</name>
        <param>
          <type>char *</type>
          <declname>str</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>format</declname>
        </param>
        <param>
          <type>va_list</type>
          <declname>ap</declname>
        </param>
        <briefdescription>
<para>Return the number of characters (not including the null character) necessary for a particular sprintf into a string. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>ArchVsnprintf</computeroutput> guarantees the C99 behavior of vsnprintf on all systems: it returns the number of bytes (not including the terminating null character) needed to actually print the requested string. If <computeroutput>size</computeroutput> indicates that <computeroutput>str</computeroutput> has enough capacity to hold the result, then the function actually prints into <computeroutput>str</computeroutput>.</para>
<para>You probably want to use the functionality of this call via <computeroutput><ref refid="group__group__tf___string_1gae42be5a0255e4c7ba38d087fd97a97db" kindref="member">TfStringPrintf()</ref></computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/arch/vsnprintf.h" line="57" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__group__arch___strings_1ga0c5e8e089bfd39d71610f329fd3b4090" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ARCH_API std::string</type>
        <definition>ARCH_API std::string ArchStringPrintf</definition>
        <argsstring>(const char *fmt,...)</argsstring>
        <name>ArchStringPrintf</name>
        <param>
          <type>const char *</type>
          <declname>fmt</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
<para>Returns a string formed by a printf()-like specification. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput><ref refid="group__group__arch___strings_1ga0c5e8e089bfd39d71610f329fd3b4090" kindref="member">ArchStringPrintf()</ref></computeroutput> is a memory-safe architecture-independent way of forming a string using printf()-like formatting. For example, <programlisting><codeline><highlight class="normal">string<sp/>formatMsg(const<sp/>string&amp;<sp/>caller,<sp/>int<sp/>i,<sp/>double<sp/>val[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>return<sp/>ArchStringPrintf(&quot;%s:<sp/>val[%d]<sp/>=<sp/>%g\n&quot;,<sp/>caller.c_str(),<sp/>i,<sp/>val[i]);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The function is safe only to the extent that the arguments match the formatting string. In particular, be careful to pass strings themselve into <computeroutput><ref refid="group__group__arch___strings_1ga0c5e8e089bfd39d71610f329fd3b4090" kindref="member">ArchStringPrintf()</ref></computeroutput> as in the above example (i.e. <computeroutput>caller.c_str()</computeroutput> as opposed to just passing <computeroutput>caller</computeroutput>). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/arch/vsnprintf.h" line="80" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Functions having to do with string massaging/manipulation. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
