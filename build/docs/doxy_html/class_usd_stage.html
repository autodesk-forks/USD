<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: UsdStage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_usd_stage.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_usd_stage-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">UsdStage Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The outermost container for scene description, which owns and presents composed prims as a scenegraph, following the composition recipe recursively described in its associated "root layer".  
 <a href="class_usd_stage.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for UsdStage:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_usd_stage__inherit__graph.png" border="0" usemap="#_usd_stage_inherit__map" alt="Inheritance graph"/></div>
<map name="_usd_stage_inherit__map" id="_usd_stage_inherit__map">
<area shape="rect"  title="The outermost container for scene description, which owns and presents composed prims as a scenegraph..." alt="" coords="67,80,151,107"/>
<area shape="rect"  href="class_tf_ref_base.html" title="Enable a concrete base class for use with TfRefPtr." alt="" coords="5,5,93,32"/>
<area shape="rect"  href="class_tf_weak_base.html" title="Enable a concrete base class for use with TfWeakPtr." alt="" coords="118,5,220,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2c6875876c420b08ca5b2baed2ac51bc"><td class="memTemplParams" colspan="2"><a id="a2c6875876c420b08ca5b2baed2ac51bc"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2c6875876c420b08ca5b2baed2ac51bc"><td class="memTemplItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_GetTypeSpecificResolvedMetadata</b> (const <a class="el" href="class_usd_object.html">UsdObject</a> &amp;obj, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;fieldName, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;keyPath, bool useFallbacks, <a class="el" href="usd_2sdf_2types_8h.html#afba891bb38b089b531e73e00fe5cc7ae">SdfTimeSampleMap</a> *result) const</td></tr>
<tr class="separator:a2c6875876c420b08ca5b2baed2ac51bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Layer Serialization</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="Usd_layerSerialization"></a></p>
<p>Functions for saving changes to layers that contribute opinions to this stage. Layers may also be saved by calling <a class="el" href="class_sdf_layer.html#ad5a54175a9d67b72094f8fdf3e83c9d9" title="Returns true if successful, false if an error occurred.">SdfLayer::Save</a> or exported to a new file by calling <a class="el" href="class_sdf_layer.html#aef819927fc1ad0d6fc5ad5fefb58dcdf" title="Exports this layer to a file.">SdfLayer::Export</a>. </p>
</div></td></tr>
<tr class="memitem:adefa2f7ebfc4d8c09f0cd54419aa36c4"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#adefa2f7ebfc4d8c09f0cd54419aa36c4">Save</a> ()</td></tr>
<tr class="memdesc:adefa2f7ebfc4d8c09f0cd54419aa36c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="class_sdf_layer.html#ad5a54175a9d67b72094f8fdf3e83c9d9" title="Returns true if successful, false if an error occurred.">SdfLayer::Save</a> on all dirty layers contributing to this stage except session layers and sublayers of session layers.  <a href="#adefa2f7ebfc4d8c09f0cd54419aa36c4">More...</a><br /></td></tr>
<tr class="separator:adefa2f7ebfc4d8c09f0cd54419aa36c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b48dc29e9c66e3efed8cb42ff18618"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a94b48dc29e9c66e3efed8cb42ff18618">SaveSessionLayers</a> ()</td></tr>
<tr class="memdesc:a94b48dc29e9c66e3efed8cb42ff18618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="class_sdf_layer.html#ad5a54175a9d67b72094f8fdf3e83c9d9" title="Returns true if successful, false if an error occurred.">SdfLayer::Save</a> on all dirty session layers and sublayers of session layers contributing to this stage.  <a href="#a94b48dc29e9c66e3efed8cb42ff18618">More...</a><br /></td></tr>
<tr class="separator:a94b48dc29e9c66e3efed8cb42ff18618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Working Set Management</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="Usd_workingSetManagement"></a></p>
<p>The following rules apply to all Load/Unload methods: </p><pre class="fragment">- Loading an already loaded prim is legal, though may result in
  some recomposition cost. Similarly, unloading an unloaded prim
  is legal.
- Specifying a path that does not target a prim is legal as long it
  has an ancestor present in the scene graph (other than the
  absolute root). If the given path has no such ancestor, it is an
  error.
- Specifying a path to an inactive prim is an error.
- Specifying a path to a prototype prim or a prim within a
  prototype is an error.
</pre><p>If an instance prim (or a path identifying a prim descendant to an instance) is encountered during a Load/Unload operation, these functions may cause instancing to change on the stage in order to ensure that no other instances are affected. The load/unload rules that affect a given prim hierarchy are considered when determining which prims can be instanced together. Instance sharing occurs when different instances have equivalent load rules.</p>
<p>The <a class="el" href="class_usd_stage.html#a8a32bd6860d97da6d01d6dfaa7eb8e2c" title="Return the stage&#39;s current UsdStageLoadRules governing payload inclusion.">GetLoadRules()</a> and <a class="el" href="class_usd_stage.html#acf86347f816ee4ac98dbf16e3b09ff2a" title="Set the UsdStageLoadRules to govern payload inclusion on this stage.">SetLoadRules()</a> provide direct low-level access to the <a class="el" href="class_usd_stage_load_rules.html" title="This class represents rules that govern payload inclusion on UsdStages.">UsdStageLoadRules</a> that govern payload inclusion on a stage. </p>
</div></td></tr>
<tr class="memitem:aece3d46e8cff565af399bfda419964e7"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_prim.html">UsdPrim</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#aece3d46e8cff565af399bfda419964e7">Load</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path=<a class="el" href="class_sdf_path.html#a9e77b565c10268c2b55f92559f621606">SdfPath::AbsoluteRootPath</a>(), <a class="el" href="common_8h.html#aeeb09bb9e2bd68b2622a29dc649c8d5a">UsdLoadPolicy</a> policy=<a class="el" href="common_8h.html#aeeb09bb9e2bd68b2622a29dc649c8d5aa42997d996674df3a923bbe2683fea7fb">UsdLoadWithDescendants</a>)</td></tr>
<tr class="memdesc:aece3d46e8cff565af399bfda419964e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify this stage's load rules to load the prim at <code>path</code>, its ancestors, and all of its descendants if <code>policy</code> is UsdLoadWithDescendants.  <a href="#aece3d46e8cff565af399bfda419964e7">More...</a><br /></td></tr>
<tr class="separator:aece3d46e8cff565af399bfda419964e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb4cb8d8943a759152b70f08e340a2c"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#aedb4cb8d8943a759152b70f08e340a2c">Unload</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path=<a class="el" href="class_sdf_path.html#a9e77b565c10268c2b55f92559f621606">SdfPath::AbsoluteRootPath</a>())</td></tr>
<tr class="memdesc:aedb4cb8d8943a759152b70f08e340a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify this stage's load rules to unload the prim and its descendants specified by <code>path</code>.  <a href="#aedb4cb8d8943a759152b70f08e340a2c">More...</a><br /></td></tr>
<tr class="separator:aedb4cb8d8943a759152b70f08e340a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1305b94bed8097515432ee78061ff009"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a1305b94bed8097515432ee78061ff009">LoadAndUnload</a> (const SdfPathSet &amp;loadSet, const SdfPathSet &amp;unloadSet, <a class="el" href="common_8h.html#aeeb09bb9e2bd68b2622a29dc649c8d5a">UsdLoadPolicy</a> policy=<a class="el" href="common_8h.html#aeeb09bb9e2bd68b2622a29dc649c8d5aa42997d996674df3a923bbe2683fea7fb">UsdLoadWithDescendants</a>)</td></tr>
<tr class="memdesc:a1305b94bed8097515432ee78061ff009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload and load the given path sets.  <a href="#a1305b94bed8097515432ee78061ff009">More...</a><br /></td></tr>
<tr class="separator:a1305b94bed8097515432ee78061ff009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3051c81e353b2d151d360b24b8f9fb88"><td class="memItemLeft" align="right" valign="top">USD_API SdfPathSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a3051c81e353b2d151d360b24b8f9fb88">GetLoadSet</a> ()</td></tr>
<tr class="memdesc:a3051c81e353b2d151d360b24b8f9fb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set of all loaded paths.  <a href="#a3051c81e353b2d151d360b24b8f9fb88">More...</a><br /></td></tr>
<tr class="separator:a3051c81e353b2d151d360b24b8f9fb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1b7f717f7418333440a0a318793b0d"><td class="memItemLeft" align="right" valign="top">USD_API SdfPathSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#adf1b7f717f7418333440a0a318793b0d">FindLoadable</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;rootPath=<a class="el" href="class_sdf_path.html#a9e77b565c10268c2b55f92559f621606">SdfPath::AbsoluteRootPath</a>())</td></tr>
<tr class="memdesc:adf1b7f717f7418333440a0a318793b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an SdfPathSet of all paths that can be loaded.  <a href="#adf1b7f717f7418333440a0a318793b0d">More...</a><br /></td></tr>
<tr class="separator:adf1b7f717f7418333440a0a318793b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a32bd6860d97da6d01d6dfaa7eb8e2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_usd_stage_load_rules.html">UsdStageLoadRules</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a8a32bd6860d97da6d01d6dfaa7eb8e2c">GetLoadRules</a> () const</td></tr>
<tr class="memdesc:a8a32bd6860d97da6d01d6dfaa7eb8e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the stage's current <a class="el" href="class_usd_stage_load_rules.html" title="This class represents rules that govern payload inclusion on UsdStages.">UsdStageLoadRules</a> governing payload inclusion.  <a href="#a8a32bd6860d97da6d01d6dfaa7eb8e2c">More...</a><br /></td></tr>
<tr class="separator:a8a32bd6860d97da6d01d6dfaa7eb8e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf86347f816ee4ac98dbf16e3b09ff2a"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#acf86347f816ee4ac98dbf16e3b09ff2a">SetLoadRules</a> (<a class="el" href="class_usd_stage_load_rules.html">UsdStageLoadRules</a> const &amp;rules)</td></tr>
<tr class="memdesc:acf86347f816ee4ac98dbf16e3b09ff2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="class_usd_stage_load_rules.html" title="This class represents rules that govern payload inclusion on UsdStages.">UsdStageLoadRules</a> to govern payload inclusion on this stage.  <a href="#acf86347f816ee4ac98dbf16e3b09ff2a">More...</a><br /></td></tr>
<tr class="separator:acf86347f816ee4ac98dbf16e3b09ff2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb4c2665d6ccecf2998b76041a9a3df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a3eb4c2665d6ccecf2998b76041a9a3df">GetPopulationMask</a> () const</td></tr>
<tr class="memdesc:a3eb4c2665d6ccecf2998b76041a9a3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this stage's population mask.  <a href="#a3eb4c2665d6ccecf2998b76041a9a3df">More...</a><br /></td></tr>
<tr class="separator:a3eb4c2665d6ccecf2998b76041a9a3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a431cb32a2d50de05ac206c474606cd"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a2a431cb32a2d50de05ac206c474606cd">SetPopulationMask</a> (<a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> const &amp;mask)</td></tr>
<tr class="memdesc:a2a431cb32a2d50de05ac206c474606cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this stage's population mask and recompose the stage.  <a href="#a2a431cb32a2d50de05ac206c474606cd">More...</a><br /></td></tr>
<tr class="separator:a2a431cb32a2d50de05ac206c474606cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d76e23eede294e2988de22b45edc3e2"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a5d76e23eede294e2988de22b45edc3e2">ExpandPopulationMask</a> (Usd_PrimFlagsPredicate const &amp;traversalPredicate, std::function&lt; bool(<a class="el" href="class_usd_relationship.html">UsdRelationship</a> const &amp;)&gt; const &amp;relPred=nullptr, std::function&lt; bool(<a class="el" href="class_usd_attribute.html">UsdAttribute</a> const &amp;)&gt; const &amp;attrPred=nullptr)</td></tr>
<tr class="memdesc:a5d76e23eede294e2988de22b45edc3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand this stage's population mask to include the targets of all relationships that pass <code>relPred</code> and connections to all attributes that pass <code>attrPred</code> recursively.  <a href="#a5d76e23eede294e2988de22b45edc3e2">More...</a><br /></td></tr>
<tr class="separator:a5d76e23eede294e2988de22b45edc3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f4bcec4c4fbd7366d4be6de13efc6d"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a35f4bcec4c4fbd7366d4be6de13efc6d">ExpandPopulationMask</a> (std::function&lt; bool(<a class="el" href="class_usd_relationship.html">UsdRelationship</a> const &amp;)&gt; const &amp;relPred=nullptr, std::function&lt; bool(<a class="el" href="class_usd_attribute.html">UsdAttribute</a> const &amp;)&gt; const &amp;attrPred=nullptr)</td></tr>
<tr class="memdesc:a35f4bcec4c4fbd7366d4be6de13efc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This convenience overload invokes <a class="el" href="class_usd_stage.html#a5d76e23eede294e2988de22b45edc3e2" title="Expand this stage&#39;s population mask to include the targets of all relationships that pass relPred and...">ExpandPopulationMask()</a> with the UsdPrimDefaultPredicate traversal predicate.  <a href="#a35f4bcec4c4fbd7366d4be6de13efc6d">More...</a><br /></td></tr>
<tr class="separator:a35f4bcec4c4fbd7366d4be6de13efc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Layers and EditTargets</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="Usd_layerManagement"></a></p>
</div></td></tr>
<tr class="memitem:afcfb38efd355873d96fd2488da4dcddd"><td class="memItemLeft" align="right" valign="top">USD_API SdfLayerHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#afcfb38efd355873d96fd2488da4dcddd">GetSessionLayer</a> () const</td></tr>
<tr class="memdesc:afcfb38efd355873d96fd2488da4dcddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this stage's root session layer.  <a href="#afcfb38efd355873d96fd2488da4dcddd">More...</a><br /></td></tr>
<tr class="separator:afcfb38efd355873d96fd2488da4dcddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae694960a036c724e285d044aea210d15"><td class="memItemLeft" align="right" valign="top">USD_API SdfLayerHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ae694960a036c724e285d044aea210d15">GetRootLayer</a> () const</td></tr>
<tr class="memdesc:ae694960a036c724e285d044aea210d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this stage's root layer.  <a href="#ae694960a036c724e285d044aea210d15">More...</a><br /></td></tr>
<tr class="separator:ae694960a036c724e285d044aea210d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabe8c6ff9089b848260f4cf43958cc7"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#adabe8c6ff9089b848260f4cf43958cc7">GetPathResolverContext</a> () const</td></tr>
<tr class="memdesc:adabe8c6ff9089b848260f4cf43958cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the path resolver context for all path resolution during composition of this stage.  <a href="#adabe8c6ff9089b848260f4cf43958cc7">More...</a><br /></td></tr>
<tr class="separator:adabe8c6ff9089b848260f4cf43958cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d23f48d36d27f3f8e5099a8c655fa4e"><td class="memItemLeft" align="right" valign="top">USD_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a5d23f48d36d27f3f8e5099a8c655fa4e">ResolveIdentifierToEditTarget</a> (std::string const &amp;identifier) const</td></tr>
<tr class="memdesc:a5d23f48d36d27f3f8e5099a8c655fa4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve the given identifier using this stage's <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> and the layer of its <a class="el" href="class_usd_stage.html#a16cb44251a2c5964583fd9076de3f753" title="Return the stage&#39;s EditTarget.">GetEditTarget()</a> as an anchor for relative references (e.g.  <a href="#a5d23f48d36d27f3f8e5099a8c655fa4e">More...</a><br /></td></tr>
<tr class="separator:a5d23f48d36d27f3f8e5099a8c655fa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfcae900fd07e3344e087ea1bd478cb"><td class="memItemLeft" align="right" valign="top">USD_API SdfLayerHandleVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a9dfcae900fd07e3344e087ea1bd478cb">GetLayerStack</a> (bool includeSessionLayers=true) const</td></tr>
<tr class="memdesc:a9dfcae900fd07e3344e087ea1bd478cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this stage's local layers in strong-to-weak order.  <a href="#a9dfcae900fd07e3344e087ea1bd478cb">More...</a><br /></td></tr>
<tr class="separator:a9dfcae900fd07e3344e087ea1bd478cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7937dd0b3f1d546e93ad4219916de9"><td class="memItemLeft" align="right" valign="top">USD_API SdfLayerHandleVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a3b7937dd0b3f1d546e93ad4219916de9">GetUsedLayers</a> (bool includeClipLayers=true) const</td></tr>
<tr class="memdesc:a3b7937dd0b3f1d546e93ad4219916de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of all of the layers <em>currently</em> consumed by this stage, as determined by the composition arcs that were traversed to compose and populate the stage.  <a href="#a3b7937dd0b3f1d546e93ad4219916de9">More...</a><br /></td></tr>
<tr class="separator:a3b7937dd0b3f1d546e93ad4219916de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff8c7b5cd9cdee23c5209c0ec7281b7"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#aaff8c7b5cd9cdee23c5209c0ec7281b7">HasLocalLayer</a> (const SdfLayerHandle &amp;layer) const</td></tr>
<tr class="memdesc:aaff8c7b5cd9cdee23c5209c0ec7281b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <em>layer</em> is one of the layers in this stage's local, root layerStack.  <a href="#aaff8c7b5cd9cdee23c5209c0ec7281b7">More...</a><br /></td></tr>
<tr class="separator:aaff8c7b5cd9cdee23c5209c0ec7281b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cb44251a2c5964583fd9076de3f753"><td class="memItemLeft" align="right" valign="top">USD_API const <a class="el" href="class_usd_edit_target.html">UsdEditTarget</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a16cb44251a2c5964583fd9076de3f753">GetEditTarget</a> () const</td></tr>
<tr class="memdesc:a16cb44251a2c5964583fd9076de3f753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the stage's EditTarget.  <a href="#a16cb44251a2c5964583fd9076de3f753">More...</a><br /></td></tr>
<tr class="separator:a16cb44251a2c5964583fd9076de3f753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a51571cd00e6f38572f7f55a101cf5"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_edit_target.html">UsdEditTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a39a51571cd00e6f38572f7f55a101cf5">GetEditTargetForLocalLayer</a> (size_t i)</td></tr>
<tr class="memdesc:a39a51571cd00e6f38572f7f55a101cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> for editing the layer at index <em>i</em> in the layer stack.  <a href="#a39a51571cd00e6f38572f7f55a101cf5">More...</a><br /></td></tr>
<tr class="separator:a39a51571cd00e6f38572f7f55a101cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acceed6daf2f94a536ff3bc8d4bfcaf45"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_edit_target.html">UsdEditTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#acceed6daf2f94a536ff3bc8d4bfcaf45">GetEditTargetForLocalLayer</a> (const SdfLayerHandle &amp;layer)</td></tr>
<tr class="memdesc:acceed6daf2f94a536ff3bc8d4bfcaf45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> for editing the given local <em>layer</em>.  <a href="#acceed6daf2f94a536ff3bc8d4bfcaf45">More...</a><br /></td></tr>
<tr class="separator:acceed6daf2f94a536ff3bc8d4bfcaf45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90008efb0f2b624fcff43de00188792"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ac90008efb0f2b624fcff43de00188792">SetEditTarget</a> (const <a class="el" href="class_usd_edit_target.html">UsdEditTarget</a> &amp;editTarget)</td></tr>
<tr class="memdesc:ac90008efb0f2b624fcff43de00188792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stage's EditTarget.  <a href="#ac90008efb0f2b624fcff43de00188792">More...</a><br /></td></tr>
<tr class="separator:ac90008efb0f2b624fcff43de00188792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af4162fe11cc6a5f21a39e770d397c2"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a8af4162fe11cc6a5f21a39e770d397c2">MuteLayer</a> (const std::string &amp;layerIdentifier)</td></tr>
<tr class="memdesc:a8af4162fe11cc6a5f21a39e770d397c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mute the layer identified by <code>layerIdentifier</code>.  <a href="#a8af4162fe11cc6a5f21a39e770d397c2">More...</a><br /></td></tr>
<tr class="separator:a8af4162fe11cc6a5f21a39e770d397c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8158f35f1f76b227f51f875db4c5d1"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a2f8158f35f1f76b227f51f875db4c5d1">UnmuteLayer</a> (const std::string &amp;layerIdentifier)</td></tr>
<tr class="memdesc:a2f8158f35f1f76b227f51f875db4c5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmute the layer identified by <code>layerIdentifier</code> if it had previously been muted.  <a href="#a2f8158f35f1f76b227f51f875db4c5d1">More...</a><br /></td></tr>
<tr class="separator:a2f8158f35f1f76b227f51f875db4c5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84244f8ed7ba7f037b8c9d9256cfeb5"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#aa84244f8ed7ba7f037b8c9d9256cfeb5">MuteAndUnmuteLayers</a> (const std::vector&lt; std::string &gt; &amp;muteLayers, const std::vector&lt; std::string &gt; &amp;unmuteLayers)</td></tr>
<tr class="memdesc:aa84244f8ed7ba7f037b8c9d9256cfeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mute and unmute the layers identified in <code>muteLayers</code> and <code>unmuteLayers</code>.  <a href="#aa84244f8ed7ba7f037b8c9d9256cfeb5">More...</a><br /></td></tr>
<tr class="separator:aa84244f8ed7ba7f037b8c9d9256cfeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ce205d182683fe0c45b97642d8051c"><td class="memItemLeft" align="right" valign="top">USD_API const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a41ce205d182683fe0c45b97642d8051c">GetMutedLayers</a> () const</td></tr>
<tr class="memdesc:a41ce205d182683fe0c45b97642d8051c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of all layers that have been muted on this stage.  <a href="#a41ce205d182683fe0c45b97642d8051c">More...</a><br /></td></tr>
<tr class="separator:a41ce205d182683fe0c45b97642d8051c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740db7501c0303b6c1e6e9ce87b10092"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a740db7501c0303b6c1e6e9ce87b10092">IsLayerMuted</a> (const std::string &amp;layerIdentifier) const</td></tr>
<tr class="memdesc:a740db7501c0303b6c1e6e9ce87b10092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the layer specified by <code>layerIdentifier</code> is muted in this cache, false otherwise.  <a href="#a740db7501c0303b6c1e6e9ce87b10092">More...</a><br /></td></tr>
<tr class="separator:a740db7501c0303b6c1e6e9ce87b10092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Flatten &amp; Export Utilities</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="Usd_stageSerialization"></a></p>
</div></td></tr>
<tr class="memitem:a3f3fa959eb4a0a6ac2ec5ca8f248cb95"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a3f3fa959eb4a0a6ac2ec5ca8f248cb95">Export</a> (const std::string &amp;filename, bool addSourceFileComment=true, const <a class="el" href="class_sdf_layer.html#a1dfd2030337b6243cd6424fce7397590">SdfLayer::FileFormatArguments</a> &amp;args=<a class="el" href="class_sdf_layer.html#a1dfd2030337b6243cd6424fce7397590">SdfLayer::FileFormatArguments</a>()) const</td></tr>
<tr class="memdesc:a3f3fa959eb4a0a6ac2ec5ca8f248cb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes out the composite scene as a single flattened layer into <em>filename</em>.  <a href="#a3f3fa959eb4a0a6ac2ec5ca8f248cb95">More...</a><br /></td></tr>
<tr class="separator:a3f3fa959eb4a0a6ac2ec5ca8f248cb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164713764becadb3b88f1c8d7694631b"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a164713764becadb3b88f1c8d7694631b">ExportToString</a> (std::string *result, bool addSourceFileComment=true) const</td></tr>
<tr class="memdesc:a164713764becadb3b88f1c8d7694631b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the composite scene as a flattened Usd text representation into the given <em>string</em>.  <a href="#a164713764becadb3b88f1c8d7694631b">More...</a><br /></td></tr>
<tr class="separator:a164713764becadb3b88f1c8d7694631b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3271778fa2ceeb82fbd51296610820a"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_tf_ref_ptr.html">SdfLayerRefPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ae3271778fa2ceeb82fbd51296610820a">Flatten</a> (bool addSourceFileComment=true) const</td></tr>
<tr class="memdesc:ae3271778fa2ceeb82fbd51296610820a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single, anonymous, merged layer for this composite scene.  <a href="#ae3271778fa2ceeb82fbd51296610820a">More...</a><br /></td></tr>
<tr class="separator:ae3271778fa2ceeb82fbd51296610820a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stage Metadata</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="Usd_stageMetadata"></a> Stage metadata applies to the entire contents of the stage, and is recorded only in the stage's root or primary session-layer. Most of the other, specific metadata methods on <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> are defined in terms of these generic methods. </p>
</div></td></tr>
<tr class="memitem:ad2d76f736733f3ad51aa1ea1df6f4d44"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad2d76f736733f3ad51aa1ea1df6f4d44"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ad2d76f736733f3ad51aa1ea1df6f4d44">GetMetadata</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;key, T *value) const</td></tr>
<tr class="memdesc:ad2d76f736733f3ad51aa1ea1df6f4d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return in <code>value</code> an authored or fallback value (if one was defined for the given metadatum) for Stage metadatum <code>key</code>.  <a href="#ad2d76f736733f3ad51aa1ea1df6f4d44">More...</a><br /></td></tr>
<tr class="separator:ad2d76f736733f3ad51aa1ea1df6f4d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af114545bd56cd7619e7d4f2f884e4128"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#af114545bd56cd7619e7d4f2f884e4128">GetMetadata</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;key, <a class="el" href="class_vt_value.html">VtValue</a> *value) const</td></tr>
<tr class="separator:af114545bd56cd7619e7d4f2f884e4128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d99fd05dbc39c2d9746fe639c24825"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ae2d99fd05dbc39c2d9746fe639c24825">HasMetadata</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;key) const</td></tr>
<tr class="memdesc:ae2d99fd05dbc39c2d9746fe639c24825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <em>key</em> has a meaningful value, that is, if <a class="el" href="class_usd_stage.html#ad2d76f736733f3ad51aa1ea1df6f4d44" title="Return in value an authored or fallback value (if one was defined for the given metadatum) for Stage ...">GetMetadata()</a> will provide a value, either because it was authored or because the Stage metadata was defined with a meaningful fallback value.  <a href="#ae2d99fd05dbc39c2d9746fe639c24825">More...</a><br /></td></tr>
<tr class="separator:ae2d99fd05dbc39c2d9746fe639c24825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37211404a939811e841d90c65cd19999"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a37211404a939811e841d90c65cd19999">HasAuthoredMetadata</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;key) const</td></tr>
<tr class="memdesc:a37211404a939811e841d90c65cd19999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the <em>key</em> has an authored value, <code>false</code> if no value was authored or the only value available is the <a class="el" href="class_sdf_schema.html" title="Class that provides information about the various scene description fields.">SdfSchema</a>'s metadata fallback.  <a href="#a37211404a939811e841d90c65cd19999">More...</a><br /></td></tr>
<tr class="separator:a37211404a939811e841d90c65cd19999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5325c3bfad050926f03f867a803c03"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1a5325c3bfad050926f03f867a803c03"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a1a5325c3bfad050926f03f867a803c03">SetMetadata</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;key, const T &amp;value) const</td></tr>
<tr class="memdesc:a1a5325c3bfad050926f03f867a803c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of Stage metadatum <code>key</code> to <code>value</code>, if the stage's current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> is the root or session layer.  <a href="#a1a5325c3bfad050926f03f867a803c03">More...</a><br /></td></tr>
<tr class="separator:a1a5325c3bfad050926f03f867a803c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccca1c487755a7f08e6e4b042d39ede"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#abccca1c487755a7f08e6e4b042d39ede">SetMetadata</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;key, const <a class="el" href="class_vt_value.html">VtValue</a> &amp;value) const</td></tr>
<tr class="separator:abccca1c487755a7f08e6e4b042d39ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75ddb7982a5b5c77f9840e67df94435"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#af75ddb7982a5b5c77f9840e67df94435">ClearMetadata</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;key) const</td></tr>
<tr class="memdesc:af75ddb7982a5b5c77f9840e67df94435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the value of stage metadatum <code>key</code>, if the stage's current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> is the root or session layer.  <a href="#af75ddb7982a5b5c77f9840e67df94435">More...</a><br /></td></tr>
<tr class="separator:af75ddb7982a5b5c77f9840e67df94435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba47c41ec8cc536290c04e219f12589c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba47c41ec8cc536290c04e219f12589c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#aba47c41ec8cc536290c04e219f12589c">GetMetadataByDictKey</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;key, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;keyPath, T *value) const</td></tr>
<tr class="memdesc:aba47c41ec8cc536290c04e219f12589c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve the requested dictionary sub-element <code>keyPath</code> of dictionary-valued metadatum named <code>key</code>, returning the resolved value.  <a href="#aba47c41ec8cc536290c04e219f12589c">More...</a><br /></td></tr>
<tr class="separator:aba47c41ec8cc536290c04e219f12589c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdf70a1d4a8754a0cb51cddab11b299"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a3bdf70a1d4a8754a0cb51cddab11b299">GetMetadataByDictKey</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;key, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;keyPath, <a class="el" href="class_vt_value.html">VtValue</a> *value) const</td></tr>
<tr class="memdesc:a3bdf70a1d4a8754a0cb51cddab11b299"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload  <a href="#a3bdf70a1d4a8754a0cb51cddab11b299">More...</a><br /></td></tr>
<tr class="separator:a3bdf70a1d4a8754a0cb51cddab11b299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911c19d77fe0552877918517818e7399"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a911c19d77fe0552877918517818e7399">HasMetadataDictKey</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;key, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;keyPath) const</td></tr>
<tr class="memdesc:a911c19d77fe0552877918517818e7399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there exists any authored or fallback opinion for <code>key</code> and <code>keyPath</code>.  <a href="#a911c19d77fe0552877918517818e7399">More...</a><br /></td></tr>
<tr class="separator:a911c19d77fe0552877918517818e7399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a01b0dd0dd51f9439b6a3a231c76ef"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a20a01b0dd0dd51f9439b6a3a231c76ef">HasAuthoredMetadataDictKey</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;key, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;keyPath) const</td></tr>
<tr class="memdesc:a20a01b0dd0dd51f9439b6a3a231c76ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there exists any authored opinion (excluding fallbacks) for <code>key</code> and <code>keyPath</code>.  <a href="#a20a01b0dd0dd51f9439b6a3a231c76ef">More...</a><br /></td></tr>
<tr class="separator:a20a01b0dd0dd51f9439b6a3a231c76ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3b367075ca8d6bba9fbf3636183ff3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f3b367075ca8d6bba9fbf3636183ff3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a7f3b367075ca8d6bba9fbf3636183ff3">SetMetadataByDictKey</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;key, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;keyPath, const T &amp;value) const</td></tr>
<tr class="memdesc:a7f3b367075ca8d6bba9fbf3636183ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Author <code>value</code> to the field identified by <code>key</code> and <code>keyPath</code> at the current EditTarget.  <a href="#a7f3b367075ca8d6bba9fbf3636183ff3">More...</a><br /></td></tr>
<tr class="separator:a7f3b367075ca8d6bba9fbf3636183ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c04b54500b5b6d5ef0e8aca66282770"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a0c04b54500b5b6d5ef0e8aca66282770">SetMetadataByDictKey</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;key, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;keyPath, const <a class="el" href="class_vt_value.html">VtValue</a> &amp;value) const</td></tr>
<tr class="separator:a0c04b54500b5b6d5ef0e8aca66282770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd756d242f6026a3d7c5606badbf8411"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#afd756d242f6026a3d7c5606badbf8411">ClearMetadataByDictKey</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;key, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;keyPath) const</td></tr>
<tr class="memdesc:afd756d242f6026a3d7c5606badbf8411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear any authored value identified by <code>key</code> and <code>keyPath</code> at the current EditTarget.  <a href="#afd756d242f6026a3d7c5606badbf8411">More...</a><br /></td></tr>
<tr class="separator:afd756d242f6026a3d7c5606badbf8411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14897ca124a0fb4a62e6ed2ccbbdbf4f"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a14897ca124a0fb4a62e6ed2ccbbdbf4f">WriteFallbackPrimTypes</a> ()</td></tr>
<tr class="memdesc:a14897ca124a0fb4a62e6ed2ccbbdbf4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the fallback prim types defined in the schema registry to the stage as dictionary valued fallback prim type metadata.  <a href="#a14897ca124a0fb4a62e6ed2ccbbdbf4f">More...</a><br /></td></tr>
<tr class="separator:a14897ca124a0fb4a62e6ed2ccbbdbf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">TimeCode API</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="Usd_timeCodeAPI"></a> Methods for managing the Stage's active timeSample range, time units, and intended rate of playback. See <a class="el" href="_usd__page__object_model.html#Usd_OM_UsdTimeCode">Time and Timing in USD</a> for more on time and TimeCodes in USD. </p>
</div></td></tr>
<tr class="memitem:a8999976ae5f8f57bc3ab845ea0453155"><td class="memItemLeft" align="right" valign="top">USD_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a8999976ae5f8f57bc3ab845ea0453155">GetStartTimeCode</a> () const</td></tr>
<tr class="memdesc:a8999976ae5f8f57bc3ab845ea0453155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stage's start timeCode.  <a href="#a8999976ae5f8f57bc3ab845ea0453155">More...</a><br /></td></tr>
<tr class="separator:a8999976ae5f8f57bc3ab845ea0453155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef35e121cd9662129b6e338e85ceab44"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#aef35e121cd9662129b6e338e85ceab44">SetStartTimeCode</a> (double)</td></tr>
<tr class="memdesc:aef35e121cd9662129b6e338e85ceab44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stage's start timeCode.  <a href="#aef35e121cd9662129b6e338e85ceab44">More...</a><br /></td></tr>
<tr class="separator:aef35e121cd9662129b6e338e85ceab44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c248e832dd9c974f9c24f6f4ef6f312"><td class="memItemLeft" align="right" valign="top">USD_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a3c248e832dd9c974f9c24f6f4ef6f312">GetEndTimeCode</a> () const</td></tr>
<tr class="memdesc:a3c248e832dd9c974f9c24f6f4ef6f312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stage's end timeCode.  <a href="#a3c248e832dd9c974f9c24f6f4ef6f312">More...</a><br /></td></tr>
<tr class="separator:a3c248e832dd9c974f9c24f6f4ef6f312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e5e8a51041bc7f9b7f1165ccec9fa4"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a05e5e8a51041bc7f9b7f1165ccec9fa4">SetEndTimeCode</a> (double)</td></tr>
<tr class="memdesc:a05e5e8a51041bc7f9b7f1165ccec9fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stage's end timeCode.  <a href="#a05e5e8a51041bc7f9b7f1165ccec9fa4">More...</a><br /></td></tr>
<tr class="separator:a05e5e8a51041bc7f9b7f1165ccec9fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66540a6d818fce71dce6f9db4b7385b"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ac66540a6d818fce71dce6f9db4b7385b">HasAuthoredTimeCodeRange</a> () const</td></tr>
<tr class="memdesc:ac66540a6d818fce71dce6f9db4b7385b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the stage has both start and end timeCodes authored in the session layer or the root layer of the stage.  <a href="#ac66540a6d818fce71dce6f9db4b7385b">More...</a><br /></td></tr>
<tr class="separator:ac66540a6d818fce71dce6f9db4b7385b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85092d7455ae894d50224e761dc6e840"><td class="memItemLeft" align="right" valign="top">USD_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a85092d7455ae894d50224e761dc6e840">GetTimeCodesPerSecond</a> () const</td></tr>
<tr class="memdesc:a85092d7455ae894d50224e761dc6e840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stage's timeCodesPerSecond value.  <a href="#a85092d7455ae894d50224e761dc6e840">More...</a><br /></td></tr>
<tr class="separator:a85092d7455ae894d50224e761dc6e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c421fcf601c28f2efc5597b8058e22"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a61c421fcf601c28f2efc5597b8058e22">SetTimeCodesPerSecond</a> (double timeCodesPerSecond) const</td></tr>
<tr class="memdesc:a61c421fcf601c28f2efc5597b8058e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stage's timeCodesPerSecond value.  <a href="#a61c421fcf601c28f2efc5597b8058e22">More...</a><br /></td></tr>
<tr class="separator:a61c421fcf601c28f2efc5597b8058e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf22202fde6282744edc795fa81a02f"><td class="memItemLeft" align="right" valign="top">USD_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a5cf22202fde6282744edc795fa81a02f">GetFramesPerSecond</a> () const</td></tr>
<tr class="memdesc:a5cf22202fde6282744edc795fa81a02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stage's framesPerSecond value.  <a href="#a5cf22202fde6282744edc795fa81a02f">More...</a><br /></td></tr>
<tr class="separator:a5cf22202fde6282744edc795fa81a02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cbe7df64c92e9fa082a0ef092c21e1"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ab3cbe7df64c92e9fa082a0ef092c21e1">SetFramesPerSecond</a> (double framesPerSecond) const</td></tr>
<tr class="memdesc:ab3cbe7df64c92e9fa082a0ef092c21e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stage's framesPerSecond value.  <a href="#ab3cbe7df64c92e9fa082a0ef092c21e1">More...</a><br /></td></tr>
<tr class="separator:ab3cbe7df64c92e9fa082a0ef092c21e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attribute Value Interpolation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="Usd_interpolation"></a> Controls the interpolation behavior when retrieving attribute values. The default behavior is linear interpolation. See <a class="el" href="class_usd_attribute.html#Usd_AttributeInterpolation">Attribute Value Interpolation</a> for more details. </p>
</div></td></tr>
<tr class="memitem:ad29a9aaba12c36407936a21abf514ea4"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ad29a9aaba12c36407936a21abf514ea4">SetInterpolationType</a> (<a class="el" href="interpolation_8h.html#a3b226373fc2194d5021c1c31b408f4c8">UsdInterpolationType</a> interpolationType)</td></tr>
<tr class="memdesc:ad29a9aaba12c36407936a21abf514ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the interpolation type used during value resolution for all attributes on this stage.  <a href="#ad29a9aaba12c36407936a21abf514ea4">More...</a><br /></td></tr>
<tr class="separator:ad29a9aaba12c36407936a21abf514ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e804b49f3bc5ed54976bf1d2a458182"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="interpolation_8h.html#a3b226373fc2194d5021c1c31b408f4c8">UsdInterpolationType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a6e804b49f3bc5ed54976bf1d2a458182">GetInterpolationType</a> () const</td></tr>
<tr class="memdesc:a6e804b49f3bc5ed54976bf1d2a458182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interpolation type used during value resolution for all attributes on this stage.  <a href="#a6e804b49f3bc5ed54976bf1d2a458182">More...</a><br /></td></tr>
<tr class="separator:a6e804b49f3bc5ed54976bf1d2a458182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Instancing</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="Usd_instancing"></a> See <a class="el" href="_usd__page__scenegraph_instancing.html">Scenegraph Instancing</a> for more details. </p>
</div></td></tr>
<tr class="memitem:aedabd9cb88feca10c5fa96c7454df493"><td class="memItemLeft" align="right" valign="top">USD_API std::vector&lt; <a class="el" href="class_usd_prim.html">UsdPrim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#aedabd9cb88feca10c5fa96c7454df493">GetPrototypes</a> () const</td></tr>
<tr class="memdesc:aedabd9cb88feca10c5fa96c7454df493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all native instancing prototype prims.  <a href="#aedabd9cb88feca10c5fa96c7454df493">More...</a><br /></td></tr>
<tr class="separator:aedabd9cb88feca10c5fa96c7454df493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_tf_ref_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_tf_ref_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_tf_ref_base.html">TfRefBase</a></td></tr>
<tr class="memitem:abcd501e4bb37d7a93faa4e625e96ecf7 inherit pub_methods_class_tf_ref_base"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_base.html#abcd501e4bb37d7a93faa4e625e96ecf7">GetCurrentCount</a> () const</td></tr>
<tr class="memdesc:abcd501e4bb37d7a93faa4e625e96ecf7 inherit pub_methods_class_tf_ref_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current reference count of this object.  <a href="class_tf_ref_base.html#abcd501e4bb37d7a93faa4e625e96ecf7">More...</a><br /></td></tr>
<tr class="separator:abcd501e4bb37d7a93faa4e625e96ecf7 inherit pub_methods_class_tf_ref_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8bc91cf9cff7c6e1da23dc59f5ad1f inherit pub_methods_class_tf_ref_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_base.html#aab8bc91cf9cff7c6e1da23dc59f5ad1f">IsUnique</a> () const</td></tr>
<tr class="memdesc:aab8bc91cf9cff7c6e1da23dc59f5ad1f inherit pub_methods_class_tf_ref_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if only one <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code> points to this object.  <a href="class_tf_ref_base.html#aab8bc91cf9cff7c6e1da23dc59f5ad1f">More...</a><br /></td></tr>
<tr class="separator:aab8bc91cf9cff7c6e1da23dc59f5ad1f inherit pub_methods_class_tf_ref_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1926aa1f9b1ad25c5c583b92bcf14b inherit pub_methods_class_tf_ref_base"><td class="memItemLeft" align="right" valign="top"><a id="abc1926aa1f9b1ad25c5c583b92bcf14b"></a>
const <a class="el" href="class_tf_ref_count.html">TfRefCount</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetRefCount</b> () const</td></tr>
<tr class="separator:abc1926aa1f9b1ad25c5c583b92bcf14b inherit pub_methods_class_tf_ref_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee7fb6df1df9be9afbda405643ecb6c inherit pub_methods_class_tf_ref_base"><td class="memItemLeft" align="right" valign="top"><a id="a6ee7fb6df1df9be9afbda405643ecb6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetShouldInvokeUniqueChangedListener</b> (bool shouldCall)</td></tr>
<tr class="separator:a6ee7fb6df1df9be9afbda405643ecb6c inherit pub_methods_class_tf_ref_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_tf_weak_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_tf_weak_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_tf_weak_base.html">TfWeakBase</a></td></tr>
<tr class="memitem:affc4c00d0bbfdfe4f9e6a8b2e81be368 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="affc4c00d0bbfdfe4f9e6a8b2e81be368"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TfWeakBase</b> (const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;)</td></tr>
<tr class="separator:affc4c00d0bbfdfe4f9e6a8b2e81be368 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aa4c4b93df067f2ec9b9e5fa4c35b3 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a01aa4c4b93df067f2ec9b9e5fa4c35b3"></a>
const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>__GetTfWeakBase__</b> () const</td></tr>
<tr class="separator:a01aa4c4b93df067f2ec9b9e5fa4c35b3 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af890ac314073e903458bf6b2397566b5 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="af890ac314073e903458bf6b2397566b5"></a>
const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;)</td></tr>
<tr class="separator:af890ac314073e903458bf6b2397566b5 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f1e27cc0c7c606ffb397b7d970ed10 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a16f1e27cc0c7c606ffb397b7d970ed10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EnableNotification2</b> () const</td></tr>
<tr class="separator:a16f1e27cc0c7c606ffb397b7d970ed10 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3241c32a82fbed0716a77049f6134e1e inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a3241c32a82fbed0716a77049f6134e1e"></a>
TF_API void const  *&#160;</td><td class="memItemRight" valign="bottom"><b>GetUniqueIdentifier</b> () const</td></tr>
<tr class="separator:a3241c32a82fbed0716a77049f6134e1e inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Variant Management</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="Usd_variantManagement"></a></p>
<p>These methods provide control over the policy to use when composing prims that specify a variant set but do not specify a selection.</p>
<p>The first is to declare a list of preferences in plugInfo.json metadata on a plugin using this structure:</p>
<div class="fragment"><div class="line">&quot;UsdVariantFallbacks&quot;: {    # top level key</div><div class="line">    &quot;shadingComplexity&quot;: [  # example variant set</div><div class="line">        &quot;full&quot;,             # example fallback #1</div><div class="line">        &quot;light&quot;             # example fallback #2</div><div class="line">    ]</div><div class="line">},</div></div><!-- fragment --><p>This example ensures that we will get the "full" shadingComplexity for any prim with a shadingComplexity VariantSet that doesn't otherwise specify a selection, <em>and</em> has a "full" variant; if its shadingComplexity does not have a "full" variant, but <em>does</em> have a "light" variant, then the selection will be "light". In other words, the entries in the "shadingComplexity" list in the plugInfo.json represent a priority-ordered list of fallback selections.</p>
<p>The plugin metadata is discovered and applied before the first <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> is constructed in a given process. It can be defined in any plugin. However, if multiple plugins express contrary lists for the same named variant set, the result is undefined.</p>
<p>The plugin metadata approach is useful for ensuring that sensible default behavior applies across a pipeline without requiring every script and binary to explicitly configure every VariantSet that subscribes to fallback in the pipeline. There may be times when you want to override this behavior in a particular script &ndash; for example, a pipeline script that knows it wants to entirely ignore shading in order to minimize processing time &ndash; which motivates the second approach.</p>
<p><a class="el" href="class_usd_stage.html#addaffc14d334e5cb1e3a90c02fadcaf6" title="Set the global variant fallback preferences used in new UsdStages.">SetGlobalVariantFallbacks()</a> provides a way to override, for the entire process, which fallbacks to use in subsequently constructed <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> instances. </p>
</div></td></tr>
<tr class="memitem:a34d1d78fe8e31f0ba439d2265d694af5"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="usd_2pcp_2types_8h.html#a72ae489ff9c2601b5f289baf87cece28">PcpVariantFallbackMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a34d1d78fe8e31f0ba439d2265d694af5">GetGlobalVariantFallbacks</a> ()</td></tr>
<tr class="memdesc:a34d1d78fe8e31f0ba439d2265d694af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global variant fallback preferences used in new UsdStages.  <a href="#a34d1d78fe8e31f0ba439d2265d694af5">More...</a><br /></td></tr>
<tr class="separator:a34d1d78fe8e31f0ba439d2265d694af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaffc14d334e5cb1e3a90c02fadcaf6"><td class="memItemLeft" align="right" valign="top">static USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#addaffc14d334e5cb1e3a90c02fadcaf6">SetGlobalVariantFallbacks</a> (const <a class="el" href="usd_2pcp_2types_8h.html#a72ae489ff9c2601b5f289baf87cece28">PcpVariantFallbackMap</a> &amp;fallbacks)</td></tr>
<tr class="memdesc:addaffc14d334e5cb1e3a90c02fadcaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global variant fallback preferences used in new UsdStages.  <a href="#addaffc14d334e5cb1e3a90c02fadcaf6">More...</a><br /></td></tr>
<tr class="separator:addaffc14d334e5cb1e3a90c02fadcaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_tf_ref_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_tf_ref_base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_tf_ref_base.html">TfRefBase</a></td></tr>
<tr class="memitem:a33e6c8ffe0caf7dac94ba5c4a4485fbd inherit pub_static_methods_class_tf_ref_base"><td class="memItemLeft" align="right" valign="top"><a id="a33e6c8ffe0caf7dac94ba5c4a4485fbd"></a>
static TF_API void&#160;</td><td class="memItemRight" valign="bottom"><b>SetUniqueChangedListener</b> (UniqueChangedListener listener)</td></tr>
<tr class="separator:a33e6c8ffe0caf7dac94ba5c4a4485fbd inherit pub_static_methods_class_tf_ref_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aec2b7ca1194f894ff2b952906abfd86c"><td class="memItemLeft" align="right" valign="top"><a id="aec2b7ca1194f894ff2b952906abfd86c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UsdAPISchemaBase</b></td></tr>
<tr class="separator:aec2b7ca1194f894ff2b952906abfd86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa332483a46ed09b95ae5344dcf051b92"><td class="memItemLeft" align="right" valign="top"><a id="aa332483a46ed09b95ae5344dcf051b92"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UsdAttribute</b></td></tr>
<tr class="separator:aa332483a46ed09b95ae5344dcf051b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf3a34e9976aa79c506135cb10ea20d"><td class="memItemLeft" align="right" valign="top"><a id="aacf3a34e9976aa79c506135cb10ea20d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UsdAttributeQuery</b></td></tr>
<tr class="separator:aacf3a34e9976aa79c506135cb10ea20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d563be232e30ddb41a8f627e982e4e"><td class="memItemLeft" align="right" valign="top"><a id="a22d563be232e30ddb41a8f627e982e4e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UsdEditTarget</b></td></tr>
<tr class="separator:a22d563be232e30ddb41a8f627e982e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597363dae3d685d482398a680c639ede"><td class="memItemLeft" align="right" valign="top"><a id="a597363dae3d685d482398a680c639ede"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UsdInherits</b></td></tr>
<tr class="separator:a597363dae3d685d482398a680c639ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7075a31a58b84795edf0b8f11f228e"><td class="memItemLeft" align="right" valign="top"><a id="a4e7075a31a58b84795edf0b8f11f228e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UsdObject</b></td></tr>
<tr class="separator:a4e7075a31a58b84795edf0b8f11f228e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2456ef04cace6b3b67dad91da7f430b8"><td class="memItemLeft" align="right" valign="top"><a id="a2456ef04cace6b3b67dad91da7f430b8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UsdPrim</b></td></tr>
<tr class="separator:a2456ef04cace6b3b67dad91da7f430b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7843eb26c70fa29eb383201c78ef69c3"><td class="memItemLeft" align="right" valign="top"><a id="a7843eb26c70fa29eb383201c78ef69c3"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UsdProperty</b></td></tr>
<tr class="separator:a7843eb26c70fa29eb383201c78ef69c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42568ffb2bb6a89af14beca5d6603ad9"><td class="memItemLeft" align="right" valign="top"><a id="a42568ffb2bb6a89af14beca5d6603ad9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UsdRelationship</b></td></tr>
<tr class="separator:a42568ffb2bb6a89af14beca5d6603ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243a743ae795cc506ad49a7b026d05d0"><td class="memItemLeft" align="right" valign="top"><a id="a243a743ae795cc506ad49a7b026d05d0"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UsdSpecializes</b></td></tr>
<tr class="separator:a243a743ae795cc506ad49a7b026d05d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3761aadba2edf545f214f9e7757d8e"><td class="memItemLeft" align="right" valign="top"><a id="a1b3761aadba2edf545f214f9e7757d8e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UsdVariantSet</b></td></tr>
<tr class="separator:a1b3761aadba2edf545f214f9e7757d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b76e42b0c2af879e36c8f304d7b0838"><td class="memItemLeft" align="right" valign="top"><a id="a4b76e42b0c2af879e36c8f304d7b0838"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UsdVariantSets</b></td></tr>
<tr class="separator:a4b76e42b0c2af879e36c8f304d7b0838"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Lifetime Management</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd30c6ee3df0025e43197d17047991253"></a><a class="anchor" id="Usd_lifetimeManagement"></a></p>
</td></tr>
<tr class="memitem:a7a661b8f729152c673078fbbafe29a46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> { <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>, 
<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ae9175fcb3934ccf24235741a50556ab3">LoadNone</a>
 }</td></tr>
<tr class="memdesc:a7a661b8f729152c673078fbbafe29a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the initial set of prims to load when opening a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>.  <a href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">More...</a><br /></td></tr>
<tr class="separator:a7a661b8f729152c673078fbbafe29a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c3f0a412aee9decb010787e5ca2e3e"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a50c3f0a412aee9decb010787e5ca2e3e">CreateNew</a> (const std::string &amp;identifier, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="memdesc:a50c3f0a412aee9decb010787e5ca2e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new stage with root layer <code>identifier</code>, destroying potentially existing files with that identifier; it is considered an error if an existing, open layer is present with this identifier.  <a href="#a50c3f0a412aee9decb010787e5ca2e3e">More...</a><br /></td></tr>
<tr class="separator:a50c3f0a412aee9decb010787e5ca2e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb7cf4c070e56d173246c5bdc1ff8e3"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a1eb7cf4c070e56d173246c5bdc1ff8e3">CreateNew</a> (const std::string &amp;identifier, const SdfLayerHandle &amp;sessionLayer, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:a1eb7cf4c070e56d173246c5bdc1ff8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4f7c64e079d5954115616207b82331"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a7f4f7c64e079d5954115616207b82331">CreateNew</a> (const std::string &amp;identifier, const SdfLayerHandle &amp;sessionLayer, const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;pathResolverContext, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:a7f4f7c64e079d5954115616207b82331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31488d38bf86c3e211a33de56a01902"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#aa31488d38bf86c3e211a33de56a01902">CreateNew</a> (const std::string &amp;identifier, const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;pathResolverContext, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:aa31488d38bf86c3e211a33de56a01902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fabfeea7271b1e6e5f308865f146391"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a7fabfeea7271b1e6e5f308865f146391">CreateInMemory</a> (<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="memdesc:a7fabfeea7271b1e6e5f308865f146391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new stage only in memory, analogous to creating an anonymous <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a>.  <a href="#a7fabfeea7271b1e6e5f308865f146391">More...</a><br /></td></tr>
<tr class="separator:a7fabfeea7271b1e6e5f308865f146391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c646259d7ddb2092e9cd62fc44bd57e"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a3c646259d7ddb2092e9cd62fc44bd57e">CreateInMemory</a> (const std::string &amp;identifier, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:a3c646259d7ddb2092e9cd62fc44bd57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ec81bad99609b7ca1795630dbbdf61"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#aa7ec81bad99609b7ca1795630dbbdf61">CreateInMemory</a> (const std::string &amp;identifier, const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;pathResolverContext, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:aa7ec81bad99609b7ca1795630dbbdf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec917a246b9918a97c0eb6a590a2442"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a5ec917a246b9918a97c0eb6a590a2442">CreateInMemory</a> (const std::string &amp;identifier, const SdfLayerHandle &amp;sessionLayer, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:a5ec917a246b9918a97c0eb6a590a2442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975784d8b8d9a44fbfdde692554d6b25"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a975784d8b8d9a44fbfdde692554d6b25">CreateInMemory</a> (const std::string &amp;identifier, const SdfLayerHandle &amp;sessionLayer, const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;pathResolverContext, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:a975784d8b8d9a44fbfdde692554d6b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd74eb9ec70572c2dadaf4cd07144380"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#abd74eb9ec70572c2dadaf4cd07144380">Open</a> (const std::string &amp;filePath, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="memdesc:abd74eb9ec70572c2dadaf4cd07144380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to find a matching existing stage in a cache if <a class="el" href="class_usd_stage_cache_context.html" title="A context object that lets the UsdStage::Open() API read from or read from and write to a UsdStageCac...">UsdStageCacheContext</a> objects exist on the stack.  <a href="#abd74eb9ec70572c2dadaf4cd07144380">More...</a><br /></td></tr>
<tr class="separator:abd74eb9ec70572c2dadaf4cd07144380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91922a33aa5d206c8f5209fac757162"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ad91922a33aa5d206c8f5209fac757162">Open</a> (const std::string &amp;filePath, const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;pathResolverContext, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:ad91922a33aa5d206c8f5209fac757162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1d90d759a085022ba76ff910815320"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ade1d90d759a085022ba76ff910815320">OpenMasked</a> (const std::string &amp;filePath, <a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> const &amp;mask, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="memdesc:ade1d90d759a085022ba76ff910815320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new stage and recursively compose prims defined within and referenced by the layer at <code>filePath</code> which must already exist, subject to <code>mask</code>.  <a href="#ade1d90d759a085022ba76ff910815320">More...</a><br /></td></tr>
<tr class="separator:ade1d90d759a085022ba76ff910815320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad891becaa0378fe97a07bbcfd07f7aef"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ad891becaa0378fe97a07bbcfd07f7aef">OpenMasked</a> (const std::string &amp;filePath, const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;pathResolverContext, <a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> const &amp;mask, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:ad891becaa0378fe97a07bbcfd07f7aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e185c150ee38ae13fb76115863d108"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ad3e185c150ee38ae13fb76115863d108">Open</a> (const SdfLayerHandle &amp;rootLayer, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="memdesc:ad3e185c150ee38ae13fb76115863d108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a stage rooted at <code>rootLayer</code>.  <a href="#ad3e185c150ee38ae13fb76115863d108">More...</a><br /></td></tr>
<tr class="separator:ad3e185c150ee38ae13fb76115863d108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a0be35427859ec030deedc150b5467"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a14a0be35427859ec030deedc150b5467">Open</a> (const SdfLayerHandle &amp;rootLayer, const SdfLayerHandle &amp;sessionLayer, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:a14a0be35427859ec030deedc150b5467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7df274caa1c118d2b7dadce1b600fe1"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ab7df274caa1c118d2b7dadce1b600fe1">Open</a> (const SdfLayerHandle &amp;rootLayer, const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;pathResolverContext, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:ab7df274caa1c118d2b7dadce1b600fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f83e49d0ca636b1a655192a42e9379"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#af5f83e49d0ca636b1a655192a42e9379">Open</a> (const SdfLayerHandle &amp;rootLayer, const SdfLayerHandle &amp;sessionLayer, const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;pathResolverContext, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:af5f83e49d0ca636b1a655192a42e9379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab01611f8cf724ea56a2a162ac1cb07"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a1ab01611f8cf724ea56a2a162ac1cb07">OpenMasked</a> (const SdfLayerHandle &amp;rootLayer, const <a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> &amp;mask, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="memdesc:a1ab01611f8cf724ea56a2a162ac1cb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a stage rooted at <code>rootLayer</code> and with limited population subject to <code>mask</code>.  <a href="#a1ab01611f8cf724ea56a2a162ac1cb07">More...</a><br /></td></tr>
<tr class="separator:a1ab01611f8cf724ea56a2a162ac1cb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79d5c92dda3279271005de91d9e7950"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ae79d5c92dda3279271005de91d9e7950">OpenMasked</a> (const SdfLayerHandle &amp;rootLayer, const SdfLayerHandle &amp;sessionLayer, const <a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> &amp;mask, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:ae79d5c92dda3279271005de91d9e7950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9833139e1c034c82bd06740ea1658847"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a9833139e1c034c82bd06740ea1658847">OpenMasked</a> (const SdfLayerHandle &amp;rootLayer, const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;pathResolverContext, const <a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> &amp;mask, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:a9833139e1c034c82bd06740ea1658847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86262226faba041d3c5a9cf6b99768bd"><td class="memItemLeft" align="right" valign="top">static USD_API UsdStageRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a86262226faba041d3c5a9cf6b99768bd">OpenMasked</a> (const SdfLayerHandle &amp;rootLayer, const SdfLayerHandle &amp;sessionLayer, const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;pathResolverContext, const <a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> &amp;mask, <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a> load=<a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a>)</td></tr>
<tr class="separator:a86262226faba041d3c5a9cf6b99768bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ae008cf02c54df2beee58c1228c5be"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#aa7ae008cf02c54df2beee58c1228c5be">IsSupportedFile</a> (const std::string &amp;filePath)</td></tr>
<tr class="memdesc:aa7ae008cf02c54df2beee58c1228c5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the specified file is supported by <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>.  <a href="#aa7ae008cf02c54df2beee58c1228c5be">More...</a><br /></td></tr>
<tr class="separator:aa7ae008cf02c54df2beee58c1228c5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08d70412c489100b8243cf5d0e61f99"><td class="memItemLeft" align="right" valign="top"><a id="af08d70412c489100b8243cf5d0e61f99"></a>
virtual USD_API&#160;</td><td class="memItemRight" valign="bottom"><b>~UsdStage</b> ()</td></tr>
<tr class="separator:af08d70412c489100b8243cf5d0e61f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf674de32ff446b3f2323b88adce89f8"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#abf674de32ff446b3f2323b88adce89f8">Reload</a> ()</td></tr>
<tr class="memdesc:abf674de32ff446b3f2323b88adce89f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="class_sdf_layer.html#aadc795502e58ced5fec2a00cf282f27a" title="Reloads the layer from its persistent representation.">SdfLayer::Reload</a> on all layers contributing to this stage, except session layers and sublayers of session layers.  <a href="#abf674de32ff446b3f2323b88adce89f8">More...</a><br /></td></tr>
<tr class="separator:abf674de32ff446b3f2323b88adce89f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Prim Access, Creation and Mutation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp1b6348704442b1ef64fd27cb8460c6ac"></a><a class="anchor" id="Usd_primManagement"></a> All of the methods in this group that accept a prim path as argument require paths in the namespace of the stage's root layer, <em>regardless</em> of what the currently active <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> is set to. In other words, a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> always presents a composed view of its scene, and all prim operations are specified in the composed namespace. </p>
</td></tr>
<tr class="memitem:a5567a555616cd3bf5fd2fc787f31accc"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_prim.html">UsdPrim</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a5567a555616cd3bf5fd2fc787f31accc">GetPseudoRoot</a> () const</td></tr>
<tr class="memdesc:a5567a555616cd3bf5fd2fc787f31accc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the stage's "pseudo-root" prim, whose name is defined by Usd.  <a href="#a5567a555616cd3bf5fd2fc787f31accc">More...</a><br /></td></tr>
<tr class="separator:a5567a555616cd3bf5fd2fc787f31accc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ee78980b91d82dddfae78300276bca"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_prim.html">UsdPrim</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a64ee78980b91d82dddfae78300276bca">GetDefaultPrim</a> () const</td></tr>
<tr class="memdesc:a64ee78980b91d82dddfae78300276bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the root <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> on this stage whose name is the root layer's defaultPrim metadata's value.  <a href="#a64ee78980b91d82dddfae78300276bca">More...</a><br /></td></tr>
<tr class="separator:a64ee78980b91d82dddfae78300276bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b260faf91fbf721b0503075f2861e2"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a82b260faf91fbf721b0503075f2861e2">SetDefaultPrim</a> (const <a class="el" href="class_usd_prim.html">UsdPrim</a> &amp;prim)</td></tr>
<tr class="memdesc:a82b260faf91fbf721b0503075f2861e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default prim layer metadata in this stage's root layer.  <a href="#a82b260faf91fbf721b0503075f2861e2">More...</a><br /></td></tr>
<tr class="separator:a82b260faf91fbf721b0503075f2861e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76429ce323495ced5ec3fe5d8b240d0e"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a76429ce323495ced5ec3fe5d8b240d0e">ClearDefaultPrim</a> ()</td></tr>
<tr class="memdesc:a76429ce323495ced5ec3fe5d8b240d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the default prim layer metadata in this stage's root layer.  <a href="#a76429ce323495ced5ec3fe5d8b240d0e">More...</a><br /></td></tr>
<tr class="separator:a76429ce323495ced5ec3fe5d8b240d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e5592905d6be9b2be90a7dcc450873"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a66e5592905d6be9b2be90a7dcc450873">HasDefaultPrim</a> () const</td></tr>
<tr class="memdesc:a66e5592905d6be9b2be90a7dcc450873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this stage's root layer has an authored opinion for the default prim layer metadata.  <a href="#a66e5592905d6be9b2be90a7dcc450873">More...</a><br /></td></tr>
<tr class="separator:a66e5592905d6be9b2be90a7dcc450873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ceb556070804b712c01a7968f925735"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_prim.html">UsdPrim</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a6ceb556070804b712c01a7968f925735">GetPrimAtPath</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path) const</td></tr>
<tr class="memdesc:a6ceb556070804b712c01a7968f925735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> at <code>path</code>, or an invalid <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> if none exists.  <a href="#a6ceb556070804b712c01a7968f925735">More...</a><br /></td></tr>
<tr class="separator:a6ceb556070804b712c01a7968f925735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9987f6fcd69d03b0b34d3ff1cf8ae345"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_object.html">UsdObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a9987f6fcd69d03b0b34d3ff1cf8ae345">GetObjectAtPath</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path) const</td></tr>
<tr class="memdesc:a9987f6fcd69d03b0b34d3ff1cf8ae345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="class_usd_object.html" title="Base class for Usd scenegraph objects, providing common API.">UsdObject</a> at <code>path</code>, or an invalid <a class="el" href="class_usd_object.html" title="Base class for Usd scenegraph objects, providing common API.">UsdObject</a> if none exists.  <a href="#a9987f6fcd69d03b0b34d3ff1cf8ae345">More...</a><br /></td></tr>
<tr class="separator:a9987f6fcd69d03b0b34d3ff1cf8ae345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e639a0e2f163cb857149604f6042bd3"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_property.html">UsdProperty</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a5e639a0e2f163cb857149604f6042bd3">GetPropertyAtPath</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path) const</td></tr>
<tr class="memdesc:a5e639a0e2f163cb857149604f6042bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="class_usd_property.html" title="Base class for UsdAttribute and UsdRelationship scenegraph objects.">UsdProperty</a> at <code>path</code>, or an invalid <a class="el" href="class_usd_property.html" title="Base class for UsdAttribute and UsdRelationship scenegraph objects.">UsdProperty</a> if none exists.  <a href="#a5e639a0e2f163cb857149604f6042bd3">More...</a><br /></td></tr>
<tr class="separator:a5e639a0e2f163cb857149604f6042bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e1347e76e9f3e269f8be1df3e99a42"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a61e1347e76e9f3e269f8be1df3e99a42">GetAttributeAtPath</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path) const</td></tr>
<tr class="memdesc:a61e1347e76e9f3e269f8be1df3e99a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> at <code>path</code>, or an invalid <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> if none exists.  <a href="#a61e1347e76e9f3e269f8be1df3e99a42">More...</a><br /></td></tr>
<tr class="separator:a61e1347e76e9f3e269f8be1df3e99a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0c4da4c5bc2470f0c5a271215c2b01"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_relationship.html">UsdRelationship</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#aea0c4da4c5bc2470f0c5a271215c2b01">GetRelationshipAtPath</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path) const</td></tr>
<tr class="memdesc:aea0c4da4c5bc2470f0c5a271215c2b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> at <code>path</code>, or an invalid <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> if none exists.  <a href="#aea0c4da4c5bc2470f0c5a271215c2b01">More...</a><br /></td></tr>
<tr class="separator:aea0c4da4c5bc2470f0c5a271215c2b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba675b55f41cc1b305bed414fc4f178"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_prim_range.html">UsdPrimRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#adba675b55f41cc1b305bed414fc4f178">Traverse</a> ()</td></tr>
<tr class="memdesc:adba675b55f41cc1b305bed414fc4f178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the active, loaded, defined, non-abstract prims on this stage depth-first.  <a href="#adba675b55f41cc1b305bed414fc4f178">More...</a><br /></td></tr>
<tr class="separator:adba675b55f41cc1b305bed414fc4f178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69332eeeb1970d4908a72d0c8fd0c3cb"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_prim_range.html">UsdPrimRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a69332eeeb1970d4908a72d0c8fd0c3cb">Traverse</a> (const Usd_PrimFlagsPredicate &amp;predicate)</td></tr>
<tr class="memdesc:a69332eeeb1970d4908a72d0c8fd0c3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Traverse the prims on this stage subject to <code>predicate</code>.  <a href="#a69332eeeb1970d4908a72d0c8fd0c3cb">More...</a><br /></td></tr>
<tr class="separator:a69332eeeb1970d4908a72d0c8fd0c3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71559921b1e48949207817b2fd8bd01b"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_prim_range.html">UsdPrimRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a71559921b1e48949207817b2fd8bd01b">TraverseAll</a> ()</td></tr>
<tr class="memdesc:a71559921b1e48949207817b2fd8bd01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse all the prims on this stage depth-first.  <a href="#a71559921b1e48949207817b2fd8bd01b">More...</a><br /></td></tr>
<tr class="separator:a71559921b1e48949207817b2fd8bd01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29523207b89d9a7e47146e4a57c9b1b0"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_prim.html">UsdPrim</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a29523207b89d9a7e47146e4a57c9b1b0">OverridePrim</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path)</td></tr>
<tr class="memdesc:a29523207b89d9a7e47146e4a57c9b1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to ensure a <em><a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a></em> at <code>path</code> exists on this stage.  <a href="#a29523207b89d9a7e47146e4a57c9b1b0">More...</a><br /></td></tr>
<tr class="separator:a29523207b89d9a7e47146e4a57c9b1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6151ae804f7145e451d9aafdde347730"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_prim.html">UsdPrim</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a6151ae804f7145e451d9aafdde347730">DefinePrim</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;typeName=<a class="el" href="class_tf_token.html">TfToken</a>())</td></tr>
<tr class="memdesc:a6151ae804f7145e451d9aafdde347730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to ensure a <em><a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a></em> at <code>path</code> is defined (according to <a class="el" href="class_usd_prim.html#a87fbe0030c0fbb6307ee434664f1142f" title="Return true if this prim and all its ancestors have defining specifiers, false otherwise.">UsdPrim::IsDefined()</a>) on this stage.  <a href="#a6151ae804f7145e451d9aafdde347730">More...</a><br /></td></tr>
<tr class="separator:a6151ae804f7145e451d9aafdde347730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9437bc67851eb38bade51612f3aaa41f"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_usd_prim.html">UsdPrim</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a9437bc67851eb38bade51612f3aaa41f">CreateClassPrim</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;rootPrimPath)</td></tr>
<tr class="memdesc:a9437bc67851eb38bade51612f3aaa41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Author an <em><a class="el" href="class_sdf_prim_spec.html" title="Represents a prim description in an SdfLayer object.">SdfPrimSpec</a></em> with <em>specifier</em> == <em>SdfSpecifierClass</em> for the class at root prim path <code>path</code> at the current EditTarget.  <a href="#a9437bc67851eb38bade51612f3aaa41f">More...</a><br /></td></tr>
<tr class="separator:a9437bc67851eb38bade51612f3aaa41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac605faad8fc2673263775b1eecad2955"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#ac605faad8fc2673263775b1eecad2955">RemovePrim</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path)</td></tr>
<tr class="memdesc:ac605faad8fc2673263775b1eecad2955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all scene description for the given <code>path</code> and its subtree <em>in the current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a></em>.  <a href="#ac605faad8fc2673263775b1eecad2955">More...</a><br /></td></tr>
<tr class="separator:ac605faad8fc2673263775b1eecad2955"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Color Configuration API</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd6845e8c8f4315344011b0b6b8704f46"></a><a class="anchor" id="Usd_ColorConfigurationAPI"></a></p>
<p>Methods for authoring and querying the color configuration to be used to interpret the per-attribute color-spaces. An external system (like OpenColorIO) is typically used for interpreting the configuration.</p>
<p>Site-wide fallback values for the colorConfiguration and colorManagementSystem metadata can be set in the plugInfo.json file of a plugin using this structure:</p>
<div class="fragment"><div class="line">&quot;UsdColorConfigFallbacks&quot;: {</div><div class="line">    &quot;colorConfiguration&quot; = &quot;https://github.com/imageworks/OpenColorIO-Configs/blob/master/aces_1.0.1/config.ocio&quot;,</div><div class="line">    &quot;colorManagementSystem&quot; : &quot;OpenColorIO&quot;</div><div class="line">}</div></div><!-- fragment --><p>The color space in which a given color or texture attribute is authored is set as token-valued metadata 'colorSpace' on the attribute. For color or texture attributes that don't have an authored 'colorSpace' value, the fallback color-space is gleaned from the color configuration oracle. This is usually the config's <b>scene_linear</b> role color-space.</p>
<p>Here's the pseudo-code for determining an attribute's color-space.</p>
<div class="fragment"><div class="line">UsdStageRefPtr stage = <a class="code" href="class_usd_stage.html#abd74eb9ec70572c2dadaf4cd07144380">UsdStage::Open</a>(filePath);</div><div class="line"><a class="code" href="class_usd_prim.html">UsdPrim</a> prim = stage-&gt;<a class="code" href="class_usd_prim.html#a6ceb556070804b712c01a7968f925735">GetPrimAtPath</a>(<span class="stringliteral">&quot;/path/to/prim&quot;</span>)</div><div class="line"><a class="code" href="class_usd_attribute.html">UsdAttribute</a> attr = prim.<a class="code" href="class_usd_prim.html#a31225ac7165f58726f000ab1d67e9e61">GetAttribute</a>(<span class="stringliteral">&quot;someColorAttr&quot;</span>);</div><div class="line"><a class="code" href="class_tf_token.html">TfToken</a> colorSpace = attr.<a class="code" href="class_usd_attribute.html#a635e3fc6927db14e49302525a354bbf2">GetColorSpace</a>();</div><div class="line"><span class="keywordflow">if</span> (colorSpace.<a class="code" href="class_tf_token.html#a8e12342fc420701fbffd97025421575a">IsEmpty</a>()) {</div><div class="line">    <span class="comment">// If colorSpace is empty, get the default from the stage&#39;s </span></div><div class="line">    <span class="comment">// colorConfiguration, using external API (not provided by USD).</span></div><div class="line">    colorSpace = ExternalAPI::GetDefaultColorSpace(</div><div class="line">                        stage-&gt;GetColorConfiguration());</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_attribute.html#Usd_AttributeColorSpaceAPI">UsdAttribute ColorSpace API</a> </dd></dl>
</td></tr>
<tr class="memitem:a6c0776d95442b399cf8dcbd185a4109f"><td class="memItemLeft" align="right" valign="top">static USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a6c0776d95442b399cf8dcbd185a4109f">GetColorConfigFallbacks</a> (<a class="el" href="class_sdf_asset_path.html">SdfAssetPath</a> *colorConfiguration, <a class="el" href="class_tf_token.html">TfToken</a> *colorManagementSystem)</td></tr>
<tr class="memdesc:a6c0776d95442b399cf8dcbd185a4109f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global fallback values of 'colorConfiguration' and 'colorManagementSystem'.  <a href="#a6c0776d95442b399cf8dcbd185a4109f">More...</a><br /></td></tr>
<tr class="separator:a6c0776d95442b399cf8dcbd185a4109f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149deb93f08b3e0da85e3dd12a20c821"><td class="memItemLeft" align="right" valign="top">static USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a149deb93f08b3e0da85e3dd12a20c821">SetColorConfigFallbacks</a> (const <a class="el" href="class_sdf_asset_path.html">SdfAssetPath</a> &amp;colorConfiguration, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;colorManagementSystem)</td></tr>
<tr class="memdesc:a149deb93f08b3e0da85e3dd12a20c821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the global fallback values of color configuration metadata which includes the 'colorConfiguration' asset path and the name of the color management system.  <a href="#a149deb93f08b3e0da85e3dd12a20c821">More...</a><br /></td></tr>
<tr class="separator:a149deb93f08b3e0da85e3dd12a20c821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff338cb37de09b0fa70ea0e693c9cd2"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#aaff338cb37de09b0fa70ea0e693c9cd2">SetColorConfiguration</a> (const <a class="el" href="class_sdf_asset_path.html">SdfAssetPath</a> &amp;colorConfig) const</td></tr>
<tr class="memdesc:aaff338cb37de09b0fa70ea0e693c9cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default color configuration to be used to interpret the per-attribute color-spaces in the composed USD stage.  <a href="#aaff338cb37de09b0fa70ea0e693c9cd2">More...</a><br /></td></tr>
<tr class="separator:aaff338cb37de09b0fa70ea0e693c9cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca98172991cd4bd223da2ac9742d495"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_sdf_asset_path.html">SdfAssetPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#abca98172991cd4bd223da2ac9742d495">GetColorConfiguration</a> () const</td></tr>
<tr class="memdesc:abca98172991cd4bd223da2ac9742d495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default color configuration used to interpret the per- attribute color-spaces in the composed USD stage.  <a href="#abca98172991cd4bd223da2ac9742d495">More...</a><br /></td></tr>
<tr class="separator:abca98172991cd4bd223da2ac9742d495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7571fb2cdc0e342775854284d53a78ab"><td class="memItemLeft" align="right" valign="top">USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#a7571fb2cdc0e342775854284d53a78ab">SetColorManagementSystem</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;cms) const</td></tr>
<tr class="memdesc:a7571fb2cdc0e342775854284d53a78ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the color management system used to interpret the color configuration file pointed at by the colorConfiguration metadata.  <a href="#a7571fb2cdc0e342775854284d53a78ab">More...</a><br /></td></tr>
<tr class="separator:a7571fb2cdc0e342775854284d53a78ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3f32f62031ea113321d4c66978692f"><td class="memItemLeft" align="right" valign="top">USD_API <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_stage.html#adb3f32f62031ea113321d4c66978692f">GetColorManagementSystem</a> () const</td></tr>
<tr class="memdesc:adb3f32f62031ea113321d4c66978692f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the color management system to be used for loading and interpreting the color configuration file.  <a href="#adb3f32f62031ea113321d4c66978692f">More...</a><br /></td></tr>
<tr class="separator:adb3f32f62031ea113321d4c66978692f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_class_tf_ref_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_tf_ref_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_tf_ref_base.html">TfRefBase</a></td></tr>
<tr class="memitem:a86baed63f8017038997266bdd638f65e inherit pub_types_class_tf_ref_base"><td class="memItemLeft" align="right" valign="top"><a id="a86baed63f8017038997266bdd638f65e"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>UniqueChangedFuncPtr</b>) (<a class="el" href="class_tf_ref_base.html">TfRefBase</a> const *, bool)</td></tr>
<tr class="separator:a86baed63f8017038997266bdd638f65e inherit pub_types_class_tf_ref_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_tf_weak_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_tf_weak_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_tf_weak_base.html">TfWeakBase</a></td></tr>
<tr class="memitem:a95139d2f4d04eb706664a4f47eb93918 inherit pro_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a95139d2f4d04eb706664a4f47eb93918"></a>
<a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; Tf_Remnant &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_Register</b> () const</td></tr>
<tr class="separator:a95139d2f4d04eb706664a4f47eb93918 inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memTemplParams" colspan="2"><a id="ac1312732482c8a286522f703f2cf90d1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; Tf_Remnant &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_Register</b> (T *tempRmnt) const</td></tr>
<tr class="separator:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5533162e8efab1be47acd6ccd5254c inherit pro_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a6a5533162e8efab1be47acd6ccd5254c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_HasRemnant</b> () const</td></tr>
<tr class="separator:a6a5533162e8efab1be47acd6ccd5254c inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The outermost container for scene description, which owns and presents composed prims as a scenegraph, following the composition recipe recursively described in its associated "root layer". </p>
<p>USD derives its persistent-storage scalability by combining and reusing simple compositions into richer aggregates using referencing and layering with sparse overrides. Ultimately, every composition (i.e. "scene") is identifiable by its root layer, i.e. the <code>.usd</code> file, and a scene is instantiated in an application on a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> that presents a composed view of the scene's root layer. Each simple composition referenced into a larger composition could be presented on its own <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>, at the same (or not) time that it is participating in the larger composition on its own <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>; all of the underlying layers will be shared by the two stages, while each maintains its own scenegraph of composed prims.</p>
<p>A <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> has sole ownership over the <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> 's with which it is populated, and retains <em>shared</em> ownership (with other stages and direct clients of <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a>'s, via the Sdf_LayerRegistry that underlies all <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> creation methods) of layers. It provides roughly five categories of API that address different aspects of scene management:</p>
<ul>
<li><a class="el" href="class_usd_stage.html#Usd_lifetimeManagement">Stage lifetime management</a> methods for constructing and initially populating a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> from an existing layer file, or one that will be created as a result, in memory or on the filesystem.</li>
<li><a class="el" href="class_usd_stage.html#Usd_workingSetManagement">Load/unload working set management</a> methods that allow you to specify which <a class="el" href="_usd__page__best_practices.html#Usd_Payloads">payloads</a> should be included and excluded from the stage's composition.</li>
<li><a class="el" href="class_usd_stage.html#Usd_variantManagement">Variant management</a> methods to manage policy for which variant to use when composing prims that provide a named variant set, but do not specify a selection.</li>
<li><a class="el" href="class_usd_stage.html#Usd_primManagement">Prim access, creation, and mutation</a> methods that allow you to find, create, or remove a prim identified by a path on the stage. This group also provides methods for efficiently traversing the prims on the stage.</li>
<li><a class="el" href="class_usd_stage.html#Usd_layerManagement">Layers and EditTargets</a> methods provide access to the layers in the stage's <em>root LayerStack</em> (i.e. the root layer and all of its recursive sublayers), and the ability to set a <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> into which all subsequent mutations to objects associated with the stage (e.g. prims, properties, etc) will go.</li>
<li><a class="el" href="class_usd_stage.html#Usd_stageSerialization">Serialization</a> methods for "flattening" a composition (to varying degrees), and exporting a completely flattened view of the stage to a string or file. These methods can be very useful for targeted asset optimization and debugging, though care should be exercized with large scenes, as flattening defeats some of the benefits of referenced scene description, and may produce very large results, especially in file formats that do not support data de-duplication, like the usda text format!</li>
</ul>
<h1><a class="anchor" id="Usd_SessionLayer"></a>
Stage Session Layers</h1>
<p>Each <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> can possess an optional "session layer". The purpose of a session layer is to hold ephemeral edits that modify a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>'s contents or behavior in a way that is useful to the client, but should not be considered as permanent mutations to be recorded upon export. A very common use of session layers is to make variant selections, to pick a specific LOD or shading variation, for example. The session layer is also frequently used to override the visibility of geometry and assets in the scene. A session layer, if present, contributes to a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>'s identity, for purposes of stage-caching, etc.</p>
<p>To edit content in a session layer, get the layer's edit target using stage-&gt;GetEditTargetForLocalLayer(stage-&gt;<a class="el" href="class_usd_stage.html#afcfb38efd355873d96fd2488da4dcddd" title="Return this stage&#39;s root session layer.">GetSessionLayer()</a>) and set that target in the stage by calling <a class="el" href="class_usd_stage.html#ac90008efb0f2b624fcff43de00188792" title="Set the stage&#39;s EditTarget.">SetEditTarget()</a> or creating a <a class="el" href="class_usd_edit_context.html" title="A utility class to temporarily modify a stage&#39;s current EditTarget during an execution scope.">UsdEditContext</a>. </p>

<p class="definition">Definition at line <a class="el" href="stage_8h_source.html#l00151">151</a> of file <a class="el" href="stage_8h_source.html">stage.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a7a661b8f729152c673078fbbafe29a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a661b8f729152c673078fbbafe29a46">&#9670;&nbsp;</a></span>InitialLoadSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the initial set of prims to load when opening a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1"></a>LoadAll&#160;</td><td class="fielddoc"><p>Load all loadable prims. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a661b8f729152c673078fbbafe29a46ae9175fcb3934ccf24235741a50556ab3"></a>LoadNone&#160;</td><td class="fielddoc"><p>Load no loadable prims. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="stage_8h_source.html#l00164">164</a> of file <a class="el" href="stage_8h_source.html">stage.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a76429ce323495ced5ec3fe5d8b240d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76429ce323495ced5ec3fe5d8b240d0e">&#9670;&nbsp;</a></span>ClearDefaultPrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void ClearDefaultPrim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the default prim layer metadata in this stage's root layer. </p>
<p>This is shorthand for: </p><div class="fragment"><div class="line">stage-&gt;GetRootLayer()-&gt;ClearDefaultPrim();</div></div><!-- fragment --><p> Note that this function always authors to the stage's root layer. To author to a different layer, use the <a class="el" href="class_sdf_layer.html#aced01fe7c9cd1be544adf59275d2f1d2" title="Set the default prim metadata for this layer.">SdfLayer::SetDefaultPrim()</a> API. </p>

</div>
</div>
<a id="af75ddb7982a5b5c77f9840e67df94435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75ddb7982a5b5c77f9840e67df94435">&#9670;&nbsp;</a></span>ClearMetadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool ClearMetadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the value of stage metadatum <code>key</code>, if the stage's current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> is the root or session layer. </p>
<p>If the current EditTarget is any other layer, raise a coding error. </p><dl class="section return"><dt>Returns</dt><dd>true if authoring was successful, false otherwise. Generates a coding error if <code>key</code> is not allowed as layer metadata.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd__page__object_model.html#Usd_OM_Metadata">General Metadata in USD</a> </dd></dl>

</div>
</div>
<a id="afd756d242f6026a3d7c5606badbf8411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd756d242f6026a3d7c5606badbf8411">&#9670;&nbsp;</a></span>ClearMetadataByDictKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool ClearMetadataByDictKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>keyPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear any authored value identified by <code>key</code> and <code>keyPath</code> at the current EditTarget. </p>
<p>The <code>keyPath</code> is a ':'-separated path identifying a path in subdictionaries stored in the metadata field at <code>key</code>. If <code>keyPath</code> is empty, no action is taken.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the value is cleared successfully, false otherwise. Generates a coding error if <code>key</code> is not allowed as layer metadata.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd__page__datatypes.html#Usd_Dictionary_Type">Dictionary-valued Metadata</a> </dd></dl>

</div>
</div>
<a id="a9437bc67851eb38bade51612f3aaa41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9437bc67851eb38bade51612f3aaa41f">&#9670;&nbsp;</a></span>CreateClassPrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_prim.html">UsdPrim</a> CreateClassPrim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>rootPrimPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Author an <em><a class="el" href="class_sdf_prim_spec.html" title="Represents a prim description in an SdfLayer object.">SdfPrimSpec</a></em> with <em>specifier</em> == <em>SdfSpecifierClass</em> for the class at root prim path <code>path</code> at the current EditTarget. </p>
<p>The current EditTarget must have UsdEditTarget::IsLocalLayer() == true.</p>
<p>The given <em>path</em> must be an absolute, root prim path that does not contain any variant selections.</p>
<p>If a defined (<a class="el" href="class_usd_prim.html#a87fbe0030c0fbb6307ee434664f1142f" title="Return true if this prim and all its ancestors have defining specifiers, false otherwise.">UsdPrim::IsDefined()</a>) non-class prim already exists at <code>path</code>, issue an error and return an invalid <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a>.</p>
<p>If it is impossible to author the necessary PrimSpec, issue an error and return an invalid <em><a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a></em>. </p>

</div>
</div>
<a id="a7fabfeea7271b1e6e5f308865f146391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fabfeea7271b1e6e5f308865f146391">&#9670;&nbsp;</a></span>CreateInMemory() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr CreateInMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new stage only in memory, analogous to creating an anonymous <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a>. </p>
<p>If <code>pathResolverContext</code> is provided it will be bound when creating the root layer at <code>identifier</code> and whenever asset path resolution is done for this stage, regardless of what other context may be bound at that time. Otherwise Usd will create the root layer with no context bound, then create a context for all future asset path resolution for the stage by calling <a class="el" href="class_ar_resolver.html#a1524962aa020859a589e786b1ad3c28f" title="Return an ArResolverContext that may be bound to this resolver to resolve assets when no other contex...">ArResolver::CreateDefaultContext</a>.</p>
<p>The initial set of prims to load on the stage can be specified using the <code>load</code> parameter. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46" title="Specifies the initial set of prims to load when opening a UsdStage.">UsdStage::InitialLoadSet</a>.</dd></dl>
<p>Invoking an overload that does not take a <code>sessionLayer</code> argument will create a stage with an anonymous in-memory session layer. To create a stage without a session layer, pass TfNullPtr (or None in python) as the <code>sessionLayer</code> argument. </p>

</div>
</div>
<a id="a3c646259d7ddb2092e9cd62fc44bd57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c646259d7ddb2092e9cd62fc44bd57e">&#9670;&nbsp;</a></span>CreateInMemory() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr CreateInMemory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa7ec81bad99609b7ca1795630dbbdf61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ec81bad99609b7ca1795630dbbdf61">&#9670;&nbsp;</a></span>CreateInMemory() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr CreateInMemory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>pathResolverContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5ec917a246b9918a97c0eb6a590a2442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec917a246b9918a97c0eb6a590a2442">&#9670;&nbsp;</a></span>CreateInMemory() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr CreateInMemory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>sessionLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a975784d8b8d9a44fbfdde692554d6b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975784d8b8d9a44fbfdde692554d6b25">&#9670;&nbsp;</a></span>CreateInMemory() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr CreateInMemory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>sessionLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>pathResolverContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a50c3f0a412aee9decb010787e5ca2e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c3f0a412aee9decb010787e5ca2e3e">&#9670;&nbsp;</a></span>CreateNew() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr CreateNew </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new stage with root layer <code>identifier</code>, destroying potentially existing files with that identifier; it is considered an error if an existing, open layer is present with this identifier. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sdf_layer.html#aad57cd44403a4f95a2bb6c730fa1b0f5" title="Creates a new empty layer with the given identifier.">SdfLayer::CreateNew()</a></dd></dl>
<p>Invoking an overload that does not take a <code>sessionLayer</code> argument will create a stage with an anonymous in-memory session layer. To create a stage without a session layer, pass TfNullPtr (or None in python) as the <code>sessionLayer</code> argument. The initial set of prims to load on the stage can be specified using the <code>load</code> parameter. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46" title="Specifies the initial set of prims to load when opening a UsdStage.">UsdStage::InitialLoadSet</a>.</dd></dl>
<p>If <code>pathResolverContext</code> is provided it will be bound when creating the root layer at <code>identifier</code> and whenever asset path resolution is done for this stage, regardless of what other context may be bound at that time. Otherwise Usd will create the root layer with no context bound, then create a context for all future asset path resolution for the stage by calling <a class="el" href="class_ar_resolver.html#a0a174a99676ff983a183d391973c7ebe" title="Return an ArResolverContext that may be bound to this resolver to resolve the asset located at assetP...">ArResolver::CreateDefaultContextForAsset</a> with the root layer's repository path if the layer has one, otherwise its resolved path. </p>

</div>
</div>
<a id="a1eb7cf4c070e56d173246c5bdc1ff8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb7cf4c070e56d173246c5bdc1ff8e3">&#9670;&nbsp;</a></span>CreateNew() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr CreateNew </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>sessionLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a7f4f7c64e079d5954115616207b82331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4f7c64e079d5954115616207b82331">&#9670;&nbsp;</a></span>CreateNew() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr CreateNew </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>sessionLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>pathResolverContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa31488d38bf86c3e211a33de56a01902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31488d38bf86c3e211a33de56a01902">&#9670;&nbsp;</a></span>CreateNew() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr CreateNew </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>pathResolverContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6151ae804f7145e451d9aafdde347730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6151ae804f7145e451d9aafdde347730">&#9670;&nbsp;</a></span>DefinePrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_prim.html">UsdPrim</a> DefinePrim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em> = <code><a class="el" href="class_tf_token.html">TfToken</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to ensure a <em><a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a></em> at <code>path</code> is defined (according to <a class="el" href="class_usd_prim.html#a87fbe0030c0fbb6307ee434664f1142f" title="Return true if this prim and all its ancestors have defining specifiers, false otherwise.">UsdPrim::IsDefined()</a>) on this stage. </p>
<p>If a prim at <code>path</code> is already defined on this stage and <code>typeName</code> is empty or equal to the existing prim's typeName, return that prim. Otherwise author an <em><a class="el" href="class_sdf_prim_spec.html" title="Represents a prim description in an SdfLayer object.">SdfPrimSpec</a></em> with <em>specifier</em> == <em>SdfSpecifierDef</em> and <code>typeName</code> for the prim at <code>path</code> at the current EditTarget. Author <em><a class="el" href="class_sdf_prim_spec.html" title="Represents a prim description in an SdfLayer object.">SdfPrimSpec</a></em> s with <code>specifier</code> == <em>SdfSpecifierDef</em> and empty typeName at the current EditTarget for any nonexistent, or existing but not <em>Defined</em> ancestors.</p>
<p>The given <em>path</em> must be an absolute prim path that does not contain any variant selections.</p>
<p>If it is impossible to author any of the necessary PrimSpecs (for example, in case <em>path</em> cannot map to the current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a>'s namespace or one of the ancestors of <code>path</code> is inactive on the <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>), issue an error and return an invalid <em><a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a></em>.</p>
<p>Note that this method may return a defined prim whose typeName does not match the supplied <code>typeName</code>, in case a stronger typeName opinion overrides the opinion at the current EditTarget. </p>

</div>
</div>
<a id="a5d76e23eede294e2988de22b45edc3e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d76e23eede294e2988de22b45edc3e2">&#9670;&nbsp;</a></span>ExpandPopulationMask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void ExpandPopulationMask </td>
          <td>(</td>
          <td class="paramtype">Usd_PrimFlagsPredicate const &amp;&#160;</td>
          <td class="paramname"><em>traversalPredicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="class_usd_relationship.html">UsdRelationship</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>relPred</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="class_usd_attribute.html">UsdAttribute</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>attrPred</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand this stage's population mask to include the targets of all relationships that pass <code>relPred</code> and connections to all attributes that pass <code>attrPred</code> recursively. </p>
<p>The attributes and relationships are those on all the prims found by traversing the stage according to <code>traversalPredicate</code>. If <code>relPred</code> is null, include all relationship targets; if <code>attrPred</code> is null, include all connections.</p>
<p>This function can be used, for example, to expand a population mask for a given prim to include bound materials, if those bound materials are expressed as relationships or attribute connections.</p>
<p>See also <a class="el" href="class_usd_prim.html#ac665feb1bef08159e2bc178181e2017a" title="Search the prim subtree rooted at this prim according to traversalPredicate for relationships for whi...">UsdPrim::FindAllRelationshipTargetPaths()</a> and <a class="el" href="class_usd_prim.html#a70a83830cef17b3c56ea4027d6a39599" title="Search the prim subtree rooted at this prim according to traversalPredicate for attributes for which ...">UsdPrim::FindAllAttributeConnectionPaths()</a>. </p>

</div>
</div>
<a id="a35f4bcec4c4fbd7366d4be6de13efc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f4bcec4c4fbd7366d4be6de13efc6d">&#9670;&nbsp;</a></span>ExpandPopulationMask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void ExpandPopulationMask </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="class_usd_relationship.html">UsdRelationship</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>relPred</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="class_usd_attribute.html">UsdAttribute</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>attrPred</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This convenience overload invokes <a class="el" href="class_usd_stage.html#a5d76e23eede294e2988de22b45edc3e2" title="Expand this stage&#39;s population mask to include the targets of all relationships that pass relPred and...">ExpandPopulationMask()</a> with the UsdPrimDefaultPredicate traversal predicate. </p>

</div>
</div>
<a id="a3f3fa959eb4a0a6ac2ec5ca8f248cb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3fa959eb4a0a6ac2ec5ca8f248cb95">&#9670;&nbsp;</a></span>Export()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool Export </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addSourceFileComment</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_layer.html#a1dfd2030337b6243cd6424fce7397590">SdfLayer::FileFormatArguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em> = <code><a class="el" href="class_sdf_layer.html#a1dfd2030337b6243cd6424fce7397590">SdfLayer::FileFormatArguments</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes out the composite scene as a single flattened layer into <em>filename</em>. </p>
<p>If addSourceFileComment is true, a comment in the output layer will mention the input layer it was generated from.</p>
<p>See <a class="el" href="class_usd_stage.html#ae3271778fa2ceeb82fbd51296610820a" title="Returns a single, anonymous, merged layer for this composite scene.">UsdStage::Flatten</a> for details of the flattening transformation. </p>

</div>
</div>
<a id="a164713764becadb3b88f1c8d7694631b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164713764becadb3b88f1c8d7694631b">&#9670;&nbsp;</a></span>ExportToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool ExportToString </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addSourceFileComment</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the composite scene as a flattened Usd text representation into the given <em>string</em>. </p>
<p>If addSourceFileComment is true, a comment in the output layer will mention the input layer it was generated from.</p>
<p>See <a class="el" href="class_usd_stage.html#ae3271778fa2ceeb82fbd51296610820a" title="Returns a single, anonymous, merged layer for this composite scene.">UsdStage::Flatten</a> for details of the flattening transformation. </p>

</div>
</div>
<a id="adf1b7f717f7418333440a0a318793b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1b7f717f7418333440a0a318793b0d">&#9670;&nbsp;</a></span>FindLoadable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API SdfPathSet FindLoadable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>rootPath</em> = <code><a class="el" href="class_sdf_path.html#a9e77b565c10268c2b55f92559f621606">SdfPath::AbsoluteRootPath</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an SdfPathSet of all paths that can be loaded. </p>
<p>Note that this method does not return paths to inactive prims as they cannot be loaded.</p>
<p>The set returned includes loaded and unloaded paths. To determine the set of unloaded paths, one can diff this set with the current load set, for example: </p><div class="fragment"><div class="line">SdfPathSet loaded = stage-&gt;GetLoadSet(),</div><div class="line">           all = stage-&gt;FindLoadable(),</div><div class="line">           result;</div><div class="line">std::set_difference(loaded.begin(), loaded.end(),</div><div class="line">                    all.begin(), all.end(),</div><div class="line">                    std::inserter(result, result.end()));</div></div><!-- fragment --><p>See <a class="el" href="class_usd_stage.html#Usd_workingSetManagement">Working Set Management</a> for more information. </p>

</div>
</div>
<a id="ae3271778fa2ceeb82fbd51296610820a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3271778fa2ceeb82fbd51296610820a">&#9670;&nbsp;</a></span>Flatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_tf_ref_ptr.html">SdfLayerRefPtr</a> Flatten </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addSourceFileComment</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a single, anonymous, merged layer for this composite scene. </p>
<p>Specifically, this function removes <b>most</b> composition metadata and authors the resolved values for each object directly into the flattened layer.</p>
<p>All VariantSets are removed and only the currently selected variants will be present in the resulting layer.</p>
<p>Class prims will still exist, however all inherits arcs will have been removed and the inherited data will be copied onto each child object. Composition arcs authored on the class itself will be flattened into the class.</p>
<p>Flatten preserves <a class="el" href="_usd__page__scenegraph_instancing.html">scenegraph instancing</a> by creating independent roots for each prototype currently composed on this stage, and adding a single internal reference arc on each instance prim to its corresponding prototype.</p>
<p>Time samples across sublayer offsets will will have the time offset and scale applied to each time index.</p>
<p>Finally, any deactivated prims will be pruned from the result. </p>

</div>
</div>
<a id="a61e1347e76e9f3e269f8be1df3e99a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e1347e76e9f3e269f8be1df3e99a42">&#9670;&nbsp;</a></span>GetAttributeAtPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> GetAttributeAtPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> at <code>path</code>, or an invalid <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> if none exists. </p>
<p>This is equivalent to </p><div class="fragment"><div class="line">stage.GetObjectAtPath(path).As&lt;<a class="code" href="class_usd_attribute.html">UsdAttribute</a>&gt;();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#a9987f6fcd69d03b0b34d3ff1cf8ae345" title="Return the UsdObject at path, or an invalid UsdObject if none exists.">GetObjectAtPath(const SdfPath&amp;) const </a> </dd></dl>

</div>
</div>
<a id="a6c0776d95442b399cf8dcbd185a4109f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0776d95442b399cf8dcbd185a4109f">&#9670;&nbsp;</a></span>GetColorConfigFallbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API void GetColorConfigFallbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sdf_asset_path.html">SdfAssetPath</a> *&#160;</td>
          <td class="paramname"><em>colorConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tf_token.html">TfToken</a> *&#160;</td>
          <td class="paramname"><em>colorManagementSystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the global fallback values of 'colorConfiguration' and 'colorManagementSystem'. </p>
<p>These are set in the plugInfo.json file of a plugin, but can be overridden by calling the static method <a class="el" href="class_usd_stage.html#a149deb93f08b3e0da85e3dd12a20c821" title="Sets the global fallback values of color configuration metadata which includes the &#39;colorConfiguratio...">SetColorConfigFallbacks()</a>.</p>
<p>The python wrapping of this method returns a tuple containing (colorConfiguration, colorManagementSystem).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#a149deb93f08b3e0da85e3dd12a20c821" title="Sets the global fallback values of color configuration metadata which includes the &#39;colorConfiguratio...">SetColorConfigFallbacks</a>, <a class="el" href="class_usd_stage.html#Usd_ColorConfigurationAPI">Color Configuration API</a> </dd></dl>

</div>
</div>
<a id="abca98172991cd4bd223da2ac9742d495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca98172991cd4bd223da2ac9742d495">&#9670;&nbsp;</a></span>GetColorConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_sdf_asset_path.html">SdfAssetPath</a> GetColorConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the default color configuration used to interpret the per- attribute color-spaces in the composed USD stage. </p>
<p><a class="el" href="class_usd_stage.html#Usd_ColorConfigurationAPI">Color Configuration API</a> </p>

</div>
</div>
<a id="adb3f32f62031ea113321d4c66978692f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3f32f62031ea113321d4c66978692f">&#9670;&nbsp;</a></span>GetColorManagementSystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_tf_token.html">TfToken</a> GetColorManagementSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the name of the color management system to be used for loading and interpreting the color configuration file. </p>
<p><a class="el" href="class_usd_stage.html#Usd_ColorConfigurationAPI">Color Configuration API</a> </p>

</div>
</div>
<a id="a64ee78980b91d82dddfae78300276bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ee78980b91d82dddfae78300276bca">&#9670;&nbsp;</a></span>GetDefaultPrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_prim.html">UsdPrim</a> GetDefaultPrim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the root <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> on this stage whose name is the root layer's defaultPrim metadata's value. </p>
<p>Return an invalid prim if there is no such prim or if the root layer's defaultPrim metadata is unset or is not a valid prim name. Note that this function only examines this stage's rootLayer. It does not consider sublayers of the rootLayer. See also <a class="el" href="class_sdf_layer.html#a9f4bc091a43e577b49007cceed42e6ae" title="Return the defaultPrim metadata for this layer.">SdfLayer::GetDefaultPrim()</a>. </p>

</div>
</div>
<a id="a16cb44251a2c5964583fd9076de3f753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cb44251a2c5964583fd9076de3f753">&#9670;&nbsp;</a></span>GetEditTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API const <a class="el" href="class_usd_edit_target.html">UsdEditTarget</a>&amp; GetEditTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the stage's EditTarget. </p>

</div>
</div>
<a id="a39a51571cd00e6f38572f7f55a101cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a51571cd00e6f38572f7f55a101cf5">&#9670;&nbsp;</a></span>GetEditTargetForLocalLayer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_edit_target.html">UsdEditTarget</a> GetEditTargetForLocalLayer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> for editing the layer at index <em>i</em> in the layer stack. </p>
<p>This edit target will incorporate any layer time offset that applies to the sublayer. </p>

</div>
</div>
<a id="acceed6daf2f94a536ff3bc8d4bfcaf45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acceed6daf2f94a536ff3bc8d4bfcaf45">&#9670;&nbsp;</a></span>GetEditTargetForLocalLayer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_edit_target.html">UsdEditTarget</a> GetEditTargetForLocalLayer </td>
          <td>(</td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> for editing the given local <em>layer</em>. </p>
<p>If the given layer appears more than once in the layer stack, the time offset to the first occurrence will be used. </p>

</div>
</div>
<a id="a3c248e832dd9c974f9c24f6f4ef6f312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c248e832dd9c974f9c24f6f4ef6f312">&#9670;&nbsp;</a></span>GetEndTimeCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API double GetEndTimeCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the stage's end timeCode. </p>
<p>If the stage has an associated session layer with an end timeCode opinion, this value is returned. Otherwise, the end timeCode opinion from the root layer is returned. </p>

</div>
</div>
<a id="a5cf22202fde6282744edc795fa81a02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf22202fde6282744edc795fa81a02f">&#9670;&nbsp;</a></span>GetFramesPerSecond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API double GetFramesPerSecond </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the stage's framesPerSecond value. </p>
<p>This makes an advisory statement about how the contained data can be most usefully consumed and presented. It's primarily an indication of the expected playback rate for the data, but a timeline editing tool might also want to use this to decide how to scale and label its timeline.</p>
<p>The default value of framesPerSecond is 24. </p>

</div>
</div>
<a id="a34d1d78fe8e31f0ba439d2265d694af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d1d78fe8e31f0ba439d2265d694af5">&#9670;&nbsp;</a></span>GetGlobalVariantFallbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API <a class="el" href="usd_2pcp_2types_8h.html#a72ae489ff9c2601b5f289baf87cece28">PcpVariantFallbackMap</a> GetGlobalVariantFallbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the global variant fallback preferences used in new UsdStages. </p>

</div>
</div>
<a id="a6e804b49f3bc5ed54976bf1d2a458182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e804b49f3bc5ed54976bf1d2a458182">&#9670;&nbsp;</a></span>GetInterpolationType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="interpolation_8h.html#a3b226373fc2194d5021c1c31b408f4c8">UsdInterpolationType</a> GetInterpolationType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the interpolation type used during value resolution for all attributes on this stage. </p>

</div>
</div>
<a id="a9dfcae900fd07e3344e087ea1bd478cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfcae900fd07e3344e087ea1bd478cb">&#9670;&nbsp;</a></span>GetLayerStack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API SdfLayerHandleVector GetLayerStack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeSessionLayers</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return this stage's local layers in strong-to-weak order. </p>
<p>If <em>includeSessionLayers</em> is true, return the linearized strong-to-weak sublayers rooted at the stage's session layer followed by the linearized strong-to-weak sublayers rooted at this stage's root layer. If <em>includeSessionLayers</em> is false, omit the sublayers rooted at this stage's session layer. </p>

</div>
</div>
<a id="a8a32bd6860d97da6d01d6dfaa7eb8e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a32bd6860d97da6d01d6dfaa7eb8e2c">&#9670;&nbsp;</a></span>GetLoadRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_usd_stage_load_rules.html">UsdStageLoadRules</a> const&amp; GetLoadRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the stage's current <a class="el" href="class_usd_stage_load_rules.html" title="This class represents rules that govern payload inclusion on UsdStages.">UsdStageLoadRules</a> governing payload inclusion. </p>
<p>See <a class="el" href="class_usd_stage.html#Usd_workingSetManagement">Working Set Management</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="stage_8h_source.html#l00653">653</a> of file <a class="el" href="stage_8h_source.html">stage.h</a>.</p>

</div>
</div>
<a id="a3051c81e353b2d151d360b24b8f9fb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3051c81e353b2d151d360b24b8f9fb88">&#9670;&nbsp;</a></span>GetLoadSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API SdfPathSet GetLoadSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a set of all loaded paths. </p>
<p>The paths returned are both those that have been explicitly loaded and those that were loaded as a result of dependencies, ancestors or descendants of explicitly loaded paths.</p>
<p>This method does not return paths to inactive prims.</p>
<p>See <a class="el" href="class_usd_stage.html#Usd_workingSetManagement">Working Set Management</a> for more information. </p>

</div>
</div>
<a id="ad2d76f736733f3ad51aa1ea1df6f4d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d76f736733f3ad51aa1ea1df6f4d44">&#9670;&nbsp;</a></span>GetMetadata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GetMetadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return in <code>value</code> an authored or fallback value (if one was defined for the given metadatum) for Stage metadatum <code>key</code>. </p>
<p>Order of resolution is session layer, followed by root layer, else fallback to the <a class="el" href="class_sdf_schema.html" title="Class that provides information about the various scene description fields.">SdfSchema</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if we successfully retrieved a value of the requested type; false if <code>key</code> is not allowed as layer metadata or no value was found. Generates a coding error if we retrieved a stored value of a type other than the requested type</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd__page__object_model.html#Usd_OM_Metadata">General Metadata in USD</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="stage_8h_source.html#l02389">2389</a> of file <a class="el" href="stage_8h_source.html">stage.h</a>.</p>

</div>
</div>
<a id="af114545bd56cd7619e7d4f2f884e4128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af114545bd56cd7619e7d4f2f884e4128">&#9670;&nbsp;</a></span>GetMetadata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool GetMetadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aba47c41ec8cc536290c04e219f12589c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba47c41ec8cc536290c04e219f12589c">&#9670;&nbsp;</a></span>GetMetadataByDictKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GetMetadataByDictKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>keyPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve the requested dictionary sub-element <code>keyPath</code> of dictionary-valued metadatum named <code>key</code>, returning the resolved value. </p>
<p>If you know you need just a small number of elements from a dictionary, accessing them element-wise using this method can be much less expensive than fetching the entire dictionary with GetMetadata(key).</p>
<dl class="section return"><dt>Returns</dt><dd>true if we successfully retrieved a value of the requested type; false if <code>key</code> is not allowed as layer metadata or no value was found. Generates a coding error if we retrieved a stored value of a type other than the requested type</dd></dl>
<p>The <code>keyPath</code> is a ':'-separated path addressing an element in subdictionaries. If <code>keyPath</code> is empty, returns an empty <a class="el" href="class_vt_value.html" title="Provides a container which may hold any type, and provides introspection and iteration over array typ...">VtValue</a>. </p>

<p class="definition">Definition at line <a class="el" href="stage_8h_source.html#l02419">2419</a> of file <a class="el" href="stage_8h_source.html">stage.h</a>.</p>

</div>
</div>
<a id="a3bdf70a1d4a8754a0cb51cddab11b299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdf70a1d4a8754a0cb51cddab11b299">&#9670;&nbsp;</a></span>GetMetadataByDictKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool GetMetadataByDictKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>keyPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overload </p>

</div>
</div>
<a id="a41ce205d182683fe0c45b97642d8051c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ce205d182683fe0c45b97642d8051c">&#9670;&nbsp;</a></span>GetMutedLayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API const std::vector&lt;std::string&gt;&amp; GetMutedLayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of all layers that have been muted on this stage. </p>

</div>
</div>
<a id="a9987f6fcd69d03b0b34d3ff1cf8ae345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9987f6fcd69d03b0b34d3ff1cf8ae345">&#9670;&nbsp;</a></span>GetObjectAtPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_object.html">UsdObject</a> GetObjectAtPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="class_usd_object.html" title="Base class for Usd scenegraph objects, providing common API.">UsdObject</a> at <code>path</code>, or an invalid <a class="el" href="class_usd_object.html" title="Base class for Usd scenegraph objects, providing common API.">UsdObject</a> if none exists. </p>
<p>If <code>path</code> indicates a prim beneath an instance, returns an instance proxy prim if a prim exists at the corresponding path in that instance's prototype. If <code>path</code> indicates a property beneath a child of an instance, returns a property whose parent prim is an instance proxy prim.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_usd_object.html">UsdObject</a> obj = stage-&gt;GetObjectAtPath(path)) {</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="class_usd_prim.html">UsdPrim</a> prim = obj.<a class="code" href="class_usd_object.html#aaca099fe79c1bbdd2216e7cb583952a9">As</a>&lt;<a class="code" href="class_usd_prim.html">UsdPrim</a>&gt;()) {</div><div class="line">        <span class="comment">// Do things with prim</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="class_usd_property.html">UsdProperty</a> prop = obj.<a class="code" href="class_usd_object.html#aaca099fe79c1bbdd2216e7cb583952a9">As</a>&lt;<a class="code" href="class_usd_property.html">UsdProperty</a>&gt;()) {</div><div class="line">        <span class="comment">// Do things with property. We can also cast to</span></div><div class="line">        <span class="comment">// UsdRelationship or UsdAttribute using this same pattern.</span></div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">    <span class="comment">// No object at specified path</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="adabe8c6ff9089b848260f4cf43958cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabe8c6ff9089b848260f4cf43958cc7">&#9670;&nbsp;</a></span>GetPathResolverContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> GetPathResolverContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the path resolver context for all path resolution during composition of this stage. </p>
<p>Useful for external clients that want to resolve paths with the same context as this stage, or create new stages with the same context. </p>

</div>
</div>
<a id="a3eb4c2665d6ccecf2998b76041a9a3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb4c2665d6ccecf2998b76041a9a3df">&#9670;&nbsp;</a></span>GetPopulationMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> GetPopulationMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this stage's population mask. </p>

<p class="definition">Definition at line <a class="el" href="stage_8h_source.html#l00670">670</a> of file <a class="el" href="stage_8h_source.html">stage.h</a>.</p>

</div>
</div>
<a id="a6ceb556070804b712c01a7968f925735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ceb556070804b712c01a7968f925735">&#9670;&nbsp;</a></span>GetPrimAtPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_prim.html">UsdPrim</a> GetPrimAtPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> at <code>path</code>, or an invalid <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> if none exists. </p>
<p>If <code>path</code> indicates a prim beneath an instance, returns an instance proxy prim if a prim exists at the corresponding path in that instance's prototype.</p>
<p>Unlike <a class="el" href="class_usd_stage.html#a29523207b89d9a7e47146e4a57c9b1b0" title="Attempt to ensure a UsdPrim at path exists on this stage.">OverridePrim()</a> and <a class="el" href="class_usd_stage.html#a6151ae804f7145e451d9aafdde347730" title="Attempt to ensure a UsdPrim at path is defined (according to UsdPrim::IsDefined()) on this stage.">DefinePrim()</a>, this method will never author scene description, and therefore is safe to use as a "reader" in the Usd multi-threading model. </p>

</div>
</div>
<a id="a5e639a0e2f163cb857149604f6042bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e639a0e2f163cb857149604f6042bd3">&#9670;&nbsp;</a></span>GetPropertyAtPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_property.html">UsdProperty</a> GetPropertyAtPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="class_usd_property.html" title="Base class for UsdAttribute and UsdRelationship scenegraph objects.">UsdProperty</a> at <code>path</code>, or an invalid <a class="el" href="class_usd_property.html" title="Base class for UsdAttribute and UsdRelationship scenegraph objects.">UsdProperty</a> if none exists. </p>
<p>This is equivalent to </p><div class="fragment"><div class="line">stage.GetObjectAtPath(path).As&lt;<a class="code" href="class_usd_property.html">UsdProperty</a>&gt;();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#a9987f6fcd69d03b0b34d3ff1cf8ae345" title="Return the UsdObject at path, or an invalid UsdObject if none exists.">GetObjectAtPath(const SdfPath&amp;) const </a> </dd></dl>

</div>
</div>
<a id="aedabd9cb88feca10c5fa96c7454df493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedabd9cb88feca10c5fa96c7454df493">&#9670;&nbsp;</a></span>GetPrototypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API std::vector&lt;<a class="el" href="class_usd_prim.html">UsdPrim</a>&gt; GetPrototypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all native instancing prototype prims. </p>

</div>
</div>
<a id="a5567a555616cd3bf5fd2fc787f31accc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5567a555616cd3bf5fd2fc787f31accc">&#9670;&nbsp;</a></span>GetPseudoRoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_prim.html">UsdPrim</a> GetPseudoRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the stage's "pseudo-root" prim, whose name is defined by Usd. </p>
<p>The stage's named root prims are namespace children of this prim, which exists to make the namespace hierarchy a tree instead of a forest. This simplifies algorithms that want to traverse all prims.</p>
<p>A <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> always has a pseudo-root prim, unless there was an error opening or creating the stage, in which case this method returns an invalid <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a>. </p>

</div>
</div>
<a id="aea0c4da4c5bc2470f0c5a271215c2b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0c4da4c5bc2470f0c5a271215c2b01">&#9670;&nbsp;</a></span>GetRelationshipAtPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_relationship.html">UsdRelationship</a> GetRelationshipAtPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> at <code>path</code>, or an invalid <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> if none exists. </p>
<p>This is equivalent to </p><div class="fragment"><div class="line">stage.GetObjectAtPath(path).As&lt;<a class="code" href="class_usd_relationship.html">UsdRelationship</a>&gt;();</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#a9987f6fcd69d03b0b34d3ff1cf8ae345" title="Return the UsdObject at path, or an invalid UsdObject if none exists.">GetObjectAtPath(const SdfPath&amp;) const </a> </dd></dl>

</div>
</div>
<a id="ae694960a036c724e285d044aea210d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae694960a036c724e285d044aea210d15">&#9670;&nbsp;</a></span>GetRootLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API SdfLayerHandle GetRootLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return this stage's root layer. </p>

</div>
</div>
<a id="afcfb38efd355873d96fd2488da4dcddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfb38efd355873d96fd2488da4dcddd">&#9670;&nbsp;</a></span>GetSessionLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API SdfLayerHandle GetSessionLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return this stage's root session layer. </p>

</div>
</div>
<a id="a8999976ae5f8f57bc3ab845ea0453155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8999976ae5f8f57bc3ab845ea0453155">&#9670;&nbsp;</a></span>GetStartTimeCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API double GetStartTimeCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the stage's start timeCode. </p>
<p>If the stage has an associated session layer with a start timeCode opinion, this value is returned. Otherwise, the start timeCode opinion from the root layer is returned. </p>

</div>
</div>
<a id="a85092d7455ae894d50224e761dc6e840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85092d7455ae894d50224e761dc6e840">&#9670;&nbsp;</a></span>GetTimeCodesPerSecond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API double GetTimeCodesPerSecond </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the stage's timeCodesPerSecond value. </p>
<p>The timeCodesPerSecond value scales the time ordinate for the samples contained in the stage to seconds. If timeCodesPerSecond is 24, then a sample at time ordinate 24 should be viewed exactly one second after the sample at time ordinate 0.</p>
<p>Like <a class="el" href="class_sdf_layer.html#a8c7a1ac2e85efa2aa4831123de576b7c" title="Returns the layer&#39;s timeCodes per second.">SdfLayer::GetTimeCodesPerSecond</a>, this accessor uses a dynamic fallback to framesPerSecond. The order of precedence is:</p>
<ul>
<li>timeCodesPerSecond from session layer </li>
<li>timeCodesPerSecond from root layer </li>
<li>framesPerSecond from session layer </li>
<li>framesPerSecond from root layer </li>
<li>fallback value of 24 </li>
</ul>

</div>
</div>
<a id="a3b7937dd0b3f1d546e93ad4219916de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7937dd0b3f1d546e93ad4219916de9">&#9670;&nbsp;</a></span>GetUsedLayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API SdfLayerHandleVector GetUsedLayers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeClipLayers</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector of all of the layers <em>currently</em> consumed by this stage, as determined by the composition arcs that were traversed to compose and populate the stage. </p>
<p>The list of consumed layers will change with the stage's load-set and variant selections, so the return value should be considered only a snapshot. The return value will include the stage's session layer, if it has one. If <em>includeClipLayers</em> is true, we will also include all of the layers that this stage has had to open so far to perform value resolution of attributes affected by <a class="el" href="_usd__page__value_clips.html">Value Clips</a> </p>

</div>
</div>
<a id="a37211404a939811e841d90c65cd19999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37211404a939811e841d90c65cd19999">&#9670;&nbsp;</a></span>HasAuthoredMetadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool HasAuthoredMetadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the <em>key</em> has an authored value, <code>false</code> if no value was authored or the only value available is the <a class="el" href="class_sdf_schema.html" title="Class that provides information about the various scene description fields.">SdfSchema</a>'s metadata fallback. </p>
<dl class="section note"><dt>Note</dt><dd>If a value for a metadatum <em>not</em> legal to author on layers is present in the root or session layer (which could happen through hand-editing or use of certain low-level API's), this method will still return <code>false</code>. </dd></dl>

</div>
</div>
<a id="a20a01b0dd0dd51f9439b6a3a231c76ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a01b0dd0dd51f9439b6a3a231c76ef">&#9670;&nbsp;</a></span>HasAuthoredMetadataDictKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool HasAuthoredMetadataDictKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>keyPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if there exists any authored opinion (excluding fallbacks) for <code>key</code> and <code>keyPath</code>. </p>
<p>The <code>keyPath</code> is a ':'-separated path identifying a value in subdictionaries stored in the metadata field at <code>key</code>. If <code>keyPath</code> is empty, returns <code>false</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd__page__datatypes.html#Usd_Dictionary_Type">Dictionary-valued Metadata</a> </dd></dl>

</div>
</div>
<a id="ac66540a6d818fce71dce6f9db4b7385b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66540a6d818fce71dce6f9db4b7385b">&#9670;&nbsp;</a></span>HasAuthoredTimeCodeRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool HasAuthoredTimeCodeRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the stage has both start and end timeCodes authored in the session layer or the root layer of the stage. </p>

</div>
</div>
<a id="a66e5592905d6be9b2be90a7dcc450873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e5592905d6be9b2be90a7dcc450873">&#9670;&nbsp;</a></span>HasDefaultPrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool HasDefaultPrim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this stage's root layer has an authored opinion for the default prim layer metadata. </p>
<p>This is shorthand for: </p><div class="fragment"><div class="line">stage-&gt;GetRootLayer()-&gt;HasDefaultPrim();</div></div><!-- fragment --><p> Note that this function only consults the stage's root layer. To consult a different layer, use the <a class="el" href="class_sdf_layer.html#a5c5be6e4d708fe1aeec63877cd1e56ff" title="Return true if the default prim metadata is set in this layer.">SdfLayer::HasDefaultPrim()</a> API. </p>

</div>
</div>
<a id="aaff8c7b5cd9cdee23c5209c0ec7281b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff8c7b5cd9cdee23c5209c0ec7281b7">&#9670;&nbsp;</a></span>HasLocalLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool HasLocalLayer </td>
          <td>(</td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <em>layer</em> is one of the layers in this stage's local, root layerStack. </p>

</div>
</div>
<a id="ae2d99fd05dbc39c2d9746fe639c24825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d99fd05dbc39c2d9746fe639c24825">&#9670;&nbsp;</a></span>HasMetadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool HasMetadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the <em>key</em> has a meaningful value, that is, if <a class="el" href="class_usd_stage.html#ad2d76f736733f3ad51aa1ea1df6f4d44" title="Return in value an authored or fallback value (if one was defined for the given metadatum) for Stage ...">GetMetadata()</a> will provide a value, either because it was authored or because the Stage metadata was defined with a meaningful fallback value. </p>
<p>Returns false if <code>key</code> is not allowed as layer metadata. </p>

</div>
</div>
<a id="a911c19d77fe0552877918517818e7399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911c19d77fe0552877918517818e7399">&#9670;&nbsp;</a></span>HasMetadataDictKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool HasMetadataDictKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>keyPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if there exists any authored or fallback opinion for <code>key</code> and <code>keyPath</code>. </p>
<p>The <code>keyPath</code> is a ':'-separated path identifying a value in subdictionaries stored in the metadata field at <code>key</code>. If <code>keyPath</code> is empty, returns <code>false</code>.</p>
<p>Returns false if <code>key</code> is not allowed as layer metadata.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd__page__datatypes.html#Usd_Dictionary_Type">Dictionary-valued Metadata</a> </dd></dl>

</div>
</div>
<a id="a740db7501c0303b6c1e6e9ce87b10092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740db7501c0303b6c1e6e9ce87b10092">&#9670;&nbsp;</a></span>IsLayerMuted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool IsLayerMuted </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layerIdentifier</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the layer specified by <code>layerIdentifier</code> is muted in this cache, false otherwise. </p>
<p>See documentation on MuteLayer for details on how <code>layerIdentifier</code> is compared to the layers that have been muted. </p>

</div>
</div>
<a id="aa7ae008cf02c54df2beee58c1228c5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ae008cf02c54df2beee58c1228c5be">&#9670;&nbsp;</a></span>IsSupportedFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsSupportedFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the specified file is supported by <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>. </p>
<p>This function is a cheap way to determine whether a file might be open-able with <a class="el" href="class_usd_stage.html#abd74eb9ec70572c2dadaf4cd07144380" title="Attempt to find a matching existing stage in a cache if UsdStageCacheContext objects exist on the sta...">UsdStage::Open</a>. It is purely based on the given <code>filePath</code> and does not open the file or perform analysis on the contents. As such, <a class="el" href="class_usd_stage.html#abd74eb9ec70572c2dadaf4cd07144380" title="Attempt to find a matching existing stage in a cache if UsdStageCacheContext objects exist on the sta...">UsdStage::Open</a> may still fail even if this function returns true. </p>

</div>
</div>
<a id="aece3d46e8cff565af399bfda419964e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece3d46e8cff565af399bfda419964e7">&#9670;&nbsp;</a></span>Load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_prim.html">UsdPrim</a> Load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em> = <code><a class="el" href="class_sdf_path.html#a9e77b565c10268c2b55f92559f621606">SdfPath::AbsoluteRootPath</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="common_8h.html#aeeb09bb9e2bd68b2622a29dc649c8d5a">UsdLoadPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="common_8h.html#aeeb09bb9e2bd68b2622a29dc649c8d5aa42997d996674df3a923bbe2683fea7fb">UsdLoadWithDescendants</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify this stage's load rules to load the prim at <code>path</code>, its ancestors, and all of its descendants if <code>policy</code> is UsdLoadWithDescendants. </p>
<p>If <code>policy</code> is UsdLoadWithoutDescendants, then payloads on descendant prims are not loaded.</p>
<p>See <a class="el" href="class_usd_stage.html#Usd_workingSetManagement">Working Set Management</a> for more information. </p>

</div>
</div>
<a id="a1305b94bed8097515432ee78061ff009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1305b94bed8097515432ee78061ff009">&#9670;&nbsp;</a></span>LoadAndUnload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void LoadAndUnload </td>
          <td>(</td>
          <td class="paramtype">const SdfPathSet &amp;&#160;</td>
          <td class="paramname"><em>loadSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SdfPathSet &amp;&#160;</td>
          <td class="paramname"><em>unloadSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="common_8h.html#aeeb09bb9e2bd68b2622a29dc649c8d5a">UsdLoadPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="common_8h.html#aeeb09bb9e2bd68b2622a29dc649c8d5aa42997d996674df3a923bbe2683fea7fb">UsdLoadWithDescendants</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unload and load the given path sets. </p>
<p>The effect is as if the unload set were processed first followed by the load set.</p>
<p>This is equivalent to calling <a class="el" href="class_usd_stage.html#aedb4cb8d8943a759152b70f08e340a2c" title="Modify this stage&#39;s load rules to unload the prim and its descendants specified by path.">UsdStage::Unload</a> for each item in the unloadSet followed by <a class="el" href="class_usd_stage.html#aece3d46e8cff565af399bfda419964e7" title="Modify this stage&#39;s load rules to load the prim at path, its ancestors, and all of its descendants if...">UsdStage::Load</a> for each item in the loadSet, however this method is more efficient as all operations are committed in a single batch. The <code>policy</code> argument is described in the documentation for <a class="el" href="class_usd_stage.html#aece3d46e8cff565af399bfda419964e7" title="Modify this stage&#39;s load rules to load the prim at path, its ancestors, and all of its descendants if...">Load()</a>.</p>
<p>See <a class="el" href="class_usd_stage.html#Usd_workingSetManagement">Working Set Management</a> for more information. </p>

</div>
</div>
<a id="aa84244f8ed7ba7f037b8c9d9256cfeb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84244f8ed7ba7f037b8c9d9256cfeb5">&#9670;&nbsp;</a></span>MuteAndUnmuteLayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void MuteAndUnmuteLayers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>muteLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>unmuteLayers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mute and unmute the layers identified in <code>muteLayers</code> and <code>unmuteLayers</code>. </p>
<p>This is equivalent to calling <a class="el" href="class_usd_stage.html#a2f8158f35f1f76b227f51f875db4c5d1" title="Unmute the layer identified by layerIdentifier if it had previously been muted.">UsdStage::UnmuteLayer</a> for each layer in <code>unmuteLayers</code> followed by <a class="el" href="class_usd_stage.html#a8af4162fe11cc6a5f21a39e770d397c2" title="Mute the layer identified by layerIdentifier.">UsdStage::MuteLayer</a> for each layer in <code>muteLayers</code>, however this method is more efficient as all operations are committed in a single batch. </p>

</div>
</div>
<a id="a8af4162fe11cc6a5f21a39e770d397c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af4162fe11cc6a5f21a39e770d397c2">&#9670;&nbsp;</a></span>MuteLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void MuteLayer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layerIdentifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mute the layer identified by <code>layerIdentifier</code>. </p>
<p>Muted layers are ignored by the stage; they do not participate in value resolution or composition and do not appear in any LayerStack. If the root layer of a reference or payload LayerStack is muted, the behavior is as if the muted layer did not exist, which means a composition error will be generated.</p>
<p>A canonical identifier for each layer in <code>layersToMute</code> will be computed using <a class="el" href="class_ar_resolver.html#a68e5ae6385d1733b79f734c59682ff61" title="Returns an identifier for the asset specified by assetPath.">ArResolver::CreateIdentifier</a> using the stage's root layer as the anchoring asset. Any layer encountered during composition with the same identifier will be considered muted and ignored.</p>
<p>Note that muting a layer will cause this stage to release all references to that layer. If no other client is holding on to references to that layer, it will be unloaded. In this case, if there are unsaved edits to the muted layer, those edits are lost.</p>
<p>Since anonymous layers are not serialized, muting an anonymous layer will cause that layer and its contents to be lost in this case.</p>
<p>Muting a layer that has not been used by this stage is not an error. If that layer is encountered later, muting will take effect and that layer will be ignored.</p>
<p>The root layer of this stage may not be muted; attempting to do so will generate a coding error. </p>

</div>
</div>
<a id="abd74eb9ec70572c2dadaf4cd07144380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd74eb9ec70572c2dadaf4cd07144380">&#9670;&nbsp;</a></span>Open() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr Open </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to find a matching existing stage in a cache if <a class="el" href="class_usd_stage_cache_context.html" title="A context object that lets the UsdStage::Open() API read from or read from and write to a UsdStageCac...">UsdStageCacheContext</a> objects exist on the stack. </p>
<p>Failing that, create a new stage and recursively compose prims defined within and referenced by the layer at <code>filePath</code>, which must already exist.</p>
<p>The initial set of prims to load on the stage can be specified using the <code>load</code> parameter. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46" title="Specifies the initial set of prims to load when opening a UsdStage.">UsdStage::InitialLoadSet</a>.</dd></dl>
<p>If <code>pathResolverContext</code> is provided it will be bound when opening the root layer at <code>filePath</code> and whenever asset path resolution is done for this stage, regardless of what other context may be bound at that time. Otherwise Usd will open the root layer with no context bound, then create a context for all future asset path resolution for the stage by calling <a class="el" href="class_ar_resolver.html#a0a174a99676ff983a183d391973c7ebe" title="Return an ArResolverContext that may be bound to this resolver to resolve the asset located at assetP...">ArResolver::CreateDefaultContextForAsset</a> with the layer's repository path if the layer has one, otherwise its resolved path. </p>

</div>
</div>
<a id="ad91922a33aa5d206c8f5209fac757162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91922a33aa5d206c8f5209fac757162">&#9670;&nbsp;</a></span>Open() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr Open </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>pathResolverContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad3e185c150ee38ae13fb76115863d108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e185c150ee38ae13fb76115863d108">&#9670;&nbsp;</a></span>Open() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr Open </td>
          <td>(</td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>rootLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a stage rooted at <code>rootLayer</code>. </p>
<p>Attempt to find a stage that matches the passed arguments in a <a class="el" href="class_usd_stage_cache.html" title="A strongly concurrency safe collection of UsdStageRefPtr s, enabling sharing across multiple clients ...">UsdStageCache</a> if <a class="el" href="class_usd_stage_cache_context.html" title="A context object that lets the UsdStage::Open() API read from or read from and write to a UsdStageCac...">UsdStageCacheContext</a> objects exist on the calling stack. If a matching stage is found, return that stage. Otherwise, create a new stage rooted at <code>rootLayer</code>.</p>
<p>Invoking an overload that does not take a <code>sessionLayer</code> argument will create a stage with an anonymous in-memory session layer. To create a stage without a session layer, pass TfNullPtr (or None in python) as the <code>sessionLayer</code> argument.</p>
<p>The initial set of prims to load on the stage can be specified using the <code>load</code> parameter. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46" title="Specifies the initial set of prims to load when opening a UsdStage.">UsdStage::InitialLoadSet</a>.</dd></dl>
<p>If <code>pathResolverContext</code> is provided it will be bound when whenever asset path resolution is done for this stage, regardless of what other context may be bound at that time. Otherwise Usd will create a context for all future asset path resolution for the stage by calling <a class="el" href="class_ar_resolver.html#a0a174a99676ff983a183d391973c7ebe" title="Return an ArResolverContext that may be bound to this resolver to resolve the asset located at assetP...">ArResolver::CreateDefaultContextForAsset</a> with the layer's repository path if the layer has one, otherwise its resolved path.</p>
<p>When searching for a matching stage in bound <a class="el" href="class_usd_stage_cache.html" title="A strongly concurrency safe collection of UsdStageRefPtr s, enabling sharing across multiple clients ...">UsdStageCache</a> s, only the provided arguments matter for cache lookup. For example, if only a root layer (or a root layer file path) is provided, the first stage found in any cache that has that root layer is returned. So, for example if you require that the stage have no session layer, you must explicitly specify TfNullPtr (or None in python) for the sessionLayer argument. </p>

</div>
</div>
<a id="a14a0be35427859ec030deedc150b5467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a0be35427859ec030deedc150b5467">&#9670;&nbsp;</a></span>Open() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr Open </td>
          <td>(</td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>rootLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>sessionLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ab7df274caa1c118d2b7dadce1b600fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7df274caa1c118d2b7dadce1b600fe1">&#9670;&nbsp;</a></span>Open() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr Open </td>
          <td>(</td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>rootLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>pathResolverContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af5f83e49d0ca636b1a655192a42e9379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f83e49d0ca636b1a655192a42e9379">&#9670;&nbsp;</a></span>Open() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr Open </td>
          <td>(</td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>rootLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>sessionLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>pathResolverContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ade1d90d759a085022ba76ff910815320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1d90d759a085022ba76ff910815320">&#9670;&nbsp;</a></span>OpenMasked() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr OpenMasked </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> const &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new stage and recursively compose prims defined within and referenced by the layer at <code>filePath</code> which must already exist, subject to <code>mask</code>. </p>
<p>These <a class="el" href="class_usd_stage.html#ade1d90d759a085022ba76ff910815320" title="Create a new stage and recursively compose prims defined within and referenced by the layer at filePa...">OpenMasked()</a> methods do not automatically consult or populate <a class="el" href="class_usd_stage_cache.html" title="A strongly concurrency safe collection of UsdStageRefPtr s, enabling sharing across multiple clients ...">UsdStageCache</a> s.</p>
<p>The initial set of prims to load on the stage can be specified using the <code>load</code> parameter. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46" title="Specifies the initial set of prims to load when opening a UsdStage.">UsdStage::InitialLoadSet</a>.</dd></dl>
<p>If <code>pathResolverContext</code> is provided it will be bound when opening the root layer at <code>filePath</code> and whenever asset path resolution is done for this stage, regardless of what other context may be bound at that time. Otherwise Usd will open the root layer with no context bound, then create a context for all future asset path resolution for the stage by calling <a class="el" href="class_ar_resolver.html#a0a174a99676ff983a183d391973c7ebe" title="Return an ArResolverContext that may be bound to this resolver to resolve the asset located at assetP...">ArResolver::CreateDefaultContextForAsset</a> with the layer's repository path if the layer has one, otherwise its resolved path. </p>

</div>
</div>
<a id="ad891becaa0378fe97a07bbcfd07f7aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad891becaa0378fe97a07bbcfd07f7aef">&#9670;&nbsp;</a></span>OpenMasked() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr OpenMasked </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>pathResolverContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> const &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a1ab01611f8cf724ea56a2a162ac1cb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab01611f8cf724ea56a2a162ac1cb07">&#9670;&nbsp;</a></span>OpenMasked() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr OpenMasked </td>
          <td>(</td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>rootLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a stage rooted at <code>rootLayer</code> and with limited population subject to <code>mask</code>. </p>
<p>These <a class="el" href="class_usd_stage.html#ade1d90d759a085022ba76ff910815320" title="Create a new stage and recursively compose prims defined within and referenced by the layer at filePa...">OpenMasked()</a> methods do not automatically consult or populate <a class="el" href="class_usd_stage_cache.html" title="A strongly concurrency safe collection of UsdStageRefPtr s, enabling sharing across multiple clients ...">UsdStageCache</a> s.</p>
<p>Invoking an overload that does not take a <code>sessionLayer</code> argument will create a stage with an anonymous in-memory session layer. To create a stage without a session layer, pass TfNullPtr (or None in python) as the <code>sessionLayer</code> argument.</p>
<p>The initial set of prims to load on the stage can be specified using the <code>load</code> parameter. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46" title="Specifies the initial set of prims to load when opening a UsdStage.">UsdStage::InitialLoadSet</a>.</dd></dl>
<p>If <code>pathResolverContext</code> is provided it will be bound when whenever asset path resolution is done for this stage, regardless of what other context may be bound at that time. Otherwise Usd will create a context for all future asset path resolution for the stage by calling <a class="el" href="class_ar_resolver.html#a0a174a99676ff983a183d391973c7ebe" title="Return an ArResolverContext that may be bound to this resolver to resolve the asset located at assetP...">ArResolver::CreateDefaultContextForAsset</a> with the layer's repository path if the layer has one, otherwise its resolved path. </p>

</div>
</div>
<a id="ae79d5c92dda3279271005de91d9e7950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79d5c92dda3279271005de91d9e7950">&#9670;&nbsp;</a></span>OpenMasked() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr OpenMasked </td>
          <td>(</td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>rootLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>sessionLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a9833139e1c034c82bd06740ea1658847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9833139e1c034c82bd06740ea1658847">&#9670;&nbsp;</a></span>OpenMasked() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr OpenMasked </td>
          <td>(</td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>rootLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>pathResolverContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a86262226faba041d3c5a9cf6b99768bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86262226faba041d3c5a9cf6b99768bd">&#9670;&nbsp;</a></span>OpenMasked() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API UsdStageRefPtr OpenMasked </td>
          <td>(</td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>rootLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>sessionLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>pathResolverContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46">InitialLoadSet</a>&#160;</td>
          <td class="paramname"><em>load</em> = <code><a class="el" href="class_usd_stage.html#a7a661b8f729152c673078fbbafe29a46ad1ac95bf08ec6edd508491eff363b6a1">LoadAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a29523207b89d9a7e47146e4a57c9b1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29523207b89d9a7e47146e4a57c9b1b0">&#9670;&nbsp;</a></span>OverridePrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_prim.html">UsdPrim</a> OverridePrim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to ensure a <em><a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a></em> at <code>path</code> exists on this stage. </p>
<p>If a prim already exists at <code>path</code>, return it. Otherwise author <em>SdfPrimSpecs</em> with <em>specifier</em> == <em>SdfSpecifierOver</em> and empty <em>typeName</em> at the current EditTarget to create this prim and any nonexistent ancestors, then return it.</p>
<p>The given <em>path</em> must be an absolute prim path that does not contain any variant selections.</p>
<p>If it is impossible to author any of the necessary PrimSpecs, (for example, in case <em>path</em> cannot map to the current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a>'s namespace) issue an error and return an invalid <em><a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a></em>.</p>
<p>If an ancestor of <code>path</code> identifies an <em>inactive</em> prim, author scene description as described above but return an invalid prim, since the resulting prim is descendant to an inactive prim. </p>

</div>
</div>
<a id="abf674de32ff446b3f2323b88adce89f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf674de32ff446b3f2323b88adce89f8">&#9670;&nbsp;</a></span>Reload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void Reload </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <a class="el" href="class_sdf_layer.html#aadc795502e58ced5fec2a00cf282f27a" title="Reloads the layer from its persistent representation.">SdfLayer::Reload</a> on all layers contributing to this stage, except session layers and sublayers of session layers. </p>
<p>This includes non-session sublayers, references and payloads. Note that reloading anonymous layers clears their content, so invoking <a class="el" href="class_usd_stage.html#abf674de32ff446b3f2323b88adce89f8" title="Calls SdfLayer::Reload on all layers contributing to this stage, except session layers and sublayers ...">Reload()</a> on a stage constructed via <a class="el" href="class_usd_stage.html#a7fabfeea7271b1e6e5f308865f146391" title="Creates a new stage only in memory, analogous to creating an anonymous SdfLayer.">CreateInMemory()</a> will clear its root layer.</p>
<dl class="section note"><dt>Note</dt><dd>This method is considered a mutation, which has potentially global effect! Unlike the various <a class="el" href="class_usd_stage.html#aece3d46e8cff565af399bfda419964e7" title="Modify this stage&#39;s load rules to load the prim at path, its ancestors, and all of its descendants if...">Load()</a> methods whose actions affect only <b>this stage</b>, <a class="el" href="class_usd_stage.html#abf674de32ff446b3f2323b88adce89f8" title="Calls SdfLayer::Reload on all layers contributing to this stage, except session layers and sublayers ...">Reload()</a> may cause layers to change their contents, and because layers are global resources shared by potentially many Stages, calling <a class="el" href="class_usd_stage.html#abf674de32ff446b3f2323b88adce89f8" title="Calls SdfLayer::Reload on all layers contributing to this stage, except session layers and sublayers ...">Reload()</a> on one stage may result in a mutation to any number of stages. In general, unless you are highly confident your stage is the only consumer of its layers, you should only call <a class="el" href="class_usd_stage.html#abf674de32ff446b3f2323b88adce89f8" title="Calls SdfLayer::Reload on all layers contributing to this stage, except session layers and sublayers ...">Reload()</a> when you are assured no other threads may be reading from any Stages. </dd></dl>

</div>
</div>
<a id="ac605faad8fc2673263775b1eecad2955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac605faad8fc2673263775b1eecad2955">&#9670;&nbsp;</a></span>RemovePrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool RemovePrim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all scene description for the given <code>path</code> and its subtree <em>in the current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a></em>. </p>
<p>This method does not do what you might initially think! Calling this function will not necessarily cause the <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> at <code>path</code> on this stage to disappear. Completely eradicating a prim from a composition can be an involved process, involving edits to many contributing layers, some of which (in many circumstances) will not be editable by a client. This method is a surgical instrument that <em>can</em> be used iteratively to effect complete removal of a prim and its subtree from namespace, assuming the proper permissions are acquired, but more commonly it is used to perform layer-level operations; e.g.: ensuring that a given layer (as expressed by a <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a>) provides no opinions for a prim and its subtree.</p>
<p>Generally, if your eye is attracted to this method, you probably want to instead use UsdPrim::SetActive(false) , which will provide the <a class="el" href="_usd__page__properties_of_scene_description.html#Usd_ActiveInactive">composed effect</a> of removing the prim and its subtree from the composition, without actually removing any scene description, which as a bonus, means that the effect is reversible at a later time! </p>

</div>
</div>
<a id="a5d23f48d36d27f3f8e5099a8c655fa4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d23f48d36d27f3f8e5099a8c655fa4e">&#9670;&nbsp;</a></span>ResolveIdentifierToEditTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API std::string ResolveIdentifierToEditTarget </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>identifier</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve the given identifier using this stage's <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> and the layer of its <a class="el" href="class_usd_stage.html#a16cb44251a2c5964583fd9076de3f753" title="Return the stage&#39;s EditTarget.">GetEditTarget()</a> as an anchor for relative references (e.g. </p>
<p>@./siblingFile.usd@).</p>
<dl class="section return"><dt>Returns</dt><dd>a non-empty string containing either the same identifier that was passed in (if the identifier refers to an already-opened layer or an "anonymous", in-memory layer), or a resolved layer filepath. If the identifier was not resolvable, return the empty string. </dd></dl>

</div>
</div>
<a id="adefa2f7ebfc4d8c09f0cd54419aa36c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefa2f7ebfc4d8c09f0cd54419aa36c4">&#9670;&nbsp;</a></span>Save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void Save </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <a class="el" href="class_sdf_layer.html#ad5a54175a9d67b72094f8fdf3e83c9d9" title="Returns true if successful, false if an error occurred.">SdfLayer::Save</a> on all dirty layers contributing to this stage except session layers and sublayers of session layers. </p>
<p>This function will emit a warning and skip each dirty anonymous layer it encounters, since anonymous layers cannot be saved with <a class="el" href="class_sdf_layer.html#ad5a54175a9d67b72094f8fdf3e83c9d9" title="Returns true if successful, false if an error occurred.">SdfLayer::Save</a>. These layers must be manually exported by calling <a class="el" href="class_sdf_layer.html#aef819927fc1ad0d6fc5ad5fefb58dcdf" title="Exports this layer to a file.">SdfLayer::Export</a>. </p>

</div>
</div>
<a id="a94b48dc29e9c66e3efed8cb42ff18618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b48dc29e9c66e3efed8cb42ff18618">&#9670;&nbsp;</a></span>SaveSessionLayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void SaveSessionLayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <a class="el" href="class_sdf_layer.html#ad5a54175a9d67b72094f8fdf3e83c9d9" title="Returns true if successful, false if an error occurred.">SdfLayer::Save</a> on all dirty session layers and sublayers of session layers contributing to this stage. </p>
<p>This function will emit a warning and skip each dirty anonymous layer it encounters, since anonymous layers cannot be saved with <a class="el" href="class_sdf_layer.html#ad5a54175a9d67b72094f8fdf3e83c9d9" title="Returns true if successful, false if an error occurred.">SdfLayer::Save</a>. These layers must be manually exported by calling <a class="el" href="class_sdf_layer.html#aef819927fc1ad0d6fc5ad5fefb58dcdf" title="Exports this layer to a file.">SdfLayer::Export</a>. </p>

</div>
</div>
<a id="a149deb93f08b3e0da85e3dd12a20c821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149deb93f08b3e0da85e3dd12a20c821">&#9670;&nbsp;</a></span>SetColorConfigFallbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API void SetColorConfigFallbacks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_asset_path.html">SdfAssetPath</a> &amp;&#160;</td>
          <td class="paramname"><em>colorConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>colorManagementSystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the global fallback values of color configuration metadata which includes the 'colorConfiguration' asset path and the name of the color management system. </p>
<p>This overrides any fallback values authored in plugInfo files.</p>
<p>If the specified value of <code>colorConfiguration</code> or <code>colorManagementSystem</code> is empty, then the corresponding fallback value isn't set. In other words, for this call to have an effect, at least one value must be non-empty. Additionally, these can't be reset to empty values.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#a6c0776d95442b399cf8dcbd185a4109f" title="Returns the global fallback values of &#39;colorConfiguration&#39; and &#39;colorManagementSystem&#39;.">GetColorConfigFallbacks()</a> <a class="el" href="class_usd_stage.html#Usd_ColorConfigurationAPI">Color Configuration API</a> </dd></dl>

</div>
</div>
<a id="aaff338cb37de09b0fa70ea0e693c9cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff338cb37de09b0fa70ea0e693c9cd2">&#9670;&nbsp;</a></span>SetColorConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void SetColorConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_asset_path.html">SdfAssetPath</a> &amp;&#160;</td>
          <td class="paramname"><em>colorConfig</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the default color configuration to be used to interpret the per-attribute color-spaces in the composed USD stage. </p>
<p>This is specified as asset path which can be resolved to the color spec file.</p>
<p><a class="el" href="class_usd_stage.html#Usd_ColorConfigurationAPI">Color Configuration API</a> </p>

</div>
</div>
<a id="a7571fb2cdc0e342775854284d53a78ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7571fb2cdc0e342775854284d53a78ab">&#9670;&nbsp;</a></span>SetColorManagementSystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void SetColorManagementSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>cms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the name of the color management system used to interpret the color configuration file pointed at by the colorConfiguration metadata. </p>
<p><a class="el" href="class_usd_stage.html#Usd_ColorConfigurationAPI">Color Configuration API</a> </p>

</div>
</div>
<a id="a82b260faf91fbf721b0503075f2861e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b260faf91fbf721b0503075f2861e2">&#9670;&nbsp;</a></span>SetDefaultPrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void SetDefaultPrim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_usd_prim.html">UsdPrim</a> &amp;&#160;</td>
          <td class="paramname"><em>prim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the default prim layer metadata in this stage's root layer. </p>
<p>This is shorthand for: </p><div class="fragment"><div class="line">stage-&gt;GetRootLayer()-&gt;SetDefaultPrim(prim.<a class="code" href="class_usd_object.html#ae57e12beedf10c423e11c5b889343f6d">GetName</a>());</div></div><!-- fragment --><p> Note that this function always authors to the stage's root layer. To author to a different layer, use the <a class="el" href="class_sdf_layer.html#aced01fe7c9cd1be544adf59275d2f1d2" title="Set the default prim metadata for this layer.">SdfLayer::SetDefaultPrim()</a> API. </p>

</div>
</div>
<a id="ac90008efb0f2b624fcff43de00188792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90008efb0f2b624fcff43de00188792">&#9670;&nbsp;</a></span>SetEditTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void SetEditTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_usd_edit_target.html">UsdEditTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>editTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stage's EditTarget. </p>
<p>If <em>editTarget.IsLocalLayer()</em>, check to see if it's a layer in this stage's local LayerStack. If not, issue an error and do nothing. If <em>editTarget</em> is invalid, issue an error and do nothing. If <em>editTarget</em> differs from the stage's current EditTarget, set the EditTarget and send UsdNotice::StageChangedEditTarget. Otherwise do nothing. </p>

</div>
</div>
<a id="a05e5e8a51041bc7f9b7f1165ccec9fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e5e8a51041bc7f9b7f1165ccec9fa4">&#9670;&nbsp;</a></span>SetEndTimeCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void SetEndTimeCode </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the stage's end timeCode. </p>
<p>The end timeCode is set in the current EditTarget, if it is the root layer of the stage or the session layer associated with the stage. If the current EditTarget is neither, a warning is issued and the end timeCode is not set. </p>

</div>
</div>
<a id="ab3cbe7df64c92e9fa082a0ef092c21e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cbe7df64c92e9fa082a0ef092c21e1">&#9670;&nbsp;</a></span>SetFramesPerSecond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void SetFramesPerSecond </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>framesPerSecond</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the stage's framesPerSecond value. </p>
<p>The framesPerSecond value is set in the current EditTarget, if it is the root layer of the stage or the session layer associated with the stage. If the current EditTarget is neither, a warning is issued and no value is set.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#a5cf22202fde6282744edc795fa81a02f" title="Returns the stage&#39;s framesPerSecond value.">GetFramesPerSecond()</a> </dd></dl>

</div>
</div>
<a id="addaffc14d334e5cb1e3a90c02fadcaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addaffc14d334e5cb1e3a90c02fadcaf6">&#9670;&nbsp;</a></span>SetGlobalVariantFallbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API void SetGlobalVariantFallbacks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="usd_2pcp_2types_8h.html#a72ae489ff9c2601b5f289baf87cece28">PcpVariantFallbackMap</a> &amp;&#160;</td>
          <td class="paramname"><em>fallbacks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the global variant fallback preferences used in new UsdStages. </p>
<p>This overrides any fallbacks configured in plugin metadata, and only affects stages created after this call.</p>
<dl class="section note"><dt>Note</dt><dd>This does not affect existing UsdStages. </dd></dl>

</div>
</div>
<a id="ad29a9aaba12c36407936a21abf514ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29a9aaba12c36407936a21abf514ea4">&#9670;&nbsp;</a></span>SetInterpolationType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void SetInterpolationType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interpolation_8h.html#a3b226373fc2194d5021c1c31b408f4c8">UsdInterpolationType</a>&#160;</td>
          <td class="paramname"><em>interpolationType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the interpolation type used during value resolution for all attributes on this stage. </p>
<p>Changing this will cause a <a class="el" href="class_usd_notice_1_1_stage_contents_changed.html" title="Ultra-conservative notice sent when the given UsdStage&#39;s contents have changed in any way.">UsdNotice::StageContentsChanged</a> notice to be sent, as values at times where no samples are authored may have changed. </p>

</div>
</div>
<a id="acf86347f816ee4ac98dbf16e3b09ff2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf86347f816ee4ac98dbf16e3b09ff2a">&#9670;&nbsp;</a></span>SetLoadRules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void SetLoadRules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_usd_stage_load_rules.html">UsdStageLoadRules</a> const &amp;&#160;</td>
          <td class="paramname"><em>rules</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="class_usd_stage_load_rules.html" title="This class represents rules that govern payload inclusion on UsdStages.">UsdStageLoadRules</a> to govern payload inclusion on this stage. </p>
<p>This rebuilds the stage's entire prim hierarchy to follow <code>rules</code>.</p>
<p>Note that subsequent calls to <a class="el" href="class_usd_stage.html#aece3d46e8cff565af399bfda419964e7" title="Modify this stage&#39;s load rules to load the prim at path, its ancestors, and all of its descendants if...">Load()</a>, <a class="el" href="class_usd_stage.html#aedb4cb8d8943a759152b70f08e340a2c" title="Modify this stage&#39;s load rules to unload the prim and its descendants specified by path.">Unload()</a>, <a class="el" href="class_usd_stage.html#a1305b94bed8097515432ee78061ff009" title="Unload and load the given path sets.">LoadAndUnload()</a> will modify this stages load rules as described in the documentation for those member functions.</p>
<p>See <a class="el" href="class_usd_stage.html#Usd_workingSetManagement">Working Set Management</a> for more information. </p>

</div>
</div>
<a id="a1a5325c3bfad050926f03f867a803c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5325c3bfad050926f03f867a803c03">&#9670;&nbsp;</a></span>SetMetadata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SetMetadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of Stage metadatum <code>key</code> to <code>value</code>, if the stage's current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> is the root or session layer. </p>
<p>If the current EditTarget is any other layer, raise a coding error. </p><dl class="section return"><dt>Returns</dt><dd>true if authoring was successful, false otherwise. Generates a coding error if <code>key</code> is not allowed as layer metadata.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd__page__object_model.html#Usd_OM_Metadata">General Metadata in USD</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="stage_8h_source.html#l02411">2411</a> of file <a class="el" href="stage_8h_source.html">stage.h</a>.</p>

</div>
</div>
<a id="abccca1c487755a7f08e6e4b042d39ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abccca1c487755a7f08e6e4b042d39ede">&#9670;&nbsp;</a></span>SetMetadata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool SetMetadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_vt_value.html">VtValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a7f3b367075ca8d6bba9fbf3636183ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3b367075ca8d6bba9fbf3636183ff3">&#9670;&nbsp;</a></span>SetMetadataByDictKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SetMetadataByDictKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>keyPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Author <code>value</code> to the field identified by <code>key</code> and <code>keyPath</code> at the current EditTarget. </p>
<p>The <code>keyPath</code> is a ':'-separated path identifying a value in subdictionaries stored in the metadata field at <code>key</code>. If <code>keyPath</code> is empty, no action is taken.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the value is authored successfully, false otherwise. Generates a coding error if <code>key</code> is not allowed as layer metadata.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd__page__datatypes.html#Usd_Dictionary_Type">Dictionary-valued Metadata</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="stage_8h_source.html#l02443">2443</a> of file <a class="el" href="stage_8h_source.html">stage.h</a>.</p>

</div>
</div>
<a id="a0c04b54500b5b6d5ef0e8aca66282770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c04b54500b5b6d5ef0e8aca66282770">&#9670;&nbsp;</a></span>SetMetadataByDictKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API bool SetMetadataByDictKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>keyPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_vt_value.html">VtValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a2a431cb32a2d50de05ac206c474606cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a431cb32a2d50de05ac206c474606cd">&#9670;&nbsp;</a></span>SetPopulationMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void SetPopulationMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_usd_stage_population_mask.html">UsdStagePopulationMask</a> const &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set this stage's population mask and recompose the stage. </p>

</div>
</div>
<a id="aef35e121cd9662129b6e338e85ceab44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef35e121cd9662129b6e338e85ceab44">&#9670;&nbsp;</a></span>SetStartTimeCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void SetStartTimeCode </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the stage's start timeCode. </p>
<p>The start timeCode is set in the current EditTarget, if it is the root layer of the stage or the session layer associated with the stage. If the current EditTarget is neither, a warning is issued and the start timeCode is not set. </p>

</div>
</div>
<a id="a61c421fcf601c28f2efc5597b8058e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c421fcf601c28f2efc5597b8058e22">&#9670;&nbsp;</a></span>SetTimeCodesPerSecond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void SetTimeCodesPerSecond </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeCodesPerSecond</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the stage's timeCodesPerSecond value. </p>
<p>The timeCodesPerSecond value is set in the current EditTarget, if it is the root layer of the stage or the session layer associated with the stage. If the current EditTarget is neither, a warning is issued and no value is set.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#a85092d7455ae894d50224e761dc6e840" title="Returns the stage&#39;s timeCodesPerSecond value.">GetTimeCodesPerSecond()</a> </dd></dl>

</div>
</div>
<a id="adba675b55f41cc1b305bed414fc4f178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba675b55f41cc1b305bed414fc4f178">&#9670;&nbsp;</a></span>Traverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_prim_range.html">UsdPrimRange</a> Traverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the active, loaded, defined, non-abstract prims on this stage depth-first. </p>
<p><a class="el" href="class_usd_stage.html#adba675b55f41cc1b305bed414fc4f178" title="Traverse the active, loaded, defined, non-abstract prims on this stage depth-first.">Traverse()</a> returns a <a class="el" href="class_usd_prim_range.html" title="An forward-iterable range that traverses a subtree of prims rooted at a given prim in depth-first ord...">UsdPrimRange</a> , which allows low-latency traversal, with the ability to prune subtrees from traversal. It is python iterable, so in its simplest form, one can do:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> prim <span class="keywordflow">in</span> stage.Traverse():</div><div class="line">    <span class="keywordflow">print</span> prim.GetPath()</div></div><!-- fragment --><p>If either a pre-and-post-order traversal or a traversal rooted at a particular prim is desired, construct a <a class="el" href="class_usd_prim_range.html" title="An forward-iterable range that traverses a subtree of prims rooted at a given prim in depth-first ord...">UsdPrimRange</a> directly.</p>
<p>This is equivalent to <a class="el" href="class_usd_prim_range.html#a8a2cda47ee8109d402d2a44b443a0098" title="Create a PrimRange that traverses all the prims on stage, and visits those that pass the default pred...">UsdPrimRange::Stage()</a> . </p>

</div>
</div>
<a id="a69332eeeb1970d4908a72d0c8fd0c3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69332eeeb1970d4908a72d0c8fd0c3cb">&#9670;&nbsp;</a></span>Traverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_prim_range.html">UsdPrimRange</a> Traverse </td>
          <td>(</td>
          <td class="paramtype">const Usd_PrimFlagsPredicate &amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Traverse the prims on this stage subject to <code>predicate</code>. </p>
<p>This is equivalent to <a class="el" href="class_usd_prim_range.html#a8a2cda47ee8109d402d2a44b443a0098" title="Create a PrimRange that traverses all the prims on stage, and visits those that pass the default pred...">UsdPrimRange::Stage()</a> . </p>

</div>
</div>
<a id="a71559921b1e48949207817b2fd8bd01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71559921b1e48949207817b2fd8bd01b">&#9670;&nbsp;</a></span>TraverseAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API <a class="el" href="class_usd_prim_range.html">UsdPrimRange</a> TraverseAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse all the prims on this stage depth-first. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#adba675b55f41cc1b305bed414fc4f178" title="Traverse the active, loaded, defined, non-abstract prims on this stage depth-first.">Traverse()</a> </dd>
<dd>
<a class="el" href="class_usd_prim_range.html#a8a2cda47ee8109d402d2a44b443a0098" title="Create a PrimRange that traverses all the prims on stage, and visits those that pass the default pred...">UsdPrimRange::Stage()</a> </dd></dl>

</div>
</div>
<a id="aedb4cb8d8943a759152b70f08e340a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb4cb8d8943a759152b70f08e340a2c">&#9670;&nbsp;</a></span>Unload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void Unload </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em> = <code><a class="el" href="class_sdf_path.html#a9e77b565c10268c2b55f92559f621606">SdfPath::AbsoluteRootPath</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify this stage's load rules to unload the prim and its descendants specified by <code>path</code>. </p>
<p>See <a class="el" href="class_usd_stage.html#Usd_workingSetManagement">Working Set Management</a> for more information. </p>

</div>
</div>
<a id="a2f8158f35f1f76b227f51f875db4c5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8158f35f1f76b227f51f875db4c5d1">&#9670;&nbsp;</a></span>UnmuteLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void UnmuteLayer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layerIdentifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmute the layer identified by <code>layerIdentifier</code> if it had previously been muted. </p>

</div>
</div>
<a id="a14897ca124a0fb4a62e6ed2ccbbdbf4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14897ca124a0fb4a62e6ed2ccbbdbf4f">&#9670;&nbsp;</a></span>WriteFallbackPrimTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API void WriteFallbackPrimTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the fallback prim types defined in the schema registry to the stage as dictionary valued fallback prim type metadata. </p>
<p>If the stage already has fallback prim type metadata, the fallback types from the schema registry will be added to the existing metadata, only for types that are already present in the dictionary, i.e. this won't overwrite existing fallback entries.</p>
<p>The current edit target determines whether the metadata is written to the root layer or the session layer. If the edit target specifies another layer besides these, this will produce an error.</p>
<p>This function can be used at any point before calling Save or Export on a stage to record the fallback types for the current schemas. This allows another version of Usd to open this stage and treat prim types it doesn't recognize as a type it does recognize defined for it in this metadata.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd__page__object_model.html#Usd_OM_FallbackPrimTypes">Fallback Prim Types</a> <a class="el" href="class_usd_schema_registry.html#a93921d1510b463b9eea85de97ea45271" title="Returns a dictionary mapping concrete schema prim type names to a VtTokenArray of fallback prim type ...">UsdSchemaRegistry::GetFallbackPrimTypes</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pxr/usd/usd/<a class="el" href="stage_8h_source.html">stage.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_usd_stage.html">UsdStage</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:11 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>