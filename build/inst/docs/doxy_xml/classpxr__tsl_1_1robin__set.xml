<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="classpxr__tsl_1_1robin__set" kind="class" language="C++" prot="public">
    <compoundname>pxr_tsl::robin_set</compoundname>
    <includes refid="robin__set_8h" local="no">robin_set.h</includes>
    <innerclass refid="classpxr__tsl_1_1robin__set_1_1_key_select" prot="private">pxr_tsl::robin_set::KeySelect</innerclass>
    <templateparamlist>
      <param>
        <type>class Key</type>
      </param>
      <param>
        <type>class Hash</type>
        <defval>std::hash&lt;Key&gt;</defval>
      </param>
      <param>
        <type>class KeyEqual</type>
        <defval>std::equal_to&lt;Key&gt;</defval>
      </param>
      <param>
        <type>class Allocator</type>
        <defval>std::allocator&lt;Key&gt;</defval>
      </param>
      <param>
        <type>bool</type>
        <declname>StoreHash</declname>
        <defname>StoreHash</defname>
        <defval>false</defval>
      </param>
      <param>
        <type>class GrowthPolicy</type>
        <defval><ref refid="classpxr__tsl_1_1rh_1_1power__of__two__growth__policy" kindref="compound">pxr_tsl::rh::power_of_two_growth_policy</ref>&lt;2&gt;</defval>
      </param>
    </templateparamlist>
      <sectiondef kind="private-type">
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1a657de4a33eb936996e50fc25d87a634c" prot="private" static="no">
        <templateparamlist>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>pxr_tsl::detail_robin_hash::has_is_transparent&lt; U &gt;</type>
        <definition>using has_is_transparent =  pxr_tsl::detail_robin_hash::has_is_transparent&lt;U&gt;</definition>
        <argsstring></argsstring>
        <name>has_is_transparent</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="98" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="98" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1a21bd1d7b2ce092663f6ddc7fea50dc65" prot="private" static="no">
        <type><ref refid="classpxr__tsl_1_1detail__robin__hash_1_1robin__hash" kindref="compound">detail_robin_hash::robin_hash</ref>&lt; Key, KeySelect, void, Hash, KeyEqual, Allocator, StoreHash, GrowthPolicy &gt;</type>
        <definition>using ht =  detail_robin_hash::robin_hash&lt;Key, KeySelect, void, Hash, KeyEqual, Allocator, StoreHash, GrowthPolicy&gt;</definition>
        <argsstring></argsstring>
        <name>ht</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="109" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="110" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1a71ca9361ab9a9ce293c143de1b9d782d" prot="public" static="no">
        <type>typename ht::key_type</type>
        <definition>using key_type =  typename ht::key_type</definition>
        <argsstring></argsstring>
        <name>key_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="113" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="113" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1a1d5e40ba2cc5604846158297136dd06f" prot="public" static="no">
        <type>typename ht::value_type</type>
        <definition>using value_type =  typename ht::value_type</definition>
        <argsstring></argsstring>
        <name>value_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="114" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="114" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1a4e12d06075970f30d6fa98909e1f2275" prot="public" static="no">
        <type>typename ht::size_type</type>
        <definition>using size_type =  typename ht::size_type</definition>
        <argsstring></argsstring>
        <name>size_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="115" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="115" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1a5fd75f23bdd81e8486824de421f0b277" prot="public" static="no">
        <type>typename ht::difference_type</type>
        <definition>using difference_type =  typename ht::difference_type</definition>
        <argsstring></argsstring>
        <name>difference_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="116" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="116" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1a2bde34e4cf112d1229eae845e9eeadfc" prot="public" static="no">
        <type>typename ht::hasher</type>
        <definition>using hasher =  typename ht::hasher</definition>
        <argsstring></argsstring>
        <name>hasher</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="117" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="117" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1a4b5c2bdf28a83e3c786459f5ce7de13b" prot="public" static="no">
        <type>typename ht::key_equal</type>
        <definition>using key_equal =  typename ht::key_equal</definition>
        <argsstring></argsstring>
        <name>key_equal</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="118" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="118" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1abf75b8d8f1c5582ed054a753633fcdcd" prot="public" static="no">
        <type>typename ht::allocator_type</type>
        <definition>using allocator_type =  typename ht::allocator_type</definition>
        <argsstring></argsstring>
        <name>allocator_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="119" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="119" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1ad7f6fba9addb50291cd00da9bbdb270e" prot="public" static="no">
        <type>typename ht::reference</type>
        <definition>using reference =  typename ht::reference</definition>
        <argsstring></argsstring>
        <name>reference</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="120" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="120" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1a88c079b4c90fca49f20794ef595bd45c" prot="public" static="no">
        <type>typename ht::const_reference</type>
        <definition>using const_reference =  typename ht::const_reference</definition>
        <argsstring></argsstring>
        <name>const_reference</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="121" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="121" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1a6df36618f79468bfe70da25ba6cae230" prot="public" static="no">
        <type>typename ht::pointer</type>
        <definition>using pointer =  typename ht::pointer</definition>
        <argsstring></argsstring>
        <name>pointer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="122" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="122" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1abc31d826a168689abe121f7c958eb64f" prot="public" static="no">
        <type>typename ht::const_pointer</type>
        <definition>using const_pointer =  typename ht::const_pointer</definition>
        <argsstring></argsstring>
        <name>const_pointer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="123" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="123" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1a257c17d47f641f36507c5059d94b0fb0" prot="public" static="no">
        <type>typename ht::iterator</type>
        <definition>using iterator =  typename ht::iterator</definition>
        <argsstring></argsstring>
        <name>iterator</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="124" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="124" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classpxr__tsl_1_1robin__set_1a3cca28ef8650f3ee6d12684b8b5172b4" prot="public" static="no">
        <type>typename ht::const_iterator</type>
        <definition>using const_iterator =  typename ht::const_iterator</definition>
        <argsstring></argsstring>
        <name>const_iterator</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="125" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="125" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classpxr__tsl_1_1robin__set_1a9080879390c54de5c88475a6e4d92c42" prot="private" static="no" mutable="no">
        <type><ref refid="classpxr__tsl_1_1detail__robin__hash_1_1robin__hash" kindref="compound">ht</ref></type>
        <definition>ht m_ht</definition>
        <argsstring></argsstring>
        <name>m_ht</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="650" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="650" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ac4dd24be24d7a03f5aa211de3f8987d3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>robin_set</definition>
        <argsstring>()</argsstring>
        <name>robin_set</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="130" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="130" bodyend="130"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a5550ad926e75aec7219917f2dca8564e" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>robin_set</definition>
        <argsstring>(size_type bucket_count, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</argsstring>
        <name>robin_set</name>
        <param>
          <type>size_type</type>
          <declname>bucket_count</declname>
        </param>
        <param>
          <type>const Hash &amp;</type>
          <declname>hash</declname>
          <defval>Hash()</defval>
        </param>
        <param>
          <type>const KeyEqual &amp;</type>
          <declname>equal</declname>
          <defval>KeyEqual()</defval>
        </param>
        <param>
          <type>const Allocator &amp;</type>
          <declname>alloc</declname>
          <defval>Allocator()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="132" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="132" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a13c72da0d998472c78a5c3615dfc1a29" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>robin_set</definition>
        <argsstring>(size_type bucket_count, const Allocator &amp;alloc)</argsstring>
        <name>robin_set</name>
        <param>
          <type>size_type</type>
          <declname>bucket_count</declname>
        </param>
        <param>
          <type>const Allocator &amp;</type>
          <declname>alloc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="137" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="137" bodyend="138"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a910a0e3aeb89f874eb71c53b2d9f506b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>robin_set</definition>
        <argsstring>(size_type bucket_count, const Hash &amp;hash, const Allocator &amp;alloc)</argsstring>
        <name>robin_set</name>
        <param>
          <type>size_type</type>
          <declname>bucket_count</declname>
        </param>
        <param>
          <type>const Hash &amp;</type>
          <declname>hash</declname>
        </param>
        <param>
          <type>const Allocator &amp;</type>
          <declname>alloc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="140" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="140" bodyend="141"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1aaa7f71ccdd192cc744faa6dd46f3d2b1" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>robin_set</definition>
        <argsstring>(const Allocator &amp;alloc)</argsstring>
        <name>robin_set</name>
        <param>
          <type>const Allocator &amp;</type>
          <declname>alloc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="143" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="143" bodyend="144"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a905d0d4db29e81ceaa1ae07e8ddd8e2d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InputIt</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>robin_set</definition>
        <argsstring>(InputIt first, InputIt last, size_type bucket_count=ht::DEFAULT_INIT_BUCKETS_SIZE, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</argsstring>
        <name>robin_set</name>
        <param>
          <type>InputIt</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIt</type>
          <declname>last</declname>
        </param>
        <param>
          <type>size_type</type>
          <declname>bucket_count</declname>
          <defval>ht::DEFAULT_INIT_BUCKETS_SIZE</defval>
        </param>
        <param>
          <type>const Hash &amp;</type>
          <declname>hash</declname>
          <defval>Hash()</defval>
        </param>
        <param>
          <type>const KeyEqual &amp;</type>
          <declname>equal</declname>
          <defval>KeyEqual()</defval>
        </param>
        <param>
          <type>const Allocator &amp;</type>
          <declname>alloc</declname>
          <defval>Allocator()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="147" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="147" bodyend="153"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a3266ed6fe035d4cc33145bdc6eb4b645" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InputIt</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>robin_set</definition>
        <argsstring>(InputIt first, InputIt last, size_type bucket_count, const Allocator &amp;alloc)</argsstring>
        <name>robin_set</name>
        <param>
          <type>InputIt</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIt</type>
          <declname>last</declname>
        </param>
        <param>
          <type>size_type</type>
          <declname>bucket_count</declname>
        </param>
        <param>
          <type>const Allocator &amp;</type>
          <declname>alloc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="156" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="156" bodyend="158"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1af3115a12b275ee5fbba4e787f69c4809" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InputIt</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>robin_set</definition>
        <argsstring>(InputIt first, InputIt last, size_type bucket_count, const Hash &amp;hash, const Allocator &amp;alloc)</argsstring>
        <name>robin_set</name>
        <param>
          <type>InputIt</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIt</type>
          <declname>last</declname>
        </param>
        <param>
          <type>size_type</type>
          <declname>bucket_count</declname>
        </param>
        <param>
          <type>const Hash &amp;</type>
          <declname>hash</declname>
        </param>
        <param>
          <type>const Allocator &amp;</type>
          <declname>alloc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="161" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="161" bodyend="163"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1af586e9608f2d0a0c3aa990858ec5c3cd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>robin_set</definition>
        <argsstring>(std::initializer_list&lt; value_type &gt; init, size_type bucket_count=ht::DEFAULT_INIT_BUCKETS_SIZE, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</argsstring>
        <name>robin_set</name>
        <param>
          <type>std::initializer_list&lt; value_type &gt;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>size_type</type>
          <declname>bucket_count</declname>
          <defval>ht::DEFAULT_INIT_BUCKETS_SIZE</defval>
        </param>
        <param>
          <type>const Hash &amp;</type>
          <declname>hash</declname>
          <defval>Hash()</defval>
        </param>
        <param>
          <type>const KeyEqual &amp;</type>
          <declname>equal</declname>
          <defval>KeyEqual()</defval>
        </param>
        <param>
          <type>const Allocator &amp;</type>
          <declname>alloc</declname>
          <defval>Allocator()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="165" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="165" bodyend="169"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a300176209626828c738336dfda0d47bd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>robin_set</definition>
        <argsstring>(std::initializer_list&lt; value_type &gt; init, size_type bucket_count, const Allocator &amp;alloc)</argsstring>
        <name>robin_set</name>
        <param>
          <type>std::initializer_list&lt; value_type &gt;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>size_type</type>
          <declname>bucket_count</declname>
        </param>
        <param>
          <type>const Allocator &amp;</type>
          <declname>alloc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="171" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="171" bodyend="174"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a8f468e7b7b8752f57902db0eabebf608" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>robin_set</definition>
        <argsstring>(std::initializer_list&lt; value_type &gt; init, size_type bucket_count, const Hash &amp;hash, const Allocator &amp;alloc)</argsstring>
        <name>robin_set</name>
        <param>
          <type>std::initializer_list&lt; value_type &gt;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>size_type</type>
          <declname>bucket_count</declname>
        </param>
        <param>
          <type>const Hash &amp;</type>
          <declname>hash</declname>
        </param>
        <param>
          <type>const Allocator &amp;</type>
          <declname>alloc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="176" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="176" bodyend="179"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a121bfb96f2e49da405c770d331068390" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classpxr__tsl_1_1robin__set" kindref="compound">robin_set</ref> &amp;</type>
        <definition>robin_set&amp; operator=</definition>
        <argsstring>(std::initializer_list&lt; value_type &gt; ilist)</argsstring>
        <name>operator=</name>
        <param>
          <type>std::initializer_list&lt; value_type &gt;</type>
          <declname>ilist</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="181" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="181" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a6e99c6263568d88f95ca01dc694f1051" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>allocator_type</type>
        <definition>allocator_type get_allocator</definition>
        <argsstring>() const</argsstring>
        <name>get_allocator</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="190" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="190" bodyend="190"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a979556eb331ec35eb33472a90a160f99" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>iterator</type>
        <definition>iterator begin</definition>
        <argsstring>() noexcept</argsstring>
        <name>begin</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="195" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="195" bodyend="195"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a1ca1fc2c9fc3e169d5d0decfd1e54221" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const_iterator</type>
        <definition>const_iterator begin</definition>
        <argsstring>() const noexcept</argsstring>
        <name>begin</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="196" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="196" bodyend="196"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1abeb76f7f3414f270020e6f467586bd93" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const_iterator</type>
        <definition>const_iterator cbegin</definition>
        <argsstring>() const noexcept</argsstring>
        <name>cbegin</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="197" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="197" bodyend="197"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1afc5380afa64b233d0df01a147616974b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>iterator</type>
        <definition>iterator end</definition>
        <argsstring>() noexcept</argsstring>
        <name>end</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="199" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="199" bodyend="199"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a5b9b57293fae9b18b26349ac0b3fdcd3" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const_iterator</type>
        <definition>const_iterator end</definition>
        <argsstring>() const noexcept</argsstring>
        <name>end</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="200" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="200" bodyend="200"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a9859a454bb6f50c654e280274d6a9d13" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const_iterator</type>
        <definition>const_iterator cend</definition>
        <argsstring>() const noexcept</argsstring>
        <name>cend</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="201" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="201" bodyend="201"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a3f6fc5de06a318920d84f3c3742db07f" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool empty</definition>
        <argsstring>() const noexcept</argsstring>
        <name>empty</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="206" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="206" bodyend="206"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a0801762a3fe36fe32dca5f16e515478d" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_type</type>
        <definition>size_type size</definition>
        <argsstring>() const noexcept</argsstring>
        <name>size</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="207" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="207" bodyend="207"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ac2a85e463df4e95c1bf051cfb8237805" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_type</type>
        <definition>size_type max_size</definition>
        <argsstring>() const noexcept</argsstring>
        <name>max_size</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="208" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="208" bodyend="208"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a03bfacfaaba9195e4498375659f43531" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void clear</definition>
        <argsstring>() noexcept</argsstring>
        <name>clear</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="213" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="213" bodyend="213"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a89db0a18088925c423aaa5ec00d02705" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::pair&lt; iterator, bool &gt;</type>
        <definition>std::pair&lt;iterator, bool&gt; insert</definition>
        <argsstring>(const value_type &amp;value)</argsstring>
        <name>insert</name>
        <param>
          <type>const value_type &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="215" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="215" bodyend="217"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ab034948893161a8e02cd8f8b7c91fb07" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::pair&lt; iterator, bool &gt;</type>
        <definition>std::pair&lt;iterator, bool&gt; insert</definition>
        <argsstring>(value_type &amp;&amp;value)</argsstring>
        <name>insert</name>
        <param>
          <type>value_type &amp;&amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="219" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="219" bodyend="221"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ae4c3c7c7ef9f0e53751e927447e07b26" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>iterator</type>
        <definition>iterator insert</definition>
        <argsstring>(const_iterator hint, const value_type &amp;value)</argsstring>
        <name>insert</name>
        <param>
          <type>const_iterator</type>
          <declname>hint</declname>
        </param>
        <param>
          <type>const value_type &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="223" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="223" bodyend="225"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ab0f735db4267778060c126f8925a4569" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>iterator</type>
        <definition>iterator insert</definition>
        <argsstring>(const_iterator hint, value_type &amp;&amp;value)</argsstring>
        <name>insert</name>
        <param>
          <type>const_iterator</type>
          <declname>hint</declname>
        </param>
        <param>
          <type>value_type &amp;&amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="227" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="227" bodyend="229"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a327bfe8ae1f7565885bce845f31eaca1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InputIt</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void insert</definition>
        <argsstring>(InputIt first, InputIt last)</argsstring>
        <name>insert</name>
        <param>
          <type>InputIt</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIt</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="232" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="232" bodyend="234"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1acf6887e321581fe6a77912a5535af4cb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void insert</definition>
        <argsstring>(std::initializer_list&lt; value_type &gt; ilist)</argsstring>
        <name>insert</name>
        <param>
          <type>std::initializer_list&lt; value_type &gt;</type>
          <declname>ilist</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="236" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="236" bodyend="238"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a3266031b8b423571de004ddf5bcddd24" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>std::pair&lt; iterator, bool &gt;</type>
        <definition>std::pair&lt;iterator, bool&gt; emplace</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>emplace</name>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Due to the way elements are stored, emplace will need to move or copy the key-value once. </para>
        </briefdescription>
        <detaileddescription>
<para>The method is equivalent to insert(value_type(std::forward&lt;Args&gt;(args)...));</para>
<para>Mainly here for compatibility with the std::unordered_map interface. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="248" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="248" bodyend="250"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1aaa893704f6fe9989f1ada11c2c503886" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>iterator</type>
        <definition>iterator emplace_hint</definition>
        <argsstring>(const_iterator hint, Args &amp;&amp;... args)</argsstring>
        <name>emplace_hint</name>
        <param>
          <type>const_iterator</type>
          <declname>hint</declname>
        </param>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Due to the way elements are stored, emplace_hint will need to move or copy the key-value once. </para>
        </briefdescription>
        <detaileddescription>
<para>The method is equivalent to insert(hint, value_type(std::forward&lt;Args&gt;(args)...));</para>
<para>Mainly here for compatibility with the std::unordered_map interface. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="260" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="260" bodyend="262"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1af7659d9799f06df763bf397101941dd7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>iterator</type>
        <definition>iterator erase</definition>
        <argsstring>(iterator pos)</argsstring>
        <name>erase</name>
        <param>
          <type>iterator</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="264" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="264" bodyend="264"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a29790c28710ec0e64b48c2f4edd0b08c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>iterator</type>
        <definition>iterator erase</definition>
        <argsstring>(const_iterator pos)</argsstring>
        <name>erase</name>
        <param>
          <type>const_iterator</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="265" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="265" bodyend="265"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1aa3af768723cd533218ea3d83af440713" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>iterator</type>
        <definition>iterator erase</definition>
        <argsstring>(const_iterator first, const_iterator last)</argsstring>
        <name>erase</name>
        <param>
          <type>const_iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>const_iterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="266" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="266" bodyend="268"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ae57ff6dd1cb4dc347b892dfa87ea6613" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_type</type>
        <definition>size_type erase</definition>
        <argsstring>(const key_type &amp;key)</argsstring>
        <name>erase</name>
        <param>
          <type>const key_type &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="269" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="269" bodyend="269"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1aa0f50653fc58cc15e1ecdddf42078e74" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_type</type>
        <definition>size_type erase</definition>
        <argsstring>(const key_type &amp;key, std::size_t precalculated_hash)</argsstring>
        <name>erase</name>
        <param>
          <type>const key_type &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>precalculated_hash</declname>
        </param>
        <briefdescription>
<para>Use the hash value &apos;precalculated_hash&apos; instead of hashing the key. </para>
        </briefdescription>
        <detaileddescription>
<para>The hash value should be the same as hash_function()(key). Useful to speed-up the lookup to the value if you already have the hash. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="276" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="276" bodyend="278"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1adcb30fce010ea21568f9b6056af45b81" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class KE</type>
            <defval>KeyEqual</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>size_type</type>
        <definition>size_type erase</definition>
        <argsstring>(const K &amp;key)</argsstring>
        <name>erase</name>
        <param>
          <type>const K &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If so, K must be hashable and comparable to Key. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="288" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="288" bodyend="290"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ae666d3fa05f9584e01e4e733ea7def05" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class KE</type>
            <defval>KeyEqual</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>size_type</type>
        <definition>size_type erase</definition>
        <argsstring>(const K &amp;key, std::size_t precalculated_hash)</argsstring>
        <name>erase</name>
        <param>
          <type>const K &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>precalculated_hash</declname>
        </param>
        <briefdescription>
<para>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If so, K must be hashable and comparable to Key.</para>
<para>Use the hash value &apos;precalculated_hash&apos; instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup to the value if you already have the hash. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="302" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="302" bodyend="304"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a7e201278794346bc8083e85c8e0907d0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void swap</definition>
        <argsstring>(robin_set &amp;other)</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classpxr__tsl_1_1robin__set" kindref="compound">robin_set</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="306" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="306" bodyend="306"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a06d7b5c3d9ab3cb983dd15a180eefe18" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_type</type>
        <definition>size_type count</definition>
        <argsstring>(const Key &amp;key) const</argsstring>
        <name>count</name>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="311" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="311" bodyend="311"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a4eefd88b96cf835514fd765dfff0498b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_type</type>
        <definition>size_type count</definition>
        <argsstring>(const Key &amp;key, std::size_t precalculated_hash) const</argsstring>
        <name>count</name>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>precalculated_hash</declname>
        </param>
        <briefdescription>
<para>Use the hash value &apos;precalculated_hash&apos; instead of hashing the key. </para>
        </briefdescription>
        <detaileddescription>
<para>The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="318" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="318" bodyend="320"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ab9302b6142f9037bb489e6717e0af56b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class KE</type>
            <defval>KeyEqual</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>size_type</type>
        <definition>size_type count</definition>
        <argsstring>(const K &amp;key) const</argsstring>
        <name>count</name>
        <param>
          <type>const K &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If so, K must be hashable and comparable to Key. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="330" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="330" bodyend="332"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1af9a9f3a334c8e885cb68883e252d87d9" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class KE</type>
            <defval>KeyEqual</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>size_type</type>
        <definition>size_type count</definition>
        <argsstring>(const K &amp;key, std::size_t precalculated_hash) const</argsstring>
        <name>count</name>
        <param>
          <type>const K &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>precalculated_hash</declname>
        </param>
        <briefdescription>
<para>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If so, K must be hashable and comparable to Key.</para>
<para>Use the hash value &apos;precalculated_hash&apos; instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="344" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="344" bodyend="346"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a141abb735cd4a5a9c55326b30bf419ca" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>iterator</type>
        <definition>iterator find</definition>
        <argsstring>(const Key &amp;key)</argsstring>
        <name>find</name>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="348" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="348" bodyend="348"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1aa3d4e52e5fcbace902503a645524760a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>iterator</type>
        <definition>iterator find</definition>
        <argsstring>(const Key &amp;key, std::size_t precalculated_hash)</argsstring>
        <name>find</name>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>precalculated_hash</declname>
        </param>
        <briefdescription>
<para>Use the hash value &apos;precalculated_hash&apos; instead of hashing the key. </para>
        </briefdescription>
        <detaileddescription>
<para>The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="355" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="355" bodyend="357"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a68e7605bb212d1d4665e05cebcbde886" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const_iterator</type>
        <definition>const_iterator find</definition>
        <argsstring>(const Key &amp;key) const</argsstring>
        <name>find</name>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="359" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="359" bodyend="359"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a1e129b22f90474ce92d6b2b837554cc1" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const_iterator</type>
        <definition>const_iterator find</definition>
        <argsstring>(const Key &amp;key, std::size_t precalculated_hash) const</argsstring>
        <name>find</name>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>precalculated_hash</declname>
        </param>
        <briefdescription>
<para>Use the hash value &apos;precalculated_hash&apos; instead of hashing the key. </para>
        </briefdescription>
        <detaileddescription>
<para>The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="364" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="364" bodyend="366"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ae482efbeca6bc4c4661659f855e05e30" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class KE</type>
            <defval>KeyEqual</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>iterator</type>
        <definition>iterator find</definition>
        <argsstring>(const K &amp;key)</argsstring>
        <name>find</name>
        <param>
          <type>const K &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If so, K must be hashable and comparable to Key. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="376" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="376" bodyend="378"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1aab7e6161d9e44421a88e1127ac703b7e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class KE</type>
            <defval>KeyEqual</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>iterator</type>
        <definition>iterator find</definition>
        <argsstring>(const K &amp;key, std::size_t precalculated_hash)</argsstring>
        <name>find</name>
        <param>
          <type>const K &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>precalculated_hash</declname>
        </param>
        <briefdescription>
<para>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If so, K must be hashable and comparable to Key.</para>
<para>Use the hash value &apos;precalculated_hash&apos; instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="390" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="390" bodyend="392"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a900919d13db42a973b642182c837af6f" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class KE</type>
            <defval>KeyEqual</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>const_iterator</type>
        <definition>const_iterator find</definition>
        <argsstring>(const K &amp;key) const</argsstring>
        <name>find</name>
        <param>
          <type>const K &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If so, K must be hashable and comparable to Key. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="400" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="400" bodyend="402"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a1c65830a6989831a96514c7dc75613cb" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class KE</type>
            <defval>KeyEqual</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>const_iterator</type>
        <definition>const_iterator find</definition>
        <argsstring>(const K &amp;key, std::size_t precalculated_hash) const</argsstring>
        <name>find</name>
        <param>
          <type>const K &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>precalculated_hash</declname>
        </param>
        <briefdescription>
<para>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If so, K must be hashable and comparable to Key.</para>
<para>Use the hash value &apos;precalculated_hash&apos; instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="414" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="414" bodyend="416"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a4ba0005e319eda1ba871a1a01be7764e" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool contains</definition>
        <argsstring>(const Key &amp;key) const</argsstring>
        <name>contains</name>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="418" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="418" bodyend="418"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a0f5822954e3c2e3debe2db48740892a7" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool contains</definition>
        <argsstring>(const Key &amp;key, std::size_t precalculated_hash) const</argsstring>
        <name>contains</name>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>precalculated_hash</declname>
        </param>
        <briefdescription>
<para>Use the hash value &apos;precalculated_hash&apos; instead of hashing the key. </para>
        </briefdescription>
        <detaileddescription>
<para>The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="425" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="425" bodyend="427"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ab1eb6dff57572f9e6e2360c7ca6bd456" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class KE</type>
            <defval>KeyEqual</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool contains</definition>
        <argsstring>(const K &amp;key) const</argsstring>
        <name>contains</name>
        <param>
          <type>const K &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If so, K must be hashable and comparable to Key. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="437" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="437" bodyend="439"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a43904eb84db5090ff895ee1d90b3b154" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class KE</type>
            <defval>KeyEqual</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool contains</definition>
        <argsstring>(const K &amp;key, std::size_t precalculated_hash) const</argsstring>
        <name>contains</name>
        <param>
          <type>const K &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>precalculated_hash</declname>
        </param>
        <briefdescription>
<para>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If so, K must be hashable and comparable to Key.</para>
<para>Use the hash value &apos;precalculated_hash&apos; instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="451" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="451" bodyend="453"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a744c88d4ddecd64d94ac37114ebd0c71" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::pair&lt; iterator, iterator &gt;</type>
        <definition>std::pair&lt;iterator, iterator&gt; equal_range</definition>
        <argsstring>(const Key &amp;key)</argsstring>
        <name>equal_range</name>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="455" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="455" bodyend="457"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ac580a1eb1053b5412102ad2d5d6489ca" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::pair&lt; iterator, iterator &gt;</type>
        <definition>std::pair&lt;iterator, iterator&gt; equal_range</definition>
        <argsstring>(const Key &amp;key, std::size_t precalculated_hash)</argsstring>
        <name>equal_range</name>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>precalculated_hash</declname>
        </param>
        <briefdescription>
<para>Use the hash value &apos;precalculated_hash&apos; instead of hashing the key. </para>
        </briefdescription>
        <detaileddescription>
<para>The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="464" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="464" bodyend="467"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ae66207d9bab00c632610ddb88331cb05" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>std::pair&lt; const_iterator, const_iterator &gt;</type>
        <definition>std::pair&lt;const_iterator, const_iterator&gt; equal_range</definition>
        <argsstring>(const Key &amp;key) const</argsstring>
        <name>equal_range</name>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="469" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="469" bodyend="471"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a7211f6328ab446351332e327503ceb5b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>std::pair&lt; const_iterator, const_iterator &gt;</type>
        <definition>std::pair&lt;const_iterator, const_iterator&gt; equal_range</definition>
        <argsstring>(const Key &amp;key, std::size_t precalculated_hash) const</argsstring>
        <name>equal_range</name>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>precalculated_hash</declname>
        </param>
        <briefdescription>
<para>Use the hash value &apos;precalculated_hash&apos; instead of hashing the key. </para>
        </briefdescription>
        <detaileddescription>
<para>The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="476" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="476" bodyend="479"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a063fa547f1200f2f9c464099c28a3366" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class KE</type>
            <defval>KeyEqual</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>std::pair&lt; iterator, iterator &gt;</type>
        <definition>std::pair&lt;iterator, iterator&gt; equal_range</definition>
        <argsstring>(const K &amp;key)</argsstring>
        <name>equal_range</name>
        <param>
          <type>const K &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If so, K must be hashable and comparable to Key. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="489" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="489" bodyend="491"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a31955f79a9c3cf5b27bd738f633bcb28" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class KE</type>
            <defval>KeyEqual</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>std::pair&lt; iterator, iterator &gt;</type>
        <definition>std::pair&lt;iterator, iterator&gt; equal_range</definition>
        <argsstring>(const K &amp;key, std::size_t precalculated_hash)</argsstring>
        <name>equal_range</name>
        <param>
          <type>const K &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>precalculated_hash</declname>
        </param>
        <briefdescription>
<para>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If so, K must be hashable and comparable to Key.</para>
<para>Use the hash value &apos;precalculated_hash&apos; instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="503" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="503" bodyend="506"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1aab526ba688ea72265ac0f2b21801474b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class KE</type>
            <defval>KeyEqual</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>std::pair&lt; const_iterator, const_iterator &gt;</type>
        <definition>std::pair&lt;const_iterator, const_iterator&gt; equal_range</definition>
        <argsstring>(const K &amp;key) const</argsstring>
        <name>equal_range</name>
        <param>
          <type>const K &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If so, K must be hashable and comparable to Key. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="514" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="514" bodyend="516"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a5e2535eea8e61800b2682356b3530f53" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class KE</type>
            <defval>KeyEqual</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>std::pair&lt; const_iterator, const_iterator &gt;</type>
        <definition>std::pair&lt;const_iterator, const_iterator&gt; equal_range</definition>
        <argsstring>(const K &amp;key, std::size_t precalculated_hash) const</argsstring>
        <name>equal_range</name>
        <param>
          <type>const K &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>precalculated_hash</declname>
        </param>
        <briefdescription>
<para>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If so, K must be hashable and comparable to Key.</para>
<para>Use the hash value &apos;precalculated_hash&apos; instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="524" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="524" bodyend="527"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a2ca98f2678c442ff9bf916525525448b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_type</type>
        <definition>size_type bucket_count</definition>
        <argsstring>() const</argsstring>
        <name>bucket_count</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="532" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="532" bodyend="532"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a4ae69adb72b0f4809ce9b67a1861b9d3" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_type</type>
        <definition>size_type max_bucket_count</definition>
        <argsstring>() const</argsstring>
        <name>max_bucket_count</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="533" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="533" bodyend="533"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a627db9dbe713266cb53c24cc5332d817" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>float load_factor</definition>
        <argsstring>() const</argsstring>
        <name>load_factor</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="538" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="538" bodyend="538"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ab53469fa213c4a9351d83175288bed23" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>float min_load_factor</definition>
        <argsstring>() const</argsstring>
        <name>min_load_factor</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="540" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="540" bodyend="540"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a85fbd2f301194e1fc85bcf09ab3308c4" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>float max_load_factor</definition>
        <argsstring>() const</argsstring>
        <name>max_load_factor</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="541" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="541" bodyend="541"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a4899ac5f6e805d6796166b308a190988" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void min_load_factor</definition>
        <argsstring>(float ml)</argsstring>
        <name>min_load_factor</name>
        <param>
          <type>float</type>
          <declname>ml</declname>
        </param>
        <briefdescription>
<para>Set the <computeroutput>min_load_factor</computeroutput> to <computeroutput>ml</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>When the <computeroutput>load_factor</computeroutput> of the set goes below <computeroutput>min_load_factor</computeroutput> after some erase operations, the set will be shrunk when an insertion occurs. The erase method itself never shrinks the set.</para>
<para>The default value of <computeroutput>min_load_factor</computeroutput> is 0.0f, the set never shrinks by default. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="552" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="552" bodyend="552"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ae72e230f99198c334e8c599b8fa4cc12" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void max_load_factor</definition>
        <argsstring>(float ml)</argsstring>
        <name>max_load_factor</name>
        <param>
          <type>float</type>
          <declname>ml</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="553" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="553" bodyend="553"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a58bad5e8253ee3308d2a7a47816083bd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void rehash</definition>
        <argsstring>(size_type count_)</argsstring>
        <name>rehash</name>
        <param>
          <type>size_type</type>
          <declname>count_</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="555" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="555" bodyend="555"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a490a9e62f58529e43aa7ffafa5830f1b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void reserve</definition>
        <argsstring>(size_type count_)</argsstring>
        <name>reserve</name>
        <param>
          <type>size_type</type>
          <declname>count_</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="556" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="556" bodyend="556"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a72ffe2880da1c06d22d90000f9720967" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>hasher</type>
        <definition>hasher hash_function</definition>
        <argsstring>() const</argsstring>
        <name>hash_function</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="561" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="561" bodyend="561"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1a10b2be386447b0ab61e83d0f5527b688" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>key_equal</type>
        <definition>key_equal key_eq</definition>
        <argsstring>() const</argsstring>
        <name>key_eq</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="562" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="562" bodyend="562"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1aa9a08d0e44e9e00fe05e2dfe467a98b5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>iterator</type>
        <definition>iterator mutable_iterator</definition>
        <argsstring>(const_iterator pos)</argsstring>
        <name>mutable_iterator</name>
        <param>
          <type>const_iterator</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
<para>Convert a const_iterator to an iterator. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="571" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="571" bodyend="573"/>
      </memberdef>
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1afaa50020d576b4292bdd62f16869fb97" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Serializer</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void serialize</definition>
        <argsstring>(Serializer &amp;serializer) const</argsstring>
        <name>serialize</name>
        <param>
          <type>Serializer &amp;</type>
          <declname>serializer</declname>
        </param>
        <briefdescription>
<para>Serialize the set through the <computeroutput>serializer</computeroutput> parameter. </para>
        </briefdescription>
        <detaileddescription>
<para>The <computeroutput>serializer</computeroutput> parameter must be a function object that supports the following call:<itemizedlist>
<listitem><para><computeroutput>template&lt;typename U&gt; void operator()(const U&amp; value);</computeroutput> where the types <computeroutput>std::int16_t</computeroutput>, <computeroutput>std::uint32_t</computeroutput>, <computeroutput>std::uint64_t</computeroutput>, <computeroutput>float</computeroutput> and <computeroutput>Key</computeroutput> must be supported for U.</para>
</listitem></itemizedlist>
</para>
<para>The implementation leaves binary compatibility (endianness, IEEE 754 for floats, ...) of the types it serializes in the hands of the <computeroutput>Serializer</computeroutput> function object if compatibility is required. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="604" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="604" bodyend="606"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="classpxr__tsl_1_1robin__set_1a55606bf1468f27f0d3b49785b48259f9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>friend bool</type>
        <definition>bool operator==</definition>
        <argsstring>(const robin_set &amp;lhs, const robin_set &amp;rhs)</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classpxr__tsl_1_1robin__set" kindref="compound">robin_set</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>const <ref refid="classpxr__tsl_1_1robin__set" kindref="compound">robin_set</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="575" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="575" bodyend="588"/>
      </memberdef>
      <memberdef kind="friend" id="classpxr__tsl_1_1robin__set_1a76f08c253db4505b664796a57a404ec5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>friend bool</type>
        <definition>bool operator!=</definition>
        <argsstring>(const robin_set &amp;lhs, const robin_set &amp;rhs)</argsstring>
        <name>operator!=</name>
        <param>
          <type>const <ref refid="classpxr__tsl_1_1robin__set" kindref="compound">robin_set</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>const <ref refid="classpxr__tsl_1_1robin__set" kindref="compound">robin_set</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="643" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="643" bodyend="645"/>
      </memberdef>
      <memberdef kind="friend" id="classpxr__tsl_1_1robin__set_1aac30ae29e5971fd44ddc98bbdd334c84" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>friend void</type>
        <definition>void swap</definition>
        <argsstring>(robin_set &amp;lhs, robin_set &amp;rhs)</argsstring>
        <name>swap</name>
        <param>
          <type><ref refid="classpxr__tsl_1_1robin__set" kindref="compound">robin_set</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="classpxr__tsl_1_1robin__set" kindref="compound">robin_set</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="647" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="647" bodyend="647"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classpxr__tsl_1_1robin__set_1ac60836d1c4297b34019f9ab162bb3b3b" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Deserializer</type>
          </param>
        </templateparamlist>
        <type><ref refid="classpxr__tsl_1_1robin__set" kindref="compound">robin_set</ref></type>
        <definition>static robin_set deserialize</definition>
        <argsstring>(Deserializer &amp;deserializer, bool hash_compatible=false)</argsstring>
        <name>deserialize</name>
        <param>
          <type>Deserializer &amp;</type>
          <declname>deserializer</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>hash_compatible</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Deserialize a previously serialized set through the <computeroutput>deserializer</computeroutput> parameter. </para>
        </briefdescription>
        <detaileddescription>
<para>The <computeroutput>deserializer</computeroutput> parameter must be a function object that supports the following call:<itemizedlist>
<listitem><para><computeroutput>template&lt;typename U&gt; U operator()();</computeroutput> where the types <computeroutput>std::int16_t</computeroutput>, <computeroutput>std::uint32_t</computeroutput>, <computeroutput>std::uint64_t</computeroutput>, <computeroutput>float</computeroutput> and <computeroutput>Key</computeroutput> must be supported for U.</para>
</listitem></itemizedlist>
</para>
<para>If the deserialized hash set type is hash compatible with the serialized set, the deserialization process can be sped up by setting <computeroutput>hash_compatible</computeroutput> to true. To be hash compatible, the Hash, KeyEqual and GrowthPolicy must behave the same way than the ones used on the serialized set and the StoreHash must have the same value. The <computeroutput>std::size_t</computeroutput> must also be of the same size as the one on the platform used to serialize the set. If these criteria are not met, the behaviour is undefined with <computeroutput>hash_compatible</computeroutput> sets to true.</para>
<para>The behaviour is undefined if the type <computeroutput>Key</computeroutput> of the <computeroutput><ref refid="classpxr__tsl_1_1robin__set" kindref="compound">robin_set</ref></computeroutput> is not the same as the type used during serialization.</para>
<para>The implementation leaves binary compatibility (endianness, IEEE 754 for floats, size of int, ...) of the types it deserializes in the hands of the <computeroutput>Deserializer</computeroutput> function object if compatibility is required. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="635" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="635" bodyend="641"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Implementation of a hash set using open-addressing and the robin hood hashing algorithm with backward shift deletion. </para>
    </briefdescription>
    <detaileddescription>
<para>For operations modifying the hash set (insert, erase, rehash, ...), the strong exception guarantee is only guaranteed when the expression <computeroutput>std::is_nothrow_swappable&lt;Key&gt;::value &amp;&amp; std::is_nothrow_move_constructible&lt;Key&gt;::value</computeroutput> is true, otherwise if an exception is thrown during the swap or the move, the hash set may end up in a undefined state. Per the standard a <computeroutput>Key</computeroutput> with a noexcept copy constructor and no move constructor also satisfies the <computeroutput>std::is_nothrow_move_constructible&lt;Key&gt;::value</computeroutput> criterion (and will thus guarantee the strong exception for the set).</para>
<para>When <computeroutput>StoreHash</computeroutput> is true, 32 bits of the hash are stored alongside the values. It can improve the performance during lookups if the <computeroutput>KeyEqual</computeroutput> function takes time (or engenders a cache-miss for example) as we then compare the stored hashes before comparing the keys. When <computeroutput><ref refid="classpxr__tsl_1_1rh_1_1power__of__two__growth__policy" kindref="compound">pxr_tsl::rh::power_of_two_growth_policy</ref></computeroutput> is used as <computeroutput>GrowthPolicy</computeroutput>, it may also speed-up the rehash process as we can avoid to recalculate the hash. When it is detected that storing the hash will not incur any memory penalty due to alignment (i.e. <computeroutput>sizeof(<ref refid="classpxr__tsl_1_1detail__robin__hash_1_1bucket__entry" kindref="compound">pxr_tsl::detail_robin_hash::bucket_entry</ref>&lt;ValueType, true&gt;) == sizeof(<ref refid="classpxr__tsl_1_1detail__robin__hash_1_1bucket__entry" kindref="compound">pxr_tsl::detail_robin_hash::bucket_entry</ref>&lt;ValueType, false&gt;)</computeroutput>) and <computeroutput><ref refid="classpxr__tsl_1_1rh_1_1power__of__two__growth__policy" kindref="compound">pxr_tsl::rh::power_of_two_growth_policy</ref></computeroutput> is used, the hash will be stored even if <computeroutput>StoreHash</computeroutput> is false so that we can speed-up the rehash (but it will not be used on lookups unless <computeroutput>StoreHash</computeroutput> is true).</para>
<para><computeroutput>GrowthPolicy</computeroutput> defines how the set grows and consequently how a hash value is mapped to a bucket. By default the set uses <computeroutput><ref refid="classpxr__tsl_1_1rh_1_1power__of__two__growth__policy" kindref="compound">pxr_tsl::rh::power_of_two_growth_policy</ref></computeroutput>. This policy keeps the number of buckets to a power of two and uses a mask to set the hash to a bucket instead of the slow modulo. Other growth policies are available and you may define your own growth policy, check <computeroutput><ref refid="classpxr__tsl_1_1rh_1_1power__of__two__growth__policy" kindref="compound">pxr_tsl::rh::power_of_two_growth_policy</ref></computeroutput> for the interface.</para>
<para><computeroutput>Key</computeroutput> must be swappable.</para>
<para><computeroutput>Key</computeroutput> must be copy and/or move constructible.</para>
<para>If the destructor of <computeroutput>Key</computeroutput> throws an exception, the behaviour of the class is undefined.</para>
<para>Iterators invalidation:<itemizedlist>
<listitem><para>clear, operator=, reserve, rehash: always invalidate the iterators.</para>
</listitem><listitem><para>insert, emplace, emplace_hint, operator[]: if there is an effective insert, invalidate the iterators.</para>
</listitem><listitem><para>erase: always invalidate the iterators. </para>
</listitem></itemizedlist>
</para>
    </detaileddescription>
    <location file="pxr/base/tf/pxrTslRobinMap/robin_set.h" line="95" column="1" bodyfile="pxr/base/tf/pxrTslRobinMap/robin_set.h" bodystart="95" bodyend="651"/>
    <listofallmembers>
      <member refid="classpxr__tsl_1_1robin__set_1abf75b8d8f1c5582ed054a753633fcdcd" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>allocator_type</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a979556eb331ec35eb33472a90a160f99" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>begin</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a1ca1fc2c9fc3e169d5d0decfd1e54221" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>begin</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a2ca98f2678c442ff9bf916525525448b" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>bucket_count</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1abeb76f7f3414f270020e6f467586bd93" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>cbegin</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a9859a454bb6f50c654e280274d6a9d13" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>cend</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a03bfacfaaba9195e4498375659f43531" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>clear</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a3cca28ef8650f3ee6d12684b8b5172b4" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>const_iterator</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1abc31d826a168689abe121f7c958eb64f" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>const_pointer</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a88c079b4c90fca49f20794ef595bd45c" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>const_reference</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a4ba0005e319eda1ba871a1a01be7764e" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>contains</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a0f5822954e3c2e3debe2db48740892a7" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>contains</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ab1eb6dff57572f9e6e2360c7ca6bd456" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>contains</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a43904eb84db5090ff895ee1d90b3b154" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>contains</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a06d7b5c3d9ab3cb983dd15a180eefe18" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>count</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a4eefd88b96cf835514fd765dfff0498b" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>count</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ab9302b6142f9037bb489e6717e0af56b" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>count</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1af9a9f3a334c8e885cb68883e252d87d9" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>count</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ac60836d1c4297b34019f9ab162bb3b3b" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>deserialize</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a5fd75f23bdd81e8486824de421f0b277" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>difference_type</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a3266031b8b423571de004ddf5bcddd24" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>emplace</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1aaa893704f6fe9989f1ada11c2c503886" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>emplace_hint</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a3f6fc5de06a318920d84f3c3742db07f" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>empty</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1afc5380afa64b233d0df01a147616974b" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>end</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a5b9b57293fae9b18b26349ac0b3fdcd3" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>end</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a744c88d4ddecd64d94ac37114ebd0c71" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>equal_range</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ac580a1eb1053b5412102ad2d5d6489ca" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>equal_range</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ae66207d9bab00c632610ddb88331cb05" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>equal_range</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a7211f6328ab446351332e327503ceb5b" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>equal_range</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a063fa547f1200f2f9c464099c28a3366" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>equal_range</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a31955f79a9c3cf5b27bd738f633bcb28" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>equal_range</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1aab526ba688ea72265ac0f2b21801474b" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>equal_range</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a5e2535eea8e61800b2682356b3530f53" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>equal_range</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1af7659d9799f06df763bf397101941dd7" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>erase</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a29790c28710ec0e64b48c2f4edd0b08c" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>erase</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1aa3af768723cd533218ea3d83af440713" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>erase</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ae57ff6dd1cb4dc347b892dfa87ea6613" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>erase</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1aa0f50653fc58cc15e1ecdddf42078e74" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>erase</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1adcb30fce010ea21568f9b6056af45b81" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>erase</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ae666d3fa05f9584e01e4e733ea7def05" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>erase</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a141abb735cd4a5a9c55326b30bf419ca" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>find</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1aa3d4e52e5fcbace902503a645524760a" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>find</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a68e7605bb212d1d4665e05cebcbde886" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>find</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a1e129b22f90474ce92d6b2b837554cc1" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>find</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ae482efbeca6bc4c4661659f855e05e30" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>find</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1aab7e6161d9e44421a88e1127ac703b7e" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>find</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a900919d13db42a973b642182c837af6f" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>find</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a1c65830a6989831a96514c7dc75613cb" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>find</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a6e99c6263568d88f95ca01dc694f1051" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>get_allocator</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a657de4a33eb936996e50fc25d87a634c" prot="private" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>has_is_transparent</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a72ffe2880da1c06d22d90000f9720967" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>hash_function</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a2bde34e4cf112d1229eae845e9eeadfc" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>hasher</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a21bd1d7b2ce092663f6ddc7fea50dc65" prot="private" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>ht</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a89db0a18088925c423aaa5ec00d02705" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>insert</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ab034948893161a8e02cd8f8b7c91fb07" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>insert</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ae4c3c7c7ef9f0e53751e927447e07b26" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>insert</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ab0f735db4267778060c126f8925a4569" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>insert</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a327bfe8ae1f7565885bce845f31eaca1" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>insert</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1acf6887e321581fe6a77912a5535af4cb" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>insert</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a257c17d47f641f36507c5059d94b0fb0" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>iterator</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a10b2be386447b0ab61e83d0f5527b688" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>key_eq</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a4b5c2bdf28a83e3c786459f5ce7de13b" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>key_equal</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a71ca9361ab9a9ce293c143de1b9d782d" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>key_type</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a627db9dbe713266cb53c24cc5332d817" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>load_factor</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a9080879390c54de5c88475a6e4d92c42" prot="private" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>m_ht</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a4ae69adb72b0f4809ce9b67a1861b9d3" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>max_bucket_count</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a85fbd2f301194e1fc85bcf09ab3308c4" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>max_load_factor</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ae72e230f99198c334e8c599b8fa4cc12" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>max_load_factor</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ac2a85e463df4e95c1bf051cfb8237805" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>max_size</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ab53469fa213c4a9351d83175288bed23" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>min_load_factor</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a4899ac5f6e805d6796166b308a190988" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>min_load_factor</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1aa9a08d0e44e9e00fe05e2dfe467a98b5" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>mutable_iterator</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a76f08c253db4505b664796a57a404ec5" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>operator!=</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a121bfb96f2e49da405c770d331068390" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>operator=</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a55606bf1468f27f0d3b49785b48259f9" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>operator==</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a6df36618f79468bfe70da25ba6cae230" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>pointer</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ad7f6fba9addb50291cd00da9bbdb270e" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>reference</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a58bad5e8253ee3308d2a7a47816083bd" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>rehash</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a490a9e62f58529e43aa7ffafa5830f1b" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>reserve</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1ac4dd24be24d7a03f5aa211de3f8987d3" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>robin_set</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a5550ad926e75aec7219917f2dca8564e" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>robin_set</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a13c72da0d998472c78a5c3615dfc1a29" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>robin_set</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a910a0e3aeb89f874eb71c53b2d9f506b" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>robin_set</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1aaa7f71ccdd192cc744faa6dd46f3d2b1" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>robin_set</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a905d0d4db29e81ceaa1ae07e8ddd8e2d" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>robin_set</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a3266ed6fe035d4cc33145bdc6eb4b645" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>robin_set</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1af3115a12b275ee5fbba4e787f69c4809" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>robin_set</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1af586e9608f2d0a0c3aa990858ec5c3cd" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>robin_set</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a300176209626828c738336dfda0d47bd" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>robin_set</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a8f468e7b7b8752f57902db0eabebf608" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>robin_set</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1afaa50020d576b4292bdd62f16869fb97" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>serialize</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a0801762a3fe36fe32dca5f16e515478d" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>size</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a4e12d06075970f30d6fa98909e1f2275" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>size_type</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a7e201278794346bc8083e85c8e0907d0" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>swap</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1aac30ae29e5971fd44ddc98bbdd334c84" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>swap</name></member>
      <member refid="classpxr__tsl_1_1robin__set_1a1d5e40ba2cc5604846158297136dd06f" prot="public" virt="non-virtual"><scope>pxr_tsl::robin_set</scope><name>value_type</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
