<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: Schema Intro By Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_usd_skel__schema_overview.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Schema Intro By Example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page provides an overview of the UsdSkel schemas, using several scene description examples. The examples here only deal with the scene description itself. For coding examples, see the <a class="el" href="_usd_skel__a_p_i__intro.html">API Introduction</a> page. For a more an more in-depth look at the schemas themselves, see the <a class="el" href="_usd_skel__schemas.html">Schemas In-Depth</a> page.</p>
<h1><a class="anchor" id="UsdSkel_SchemaOverview_SkinningAnArm"></a>
Skinning an Arm</h1>
<p>The following example demonstrates a 3-joint, skinned arm, with an animation that rotates the elbow by 90 degrees, over 10 frames:</p>
<div class="fragment"><div class="line">#usda 1.0</div><div class="line">(</div><div class="line">    defaultPrim = &quot;Model&quot;</div><div class="line">    endTimeCode = 10</div><div class="line">    startTimeCode = 1</div><div class="line">    metersPerUnit = .01</div><div class="line">    upAxis = &#39;Y&#39;</div><div class="line">)</div><div class="line"></div><div class="line">def SkelRoot &quot;Model&quot; (</div><div class="line">    kind = &quot;component&quot;</div><div class="line">    prepend apiSchemas = [&quot;SkelBindingAPI&quot;]</div><div class="line">)</div><div class="line">{</div><div class="line">    def Skeleton &quot;Skel&quot; {</div><div class="line">        uniform token[] joints = [&quot;Shoulder&quot;, &quot;Shoulder/Elbow&quot;, &quot;Shoulder/Elbow/Hand&quot;]</div><div class="line">        uniform matrix4d[] bindTransforms = [</div><div class="line">            ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1)),</div><div class="line">            ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,2,1)),</div><div class="line">            ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,4,1)) </div><div class="line">        ]</div><div class="line"></div><div class="line">        uniform matrix4d[] restTransforms = [</div><div class="line">            ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1)),</div><div class="line">            ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,2,1)),</div><div class="line">            ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,2,1))</div><div class="line">        ]</div><div class="line"></div><div class="line">        def SkelAnimation &quot;Anim&quot; {</div><div class="line">            uniform token[] joints = [&quot;Shoulder/Elbow&quot;]</div><div class="line">        </div><div class="line">            float3[] translations = [(0,0,2)]</div><div class="line">            quatf[] rotations.timeSamples = {</div><div class="line">                1: [(1,0,0,0)],</div><div class="line">                10: [(0.7071, 0.7071, 0, 0)]</div><div class="line">            }</div><div class="line">            half3[] scales = [(1,1,1)]</div><div class="line">        }</div><div class="line">        </div><div class="line">        rel skel:animationSource = &lt;/Model/Skel/Anim&gt;</div><div class="line">    }</div><div class="line"></div><div class="line">    # Both the binding of the Skeleton, and the specificatin of the</div><div class="line">    # weighting primvars necessitates the application of the </div><div class="line">    # SkelBindingAPI schema</div><div class="line">    def Mesh &quot;Arm&quot; (</div><div class="line">        prepend apiSchemas = [&quot;SkelBindingAPI&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line"> </div><div class="line">       int[] faceVertexCounts = [4, 4, 4, 4, 4, 4, 4, 4, 4, 4]</div><div class="line">       int[] faceVertexIndices = [</div><div class="line">           2, 3, 1, 0,</div><div class="line">           6, 7, 5, 4,</div><div class="line">           8, 9, 7, 6,</div><div class="line">           3, 2, 9, 8,</div><div class="line">           10, 11, 4, 5,</div><div class="line">           0, 1, 11, 10,</div><div class="line">           7, 9, 10, 5,</div><div class="line">           9, 2, 0, 10,</div><div class="line">           3, 8, 11, 1,</div><div class="line">           8, 6, 4, 11</div><div class="line">       ]</div><div class="line">       point3f[] points = [</div><div class="line">           (0.5, -0.5, 4), (-0.5, -0.5, 4), (0.5, 0.5, 4), (-0.5, 0.5, 4),</div><div class="line">           (-0.5, -0.5, 0), (0.5, -0.5, 0), (-0.5, 0.5, 0), (0.5, 0.5, 0),</div><div class="line">           (-0.5, 0.5, 2), (0.5, 0.5, 2), (0.5, -0.5, 2), (-0.5, -0.5, 2)</div><div class="line">       ]</div><div class="line"></div><div class="line">       rel skel:skeleton = &lt;/Model/Skel&gt;</div><div class="line"></div><div class="line">       int[] primvars:skel:jointIndices = [</div><div class="line">           2,2,2,2, 0,0,0,0, 1,1,1,1</div><div class="line">       ] (</div><div class="line">           interpolation = &quot;vertex&quot;</div><div class="line">           elementSize = 1</div><div class="line">       )</div><div class="line">       float[] primvars:skel:jointWeights = [</div><div class="line">           1,1,1,1, 1,1,1,1, 1,1,1,1</div><div class="line">        ] (</div><div class="line">           interpolation = &quot;vertex&quot;</div><div class="line">           elementSize = 1</div><div class="line">       )</div><div class="line">       matrix4d primvars:skel:geomBindTransform = ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>We will proceed to break this down one piece at a time.</p>
<h2><a class="anchor" id="UsdSkel_SchemaOverview_SkelRoot"></a>
Skinning an Arm: The Skel Root</h2>
 </p><div class="fragment"><div class="line">def SkelRoot <span class="stringliteral">&quot;Model&quot;</span> (</div><div class="line">    kind = <span class="stringliteral">&quot;component&quot;</span></div><div class="line">    prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">)</div><div class="line">{</div></div><!-- fragment --><p>When a model (or other grouping of prims) contains skinned data, it must be encapsulated within a <a class="el" href="class_usd_skel_root.html" title="Boundable prim type used to identify a scope beneath which skeletally-posed primitives are defined.">UsdSkelRoot</a> primitive. This serves two purposes:</p>
<ol type="1">
<li>Informs applications that are consuming the file that a branch of the scene graph contains skinned primitives, as such data often requires special processing by the consuming application.</li>
<li>Provides a place to encode pre-computed bounding information for the skinned primitives (a <a class="el" href="class_usd_skel_root.html" title="Boundable prim type used to identify a scope beneath which skeletally-posed primitives are defined.">UsdSkelRoot</a> is a subclass of <code><a class="el" href="class_usd_geom_boundable.html" title="Boundable introduces the ability for a prim to persistently cache a rectilinear, local-space,...">UsdGeomBoundable</a></code>). This allows renderers to determine where in space the result of skinning resides without having to apply skinning first. For example, a renderer is capable of efficiently culling objects that are not visible in camera without paying the cost of computing skinning.</li>
</ol>
<p>Secondly, we see that the <a class="el" href="class_usd_skel_binding_a_p_i.html" title="Provides API for authoring and extracting all the skinning-related data that lives in the &quot;geometry h...">UsdSkelBindingAPI</a> schema has been applied to the prim. This informs the runtime that skel-related data is being specified on the prim. "skel-related data" includes binding SkelAnimation or Skeleton prims, BlendShapes, or specifying skel weighting or joint influences primvars.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd_skel__schemas.html#UsdSkel_SkelRoot">Skeleton Root Schema</a></dd></dl>
<h2><a class="anchor" id="UsdSkel_SchemaOverview_DefiningSkeletons"></a>
Skinning an Arm: Defining a Skeleton</h2>
<div class="fragment"><div class="line">    def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {</div><div class="line">        uniform token[] joints = [<span class="stringliteral">&quot;Shoulder&quot;</span>, <span class="stringliteral">&quot;Shoulder/Elbow&quot;</span>, <span class="stringliteral">&quot;Shoulder/Elbow/Hand&quot;</span>]</div></div><!-- fragment --><p>A Skeleton encodes a joint hierarchy. The actual joints and their parent&lt;-&gt;child relationships are encoded in a compact, vectorized token array. Each token in the array is the token-valued form of a relative path to that joint. The paths follow the same syntax rules as other prim paths in USD, and may be constructed using the <code><a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a></code> API.</p>
<p>The tokens authored for <em>joints</em> may be considered as defining the <em>topology</em> of the Skeleton.</p>
<p>Each joint's parent is identified by path. If an intermediate path is excluded, then the next nearest ancestor path that is included is used instead. For example, if the joint list above did not include <code>Shoulder/Elbow</code>, then the parent of <code>Shoulder/Elbow/Hand</code> would be <code>Shoulder</code>. Consumers of UsdSkel files are encouraged to use the <a class="el" href="class_usd_skel_topology.html" title="Object holding information describing skeleton topology.">UsdSkelTopology</a> utility class to reason about these relationships.</p>
<p>Note that it is <em>valid</em> to have multiple root joints in a Skeleton. For example:</p>
<div class="fragment"><div class="line">def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {</div><div class="line">    uniform token[] joints = [<span class="stringliteral">&quot;RootA&quot;</span>, <span class="stringliteral">&quot;RootA/Child&quot;</span>, <span class="stringliteral">&quot;RootB&quot;</span>]</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>This is allowed because some of the applications that UsdSkel interchanges with also allow it. In a way, the Skeleton primitive itself may be thought of as the true root of the Skeleton.</p>
<h3><a class="anchor" id="UsdSkel_SchemaOverview_DefiningSkeletons_BindTransforms"></a>
Bind Transforms</h3>
 </p><div class="fragment"><div class="line">    def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {</div><div class="line">        uniform matrix4d[] bindTransforms = [</div><div class="line">            ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1)),</div><div class="line">            ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,2,1)),</div><div class="line">            ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,4,1)) </div><div class="line">        ]</div></div><!-- fragment --><p>The <em>bindTransforms</em> property of a Skeleton provides the <em>world space</em> transform of each joint at bind time. A world space encoding has been chosen for bind transforms, since most DCC apps tend to use the same encoding, so using the same encoding tends to simplify IO.</p>
<p>The entries of the <em>bindTransforms</em> array are ordered according to the order of the <em>joints</em> attribute. So for this example, the first entry in the array corresponds to joint <code>Shoulder</code>, the second to <code>Shoulder/Elbow</code>, and so forth.</p>
<h3><a class="anchor" id="UsdSkel_SchemaOverview_DefiningSkeletons_RestTransforms"></a>
Rest Transforms</h3>
 </p><div class="fragment"><div class="line">    def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {</div><div class="line">        uniform matrix4d[] restTransforms = [</div><div class="line">            ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1)),</div><div class="line">            ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,2,1)),</div><div class="line">            ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,2,1))</div><div class="line">        ]</div></div><!-- fragment --><p>The <em>restTransforms</em> property of a Skeleton provides <em>local space</em> rest transforms of each joint, which serve as a fallback values for joints that have not been overridden by an animation. As with <em>bindTransforms</em>, the <em>restTransforms</em> are ordered according to the order of the <em>joints</em> attribute.</p>
<p>The <em>restTransforms</em> may be considered optional, but if left unspecified, the Skeleton must be bound to a <em>complete</em>, non-sparse animation. It is common for the <em>restTransforms</em> to refer to the same pose as the <em>bindTransforms</em>, only in joint-local space, rather than world space, but this is not required.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd_skel__schemas.html#UsdSkel_Skeleton">Skeleton Schema</a></dd></dl>
<h2><a class="anchor" id="UsdSkel_SchemaOverview_SkelAnimations"></a>
Skinning an Arm: Skel Animations</h2>
<div class="fragment"><div class="line">        def SkelAnimation <span class="stringliteral">&quot;Anim&quot;</span> {</div><div class="line">            uniform token[] joints = [<span class="stringliteral">&quot;Shoulder/Elbow&quot;</span>]</div></div><!-- fragment --><p>Instead of encoding joint animations directly on a Skeleton, the animations are encoded in a <code><a class="el" href="class_usd_skel_animation.html" title="Describes a skel animation, where joint animation is stored in a vectorized form.">UsdSkelAnimation</a></code> primitive. The animation of a Skeleton is kept separate in this manner both to allow different animation encodings &ndash; as different prim types &ndash; as well as for the sake of <a class="el" href="_usd_skel__instancing.html">instancing</a>.</p>
<p>An animation must define <em>joints</em>, which determines the set of joints that the animation affects. This order does not need to match the order given on the <em>Skeleton</em> primitive. To emphasize that point, this particular animation has been setup to affect only a single joint (<code>Shoulder/Elbow</code>).</p>
<h3><a class="anchor" id="UsdSkel_SchemaOverview_JointTransforms"></a>
Joint Transforms</h3>
 </p><div class="fragment"><div class="line">        def SkelAnimation <span class="stringliteral">&quot;Anim&quot;</span> {</div><div class="line">            float3[] translations = [(0,0,2)]</div><div class="line">            quatf[] rotations.timeSamples = {</div><div class="line">                1: [(1,0,0,0)],</div><div class="line">                10: [(0.7071, 0.7071, 0, 0)]</div><div class="line">            }</div><div class="line">            half3[] scales = [(1,1,1)]</div><div class="line">        }</div></div><!-- fragment --><p>Currently, UsdSkel encodes joint animations as arrays of translation, rotation and scale components. The encoding is vectorized for scalability reasons, and with consideration for IO performance on large-scale crowds. It is broken into these separate components primarily for the sake of interpolation, but this also has storage benefits &ndash; such as enabling separate run-length encoding for different components. For example, if only the rotations are changing over time, as is often the case, then we need only store animated values for those rotations, and need not store unique scale/translation samples per frame.</p>
<p>These transform components combine to describe the <em>local space</em> transforms of a set of joints. Helper methods <a class="el" href="group___usd_skel___transform_composition_utils.html#ga457d8118163ca7ff9baec7a810972e8e" title="Decompose an array of transforms into translate/rotate/scale components.">UsdSkelDecomposeTransforms()</a> and <a class="el" href="group___usd_skel___transform_composition_utils.html#ga9edeef3ded1f2765880a5a70ee12fba6" title="Create transforms from arrays of components.">UsdSkelMakeTransforms()</a> can be used to convert between these components and arrays of matrices.</p>
<p>Note that this encoding implies that joint local transforms must have an <em>orthogonal</em> basis. While non-uniform scales may still be authored, non-uniform scale values should only be used to apply reflections; each component of the scale should otherwise have the same magnitude. It is further <em>recommended</em> that users make an effort to stick to purely orthonormal transforms: Many applications do not support non-uniform joint scaling, so translating non-orthonormal transforms to other packages may be problematic.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd_skel__schemas.html#UsdSkel_SkelAnimation">Skel Animation Schema</a></dd></dl>
<h3><a class="anchor" id="UsdSkel_SchemaOverview_BindingAnAnimation"></a>
Binding An Animation To A Skeleton</h3>
 </p><div class="fragment"><div class="line">    def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {</div><div class="line">        def SkelAnimation <span class="stringliteral">&quot;Anim&quot;</span> {</div><div class="line">        }</div><div class="line">        </div><div class="line">        rel skel:animationSource = &lt;/Model/Skel/Anim&gt;</div><div class="line">    }</div></div><!-- fragment --><p>In order for a SkelAnimation to have any effect, it must be bound to a Skeleton. This is done using the <em>skel:animationSource</em> relationship, as created through the <a class="el" href="class_usd_skel_binding_a_p_i.html" title="Provides API for authoring and extracting all the skinning-related data that lives in the &quot;geometry h...">UsdSkelBindingAPI</a>.</p>
<p>The animation source binding is <em>inherited</em> down namespace. For example, suppose we have:</p>
<div class="fragment"><div class="line">def Scope <span class="stringliteral">&quot;Scope&quot;</span> {</div><div class="line">    </div><div class="line">    rel skel:animationSource = &lt;/Anim&gt;</div><div class="line">    </div><div class="line">    def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {}</div><div class="line">}</div></div><!-- fragment --><p>In that case, the Skeleton at <code>&lt;/Scope/Skel&gt;</code> inherits the animation source binding established at <code>&lt;/Scope&gt;</code>. The primary motivation for this inheritance property is that it is the means by which UsdSkel allows <em>instanced</em> primitives to be driven by different joint animations. The <a class="el" href="_usd_skel__instancing.html">instancing</a> section goes into this in more detail.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd_skel__schemas.html#UsdSkel_BindingAPI">Binding API Schema</a></dd></dl>
<h2><a class="anchor" id="UsdSkel_SchemaOverview_BindingSkeletons"></a>
Skinning an Arm: Binding Skeletons to Prims</h2>
 </p><div class="fragment"><div class="line">    def Mesh <span class="stringliteral">&quot;Arm&quot;</span> (</div><div class="line">        prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">    )</div><div class="line">    {</div><div class="line">       rel skel:skeleton = &lt;/Model/Skel&gt;</div><div class="line">    }</div></div><!-- fragment --><p>Skeletons are bound to the primitives that they skin by way of the <em>skel:skeleton</em> binding relationship, which can be set through the <a class="el" href="class_usd_skel_binding_a_p_i.html" title="Provides API for authoring and extracting all the skinning-related data that lives in the &quot;geometry h...">UsdSkelBindingAPI</a>, which must be <b>applied</b> to the Mesh prim for the binding to be recognized.</p>
<p>This relationship works in a similar manner to the <em>skel:animationSource</em> binding, in that the binding is inherited. Using this inheritance, it is common on production assets to bind the skeleton at a higher scope, rather than on individual primitives &ndash; of which there may be many! For example:</p>
<div class="fragment"><div class="line">def SkelRoot <span class="stringliteral">&quot;ComplexModelWithHundredsOfMeshes&quot;</span> {</div><div class="line">    rel skel:skeleton = &lt;/SkelRoot/Skel&gt;</div><div class="line"></div><div class="line">    def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {}</div><div class="line"></div><div class="line">    def Mesh <span class="stringliteral">&quot;Mesh0&quot;</span> {}</div><div class="line">    def Mesh <span class="stringliteral">&quot;Mesh1&quot;</span> {}</div><div class="line">    ...</div><div class="line">    def Mesh <span class="stringliteral">&quot;Mesh1000&quot;</span> {}</div><div class="line">}</div></div><!-- fragment --><p>Note that it is only valid to bind skeletons either on <a class="el" href="class_usd_skel_root.html" title="Boundable prim type used to identify a scope beneath which skeletally-posed primitives are defined.">UsdSkelRoot</a> primitives, or on their descendants.</p>
<p>This example shows the common case of mesh skinning, but UsdSkel's skinning is not restricted to only meshes.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd_skel__schemas.html#UsdSkel_BindingAPI">Binding API Schema</a> <a class="el" href="_usd_skel__intro.html#UsdSkel_SkinnablePrims">What Can Be Skinned?</a></dd></dl>
<h2><a class="anchor" id="UsdSkel_SchemaOverview_JointInfluences"></a>
Skinning an Arm: Joint Influences</h2>
 </p><div class="fragment"><div class="line">    def Mesh <span class="stringliteral">&quot;Arm&quot;</span> (</div><div class="line">        prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">    )</div><div class="line">    {</div><div class="line">       <span class="keywordtype">int</span>[] primvars:skel:jointIndices = [</div><div class="line">           2,2,2,2, 0,0,0,0, 1,1,1,1</div><div class="line">       ] (</div><div class="line">           interpolation = <span class="stringliteral">&quot;vertex&quot;</span></div><div class="line">           elementSize = 1</div><div class="line">       )</div><div class="line">       <span class="keywordtype">float</span>[] primvars:skel:jointWeights = [</div><div class="line">           1,1,1,1, 1,1,1,1, 1,1,1,1</div><div class="line">        ] (</div><div class="line">           interpolation = <span class="stringliteral">&quot;vertex&quot;</span></div><div class="line">           elementSize = 1</div><div class="line">       )</div><div class="line">    }</div></div><!-- fragment --><p>The <em>jointIndices</em> and <em>jointWeights</em> primvars store the joints and joint weights for each vertex. Both primvars are required to have a matching <em>interpolation</em> and array size, and the <em>interpolation</em> must be either 'constant' or 'vertex'.</p>
<p>Each value from <em>primvars:skel:jointIndices</em> gives the index of a joint, while the corresponding element from <em>primvars:skel:jointWeights</em> provides the weight for that joint.</p>
<p>Without setting any additional properties, the index values stored by the <em>jointIndices</em> primvar refers to joints in the ordering defined by the <em>joints</em> attribute of the bound Skeleton. So, referring back to the definition of the Skeleton:</p>
 </p><div class="fragment"><div class="line">    def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {</div><div class="line">        uniform token[] joints = [<span class="stringliteral">&quot;Shoulder&quot;</span>, <span class="stringliteral">&quot;Shoulder/Elbow&quot;</span>, <span class="stringliteral">&quot;Shoulder/Elbow/Hand&quot;</span>]</div><div class="line">    }</div></div><!-- fragment --><p>Given the set of joints defined here, a value of <b>0</b> in <em>jointIndices</em> refers to the <code>Shoulder</code> joint, a value of <b>1</b> refers to <code>Shoulder/Elbow</code>, and so forth.</p>
<h3><a class="anchor" id="UsdSkel_SchemaOverview_ExplicitJointOrders"></a>
Explicit Joint Orders</h3>
<p>Instead of using the joint order declared on the Skeleton, it is also possible to define an explicit ordering directly on a skinned mesh. For example:</p>
<div class="fragment"><div class="line">def Mesh <span class="stringliteral">&quot;Arm&quot;</span> {</div><div class="line">    ...</div><div class="line">    uniform token[] skel:joints = [<span class="stringliteral">&quot;Shoulder/Elbow&quot;</span>, <span class="stringliteral">&quot;Shoulder&quot;</span>]</div><div class="line">    <span class="keywordtype">int</span>[] primvars:skel:jointIndices = [1,1,1,1, 1,1,1,1, 0,0,0,0] (</div><div class="line">       interpolation = <span class="stringliteral">&quot;vertex&quot;</span></div><div class="line">       elementSize = 1</div><div class="line">    )</div><div class="line">    <span class="keywordtype">float</span>[] primvars:skel:jointWeights = [1,1,1,1, 1,1,1,1, 1,1,1,1] (</div><div class="line">       interpolation = <span class="stringliteral">&quot;vertex&quot;</span></div><div class="line">       elementSize = 1</div><div class="line">    )</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>Here, we have an explicit <em>skel:joints</em> ordering. Using that ordering, a value of <b>0</b> in <em>jointIndices</em> refers to the <code>Shoulder/Elbow</code> joint, and a value of <b>1</b> refers to the <code>Shoulder</code> joint. As with the <em>skel:skeleton</em> and <em>skel:animationSource</em> binding relationships, <em>primvars:skel:joints</em> is an inherited property, and may be set set on ancestor primitives. For that matter, <em>all</em> primvars in USD inherited down namespace.</p>
<h2><a class="anchor" id="UsdSkel_SchemaOverview_GeomBindTransform"></a>
Skinning an Arm: Geom Bind Transform</h2>
 </p><div class="fragment"><div class="line">    def Mesh <span class="stringliteral">&quot;Arm&quot;</span> (</div><div class="line">        prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">    )</div><div class="line">    {</div><div class="line">       matrix4d primvars:skel:geomBindTransform = ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))</div><div class="line">    }</div></div><!-- fragment --><p>The <em>primvars:skel:geomBindTransform</em> primvar provides the world space transform of a skinned primitive at bind-time. As with the case of the Skeleton's bindTransform property, the bind transforms are given in world space, since that is how most DCC apps tend to encode the property.</p>
<p>The points of the skinned primitive are transformed by the geomBindTransform prior to skinning.</p>
<p>If left undefined, the geom bind transform is assumed to be the identity.</p>
<p>It is often the case that a skinned primitive will also have a transform authored using the typical <a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable</a> API, in addition to the geomBindTransform. If that is the case, the geomBindTransform is still the only transform used for skinning. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="usd_skel_page_front.html">UsdSkel : USD Skeleton Schema and API</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:57 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>