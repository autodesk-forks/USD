<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: String Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group__tf___string.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">String Utilities</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions/classes for string manipulation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:tf_2hash_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tf_2hash_8h.html">hash.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pattern_matcher_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pattern_matcher_8h.html">patternMatcher.h</a></td></tr>
<tr class="memdesc:pattern_matcher_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple glob and regex matching utility. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:string_utils_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_utils_8h.html">stringUtils.h</a></td></tr>
<tr class="memdesc:string_utils_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of basic string utilities in tf. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unicode_utils_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unicode_utils_8h.html">unicodeUtils.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tf_dictionary_less_than.html">TfDictionaryLessThan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides dictionary ordering binary predicate function on strings.  <a href="struct_tf_dictionary_less_than.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tf_stream_float.html">TfStreamFloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type which offers streaming for floats in a canonical format that can safely roundtrip with the minimal number of digits.  <a href="struct_tf_stream_float.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tf_stream_double.html">TfStreamDouble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type which offers streaming for doubles in a canonical format that can safely roundtrip with the minimal number of digits.  <a href="struct_tf_stream_double.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_hash.html">TfHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A user-extensible hashing mechanism for use with runtime hash tables.  <a href="class_tf_hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_pattern_matcher.html">TfPatternMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for matching regular expressions.  <a href="class_tf_pattern_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_template_string.html">TfTemplateString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tf_template_string.html" title="TfTemplateString provides simple string substitutions based on named placeholders.">TfTemplateString</a> provides simple string substitutions based on named placeholders.  <a href="class_tf_template_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_token.html">TfToken</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Token for efficient comparison, assignment, and hashing of known strings.  <a href="class_tf_token.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae42be5a0255e4c7ba38d087fd97a97db"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gae42be5a0255e4c7ba38d087fd97a97db">TfStringPrintf</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:gae42be5a0255e4c7ba38d087fd97a97db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string formed by a printf()-like specification.  <a href="#gae42be5a0255e4c7ba38d087fd97a97db">More...</a><br /></td></tr>
<tr class="separator:gae42be5a0255e4c7ba38d087fd97a97db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7865a37742a57ae8e151de7eea160920"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga7865a37742a57ae8e151de7eea160920">TfVStringPrintf</a> (const std::string &amp;fmt, va_list ap)</td></tr>
<tr class="memdesc:ga7865a37742a57ae8e151de7eea160920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string formed by a printf()-like specification.  <a href="#ga7865a37742a57ae8e151de7eea160920">More...</a><br /></td></tr>
<tr class="separator:ga7865a37742a57ae8e151de7eea160920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0338d0b229616b6061ee60f971e0dc1"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gac0338d0b229616b6061ee60f971e0dc1">TfVStringPrintf</a> (const char *fmt, va_list ap)</td></tr>
<tr class="memdesc:gac0338d0b229616b6061ee60f971e0dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bloat-avoidance version of <a class="el" href="group__group__tf___string.html#ga7865a37742a57ae8e151de7eea160920" title="Returns a string formed by a printf()-like specification.">TfVStringPrintf()</a>  <a href="#gac0338d0b229616b6061ee60f971e0dc1">More...</a><br /></td></tr>
<tr class="separator:gac0338d0b229616b6061ee60f971e0dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga266a173b9f73e164456b5ff7577fdd9d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga266a173b9f73e164456b5ff7577fdd9d">TfSafeString</a> (const char *ptr)</td></tr>
<tr class="memdesc:ga266a173b9f73e164456b5ff7577fdd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely create a std::string from a (possibly NULL) char*.  <a href="#ga266a173b9f73e164456b5ff7577fdd9d">More...</a><br /></td></tr>
<tr class="separator:ga266a173b9f73e164456b5ff7577fdd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga286f433e8bca5054a868dcbb44786382"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga286f433e8bca5054a868dcbb44786382">TfIntToString</a> (int i)</td></tr>
<tr class="memdesc:ga286f433e8bca5054a868dcbb44786382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given integer as a string.  <a href="#ga286f433e8bca5054a868dcbb44786382">More...</a><br /></td></tr>
<tr class="separator:ga286f433e8bca5054a868dcbb44786382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab03b8ef5e730ae50cd19cacf4fbb65"><td class="memItemLeft" align="right" valign="top">TF_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gaeab03b8ef5e730ae50cd19cacf4fbb65">TfStringToDouble</a> (const std::string &amp;txt)</td></tr>
<tr class="memdesc:gaeab03b8ef5e730ae50cd19cacf4fbb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts text string to double.  <a href="#gaeab03b8ef5e730ae50cd19cacf4fbb65">More...</a><br /></td></tr>
<tr class="separator:gaeab03b8ef5e730ae50cd19cacf4fbb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60957f94df2a8e584431b0d80b042df5"><td class="memItemLeft" align="right" valign="top">TF_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga60957f94df2a8e584431b0d80b042df5">TfStringToDouble</a> (const char *text)</td></tr>
<tr class="separator:ga60957f94df2a8e584431b0d80b042df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fa531c70ccef3fb5fbb75e75091a786"><td class="memItemLeft" align="right" valign="top">TF_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga8fa531c70ccef3fb5fbb75e75091a786">TfStringToDouble</a> (const char *text, int len)</td></tr>
<tr class="separator:ga8fa531c70ccef3fb5fbb75e75091a786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac87e0d845d3c64b8c756945a376ad22b"><td class="memItemLeft" align="right" valign="top">TF_API long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gac87e0d845d3c64b8c756945a376ad22b">TfStringToLong</a> (const std::string &amp;txt, bool *outOfRange=NULL)</td></tr>
<tr class="memdesc:gac87e0d845d3c64b8c756945a376ad22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a sequence of digits in <code>txt</code> to a long int value.  <a href="#gac87e0d845d3c64b8c756945a376ad22b">More...</a><br /></td></tr>
<tr class="separator:gac87e0d845d3c64b8c756945a376ad22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4197b90755833d5aa6b46bd84ae2b376"><td class="memItemLeft" align="right" valign="top">TF_API long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga4197b90755833d5aa6b46bd84ae2b376">TfStringToLong</a> (const char *txt, bool *outOfRange=NULL)</td></tr>
<tr class="separator:ga4197b90755833d5aa6b46bd84ae2b376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3f8a26ec832a2f46998c868114d7ded"><td class="memItemLeft" align="right" valign="top">TF_API unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gad3f8a26ec832a2f46998c868114d7ded">TfStringToULong</a> (const std::string &amp;txt, bool *outOfRange=NULL)</td></tr>
<tr class="memdesc:gad3f8a26ec832a2f46998c868114d7ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a sequence of digits in <code>txt</code> to an unsigned long value.  <a href="#gad3f8a26ec832a2f46998c868114d7ded">More...</a><br /></td></tr>
<tr class="separator:gad3f8a26ec832a2f46998c868114d7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7e37af76c24cb746fadbb409f7184b"><td class="memItemLeft" align="right" valign="top">TF_API unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gafc7e37af76c24cb746fadbb409f7184b">TfStringToULong</a> (const char *txt, bool *outOfRange=NULL)</td></tr>
<tr class="separator:gafc7e37af76c24cb746fadbb409f7184b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03fa88100e2c0093f0c593acaaa4c396"><td class="memItemLeft" align="right" valign="top">TF_API int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga03fa88100e2c0093f0c593acaaa4c396">TfStringToInt64</a> (const std::string &amp;txt, bool *outOfRange=NULL)</td></tr>
<tr class="memdesc:ga03fa88100e2c0093f0c593acaaa4c396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a sequence of digits in <code>txt</code> to an int64_t value.  <a href="#ga03fa88100e2c0093f0c593acaaa4c396">More...</a><br /></td></tr>
<tr class="separator:ga03fa88100e2c0093f0c593acaaa4c396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5857c662ea9a36c77f42f7625a913463"><td class="memItemLeft" align="right" valign="top">TF_API int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga5857c662ea9a36c77f42f7625a913463">TfStringToInt64</a> (const char *txt, bool *outOfRange=NULL)</td></tr>
<tr class="separator:ga5857c662ea9a36c77f42f7625a913463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc528911e7f5d69e43ef990d4b5bb17a"><td class="memItemLeft" align="right" valign="top">TF_API uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gacc528911e7f5d69e43ef990d4b5bb17a">TfStringToUInt64</a> (const std::string &amp;txt, bool *outOfRange=NULL)</td></tr>
<tr class="memdesc:gacc528911e7f5d69e43ef990d4b5bb17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a sequence of digits in <code>txt</code> to a uint64_t value.  <a href="#gacc528911e7f5d69e43ef990d4b5bb17a">More...</a><br /></td></tr>
<tr class="separator:gacc528911e7f5d69e43ef990d4b5bb17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f3aee7ef57cf1b9e48c8dbea3bc5468"><td class="memItemLeft" align="right" valign="top">TF_API uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga1f3aee7ef57cf1b9e48c8dbea3bc5468">TfStringToUInt64</a> (const char *txt, bool *outOfRange=NULL)</td></tr>
<tr class="separator:ga1f3aee7ef57cf1b9e48c8dbea3bc5468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga197320d753aa921027df5a3a6ab1adb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga197320d753aa921027df5a3a6ab1adb8">TfStringStartsWith</a> (const std::string &amp;s, const char *prefix)</td></tr>
<tr class="memdesc:ga197320d753aa921027df5a3a6ab1adb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>s</code> starts with <code>prefix</code>.  <a href="#ga197320d753aa921027df5a3a6ab1adb8">More...</a><br /></td></tr>
<tr class="separator:ga197320d753aa921027df5a3a6ab1adb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9acd1b6d56d7ba358910f1cb9f040c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gac9acd1b6d56d7ba358910f1cb9f040c4">TfStringStartsWith</a> (const std::string &amp;s, const std::string &amp;prefix)</td></tr>
<tr class="separator:gac9acd1b6d56d7ba358910f1cb9f040c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb023dfd25a6ab8b3696e33e50d80549"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gacb023dfd25a6ab8b3696e33e50d80549">TfStringEndsWith</a> (const std::string &amp;s, const char *suffix)</td></tr>
<tr class="memdesc:gacb023dfd25a6ab8b3696e33e50d80549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>s</code> ends with <code>suffix</code>.  <a href="#gacb023dfd25a6ab8b3696e33e50d80549">More...</a><br /></td></tr>
<tr class="separator:gacb023dfd25a6ab8b3696e33e50d80549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b1cad632066ef0674fb139fc2f1e0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gaa2b1cad632066ef0674fb139fc2f1e0a">TfStringEndsWith</a> (const std::string &amp;s, const std::string &amp;suffix)</td></tr>
<tr class="separator:gaa2b1cad632066ef0674fb139fc2f1e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga093436e3b1b3109e05899be5f7638e9f"><td class="memItemLeft" align="right" valign="top">TF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga093436e3b1b3109e05899be5f7638e9f">TfStringContains</a> (const std::string &amp;s, const char *substring)</td></tr>
<tr class="memdesc:ga093436e3b1b3109e05899be5f7638e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>s</code> contains <code>substring</code>.  <a href="#ga093436e3b1b3109e05899be5f7638e9f">More...</a><br /></td></tr>
<tr class="separator:ga093436e3b1b3109e05899be5f7638e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga697055ba2baa6c4b5921a60dbbfc0bfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga697055ba2baa6c4b5921a60dbbfc0bfb">TfStringContains</a> (const std::string &amp;s, const std::string &amp;substring)</td></tr>
<tr class="separator:ga697055ba2baa6c4b5921a60dbbfc0bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad451dea1974d5a2a597cd44482e82546"><td class="memItemLeft" align="right" valign="top">TF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gad451dea1974d5a2a597cd44482e82546">TfStringContains</a> (const std::string &amp;s, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;substring)</td></tr>
<tr class="separator:gad451dea1974d5a2a597cd44482e82546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2268a5910931796c2e0a53261e6ce7da"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga2268a5910931796c2e0a53261e6ce7da">TfStringToLower</a> (const std::string &amp;source)</td></tr>
<tr class="memdesc:ga2268a5910931796c2e0a53261e6ce7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes all characters in <code>source</code> lowercase, and returns the result.  <a href="#ga2268a5910931796c2e0a53261e6ce7da">More...</a><br /></td></tr>
<tr class="separator:ga2268a5910931796c2e0a53261e6ce7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e7f46e6c7381ec8c93e54918061119"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gae3e7f46e6c7381ec8c93e54918061119">TfStringToUpper</a> (const std::string &amp;source)</td></tr>
<tr class="memdesc:gae3e7f46e6c7381ec8c93e54918061119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes all characters in <code>source</code> uppercase, and returns the result.  <a href="#gae3e7f46e6c7381ec8c93e54918061119">More...</a><br /></td></tr>
<tr class="separator:gae3e7f46e6c7381ec8c93e54918061119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad14e4ee556adf58a4d9712fa45fd28c4"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gad14e4ee556adf58a4d9712fa45fd28c4">TfStringCapitalize</a> (const std::string &amp;source)</td></tr>
<tr class="memdesc:gad14e4ee556adf58a4d9712fa45fd28c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the <code>source</code> string with only its first character capitalized.  <a href="#gad14e4ee556adf58a4d9712fa45fd28c4">More...</a><br /></td></tr>
<tr class="separator:gad14e4ee556adf58a4d9712fa45fd28c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27db779aeaabe869b15510d0ab2cdf9b"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga27db779aeaabe869b15510d0ab2cdf9b">TfStringToLowerAscii</a> (const std::string &amp;source)</td></tr>
<tr class="memdesc:ga27db779aeaabe869b15510d0ab2cdf9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locale-independent case folding of [A-Z] for ASCII or UTF-8 encoded <code>source</code> strings.  <a href="#ga27db779aeaabe869b15510d0ab2cdf9b">More...</a><br /></td></tr>
<tr class="separator:ga27db779aeaabe869b15510d0ab2cdf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18c42c9ff7aab2733dd4966ba8d74151"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga18c42c9ff7aab2733dd4966ba8d74151">TfStringTrimLeft</a> (const std::string &amp;s, const char *trimChars=&quot; \n\t\r&quot;)</td></tr>
<tr class="memdesc:ga18c42c9ff7aab2733dd4966ba8d74151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims characters (by default, whitespace) from the left.  <a href="#ga18c42c9ff7aab2733dd4966ba8d74151">More...</a><br /></td></tr>
<tr class="separator:ga18c42c9ff7aab2733dd4966ba8d74151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c4f6847ddb76db0e4f5dbb77f94d56"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gae7c4f6847ddb76db0e4f5dbb77f94d56">TfStringTrimRight</a> (const std::string &amp;s, const char *trimChars=&quot; \n\t\r&quot;)</td></tr>
<tr class="memdesc:gae7c4f6847ddb76db0e4f5dbb77f94d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims characters (by default, whitespace) from the right.  <a href="#gae7c4f6847ddb76db0e4f5dbb77f94d56">More...</a><br /></td></tr>
<tr class="separator:gae7c4f6847ddb76db0e4f5dbb77f94d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe1cb80f75a655f23b7923f02a849b06"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gafe1cb80f75a655f23b7923f02a849b06">TfStringTrim</a> (const std::string &amp;s, const char *trimChars=&quot; \n\t\r&quot;)</td></tr>
<tr class="memdesc:gafe1cb80f75a655f23b7923f02a849b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims characters (by default, whitespace) from the beginning and end of string.  <a href="#gafe1cb80f75a655f23b7923f02a849b06">More...</a><br /></td></tr>
<tr class="separator:gafe1cb80f75a655f23b7923f02a849b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2bfa0c8e61096bd0321aec28caa2515"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gad2bfa0c8e61096bd0321aec28caa2515">TfStringGetCommonPrefix</a> (std::string a, std::string b)</td></tr>
<tr class="memdesc:gad2bfa0c8e61096bd0321aec28caa2515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the common prefix of the input strings, if any.  <a href="#gad2bfa0c8e61096bd0321aec28caa2515">More...</a><br /></td></tr>
<tr class="separator:gad2bfa0c8e61096bd0321aec28caa2515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd1e0eb3f3e4f9ca32e674330f062697"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gafd1e0eb3f3e4f9ca32e674330f062697">TfStringGetSuffix</a> (const std::string &amp;name, char delimiter='.')</td></tr>
<tr class="memdesc:gafd1e0eb3f3e4f9ca32e674330f062697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the suffix of a string.  <a href="#gafd1e0eb3f3e4f9ca32e674330f062697">More...</a><br /></td></tr>
<tr class="separator:gafd1e0eb3f3e4f9ca32e674330f062697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9e93734112b176029a356b304c56767"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gac9e93734112b176029a356b304c56767">TfStringGetBeforeSuffix</a> (const std::string &amp;name, char delimiter='.')</td></tr>
<tr class="memdesc:gac9e93734112b176029a356b304c56767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns everything up to the suffix of a string.  <a href="#gac9e93734112b176029a356b304c56767">More...</a><br /></td></tr>
<tr class="separator:gac9e93734112b176029a356b304c56767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcc90872f80f8023a17118edf91ec75c"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gadcc90872f80f8023a17118edf91ec75c">TfGetBaseName</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:gadcc90872f80f8023a17118edf91ec75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the base name of a file (final component of the path).  <a href="#gadcc90872f80f8023a17118edf91ec75c">More...</a><br /></td></tr>
<tr class="separator:gadcc90872f80f8023a17118edf91ec75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d7260aded12055629188966c8f7e86"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gaf2d7260aded12055629188966c8f7e86">TfGetPathName</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:gaf2d7260aded12055629188966c8f7e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the path component of a file (complement of <a class="el" href="group__group__tf___string.html#gadcc90872f80f8023a17118edf91ec75c" title="Returns the base name of a file (final component of the path).">TfGetBaseName()</a>).  <a href="#gaf2d7260aded12055629188966c8f7e86">More...</a><br /></td></tr>
<tr class="separator:gaf2d7260aded12055629188966c8f7e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac52faea3628696e9a242bf79cbce4be6"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gac52faea3628696e9a242bf79cbce4be6">TfStringReplace</a> (const std::string &amp;source, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="memdesc:gac52faea3628696e9a242bf79cbce4be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of string <code>from</code> with <code>to</code> in <code>source</code>.  <a href="#gac52faea3628696e9a242bf79cbce4be6">More...</a><br /></td></tr>
<tr class="separator:gac52faea3628696e9a242bf79cbce4be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd37bcc74ba568292651ece78d667bb9"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:gacd37bcc74ba568292651ece78d667bb9"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gacd37bcc74ba568292651ece78d667bb9">TfStringJoin</a> (ForwardIterator begin, ForwardIterator end, const char *separator=&quot; &quot;)</td></tr>
<tr class="memdesc:gacd37bcc74ba568292651ece78d667bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the strings (<code>begin</code>, <code>end</code>), with default separator.  <a href="#gacd37bcc74ba568292651ece78d667bb9">More...</a><br /></td></tr>
<tr class="separator:gacd37bcc74ba568292651ece78d667bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2693efcb60908bf5b07caa0786ec000a"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga2693efcb60908bf5b07caa0786ec000a">TfStringJoin</a> (const std::vector&lt; std::string &gt; &amp;strings, const char *separator=&quot; &quot;)</td></tr>
<tr class="memdesc:ga2693efcb60908bf5b07caa0786ec000a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates <code>strings</code>, with default separator.  <a href="#ga2693efcb60908bf5b07caa0786ec000a">More...</a><br /></td></tr>
<tr class="separator:ga2693efcb60908bf5b07caa0786ec000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d739e380be70b26f487bb5476cd07a7"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga9d739e380be70b26f487bb5476cd07a7">TfStringJoin</a> (const std::set&lt; std::string &gt; &amp;strings, const char *separator=&quot; &quot;)</td></tr>
<tr class="memdesc:ga9d739e380be70b26f487bb5476cd07a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates <code>strings</code>, with default separator.  <a href="#ga9d739e380be70b26f487bb5476cd07a7">More...</a><br /></td></tr>
<tr class="separator:ga9d739e380be70b26f487bb5476cd07a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb4e5db4f6eaf230ae41ff0159316fa5"><td class="memItemLeft" align="right" valign="top">TF_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gaeb4e5db4f6eaf230ae41ff0159316fa5">TfStringSplit</a> (std::string const &amp;src, std::string const &amp;separator)</td></tr>
<tr class="memdesc:gaeb4e5db4f6eaf230ae41ff0159316fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the given string apart, returning a vector of strings.  <a href="#gaeb4e5db4f6eaf230ae41ff0159316fa5">More...</a><br /></td></tr>
<tr class="separator:gaeb4e5db4f6eaf230ae41ff0159316fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad12791e5ba9776711b996a6faa630d1b"><td class="memItemLeft" align="right" valign="top">TF_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gad12791e5ba9776711b996a6faa630d1b">TfStringTokenize</a> (const std::string &amp;source, const char *delimiters=&quot; \t\n&quot;)</td></tr>
<tr class="memdesc:gad12791e5ba9776711b996a6faa630d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the given string apart, returning a vector of strings.  <a href="#gad12791e5ba9776711b996a6faa630d1b">More...</a><br /></td></tr>
<tr class="separator:gad12791e5ba9776711b996a6faa630d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf315ed978a85fc5db45253354538c924"><td class="memItemLeft" align="right" valign="top">TF_API std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gaf315ed978a85fc5db45253354538c924">TfStringTokenizeToSet</a> (const std::string &amp;source, const char *delimiters=&quot; \t\n&quot;)</td></tr>
<tr class="memdesc:gaf315ed978a85fc5db45253354538c924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the given string apart, returning a set of strings.  <a href="#gaf315ed978a85fc5db45253354538c924">More...</a><br /></td></tr>
<tr class="separator:gaf315ed978a85fc5db45253354538c924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga878abd789ce48a84906f17092b060181"><td class="memItemLeft" align="right" valign="top">TF_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga878abd789ce48a84906f17092b060181">TfQuotedStringTokenize</a> (const std::string &amp;source, const char *delimiters=&quot; \t\n&quot;, std::string *errors=NULL)</td></tr>
<tr class="memdesc:ga878abd789ce48a84906f17092b060181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the given quoted string apart, returning a vector of strings.  <a href="#ga878abd789ce48a84906f17092b060181">More...</a><br /></td></tr>
<tr class="separator:ga878abd789ce48a84906f17092b060181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee93c5e6983de60eb856fceb6daa64e4"><td class="memItemLeft" align="right" valign="top">TF_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gaee93c5e6983de60eb856fceb6daa64e4">TfMatchedStringTokenize</a> (const std::string &amp;source, char openDelimiter, char closeDelimiter, char escapeCharacter='\0', std::string *errors=NULL)</td></tr>
<tr class="memdesc:gaee93c5e6983de60eb856fceb6daa64e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the given string apart by matching delimiters.  <a href="#gaee93c5e6983de60eb856fceb6daa64e4">More...</a><br /></td></tr>
<tr class="separator:gaee93c5e6983de60eb856fceb6daa64e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga989b2d5332b2b1b5a869eba7062a4429"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga989b2d5332b2b1b5a869eba7062a4429">TfMatchedStringTokenize</a> (const std::string &amp;source, char openDelimiter, char closeDelimiter, std::string *errors)</td></tr>
<tr class="memdesc:ga989b2d5332b2b1b5a869eba7062a4429"><td class="mdescLeft">&#160;</td><td class="mdescRight">This overloaded version of <code>TfMatchedStringTokenize</code> does not take an <code>escapeCharacter</code> parameter but does take.  <a href="#ga989b2d5332b2b1b5a869eba7062a4429">More...</a><br /></td></tr>
<tr class="separator:ga989b2d5332b2b1b5a869eba7062a4429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7554a67d6bbf6eae3f12131757f13d36"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7554a67d6bbf6eae3f12131757f13d36"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga7554a67d6bbf6eae3f12131757f13d36">TfStringify</a> (const T &amp;v)</td></tr>
<tr class="memdesc:ga7554a67d6bbf6eae3f12131757f13d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an arbitrary type into a string.  <a href="#ga7554a67d6bbf6eae3f12131757f13d36">More...</a><br /></td></tr>
<tr class="separator:ga7554a67d6bbf6eae3f12131757f13d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58598a7ac8a668999f3eb636fb829fa6"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga58598a7ac8a668999f3eb636fb829fa6">TfStringify</a> (bool v)</td></tr>
<tr class="separator:ga58598a7ac8a668999f3eb636fb829fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad579d7a6cc3940fdf0f68f112fba50cc"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gad579d7a6cc3940fdf0f68f112fba50cc">TfStringify</a> (std::string const &amp;)</td></tr>
<tr class="separator:gad579d7a6cc3940fdf0f68f112fba50cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8052dd5f6567ee32be0c031babd977d"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gae8052dd5f6567ee32be0c031babd977d">TfStringify</a> (float)</td></tr>
<tr class="separator:gae8052dd5f6567ee32be0c031babd977d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae9cf24d4c04b84f808cc62fe7c8e5d2"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gaae9cf24d4c04b84f808cc62fe7c8e5d2">TfStringify</a> (double)</td></tr>
<tr class="separator:gaae9cf24d4c04b84f808cc62fe7c8e5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57115176ec4d2251da17677287347dbb"><td class="memItemLeft" align="right" valign="top">TF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga57115176ec4d2251da17677287347dbb">TfDoubleToString</a> (double d, char *buffer, int len, bool emitTrailingZero)</td></tr>
<tr class="memdesc:ga57115176ec4d2251da17677287347dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the string representation of <code>d</code> to <code>buffer</code> of length <code>len</code>.  <a href="#ga57115176ec4d2251da17677287347dbb">More...</a><br /></td></tr>
<tr class="separator:ga57115176ec4d2251da17677287347dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6643f7d1a1e3913862212d5fef53303"><td class="memItemLeft" align="right" valign="top"><a id="gaa6643f7d1a1e3913862212d5fef53303"></a>
TF_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;o, <a class="el" href="struct_tf_stream_float.html">TfStreamFloat</a> t)</td></tr>
<tr class="separator:gaa6643f7d1a1e3913862212d5fef53303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5ac1b82b3e090927a465671db89fd25"><td class="memItemLeft" align="right" valign="top"><a id="gaf5ac1b82b3e090927a465671db89fd25"></a>
TF_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;o, <a class="el" href="struct_tf_stream_double.html">TfStreamDouble</a> t)</td></tr>
<tr class="separator:gaf5ac1b82b3e090927a465671db89fd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c7135a04eb120c2b29104d10524e9b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1c7135a04eb120c2b29104d10524e9b7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga1c7135a04eb120c2b29104d10524e9b7">TfUnstringify</a> (const std::string &amp;instring, bool *status=NULL)</td></tr>
<tr class="memdesc:ga1c7135a04eb120c2b29104d10524e9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to an arbitrary type.  <a href="#ga1c7135a04eb120c2b29104d10524e9b7">More...</a><br /></td></tr>
<tr class="separator:ga1c7135a04eb120c2b29104d10524e9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf0a426bf874f8f887f64abc38b0388"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga1bf0a426bf874f8f887f64abc38b0388"><td class="memTemplItemLeft" align="right" valign="top">TF_API bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga1bf0a426bf874f8f887f64abc38b0388">TfUnstringify</a> (const std::string &amp;instring, bool *status)</td></tr>
<tr class="memdesc:ga1bf0a426bf874f8f887f64abc38b0388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to an arbitrary type.  <a href="#ga1bf0a426bf874f8f887f64abc38b0388">More...</a><br /></td></tr>
<tr class="separator:ga1bf0a426bf874f8f887f64abc38b0388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7db15f80d51dbb6182376c689b86cb54"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga7db15f80d51dbb6182376c689b86cb54">TfStringGlobToRegex</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ga7db15f80d51dbb6182376c689b86cb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string with glob characters converted to their regular expression equivalents.  <a href="#ga7db15f80d51dbb6182376c689b86cb54">More...</a><br /></td></tr>
<tr class="separator:ga7db15f80d51dbb6182376c689b86cb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6646faf6bcb393bab4d0e7deffa63c2"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gab6646faf6bcb393bab4d0e7deffa63c2">TfEscapeString</a> (const std::string &amp;in)</td></tr>
<tr class="memdesc:gab6646faf6bcb393bab4d0e7deffa63c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process escape sequences in ANSI C string constants.  <a href="#gab6646faf6bcb393bab4d0e7deffa63c2">More...</a><br /></td></tr>
<tr class="separator:gab6646faf6bcb393bab4d0e7deffa63c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40fe85ada23efac4548638f78085e987"><td class="memItemLeft" align="right" valign="top"><a id="ga40fe85ada23efac4548638f78085e987"></a>
TF_API void&#160;</td><td class="memItemRight" valign="bottom"><b>TfEscapeStringReplaceChar</b> (const char **in, char **out)</td></tr>
<tr class="separator:ga40fe85ada23efac4548638f78085e987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6e041049a2367beb8cbd7c8efee5c85"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gaa6e041049a2367beb8cbd7c8efee5c85">TfStringCatPaths</a> (const std::string &amp;prefix, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:gaa6e041049a2367beb8cbd7c8efee5c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two strings containing '/' and '..' tokens like a file path or scope name.  <a href="#gaa6e041049a2367beb8cbd7c8efee5c85">More...</a><br /></td></tr>
<tr class="separator:gaa6e041049a2367beb8cbd7c8efee5c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa129b294af3f68d01477d430b70d40c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gaa129b294af3f68d01477d430b70d40c8">TfIsValidIdentifier</a> (std::string const &amp;identifier)</td></tr>
<tr class="memdesc:gaa129b294af3f68d01477d430b70d40c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether <em>identifier</em> is valid.  <a href="#gaa129b294af3f68d01477d430b70d40c8">More...</a><br /></td></tr>
<tr class="separator:gaa129b294af3f68d01477d430b70d40c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68e587cc7f9f5a5dd3ae8f03dcffe15c"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#ga68e587cc7f9f5a5dd3ae8f03dcffe15c">TfMakeValidIdentifier</a> (const std::string &amp;in)</td></tr>
<tr class="memdesc:ga68e587cc7f9f5a5dd3ae8f03dcffe15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a valid identifier (see TfIsValidIdentifier) from <code>in</code> by replacing invalid characters with '_'.  <a href="#ga68e587cc7f9f5a5dd3ae8f03dcffe15c">More...</a><br /></td></tr>
<tr class="separator:ga68e587cc7f9f5a5dd3ae8f03dcffe15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0fabf3c64bda983fe69edea41ac87f3"><td class="memItemLeft" align="right" valign="top">TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__tf___string.html#gaf0fabf3c64bda983fe69edea41ac87f3">TfGetXmlEscapedString</a> (const std::string &amp;in)</td></tr>
<tr class="memdesc:gaf0fabf3c64bda983fe69edea41ac87f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escapes characters in <em>in</em> so that they are valid XML.  <a href="#gaf0fabf3c64bda983fe69edea41ac87f3">More...</a><br /></td></tr>
<tr class="separator:gaf0fabf3c64bda983fe69edea41ac87f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions/classes for string manipulation. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga57115176ec4d2251da17677287347dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57115176ec4d2251da17677287347dbb">&#9670;&nbsp;</a></span>TfDoubleToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API bool TfDoubleToString </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emitTrailingZero</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the string representation of <code>d</code> to <code>buffer</code> of length <code>len</code>. </p>
<p>If <code>emitTrailingZero</code> is true, the string representation will end with .0 in the case where d is an integer otherwise it will be omitted. The buffer length must be at least 25 in order to ensure that all doubles values can be represented. Returns whether the conversion was successful. </p>

</div>
</div>
<a id="gab6646faf6bcb393bab4d0e7deffa63c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6646faf6bcb393bab4d0e7deffa63c2">&#9670;&nbsp;</a></span>TfEscapeString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfEscapeString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process escape sequences in ANSI C string constants. </p>
<p>The following escape sequences are accepted:</p>
<ul>
<li>\\: backslash </li>
<li>\a: ring the bell </li>
<li>\b: backspace </li>
<li>\f: form feed </li>
<li>\n: new line </li>
<li>\r: carriage return </li>
<li>\t: tab </li>
<li>\v: vertical tab </li>
<li>\xdd: hex constant </li>
<li>\ddd: octal constant</li>
</ul>
<p>So, if the two-character sequence "\\n" appears in the string, it is replaced by an actual newline. Each hex and octal constant translates into one character in the output string. Hex constants can be up to 2 digits, octal constants can be up to 3 digits. Both are terminated by a character that is not a valid constant. Note that it is good practice to encode hex and octal constants with maximum width (2 and 3 digits, respectively) using leading zeroes if necessary. This avoids problems where characters after the hex/octal constant that shouldn't be part of the constant get interpreted as part of it. For example, the sequence "\x2defaced" will produce the characters "-efaced" when what was probably intended was the character 0x02 (STX) followed by "defaced". Illegal escape sequences are replaced by the character following the backslash, so the two character sequence "\\c" would become "c". Processing continues until the input hits a NUL character in the input string - anything appearing after the NUL will be ignored. </p>

</div>
</div>
<a id="gadcc90872f80f8023a17118edf91ec75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcc90872f80f8023a17118edf91ec75c">&#9670;&nbsp;</a></span>TfGetBaseName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfGetBaseName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the base name of a file (final component of the path). </p>

</div>
</div>
<a id="gaf2d7260aded12055629188966c8f7e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2d7260aded12055629188966c8f7e86">&#9670;&nbsp;</a></span>TfGetPathName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfGetPathName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the path component of a file (complement of <a class="el" href="group__group__tf___string.html#gadcc90872f80f8023a17118edf91ec75c" title="Returns the base name of a file (final component of the path).">TfGetBaseName()</a>). </p>
<p>The returned string ends in a '/' (or possibly a '\' on Windows), unless none was found in <code>fileName</code>, in which case the empty string is returned. In particular, <code>TfGetPathName(s)+TfGetBaseName(s)</code> == <code>s</code> for any string <code>s</code> (as long as <code>s</code> doesn't end with multiple adjacent slashes, which is illegal). </p>

</div>
</div>
<a id="gaf0fabf3c64bda983fe69edea41ac87f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0fabf3c64bda983fe69edea41ac87f3">&#9670;&nbsp;</a></span>TfGetXmlEscapedString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfGetXmlEscapedString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escapes characters in <em>in</em> so that they are valid XML. </p>
<p>Returns the name with special characters (&amp;, &lt;, &gt;, ", ') replaced with the corresponding escape sequences. </p>

</div>
</div>
<a id="ga286f433e8bca5054a868dcbb44786382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga286f433e8bca5054a868dcbb44786382">&#9670;&nbsp;</a></span>TfIntToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TfIntToString </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the given integer as a string. </p>

<p class="definition">Definition at line <a class="el" href="string_utils_8h_source.html#l00108">108</a> of file <a class="el" href="string_utils_8h_source.html">stringUtils.h</a>.</p>

</div>
</div>
<a id="gaa129b294af3f68d01477d430b70d40c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa129b294af3f68d01477d430b70d40c8">&#9670;&nbsp;</a></span>TfIsValidIdentifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TfIsValidIdentifier </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>identifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether <em>identifier</em> is valid. </p>
<p>An identifier is valid if it follows the C/Python identifier convention; that is, it must be at least one character long, must start with a letter or underscore, and must contain only letters, underscores, and numerals. </p>

<p class="definition">Definition at line <a class="el" href="string_utils_8h_source.html#l00712">712</a> of file <a class="el" href="string_utils_8h_source.html">stringUtils.h</a>.</p>

</div>
</div>
<a id="ga68e587cc7f9f5a5dd3ae8f03dcffe15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68e587cc7f9f5a5dd3ae8f03dcffe15c">&#9670;&nbsp;</a></span>TfMakeValidIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfMakeValidIdentifier </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a valid identifier (see TfIsValidIdentifier) from <code>in</code> by replacing invalid characters with '_'. </p>
<p>If <code>in</code> is empty, return "_". </p>

</div>
</div>
<a id="gaee93c5e6983de60eb856fceb6daa64e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee93c5e6983de60eb856fceb6daa64e4">&#9670;&nbsp;</a></span>TfMatchedStringTokenize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::vector&lt;std::string&gt; TfMatchedStringTokenize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>openDelimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>closeDelimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>escapeCharacter</em> = <code>'\0'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errors</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Breaks the given string apart by matching delimiters. </p>
<p>The string <code>source</code> is broken apart into individual words, where a word begins with <code>openDelimiter</code> and ends with a matching <code>closeDelimiter</code>. Any delimiters within the matching delimiters become part of the word, and anything outside matching delimiters gets dropped. For example, <code>TfMatchedStringTokenize</code>("{a} string {to {be} split}", '{', '}') would return a vector containing "a" and "to {be} split". If <code>openDelimiter</code> and <code>closeDelimiter</code> cannot be the same. <code>errors</code>, if provided, contains any error messages. </p>

</div>
</div>
<a id="ga989b2d5332b2b1b5a869eba7062a4429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga989b2d5332b2b1b5a869eba7062a4429">&#9670;&nbsp;</a></span>TfMatchedStringTokenize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; TfMatchedStringTokenize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>openDelimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>closeDelimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This overloaded version of <code>TfMatchedStringTokenize</code> does not take an <code>escapeCharacter</code> parameter but does take. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errors.</td><td>It allows <code>TfMatchedStringTokenize</code> to be called with or without an <code>escapeCharacter</code> and with or without <code>errors</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="string_utils_8h_source.html#l00489">489</a> of file <a class="el" href="string_utils_8h_source.html">stringUtils.h</a>.</p>

</div>
</div>
<a id="ga878abd789ce48a84906f17092b060181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga878abd789ce48a84906f17092b060181">&#9670;&nbsp;</a></span>TfQuotedStringTokenize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::vector&lt;std::string&gt; TfQuotedStringTokenize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delimiters</em> = <code>&quot;&#160;\t\n&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errors</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Breaks the given quoted string apart, returning a vector of strings. </p>
<p>The string <code>source</code> is broken apart into individual words, where a word is delimited by the characters in <code>delimiters</code>. This function is similar to <code>TfStringTokenize</code>, except it considers a quoted string as a single word. The function will preserve quotes that are nested within other quotes or are preceded by a backslash character. <code>errors</code>, if provided, contains any error messages. Delimiters default to white space (space, tab, and newline). </p>

</div>
</div>
<a id="ga266a173b9f73e164456b5ff7577fdd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga266a173b9f73e164456b5ff7577fdd9d">&#9670;&nbsp;</a></span>TfSafeString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TfSafeString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely create a std::string from a (possibly NULL) char*. </p>
<p>If <code>ptr</code> is NULL, the empty string is safely returned. </p>

<p class="definition">Definition at line <a class="el" href="string_utils_8h_source.html#l00103">103</a> of file <a class="el" href="string_utils_8h_source.html">stringUtils.h</a>.</p>

</div>
</div>
<a id="gad14e4ee556adf58a4d9712fa45fd28c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad14e4ee556adf58a4d9712fa45fd28c4">&#9670;&nbsp;</a></span>TfStringCapitalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringCapitalize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the <code>source</code> string with only its first character capitalized. </p>
<p>This emulates the behavior of Python's <code>str.capitalize()</code>. </p>

</div>
</div>
<a id="gaa6e041049a2367beb8cbd7c8efee5c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6e041049a2367beb8cbd7c8efee5c85">&#9670;&nbsp;</a></span>TfStringCatPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringCatPaths </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two strings containing '/' and '..' tokens like a file path or scope name. </p>
<p>Tokenize the input strings using a '/' delimiter. Look for '..' tokens in the suffix and construct the appropriate result.</p>
<p>Examples:</p>
<ul>
<li>TfStringCatPaths( "foo/bar", "jive" ) =&gt; "foo/bar/jive" </li>
<li>TfStringCatPaths( "foo/bar", "../jive" ) =&gt; "foo/jive" </li>
</ul>

</div>
</div>
<a id="ga093436e3b1b3109e05899be5f7638e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga093436e3b1b3109e05899be5f7638e9f">&#9670;&nbsp;</a></span>TfStringContains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API bool TfStringContains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>substring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>s</code> contains <code>substring</code>. </p>

</div>
</div>
<a id="ga697055ba2baa6c4b5921a60dbbfc0bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga697055ba2baa6c4b5921a60dbbfc0bfb">&#9670;&nbsp;</a></span>TfStringContains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TfStringContains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>substring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="string_utils_8h_source.html#l00260">260</a> of file <a class="el" href="string_utils_8h_source.html">stringUtils.h</a>.</p>

</div>
</div>
<a id="gad451dea1974d5a2a597cd44482e82546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad451dea1974d5a2a597cd44482e82546">&#9670;&nbsp;</a></span>TfStringContains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API bool TfStringContains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>substring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gacb023dfd25a6ab8b3696e33e50d80549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb023dfd25a6ab8b3696e33e50d80549">&#9670;&nbsp;</a></span>TfStringEndsWith() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TfStringEndsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>s</code> ends with <code>suffix</code>. </p>

<p class="definition">Definition at line <a class="el" href="string_utils_8h_source.html#l00240">240</a> of file <a class="el" href="string_utils_8h_source.html">stringUtils.h</a>.</p>

</div>
</div>
<a id="gaa2b1cad632066ef0674fb139fc2f1e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2b1cad632066ef0674fb139fc2f1e0a">&#9670;&nbsp;</a></span>TfStringEndsWith() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TfStringEndsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="string_utils_8h_source.html#l00248">248</a> of file <a class="el" href="string_utils_8h_source.html">stringUtils.h</a>.</p>

</div>
</div>
<a id="gac9e93734112b176029a356b304c56767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9e93734112b176029a356b304c56767">&#9670;&nbsp;</a></span>TfStringGetBeforeSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringGetBeforeSuffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns everything up to the suffix of a string. </p>
<p>Returns characters before the final character <code>delimiter</code> (default ".") of a string. Thus not-suffix of "abc.def" is "abc" using "." as the delimiter. If the delimiter does not occur, the original string is returned. </p>

</div>
</div>
<a id="gad2bfa0c8e61096bd0321aec28caa2515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2bfa0c8e61096bd0321aec28caa2515">&#9670;&nbsp;</a></span>TfStringGetCommonPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringGetCommonPrefix </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the common prefix of the input strings, if any. </p>
<p>Copies of the input strings are compared. Returns a new string which is the longest prefix common to both input strings. If the strings have no common prefix, an empty string is returned. </p>

</div>
</div>
<a id="gafd1e0eb3f3e4f9ca32e674330f062697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd1e0eb3f3e4f9ca32e674330f062697">&#9670;&nbsp;</a></span>TfStringGetSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringGetSuffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the suffix of a string. </p>
<p>Returns characters after the final character <code>delimiter</code> (default ".") of a string. Thus suffix of "abc.def" is "def" using "." as the delimiter. If the delimiter does not occur, the empty string is returned. </p>

</div>
</div>
<a id="ga7db15f80d51dbb6182376c689b86cb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7db15f80d51dbb6182376c689b86cb54">&#9670;&nbsp;</a></span>TfStringGlobToRegex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringGlobToRegex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string with glob characters converted to their regular expression equivalents. </p>
<p>Currently, this transforms strings by replacing all instances of '.' with '.', '*' with '.*', and '?' with '.', in that order. </p>

</div>
</div>
<a id="ga7554a67d6bbf6eae3f12131757f13d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7554a67d6bbf6eae3f12131757f13d36">&#9670;&nbsp;</a></span>TfStringify() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string TfStringify </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an arbitrary type into a string. </p>
<p>Use the type's stream output operator to convert it into a string. You are free to use the stream operators in <a class="el" href="ostream_methods_8h.html" title="Handy ostream output for various lib/tf and STL containers.">ostreamMethods.h</a>, but are not required to do so. </p>

<p class="definition">Definition at line <a class="el" href="string_utils_8h_source.html#l00572">572</a> of file <a class="el" href="string_utils_8h_source.html">stringUtils.h</a>.</p>

</div>
</div>
<a id="ga58598a7ac8a668999f3eb636fb829fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58598a7ac8a668999f3eb636fb829fa6">&#9670;&nbsp;</a></span>TfStringify() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringify </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gad579d7a6cc3940fdf0f68f112fba50cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad579d7a6cc3940fdf0f68f112fba50cc">&#9670;&nbsp;</a></span>TfStringify() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringify </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gae8052dd5f6567ee32be0c031babd977d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8052dd5f6567ee32be0c031babd977d">&#9670;&nbsp;</a></span>TfStringify() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringify </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaae9cf24d4c04b84f808cc62fe7c8e5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae9cf24d4c04b84f808cc62fe7c8e5d2">&#9670;&nbsp;</a></span>TfStringify() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringify </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gacd37bcc74ba568292651ece78d667bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd37bcc74ba568292651ece78d667bb9">&#9670;&nbsp;</a></span>TfStringJoin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string TfStringJoin </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates the strings (<code>begin</code>, <code>end</code>), with default separator. </p>
<p>Returns the concatenation of the strings in the range <code>begin</code> to <code>end</code>, with <code>separator</code> (by default, a space) added between each successive pair of strings. </p>

<p class="definition">Definition at line <a class="el" href="string_utils_8h_source.html#l00374">374</a> of file <a class="el" href="string_utils_8h_source.html">stringUtils.h</a>.</p>

</div>
</div>
<a id="ga2693efcb60908bf5b07caa0786ec000a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2693efcb60908bf5b07caa0786ec000a">&#9670;&nbsp;</a></span>TfStringJoin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringJoin </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates <code>strings</code>, with default separator. </p>
<p>Returns the concatenation of the strings in <code>strings</code>, with <code>separator</code> (by default, a space) added between each successive pair of strings. </p>

</div>
</div>
<a id="ga9d739e380be70b26f487bb5476cd07a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d739e380be70b26f487bb5476cd07a7">&#9670;&nbsp;</a></span>TfStringJoin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringJoin </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates <code>strings</code>, with default separator. </p>
<p>Returns the concatenation of the strings in <code>strings</code>, with <code>separator</code> (by default, a space) added between each successive pair of strings. </p>

</div>
</div>
<a id="gae42be5a0255e4c7ba38d087fd97a97db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae42be5a0255e4c7ba38d087fd97a97db">&#9670;&nbsp;</a></span>TfStringPrintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringPrintf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string formed by a printf()-like specification. </p>
<p><code><a class="el" href="group__group__tf___string.html#gae42be5a0255e4c7ba38d087fd97a97db" title="Returns a string formed by a printf()-like specification.">TfStringPrintf()</a></code> is a memory-safe way of forming a string using printf()-like formatting. For example, </p><div class="fragment"><div class="line"><span class="keywordtype">string</span> formatMsg(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; caller, <span class="keywordtype">int</span> i, <span class="keywordtype">double</span> val[])</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> TfStringfPrintf(<span class="stringliteral">&quot;%s: val[%d] = %g\n&quot;</span>, caller.c_str(), i, val[i]);</div><div class="line">}</div></div><!-- fragment --><p>The function is safe only to the extent that the arguments match the formatting string. In particular, be careful to pass strings themselves into <code><a class="el" href="group__group__tf___string.html#gae42be5a0255e4c7ba38d087fd97a97db" title="Returns a string formed by a printf()-like specification.">TfStringPrintf()</a></code> as in the above example (i.e. <code>caller.c_str()</code> as opposed to just passing <code>caller</code>).</p>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="group__group__tf___string.html#gae42be5a0255e4c7ba38d087fd97a97db" title="Returns a string formed by a printf()-like specification.">TfStringPrintf()</a></code> is just a wrapper for <code><a class="el" href="group__group__arch___strings.html#ga0c5e8e089bfd39d71610f329fd3b4090" title="Returns a string formed by a printf()-like specification.">ArchStringPrintf()</a></code>. </dd></dl>

</div>
</div>
<a id="gac52faea3628696e9a242bf79cbce4be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac52faea3628696e9a242bf79cbce4be6">&#9670;&nbsp;</a></span>TfStringReplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringReplace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all occurrences of string <code>from</code> with <code>to</code> in <code>source</code>. </p>
<p>Returns a new string which is created by copying <code>source</code> and replacing every occurrence of <code>from</code> with <code>to</code>. Correctly handles the case in which <code>to</code> contains <code>from</code>. </p>

</div>
</div>
<a id="gaeb4e5db4f6eaf230ae41ff0159316fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb4e5db4f6eaf230ae41ff0159316fa5">&#9670;&nbsp;</a></span>TfStringSplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::vector&lt;std::string&gt; TfStringSplit </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Breaks the given string apart, returning a vector of strings. </p>
<p>The string <code>source</code> is broken apart into individual words, where a word is delimited by the string <code>separator</code>. This function behaves like pythons string split method. </p>

</div>
</div>
<a id="ga197320d753aa921027df5a3a6ab1adb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga197320d753aa921027df5a3a6ab1adb8">&#9670;&nbsp;</a></span>TfStringStartsWith() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TfStringStartsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>s</code> starts with <code>prefix</code>. </p>

<p class="definition">Definition at line <a class="el" href="string_utils_8h_source.html#l00220">220</a> of file <a class="el" href="string_utils_8h_source.html">stringUtils.h</a>.</p>

</div>
</div>
<a id="gac9acd1b6d56d7ba358910f1cb9f040c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9acd1b6d56d7ba358910f1cb9f040c4">&#9670;&nbsp;</a></span>TfStringStartsWith() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TfStringStartsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="string_utils_8h_source.html#l00228">228</a> of file <a class="el" href="string_utils_8h_source.html">stringUtils.h</a>.</p>

</div>
</div>
<a id="gaeab03b8ef5e730ae50cd19cacf4fbb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeab03b8ef5e730ae50cd19cacf4fbb65">&#9670;&nbsp;</a></span>TfStringToDouble() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API double TfStringToDouble </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>txt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts text string to double. </p>
<p>This method converts strings to floating point numbers. It is similar to libc's atof(), but performs the conversion much more quickly.</p>
<p>It expects somewhat valid input: it will continue parsing the input until it hits an unrecognized character, as described by the regexp below, and at that point will return the results up to that point.</p>
<p>(-?[0-9]+(.[0-9]*)?|-?.[0-9]+)([eE][-+]?[0-9]+)?</p>
<p>It will not check to see if there is any input at all, or whitespace after the digits. Ie: TfStringToDouble("") == 0.0 TfStringToDouble("blah") == 0.0 TfStringToDouble("-") == -0.0 TfStringToDouble("1.2foo") == 1.2</p>
<dl class="section note"><dt>Note</dt><dd><code>TfStringToDouble</code> is a wrapper around the extern-c TfStringToDouble </dd></dl>

</div>
</div>
<a id="ga60957f94df2a8e584431b0d80b042df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60957f94df2a8e584431b0d80b042df5">&#9670;&nbsp;</a></span>TfStringToDouble() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API double TfStringToDouble </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga8fa531c70ccef3fb5fbb75e75091a786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fa531c70ccef3fb5fbb75e75091a786">&#9670;&nbsp;</a></span>TfStringToDouble() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API double TfStringToDouble </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga03fa88100e2c0093f0c593acaaa4c396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03fa88100e2c0093f0c593acaaa4c396">&#9670;&nbsp;</a></span>TfStringToInt64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API int64_t TfStringToInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>outOfRange</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a sequence of digits in <code>txt</code> to an int64_t value. </p>
<p>Caller must ensure that <code>txt</code> has content matching:</p>
<div class="fragment"><div class="line">-?[0-9]+</div></div><!-- fragment --><p>If the digit sequence's value is out of range, set <code>*outOfRange</code> to true (if <code>outOfRange</code> is not NULL) and return either std::numeric_limits&lt;int64_t&gt;::min() or max(), whichever is closest to the true value. </p>

</div>
</div>
<a id="ga5857c662ea9a36c77f42f7625a913463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5857c662ea9a36c77f42f7625a913463">&#9670;&nbsp;</a></span>TfStringToInt64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API int64_t TfStringToInt64 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>outOfRange</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gad12791e5ba9776711b996a6faa630d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad12791e5ba9776711b996a6faa630d1b">&#9670;&nbsp;</a></span>TfStringTokenize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::vector&lt;std::string&gt; TfStringTokenize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delimiters</em> = <code>&quot;&#160;\t\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Breaks the given string apart, returning a vector of strings. </p>
<p>The string <code>source</code> is broken apart into individual words, where a word is delimited by the characters in <code>delimiters</code>. Delimiters default to white space (space, tab, and newline).</p>
<p>No empty strings are returned: delimiters at the start or end are ignored, consecutive delimiters are treated as though they were one, and an empty input will result in an empty return vector. </p>

</div>
</div>
<a id="gaf315ed978a85fc5db45253354538c924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf315ed978a85fc5db45253354538c924">&#9670;&nbsp;</a></span>TfStringTokenizeToSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::set&lt;std::string&gt; TfStringTokenizeToSet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delimiters</em> = <code>&quot;&#160;\t\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Breaks the given string apart, returning a set of strings. </p>
<p>Same as TfStringTokenize, except this one returns a set. </p>

</div>
</div>
<a id="gac87e0d845d3c64b8c756945a376ad22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac87e0d845d3c64b8c756945a376ad22b">&#9670;&nbsp;</a></span>TfStringToLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API long TfStringToLong </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>outOfRange</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a sequence of digits in <code>txt</code> to a long int value. </p>
<p>Caller is responsible for ensuring that <code>txt</code> has content matching:</p>
<div class="fragment"><div class="line">-?[0-9]+</div></div><!-- fragment --><p>If the digit sequence's value is out of range, set <code>*outOfRange</code> to true (if <code>outOfRange</code> is not NULL) and return either std::numeric_limits&lt;long&gt;::min() or max(), whichever is closest to the true value. </p>

</div>
</div>
<a id="ga4197b90755833d5aa6b46bd84ae2b376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4197b90755833d5aa6b46bd84ae2b376">&#9670;&nbsp;</a></span>TfStringToLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API long TfStringToLong </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>outOfRange</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga2268a5910931796c2e0a53261e6ce7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2268a5910931796c2e0a53261e6ce7da">&#9670;&nbsp;</a></span>TfStringToLower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringToLower </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes all characters in <code>source</code> lowercase, and returns the result. </p>

</div>
</div>
<a id="ga27db779aeaabe869b15510d0ab2cdf9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27db779aeaabe869b15510d0ab2cdf9b">&#9670;&nbsp;</a></span>TfStringToLowerAscii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringToLowerAscii </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locale-independent case folding of [A-Z] for ASCII or UTF-8 encoded <code>source</code> strings. </p>
<p>This can be used for case insensitive matching where one of the strings being compared either known to be ASCII only by specification (like a URI scheme or an explicit token) or where the specification explicitly notes that only [A-Z] will be matched case insensitively.</p>
<div class="fragment"><div class="line"><a class="code" href="group__group__tf___string.html#gacb023dfd25a6ab8b3696e33e50d80549">TfStringEndsWith</a>(<a class="code" href="group__group__tf___string.html#ga27db779aeaabe869b15510d0ab2cdf9b">TfStringToLowerAscii</a>(<span class="stringliteral">&quot;ü.JPG&quot;</span>), <span class="stringliteral">&quot;.jpg&quot;</span>)</div></div><!-- fragment --> 
</div>
</div>
<a id="gacc528911e7f5d69e43ef990d4b5bb17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc528911e7f5d69e43ef990d4b5bb17a">&#9670;&nbsp;</a></span>TfStringToUInt64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API uint64_t TfStringToUInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>outOfRange</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a sequence of digits in <code>txt</code> to a uint64_t value. </p>
<p>Caller is responsible for ensuring that <code>txt</code> has content matching:</p>
<div class="fragment"><div class="line">[0-9]+</div></div><!-- fragment --><p>If the digit sequence's value is out of range, set <code>*outOfRange</code> to true (if <code>outOfRange</code> is not NULL) and return std::numeric_limits&lt;unsigned long&gt;=""&gt;::max(). </p>

</div>
</div>
<a id="ga1f3aee7ef57cf1b9e48c8dbea3bc5468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f3aee7ef57cf1b9e48c8dbea3bc5468">&#9670;&nbsp;</a></span>TfStringToUInt64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API uint64_t TfStringToUInt64 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>outOfRange</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gad3f8a26ec832a2f46998c868114d7ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3f8a26ec832a2f46998c868114d7ded">&#9670;&nbsp;</a></span>TfStringToULong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API unsigned long TfStringToULong </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>outOfRange</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a sequence of digits in <code>txt</code> to an unsigned long value. </p>
<p>Caller is responsible for ensuring that <code>txt</code> has content matching:</p>
<div class="fragment"><div class="line">[0-9]+</div></div><!-- fragment --><p>If the digit sequence's value is out of range, set <code>*outOfRange</code> to true (if <code>outOfRange</code> is not NULL) and return std::numeric_limits&lt;unsigned long&gt;=""&gt;::max(). </p>

</div>
</div>
<a id="gafc7e37af76c24cb746fadbb409f7184b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc7e37af76c24cb746fadbb409f7184b">&#9670;&nbsp;</a></span>TfStringToULong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API unsigned long TfStringToULong </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>outOfRange</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gae3e7f46e6c7381ec8c93e54918061119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3e7f46e6c7381ec8c93e54918061119">&#9670;&nbsp;</a></span>TfStringToUpper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringToUpper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes all characters in <code>source</code> uppercase, and returns the result. </p>

</div>
</div>
<a id="gafe1cb80f75a655f23b7923f02a849b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe1cb80f75a655f23b7923f02a849b06">&#9670;&nbsp;</a></span>TfStringTrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringTrim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>trimChars</em> = <code>&quot;&#160;\n\t\r&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims characters (by default, whitespace) from the beginning and end of string. </p>
<p>Characters at the beginning and end of <code>s</code> are removed until a character not in <code>trimChars</code> is found; the result is returned. </p>

</div>
</div>
<a id="ga18c42c9ff7aab2733dd4966ba8d74151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18c42c9ff7aab2733dd4966ba8d74151">&#9670;&nbsp;</a></span>TfStringTrimLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringTrimLeft </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>trimChars</em> = <code>&quot;&#160;\n\t\r&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims characters (by default, whitespace) from the left. </p>
<p>Characters from the beginning of <code>s</code> are removed until a character not in <code>trimChars</code> is found; the result is returned. </p>

</div>
</div>
<a id="gae7c4f6847ddb76db0e4f5dbb77f94d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7c4f6847ddb76db0e4f5dbb77f94d56">&#9670;&nbsp;</a></span>TfStringTrimRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfStringTrimRight </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>trimChars</em> = <code>&quot;&#160;\n\t\r&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims characters (by default, whitespace) from the right. </p>
<p>Characters at the end of <code>s</code> are removed until a character not in <code>trimChars</code> is found; the result is returned. </p>

</div>
</div>
<a id="ga1c7135a04eb120c2b29104d10524e9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c7135a04eb120c2b29104d10524e9b7">&#9670;&nbsp;</a></span>TfUnstringify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T TfUnstringify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>status</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to an arbitrary type. </p>
<p>Use the type's stream input operator to get it from a string. If <code>status</code> is non-NULL and <code>instring</code> cannot be converted to a <code>T</code>, <code>*status</code> is set to <code>false</code>; otherwise, <code>*status</code> is not modified. </p>

<p class="definition">Definition at line <a class="el" href="string_utils_8h_source.html#l00631">631</a> of file <a class="el" href="string_utils_8h_source.html">stringUtils.h</a>.</p>

</div>
</div>
<a id="ga1bf0a426bf874f8f887f64abc38b0388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bf0a426bf874f8f887f64abc38b0388">&#9670;&nbsp;</a></span>TfUnstringify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API bool TfUnstringify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>status</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to an arbitrary type. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Use the type's stream input operator to get it from a string. If <code>status</code> is non-NULL and <code>instring</code> cannot be converted to a <code>T</code>, <code>*status</code> is set to <code>false</code>; otherwise, <code>*status</code> is not modified. </p>

<p class="definition">Definition at line <a class="el" href="string_utils_8h_source.html#l00631">631</a> of file <a class="el" href="string_utils_8h_source.html">stringUtils.h</a>.</p>

</div>
</div>
<a id="ga7865a37742a57ae8e151de7eea160920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7865a37742a57ae8e151de7eea160920">&#9670;&nbsp;</a></span>TfVStringPrintf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfVStringPrintf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string formed by a printf()-like specification. </p>
<p><code><a class="el" href="group__group__tf___string.html#ga7865a37742a57ae8e151de7eea160920" title="Returns a string formed by a printf()-like specification.">TfVStringPrintf()</a></code> is equivalent to <code><a class="el" href="group__group__tf___string.html#gae42be5a0255e4c7ba38d087fd97a97db" title="Returns a string formed by a printf()-like specification.">TfStringPrintf()</a></code> except that it is called with a <code>va_list</code> instead of a variable number of arguments. <code><a class="el" href="group__group__tf___string.html#ga7865a37742a57ae8e151de7eea160920" title="Returns a string formed by a printf()-like specification.">TfVStringPrintf()</a></code> does not call the <code>va_end</code> macro. Consequently, the value of <code>ap</code> is undefined after the call. A functions that calls <code><a class="el" href="group__group__tf___string.html#ga7865a37742a57ae8e151de7eea160920" title="Returns a string formed by a printf()-like specification.">TfVStringPrintf()</a></code> should call <code>va_end(ap)</code> itself afterwards.</p>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="group__group__tf___string.html#ga7865a37742a57ae8e151de7eea160920" title="Returns a string formed by a printf()-like specification.">TfVStringPrintf()</a></code> is just a wrapper for <code>ArchVStringPrintf()</code>. </dd></dl>

</div>
</div>
<a id="gac0338d0b229616b6061ee60f971e0dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0338d0b229616b6061ee60f971e0dc1">&#9670;&nbsp;</a></span>TfVStringPrintf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::string TfVStringPrintf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bloat-avoidance version of <a class="el" href="group__group__tf___string.html#ga7865a37742a57ae8e151de7eea160920" title="Returns a string formed by a printf()-like specification.">TfVStringPrintf()</a> </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:58 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>