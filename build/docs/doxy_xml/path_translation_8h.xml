<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="path_translation_8h" kind="file" language="C++">
    <compoundname>pathTranslation.h</compoundname>
    <includes refid="pxr_8h" local="yes">pxr/pxr.h</includes>
    <includes refid="usd_2pcp_2api_8h" local="yes">pxr/usd/pcp/api.h</includes>
    <incdepgraph>
      <node id="165738">
        <label>pxr/base/arch/export.h</label>
        <link refid="export_8h"/>
        <childnode refid="165739" relation="include">
        </childnode>
      </node>
      <node id="165736">
        <label>pxr/pxr.h</label>
        <link refid="pxr_8h"/>
      </node>
      <node id="165739">
        <label>pxr/base/arch/defines.h</label>
        <link refid="defines_8h_source"/>
      </node>
      <node id="165735">
        <label>pxr/usd/pcp/pathTranslation.h</label>
        <link refid="path_translation_8h"/>
        <childnode refid="165736" relation="include">
        </childnode>
        <childnode refid="165737" relation="include">
        </childnode>
      </node>
      <node id="165737">
        <label>pxr/usd/pcp/api.h</label>
        <link refid="usd_2pcp_2api_8h_source"/>
        <childnode refid="165738" relation="include">
        </childnode>
      </node>
    </incdepgraph>
      <sectiondef kind="func">
      <memberdef kind="function" id="path_translation_8h_1aac0d3b0296eb726e76d81fdd4e69b2b7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PCP_API <ref refid="class_sdf_path" kindref="compound">SdfPath</ref></type>
        <definition>PCP_API SdfPath PcpTranslatePathFromNodeToRoot</definition>
        <argsstring>(const PcpNodeRef &amp;sourceNode, const SdfPath &amp;pathInNodeNamespace, bool *pathWasTranslated=0)</argsstring>
        <name>PcpTranslatePathFromNodeToRoot</name>
        <param>
          <type>const <ref refid="class_pcp_node_ref" kindref="compound">PcpNodeRef</ref> &amp;</type>
          <declname>sourceNode</declname>
        </param>
        <param>
          <type>const <ref refid="class_sdf_path" kindref="compound">SdfPath</ref> &amp;</type>
          <declname>pathInNodeNamespace</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>pathWasTranslated</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Translates <computeroutput>pathInNodeNamespace</computeroutput> from the namespace of the prim index node <computeroutput>sourceNode</computeroutput> to the namespace of the prim index&apos;s root node. </para>
        </briefdescription>
        <detaileddescription>
<para>This applies all necessary namespace translations.</para>
<para>If the path is successfully translated and <computeroutput>pathWasTranslated</computeroutput> is supplied, it will be set to <computeroutput>true</computeroutput>. In some cases, paths may fail to translate because they fall outside the set of paths that are allowed by nodes in the prim index. For instance, for a referenced model, paths referring to locations outside that model will not be translated. In these cases, this function will return an empty <ref refid="class_sdf_path" kindref="compound">SdfPath</ref> and <computeroutput>pathWasTranslated</computeroutput> will be set to <computeroutput>false</computeroutput>.</para>
<para>In Sd/Csd terminology, this is forward path translation from the namespace of the prim spec represented by <computeroutput>sourceNode</computeroutput> to the composed scene namespace. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/pcp/pathTranslation.h" line="56" column="1"/>
      </memberdef>
      <memberdef kind="function" id="path_translation_8h_1a7ac9fcfa3b15058379f75daf75fda373" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PCP_API <ref refid="class_sdf_path" kindref="compound">SdfPath</ref></type>
        <definition>PCP_API SdfPath PcpTranslatePathFromRootToNode</definition>
        <argsstring>(const PcpNodeRef &amp;destNode, const SdfPath &amp;pathInRootNamespace, bool *pathWasTranslated=0)</argsstring>
        <name>PcpTranslatePathFromRootToNode</name>
        <param>
          <type>const <ref refid="class_pcp_node_ref" kindref="compound">PcpNodeRef</ref> &amp;</type>
          <declname>destNode</declname>
        </param>
        <param>
          <type>const <ref refid="class_sdf_path" kindref="compound">SdfPath</ref> &amp;</type>
          <declname>pathInRootNamespace</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>pathWasTranslated</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Translates <computeroutput>pathInRootNamespace</computeroutput> from the namespace of the root of the prim index that <computeroutput>destNode</computeroutput> belongs to to the namespace of <computeroutput>destNode</computeroutput> itself. </para>
        </briefdescription>
        <detaileddescription>
<para>This applies all necessary namespace translations.</para>
<para>If the path is successfully translated and <computeroutput>pathWasTranslated</computeroutput> is supplied, it will be set to <computeroutput>true</computeroutput>. In some cases, paths may fail to translate because they fall outside the set of paths that are allowed by nodes in the prim index. For instance, for a referenced model, paths referring to locations outside that model will not be translated. In these cases, this function will return an empty <ref refid="class_sdf_path" kindref="compound">SdfPath</ref> and <computeroutput>pathWasTranslated</computeroutput> will be set to <computeroutput>false</computeroutput>.</para>
<para>In Sd/Csd terminology, this is reverse path translation from the namespace of the composed scene to the namespace of the prim spec represented by <computeroutput>destNode</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/pcp/pathTranslation.h" line="78" column="1"/>
      </memberdef>
      <memberdef kind="function" id="path_translation_8h_1a741a0c639cbd36f4d2690facc198b379" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PCP_API <ref refid="class_sdf_path" kindref="compound">SdfPath</ref></type>
        <definition>PCP_API SdfPath PcpTranslateTargetPathFromRootToNode</definition>
        <argsstring>(const PcpNodeRef &amp;destNode, const SdfPath &amp;pathInRootNamespace, bool *pathWasTranslated=0)</argsstring>
        <name>PcpTranslateTargetPathFromRootToNode</name>
        <param>
          <type>const <ref refid="class_pcp_node_ref" kindref="compound">PcpNodeRef</ref> &amp;</type>
          <declname>destNode</declname>
        </param>
        <param>
          <type>const <ref refid="class_sdf_path" kindref="compound">SdfPath</ref> &amp;</type>
          <declname>pathInRootNamespace</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>pathWasTranslated</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Same as <emphasis>PcpTranslatePathFromRootToNode</emphasis>, but explicitly for use when translating paths intended for use as attribute connections or relationship targets. </para>
        </briefdescription>
        <detaileddescription>
<para>The primary difference is that variant selections will never be included in the translated path. This is functionally equivalent to calling StripAllVariantSelections() on the result of the referenced function, but is more efficient. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/pcp/pathTranslation.h" line="91" column="1"/>
      </memberdef>
      <memberdef kind="function" id="path_translation_8h_1a0a62e5e3c3d1449211920c4b584f4033" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PCP_API <ref refid="class_sdf_path" kindref="compound">SdfPath</ref></type>
        <definition>PCP_API SdfPath PcpTranslatePathFromRootToNodeUsingFunction</definition>
        <argsstring>(const PcpMapFunction &amp;mapToRoot, const SdfPath &amp;pathInRootNamespace, bool *pathWasTranslated=0)</argsstring>
        <name>PcpTranslatePathFromRootToNodeUsingFunction</name>
        <param>
          <type>const <ref refid="class_pcp_map_function" kindref="compound">PcpMapFunction</ref> &amp;</type>
          <declname>mapToRoot</declname>
        </param>
        <param>
          <type>const <ref refid="class_sdf_path" kindref="compound">SdfPath</ref> &amp;</type>
          <declname>pathInRootNamespace</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>pathWasTranslated</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Convenience function like <emphasis>PcpTranslatePathFromRootToNode</emphasis>, but takes a function rather than a node. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/pcp/pathTranslation.h" line="100" column="1"/>
      </memberdef>
      <memberdef kind="function" id="path_translation_8h_1ab3f4be4e8afb68a4edb49f346d9bc0fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PCP_API <ref refid="class_sdf_path" kindref="compound">SdfPath</ref></type>
        <definition>PCP_API SdfPath PcpTranslatePathFromNodeToRootUsingFunction</definition>
        <argsstring>(const PcpMapFunction &amp;mapToRoot, const SdfPath &amp;pathInNodeNamespace, bool *pathWasTranslated=0)</argsstring>
        <name>PcpTranslatePathFromNodeToRootUsingFunction</name>
        <param>
          <type>const <ref refid="class_pcp_map_function" kindref="compound">PcpMapFunction</ref> &amp;</type>
          <declname>mapToRoot</declname>
        </param>
        <param>
          <type>const <ref refid="class_sdf_path" kindref="compound">SdfPath</ref> &amp;</type>
          <declname>pathInNodeNamespace</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>pathWasTranslated</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Convenience function like <emphasis>PcpTranslatePathFromNodeToRoot</emphasis>, but takes a function rather than a node. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/pcp/pathTranslation.h" line="109" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Path translation. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Copyright<sp/>2016<sp/>Pixar</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Licensed<sp/>under<sp/>the<sp/>Apache<sp/>License,<sp/>Version<sp/>2.0<sp/>(the<sp/>&quot;Apache<sp/>License&quot;)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight><highlight class="comment">//<sp/>with<sp/>the<sp/>following<sp/>modification;<sp/>you<sp/>may<sp/>not<sp/>use<sp/>this<sp/>file<sp/>except<sp/>in</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="comment">//<sp/>compliance<sp/>with<sp/>the<sp/>Apache<sp/>License<sp/>and<sp/>the<sp/>following<sp/>modification<sp/>to<sp/>it:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Section<sp/>6.<sp/>Trademarks.<sp/>is<sp/>deleted<sp/>and<sp/>replaced<sp/>with:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight><highlight class="comment">//<sp/>6.<sp/>Trademarks.<sp/>This<sp/>License<sp/>does<sp/>not<sp/>grant<sp/>permission<sp/>to<sp/>use<sp/>the<sp/>trade</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>names,<sp/>trademarks,<sp/>service<sp/>marks,<sp/>or<sp/>product<sp/>names<sp/>of<sp/>the<sp/>Licensor</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>and<sp/>its<sp/>affiliates,<sp/>except<sp/>as<sp/>required<sp/>to<sp/>comply<sp/>with<sp/>Section<sp/>4(c)<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>the<sp/>License<sp/>and<sp/>to<sp/>reproduce<sp/>the<sp/>content<sp/>of<sp/>the<sp/>NOTICE<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight><highlight class="comment">//<sp/>You<sp/>may<sp/>obtain<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>Apache<sp/>License<sp/>at</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>http://www.apache.org/licenses/LICENSE-2.0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Unless<sp/>required<sp/>by<sp/>applicable<sp/>law<sp/>or<sp/>agreed<sp/>to<sp/>in<sp/>writing,<sp/>software</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight><highlight class="comment">//<sp/>distributed<sp/>under<sp/>the<sp/>Apache<sp/>License<sp/>with<sp/>the<sp/>above<sp/>modification<sp/>is</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight><highlight class="comment">//<sp/>distributed<sp/>on<sp/>an<sp/>&quot;AS<sp/>IS&quot;<sp/>BASIS,<sp/>WITHOUT<sp/>WARRANTIES<sp/>OR<sp/>CONDITIONS<sp/>OF<sp/>ANY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="comment">//<sp/>KIND,<sp/>either<sp/>express<sp/>or<sp/>implied.<sp/>See<sp/>the<sp/>Apache<sp/>License<sp/>for<sp/>the<sp/>specific</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight><highlight class="comment">//<sp/>language<sp/>governing<sp/>permissions<sp/>and<sp/>limitations<sp/>under<sp/>the<sp/>Apache<sp/>License.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>PXR_USD_PCP_PATH_TRANSLATION_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>PXR_USD_PCP_PATH_TRANSLATION_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight></codeline>
<codeline lineno="30"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="pxr_8h" kindref="compound">pxr/pxr.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="31"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pxr/usd/pcp/api.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"></highlight></codeline>
<codeline lineno="33"><highlight class="normal">PXR_NAMESPACE_OPEN_SCOPE</highlight></codeline>
<codeline lineno="34"><highlight class="normal"></highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="class_pcp_map_function" kindref="compound">PcpMapFunction</ref>;</highlight></codeline>
<codeline lineno="36"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="class_pcp_node_ref" kindref="compound">PcpNodeRef</ref>;</highlight></codeline>
<codeline lineno="37"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="class_sdf_path" kindref="compound">SdfPath</ref>;</highlight></codeline>
<codeline lineno="38"><highlight class="normal"></highlight></codeline>
<codeline lineno="54"><highlight class="normal">PCP_API</highlight></codeline>
<codeline lineno="55"><highlight class="normal"><ref refid="class_sdf_path" kindref="compound">SdfPath</ref></highlight></codeline>
<codeline lineno="56"><highlight class="normal"><ref refid="path_translation_8h_1aac0d3b0296eb726e76d81fdd4e69b2b7" kindref="member">PcpTranslatePathFromNodeToRoot</ref>(</highlight></codeline>
<codeline lineno="57"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_pcp_node_ref" kindref="compound">PcpNodeRef</ref>&amp;<sp/>sourceNode,<sp/></highlight></codeline>
<codeline lineno="58"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_sdf_path" kindref="compound">SdfPath</ref>&amp;<sp/>pathInNodeNamespace,</highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">*<sp/>pathWasTranslated<sp/>=<sp/>0);</highlight></codeline>
<codeline lineno="60"><highlight class="normal"></highlight></codeline>
<codeline lineno="76"><highlight class="normal">PCP_API</highlight></codeline>
<codeline lineno="77"><highlight class="normal"><ref refid="class_sdf_path" kindref="compound">SdfPath</ref></highlight></codeline>
<codeline lineno="78"><highlight class="normal"><ref refid="path_translation_8h_1a7ac9fcfa3b15058379f75daf75fda373" kindref="member">PcpTranslatePathFromRootToNode</ref>(</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_pcp_node_ref" kindref="compound">PcpNodeRef</ref>&amp;<sp/>destNode,</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_sdf_path" kindref="compound">SdfPath</ref>&amp;<sp/>pathInRootNamespace,</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">*<sp/>pathWasTranslated<sp/>=<sp/>0);</highlight></codeline>
<codeline lineno="82"><highlight class="normal"></highlight></codeline>
<codeline lineno="89"><highlight class="normal">PCP_API</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><ref refid="class_sdf_path" kindref="compound">SdfPath</ref></highlight></codeline>
<codeline lineno="91"><highlight class="normal"><ref refid="path_translation_8h_1a741a0c639cbd36f4d2690facc198b379" kindref="member">PcpTranslateTargetPathFromRootToNode</ref>(</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_pcp_node_ref" kindref="compound">PcpNodeRef</ref>&amp;<sp/>destNode,</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_sdf_path" kindref="compound">SdfPath</ref>&amp;<sp/>pathInRootNamespace,</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">*<sp/>pathWasTranslated<sp/>=<sp/>0);</highlight></codeline>
<codeline lineno="95"><highlight class="normal"></highlight></codeline>
<codeline lineno="98"><highlight class="normal">PCP_API</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><ref refid="class_sdf_path" kindref="compound">SdfPath</ref></highlight></codeline>
<codeline lineno="100"><highlight class="normal"><ref refid="path_translation_8h_1a0a62e5e3c3d1449211920c4b584f4033" kindref="member">PcpTranslatePathFromRootToNodeUsingFunction</ref>(</highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_pcp_map_function" kindref="compound">PcpMapFunction</ref><sp/>&amp;mapToRoot,</highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_sdf_path" kindref="compound">SdfPath</ref><sp/>&amp;pathInRootNamespace,</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>*pathWasTranslated<sp/>=<sp/>0);</highlight></codeline>
<codeline lineno="104"><highlight class="normal"></highlight></codeline>
<codeline lineno="107"><highlight class="normal">PCP_API</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><ref refid="class_sdf_path" kindref="compound">SdfPath</ref></highlight></codeline>
<codeline lineno="109"><highlight class="normal"><ref refid="path_translation_8h_1ab3f4be4e8afb68a4edb49f346d9bc0fa" kindref="member">PcpTranslatePathFromNodeToRootUsingFunction</ref>(</highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_pcp_map_function" kindref="compound">PcpMapFunction</ref><sp/>&amp;mapToRoot,</highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="class_sdf_path" kindref="compound">SdfPath</ref><sp/>&amp;pathInNodeNamespace,</highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>*pathWasTranslated<sp/>=<sp/>0);</highlight></codeline>
<codeline lineno="113"><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal">PXR_NAMESPACE_CLOSE_SCOPE</highlight></codeline>
<codeline lineno="115"><highlight class="normal"></highlight></codeline>
<codeline lineno="116"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/>//<sp/>PXR_USD_PCP_PATH_TRANSLATION_H</highlight></codeline>
    </programlisting>
    <location file="pxr/usd/pcp/pathTranslation.h"/>
  </compounddef>
</doxygen>
