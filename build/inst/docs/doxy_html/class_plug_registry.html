<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: PlugRegistry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_plug_registry.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_plug_registry-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PlugRegistry Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines an interface for registering plugins.  
 <a href="class_plug_registry.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for PlugRegistry:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_plug_registry__inherit__graph.png" border="0" usemap="#_plug_registry_inherit__map" alt="Inheritance graph"/></div>
<map name="_plug_registry_inherit__map" id="_plug_registry_inherit__map">
<area shape="rect"  title="Defines an interface for registering plugins." alt="" coords="5,80,107,107"/>
<area shape="rect"  href="class_tf_weak_base.html" title="Enable a concrete base class for use with TfWeakPtr." alt="" coords="5,5,107,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab096e6a24e35ffd8c12719cb632570b7"><td class="memItemLeft" align="right" valign="top"><a id="ab096e6a24e35ffd8c12719cb632570b7"></a>
typedef <a class="el" href="class_plug_registry.html">PlugRegistry</a>&#160;</td><td class="memItemRight" valign="bottom"><b>This</b></td></tr>
<tr class="separator:ab096e6a24e35ffd8c12719cb632570b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea5a2717c8af13dadc9919e197ffe5b"><td class="memItemLeft" align="right" valign="top"><a id="adea5a2717c8af13dadc9919e197ffe5b"></a>
typedef std::vector&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TypeVector</b></td></tr>
<tr class="separator:adea5a2717c8af13dadc9919e197ffe5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ada54bcdd334de360eddab430894dd5ac"><td class="memItemLeft" align="right" valign="top">PLUG_API PlugPluginPtrVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plug_registry.html#ada54bcdd334de360eddab430894dd5ac">RegisterPlugins</a> (const std::string &amp;pathToPlugInfo)</td></tr>
<tr class="memdesc:ada54bcdd334de360eddab430894dd5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all plug-ins discovered at <em>pathToPlugInfo</em>.  <a href="#ada54bcdd334de360eddab430894dd5ac">More...</a><br /></td></tr>
<tr class="separator:ada54bcdd334de360eddab430894dd5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fe0749d24f0dd2a909a6abf2d427f9"><td class="memItemLeft" align="right" valign="top">PLUG_API PlugPluginPtrVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plug_registry.html#a43fe0749d24f0dd2a909a6abf2d427f9">RegisterPlugins</a> (const std::vector&lt; std::string &gt; &amp;pathsToPlugInfo)</td></tr>
<tr class="memdesc:a43fe0749d24f0dd2a909a6abf2d427f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all plug-ins discovered in any of <em>pathsToPlugInfo</em>.  <a href="#a43fe0749d24f0dd2a909a6abf2d427f9">More...</a><br /></td></tr>
<tr class="separator:a43fe0749d24f0dd2a909a6abf2d427f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5dfc1c3b55017173c9df93b091424c"><td class="memItemLeft" align="right" valign="top">PLUG_API PlugPluginPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plug_registry.html#a4c5dfc1c3b55017173c9df93b091424c">GetPluginForType</a> (<a class="el" href="class_tf_type.html">TfType</a> t) const</td></tr>
<tr class="memdesc:a4c5dfc1c3b55017173c9df93b091424c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the plug-in for the given type, or a null pointer if there is no registered plug-in.  <a href="#a4c5dfc1c3b55017173c9df93b091424c">More...</a><br /></td></tr>
<tr class="separator:a4c5dfc1c3b55017173c9df93b091424c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa395fd445592f25012f9406b155431d7"><td class="memItemLeft" align="right" valign="top">PLUG_API PlugPluginPtrVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plug_registry.html#aa395fd445592f25012f9406b155431d7">GetAllPlugins</a> () const</td></tr>
<tr class="memdesc:aa395fd445592f25012f9406b155431d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all registered plug-ins.  <a href="#aa395fd445592f25012f9406b155431d7">More...</a><br /></td></tr>
<tr class="separator:aa395fd445592f25012f9406b155431d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab64fbe6f5a8d113e4f31a3bde0959a"><td class="memItemLeft" align="right" valign="top">PLUG_API PlugPluginPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plug_registry.html#abab64fbe6f5a8d113e4f31a3bde0959a">GetPluginWithName</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:abab64fbe6f5a8d113e4f31a3bde0959a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a plugin with the specified library name.  <a href="#abab64fbe6f5a8d113e4f31a3bde0959a">More...</a><br /></td></tr>
<tr class="separator:abab64fbe6f5a8d113e4f31a3bde0959a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545f23185a7f34a760b125daa5a6698a"><td class="memItemLeft" align="right" valign="top">PLUG_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plug_registry.html#a545f23185a7f34a760b125daa5a6698a">GetStringFromPluginMetaData</a> (<a class="el" href="class_tf_type.html">TfType</a> type, const std::string &amp;key) const</td></tr>
<tr class="memdesc:a545f23185a7f34a760b125daa5a6698a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for a string associated with <em>type</em> and <em>key</em> and returns it, or an empty string if <em>type</em> or <em>key</em> are not found.  <a href="#a545f23185a7f34a760b125daa5a6698a">More...</a><br /></td></tr>
<tr class="separator:a545f23185a7f34a760b125daa5a6698a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a448ab0535968b4b3f1ef497322398"><td class="memItemLeft" align="right" valign="top">PLUG_API <a class="el" href="class_js_value.html">JsValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plug_registry.html#a51a448ab0535968b4b3f1ef497322398">GetDataFromPluginMetaData</a> (<a class="el" href="class_tf_type.html">TfType</a> type, const std::string &amp;key) const</td></tr>
<tr class="memdesc:a51a448ab0535968b4b3f1ef497322398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for a <a class="el" href="class_js_value.html" title="A discriminated union type for JSON values.">JsValue</a> associated with <em>type</em> and <em>key</em> and returns it, or a null <a class="el" href="class_js_value.html" title="A discriminated union type for JSON values.">JsValue</a> if <em>type</em> or <em>key</em> are not found.  <a href="#a51a448ab0535968b4b3f1ef497322398">More...</a><br /></td></tr>
<tr class="separator:a51a448ab0535968b4b3f1ef497322398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_tf_weak_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_tf_weak_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_tf_weak_base.html">TfWeakBase</a></td></tr>
<tr class="memitem:affc4c00d0bbfdfe4f9e6a8b2e81be368 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="affc4c00d0bbfdfe4f9e6a8b2e81be368"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TfWeakBase</b> (const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;)</td></tr>
<tr class="separator:affc4c00d0bbfdfe4f9e6a8b2e81be368 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aa4c4b93df067f2ec9b9e5fa4c35b3 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a01aa4c4b93df067f2ec9b9e5fa4c35b3"></a>
const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>__GetTfWeakBase__</b> () const</td></tr>
<tr class="separator:a01aa4c4b93df067f2ec9b9e5fa4c35b3 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af890ac314073e903458bf6b2397566b5 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="af890ac314073e903458bf6b2397566b5"></a>
const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;)</td></tr>
<tr class="separator:af890ac314073e903458bf6b2397566b5 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f1e27cc0c7c606ffb397b7d970ed10 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a16f1e27cc0c7c606ffb397b7d970ed10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EnableNotification2</b> () const</td></tr>
<tr class="separator:a16f1e27cc0c7c606ffb397b7d970ed10 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3241c32a82fbed0716a77049f6134e1e inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a3241c32a82fbed0716a77049f6134e1e"></a>
TF_API void const  *&#160;</td><td class="memItemRight" valign="bottom"><b>GetUniqueIdentifier</b> () const</td></tr>
<tr class="separator:a3241c32a82fbed0716a77049f6134e1e inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8b287622f64269e7f9edd1410436d805"><td class="memItemLeft" align="right" valign="top">static PLUG_API <a class="el" href="class_plug_registry.html">PlugRegistry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plug_registry.html#a8b287622f64269e7f9edd1410436d805">GetInstance</a> ()</td></tr>
<tr class="memdesc:a8b287622f64269e7f9edd1410436d805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the singleton <code><a class="el" href="class_plug_registry.html" title="Defines an interface for registering plugins.">PlugRegistry</a></code> instance.  <a href="#a8b287622f64269e7f9edd1410436d805">More...</a><br /></td></tr>
<tr class="separator:a8b287622f64269e7f9edd1410436d805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b3d4cb0992361d63ea170161fc6171"><td class="memItemLeft" align="right" valign="top">static PLUG_API <a class="el" href="class_tf_type.html">TfType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plug_registry.html#ad4b3d4cb0992361d63ea170161fc6171">FindTypeByName</a> (std::string const &amp;typeName)</td></tr>
<tr class="memdesc:ad4b3d4cb0992361d63ea170161fc6171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to the given <code>name</code>.  <a href="#ad4b3d4cb0992361d63ea170161fc6171">More...</a><br /></td></tr>
<tr class="separator:ad4b3d4cb0992361d63ea170161fc6171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d9978a85af6f5020d5f07a8ba644cf"><td class="memItemLeft" align="right" valign="top">static PLUG_API <a class="el" href="class_tf_type.html">TfType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plug_registry.html#ab8d9978a85af6f5020d5f07a8ba644cf">FindDerivedTypeByName</a> (<a class="el" href="class_tf_type.html">TfType</a> base, std::string const &amp;typeName)</td></tr>
<tr class="memdesc:ab8d9978a85af6f5020d5f07a8ba644cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> that derives from <code>base</code> and has the given alias or type name <code>typeName</code>.  <a href="#ab8d9978a85af6f5020d5f07a8ba644cf">More...</a><br /></td></tr>
<tr class="separator:ab8d9978a85af6f5020d5f07a8ba644cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad656572db5fa6cb4d0a4b7ab17b3880f"><td class="memTemplParams" colspan="2">template&lt;class Base &gt; </td></tr>
<tr class="memitem:ad656572db5fa6cb4d0a4b7ab17b3880f"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_tf_type.html">TfType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_plug_registry.html#ad656572db5fa6cb4d0a4b7ab17b3880f">FindDerivedTypeByName</a> (std::string const &amp;typeName)</td></tr>
<tr class="memdesc:ad656572db5fa6cb4d0a4b7ab17b3880f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> that derives from <code>Base</code> and has the given alias or type name <code>typeName</code>.  <a href="#ad656572db5fa6cb4d0a4b7ab17b3880f">More...</a><br /></td></tr>
<tr class="separator:ad656572db5fa6cb4d0a4b7ab17b3880f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491223b1f382752c136b50925cbc6d07"><td class="memItemLeft" align="right" valign="top">static PLUG_API std::vector&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plug_registry.html#a491223b1f382752c136b50925cbc6d07">GetDirectlyDerivedTypes</a> (<a class="el" href="class_tf_type.html">TfType</a> base)</td></tr>
<tr class="memdesc:a491223b1f382752c136b50925cbc6d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of types derived directly from <em>base</em>.  <a href="#a491223b1f382752c136b50925cbc6d07">More...</a><br /></td></tr>
<tr class="separator:a491223b1f382752c136b50925cbc6d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af859ac657fb599ad71583621d0cf805b"><td class="memItemLeft" align="right" valign="top">static PLUG_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plug_registry.html#af859ac657fb599ad71583621d0cf805b">GetAllDerivedTypes</a> (<a class="el" href="class_tf_type.html">TfType</a> base, std::set&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt; *result)</td></tr>
<tr class="memdesc:af859ac657fb599ad71583621d0cf805b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the set of all types derived (directly or indirectly) from <em>base</em>.  <a href="#af859ac657fb599ad71583621d0cf805b">More...</a><br /></td></tr>
<tr class="separator:af859ac657fb599ad71583621d0cf805b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bd4722b659ca5c2ee2dd93ec79db67"><td class="memTemplParams" colspan="2">template&lt;class Base &gt; </td></tr>
<tr class="memitem:a07bd4722b659ca5c2ee2dd93ec79db67"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_plug_registry.html#a07bd4722b659ca5c2ee2dd93ec79db67">GetAllDerivedTypes</a> (std::set&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt; *result)</td></tr>
<tr class="memdesc:a07bd4722b659ca5c2ee2dd93ec79db67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the set of all types derived (directly or indirectly) from <em>Base</em>.  <a href="#a07bd4722b659ca5c2ee2dd93ec79db67">More...</a><br /></td></tr>
<tr class="separator:a07bd4722b659ca5c2ee2dd93ec79db67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a610a5b8b8da196db90eb4d99d542a4f6"><td class="memItemLeft" align="right" valign="top"><a id="a610a5b8b8da196db90eb4d99d542a4f6"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TfSingleton&lt; PlugRegistry &gt;</b></td></tr>
<tr class="separator:a610a5b8b8da196db90eb4d99d542a4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcd707c468bf0fb07ddb3e2d6a58367"><td class="memItemLeft" align="right" valign="top"><a id="a4bcd707c468bf0fb07ddb3e2d6a58367"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PlugPlugin</b></td></tr>
<tr class="separator:a4bcd707c468bf0fb07ddb3e2d6a58367"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_tf_weak_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_tf_weak_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_tf_weak_base.html">TfWeakBase</a></td></tr>
<tr class="memitem:a95139d2f4d04eb706664a4f47eb93918 inherit pro_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a95139d2f4d04eb706664a4f47eb93918"></a>
<a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; Tf_Remnant &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_Register</b> () const</td></tr>
<tr class="separator:a95139d2f4d04eb706664a4f47eb93918 inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memTemplParams" colspan="2"><a id="ac1312732482c8a286522f703f2cf90d1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; Tf_Remnant &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_Register</b> (T *tempRmnt) const</td></tr>
<tr class="separator:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5533162e8efab1be47acd6ccd5254c inherit pro_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a6a5533162e8efab1be47acd6ccd5254c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_HasRemnant</b> () const</td></tr>
<tr class="separator:a6a5533162e8efab1be47acd6ccd5254c inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines an interface for registering plugins. </p>
<p><a class="el" href="class_plug_registry.html" title="Defines an interface for registering plugins.">PlugRegistry</a> maintains a registry of plug-ins known to the system and provides an interface for base classes to load any plug-ins required to instantiate a subclass of a given type.</p>
<h2>Defining a Base Class API</h2>
<p>In order to use this facility you will generally provide a library which defines the API for a plug-in base class. This API will be sufficient for the application or framework to make use of custom subclasses that will be written by plug-in developers.</p>
<p>For example, if you have an image processing application, you might want to support plug-ins that implement image filters. You can define an abstract base class for image filters that declares the API your application will require image filters to implement; perhaps something simple like <a class="el" href="class_plug_registry.html#plug_cppcode_PlugRegistry1">C++ Code Example 1</a> (Doxygen only).</p>
<p>People writing custom filters would write a subclass of ImageFilter that overrides the two methods, implementing their own special filtering behavior.</p>
<h1><a class="anchor" id="plug_EnablingPlugins"></a>
Enabling Plug-in Loading for the Base Class</h1>
<p>In order for ImageFilter to be able to load plug-ins that implement these custom subclasses, it must be registered with the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> system.</p>
<p>The ImageFilter base class, as was mentioned earlier, should be made available in a library that the application links with. This is done so that plug-ins that want to provide ImageFilters can also link with the library allowing them to subclass ImageFilter.</p>
<h1><a class="anchor" id="plug_RegisteringPlugins"></a>
Registering Plug-ins</h1>
<p>A plug-in developer can now write plug-ins with ImageFilter subclasses. Plug-ins can be implemented either as native dynamic libraries (either regular dynamic libraries or framework bundles) or as Python modules.</p>
<p>Plug-ins must be registered with the registry. All plugins are registered via <a class="el" href="class_plug_registry.html#ada54bcdd334de360eddab430894dd5ac" title="Registers all plug-ins discovered at pathToPlugInfo.">RegisterPlugins()</a>. Plug-in Python modules must be directly importable (in other words they must be able to be found in Python's module path.) Plugins are registered by providing a path or paths to JSON files that describe the location, structure and contents of the plugin. The standard name for these files in plugInfo.json.</p>
<p>Typically, the application that hosts plug-ins will locate and register plug-ins at startup.</p>
<p>The plug-in facility is lazy. It does not dynamically load code from plug-in bundles until that code is required.</p>
<h1><a class="anchor" id="plug_plugInfo"></a>
plugInfo.json</h1>
<p>A plugInfo.json file has the following structure:</p>
<div class="fragment"><div class="line">{</div><div class="line"><span class="preprocessor">    # Comments are allowed and indicated by a hash at the start of a</span></div><div class="line"><span class="preprocessor">    # line or after spaces and tabs.  They continue to the end of line.</span></div><div class="line"><span class="preprocessor">    # Blank lines are okay, too.</span></div><div class="line"></div><div class="line"><span class="preprocessor">    # This is optional.  It may contain any number of strings.</span></div><div class="line"><span class="preprocessor">    #   Paths may be absolute or relative.</span></div><div class="line"><span class="preprocessor">    #   Paths ending with slash have plugInfo.json appended automatically.</span></div><div class="line"><span class="preprocessor">    #   &#39;*&#39; may be used anywhere to match any character except slash.</span></div><div class="line"><span class="preprocessor">    #   &#39;**&#39; may be used anywhere to match any character including slash.</span></div><div class="line">    <span class="stringliteral">&quot;Includes&quot;</span>: [</div><div class="line">        <span class="stringliteral">&quot;/absolute/path/to/plugInfo.json&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;/absolute/path/to/custom.filename&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;/absolute/path/to/directory/with/plugInfo/&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;relative/path/to/plugInfo.json&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;relative/path/to/directory/with/plugInfo/&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;glob*/pa*th/*to*/*/plugInfo.json&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;recursive/pa**th/**/&quot;</span></div><div class="line">    ],</div><div class="line"></div><div class="line"><span class="preprocessor">    # This is optional.  It may contain any number of objects.</span></div><div class="line">    <span class="stringliteral">&quot;Plugins&quot;</span>: [</div><div class="line">        {</div><div class="line"><span class="preprocessor">            # Type is required and may be &quot;library&quot;, &quot;python&quot; or &quot;resource&quot;.</span></div><div class="line">            <span class="stringliteral">&quot;Type&quot;</span>: <span class="stringliteral">&quot;library&quot;</span>,</div><div class="line"></div><div class="line"><span class="preprocessor">            # Name is required.  It should be the Python module name,</span></div><div class="line"><span class="preprocessor">            # the shared library name, or a unique resource name.</span></div><div class="line">            <span class="stringliteral">&quot;Name&quot;</span>: <span class="stringliteral">&quot;myplugin&quot;</span>,</div><div class="line"></div><div class="line"><span class="preprocessor">            # Root is optional.  It defaults to &quot;.&quot;.</span></div><div class="line"><span class="preprocessor">            # This gives the path to the plugin as a whole if the plugin</span></div><div class="line"><span class="preprocessor">            # has substructure.  For Python it should be the directory</span></div><div class="line"><span class="preprocessor">            # with the __init__.py file.  The path is usually relative.</span></div><div class="line">            <span class="stringliteral">&quot;Root&quot;</span>: <span class="stringliteral">&quot;.&quot;</span>,</div><div class="line"></div><div class="line"><span class="preprocessor">            # LibraryPath is required by Type &quot;library&quot; and unused</span></div><div class="line"><span class="preprocessor">            # otherwise.  It gives the path to the shared library</span></div><div class="line"><span class="preprocessor">            # object, either absolute or relative to Root.</span></div><div class="line">            <span class="stringliteral">&quot;LibraryPath&quot;</span>: <span class="stringliteral">&quot;libmyplugin.so&quot;</span>,</div><div class="line"></div><div class="line"><span class="preprocessor">            # ResourcePath is option.  It defaults to &quot;.&quot;.</span></div><div class="line"><span class="preprocessor">            # This gives the path to the plugin&#39;s resources directory.</span></div><div class="line"><span class="preprocessor">            # The path is either absolute or relative to Root.</span></div><div class="line">            <span class="stringliteral">&quot;ResourcePath&quot;</span>: <span class="stringliteral">&quot;resources&quot;</span>,</div><div class="line"></div><div class="line"><span class="preprocessor">            # Info is required.  It&#39;s described below.</span></div><div class="line">            <span class="stringliteral">&quot;Info&quot;</span>: {</div><div class="line"><span class="preprocessor">                # Plugin contents.</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    ]</div><div class="line">}</div></div><!-- fragment --><p>As a special case, if a plugInfo.json contains an object that doesn't have either the "Includes" or "Plugins" keys then it's as if the object was in a "Plugins" array.</p>
<h1><a class="anchor" id="plug_Advertising"></a>
Advertising a Plug-in's Contents</h1>
<p>Once the plug-ins are registered, the plug-in facility must also be able to tell what they contain. Specifically, it must be able to find out what subclasses of what plug-in base classes each plug-in contains. Plug-ins must advertise this information through their plugInfo.json file in the "Info" key. In the "Info" object there should be a key "Types" holding an object.</p>
<p>This "Types" object's keys are names of subclasses and its values are yet more objects (the subclass meta-data objects). The meta-data objects can contain arbitrary key-value pairs. The plug-in mechanism will look for a meta-data key called "displayName" whose value should be the display name of the subclass. The plug-in mechanism will look for a meta-data key called "bases" whose value should be an array of base class type names.</p>
<p>For example, a bundle that contains a subclass of ImageFilter might have a plugInfo.json that looks like the following example.</p>
<div class="fragment"><div class="line">{</div><div class="line">    <span class="stringliteral">&quot;Types&quot;</span>: {</div><div class="line">        <span class="stringliteral">&quot;MyCustomCoolFilter&quot;</span> : {</div><div class="line">            <span class="stringliteral">&quot;bases&quot;</span>: [<span class="stringliteral">&quot;ImageFilter&quot;</span>],</div><div class="line">            <span class="stringliteral">&quot;displayName&quot;</span>: <span class="stringliteral">&quot;Add Coolness to Image&quot;</span></div><div class="line"><span class="preprocessor">            # other arbitrary metadata for MyCustomCoolFilter here</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>What this says is that the plug-in contains a type called MyCustomCoolFilter which has a base class ImageFilter and that this subclass should be called "Add Coolness to Image" in user-visible contexts.</p>
<p>In addition to the "displayName" meta-data key which is actually known to the plug-in facility, you may put whatever other information you want into a class' meta-data dictionary. If your plug-in base class wants to define custom keys that it requires all subclasses to provide, you can do that. Or, if a plug-in writer wants to define their own keys that their code will look for at runtime, that is OK as well.</p>
<h1><a class="anchor" id="plug_subClasses"></a>
Working with Subclasses of a Plug-in Base Class</h1>
<p>Most code with uses types defined in plug-ins doesn't deal with the Plug API directly. Instead, the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> interface is used to lookup types and to manufacture instances. The <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> interface will take care to load any required plugins.</p>
<p>To wrap up our example, the application that wants to actually use ImageFilter plug-ins would probably do a couple of things. First, it would get a list of available ImageFilters to present to the user. This could be accomplished as shown in <a class="el" href="class_plug_registry.html#plug_cppcode_PlugRegistry2">Python Code Example 2</a> (Doxygen only).</p>
<p>Then, when the user picks a filter from the list, it would manufacture and instance of the filter as shown in <a class="el" href="class_plug_registry.html#plug_cppcode_PlugRegistry3">Python Code Example 3</a> (Doxygen only).</p>
<p>As was mentioned earlier, this plug-in facility tries to be as lazy as possible about loading the code associated with plug-ins. To that end, loading of a plugin will be deferred until an instance of a type is manufactured which requires the plugin.</p>
<h1><a class="anchor" id="plug_MultipleSubclasses"></a>
Multiple Subclasses of Multiple Plug-in Base Classes</h1>
<p>It is possible for a bundle to implement multiple subclasses for a plug-in base class if desired. If you want to package half a dozen ImageFilter subclasses in one bundle, that will work fine. All must be declared in the plugInfo.json.</p>
<p>It is possible for there to be multiple classes in your application or framework that are plug-in base classes. Plug-ins that implement subclasses of any of these base classes can all coexist. And, it is possible to have subclasses of multiple plug-in base classes in the same bundle.</p>
<p>When putting multiple subclasses (of the same or different base classes) in a bundle, keep in mind that dynamic loading happens for the whole bundle the first time any subclass is needed, the whole bundle will be loaded. But this is generally not a big concern.</p>
<p>For example, say the example application also has a plug-in base class "ImageCodec" that allows people to add support for reading and writing other image formats. Imagine that you want to supply a plug-in that has two codecs and a filter all in a single plug-in. Your plugInfo.json "Info" object might look something like this example.</p>
<div class="fragment"><div class="line">{</div><div class="line">    <span class="stringliteral">&quot;Types&quot;</span>: {</div><div class="line">        <span class="stringliteral">&quot;MyTIFFCodec&quot;</span>: {</div><div class="line">            <span class="stringliteral">&quot;bases&quot;</span>: [<span class="stringliteral">&quot;ImageCodec&quot;</span>],</div><div class="line">            <span class="stringliteral">&quot;displayName&quot;</span>: <span class="stringliteral">&quot;TIFF Image&quot;</span></div><div class="line">        },</div><div class="line">        <span class="stringliteral">&quot;MyJPEGCodec&quot;</span>: {</div><div class="line">            <span class="stringliteral">&quot;bases&quot;</span>: [<span class="stringliteral">&quot;ImageCodec&quot;</span>],</div><div class="line">            <span class="stringliteral">&quot;displayName&quot;</span>: <span class="stringliteral">&quot;JPEG Image&quot;</span></div><div class="line">        },</div><div class="line">        <span class="stringliteral">&quot;MyCustomCoolFilter&quot;</span> : {</div><div class="line">            <span class="stringliteral">&quot;bases&quot;</span>: [<span class="stringliteral">&quot;ImageFilter&quot;</span>],</div><div class="line">            <span class="stringliteral">&quot;displayName&quot;</span>: <span class="stringliteral">&quot;Add Coolness to Image&quot;</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="plug_Dependencies"></a>
Dependencies on Other Plug-ins</h1>
<p>If you write a plug-in that has dependencies on another plug-in that you cannot (or do not want to) link against statically, you can declare the dependencies in your plug-in's plugInfo.json . A plug-in declares dependencies on other classes with a PluginDependencies key whose value is a dictionary. The keys of the dictionary are plug-in base class names and the values are arrays of subclass names.</p>
<p>The following example contains an example of a plug-in that depends on two classes from the plug-in in the previous example.</p>
<div class="fragment"><div class="line">{</div><div class="line">    <span class="stringliteral">&quot;Types&quot;</span>: {</div><div class="line">        <span class="stringliteral">&quot;UltraCoolFilter&quot;</span>: {</div><div class="line">            <span class="stringliteral">&quot;bases&quot;</span>: [<span class="stringliteral">&quot;MyCustomCoolFilter&quot;</span>],</div><div class="line">            <span class="stringliteral">&quot;displayName&quot;</span>: <span class="stringliteral">&quot;Add Unbelievable Coolness to Image&quot;</span></div><div class="line"><span class="preprocessor">            # A subclass of MyCustomCoolFilter that also uses MyTIFFCodec</span></div><div class="line">        }</div><div class="line">    },</div><div class="line">    <span class="stringliteral">&quot;PluginDependencies&quot;</span>: {</div><div class="line">        <span class="stringliteral">&quot;ImageFilter&quot;</span>: [<span class="stringliteral">&quot;MyCustomCoolFilter&quot;</span>],</div><div class="line">        <span class="stringliteral">&quot;ImageCodec&quot;</span>: [<span class="stringliteral">&quot;MyTIFFCodec&quot;</span>]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The ImageFilter provided by the plug-in in this example depends on the other ImageFilter MyCoolImageFilter and the ImageCodec MyTIFFCodec. Before loading this plug-in, the plug-in facility will ensure that those two classes are present, loading the plug-in that contains them if needed.</p>
<h1><a class="anchor" id="plug_cppcode_PlugRegistry1"></a>
C++ Code Example 1</h1>
<div class="fragment"><div class="line"><span class="comment">// Declare a base class interface</span></div><div class="line"><span class="keyword">class </span>ImageFilter {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> CanFilterImage(<span class="keyword">const</span> ImagePtr &amp; inputImage) = 0;</div><div class="line">   <span class="keyword">virtual</span> ImagePtr FilterImage(<span class="keyword">const</span> ImagePtr &amp; inputImage) = 0;</div><div class="line">};</div></div><!-- fragment --><h1><a class="anchor" id="plug_cppcode_PlugRegistry2"></a>
Python Code Example 2</h1>
<div class="fragment"><div class="line"><span class="preprocessor"># Get the names of derived types</span></div><div class="line">baseType = Tf.Type.Find(ImageFilter)</div><div class="line"><span class="keywordflow">if</span> baseType:</div><div class="line">    derivedTypes = baseType.GetAllDerived()</div><div class="line">    derivedTypeNames = [ derived.typeName <span class="keywordflow">for</span> derived in derivedTypes ]</div></div><!-- fragment --><h1><a class="anchor" id="plug_cppcode_PlugRegistry3"></a>
Python Code Example 3</h1>
<div class="fragment"><div class="line"><span class="preprocessor"># Manufacture an instance of a derived type</span></div><div class="line">imageFilterType = Tf.Type.Find(ImageFilter)</div><div class="line">myFilterType = Tf.Type.FindByName(<span class="stringliteral">&#39;UltraCoolImageFilter&#39;</span>)</div><div class="line"><span class="keywordflow">if</span> myFilterType and myFilterType.IsA(imageFilterType):</div><div class="line">    myFilter = myFilterType.Manufacture()</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="base_2plug_2registry_8h_source.html#l00336">336</a> of file <a class="el" href="base_2plug_2registry_8h_source.html">registry.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab8d9978a85af6f5020d5f07a8ba644cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d9978a85af6f5020d5f07a8ba644cf">&#9670;&nbsp;</a></span>FindDerivedTypeByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PLUG_API <a class="el" href="class_tf_type.html">TfType</a> FindDerivedTypeByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_type.html">TfType</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>typeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> that derives from <code>base</code> and has the given alias or type name <code>typeName</code>. </p>
<p>See the documentation for <code><a class="el" href="class_tf_type.html#ac2acc8a814d948d5444aba8852db5bcf" title="Retrieve the TfType that derives from this type and has the given alias or typename.">TfType::FindDerivedByName</a></code> for more information. Use this function if you expect that the derived type may be provided by a plugin. Calling this function will incur plugin discovery (but not loading) if plugin discovery has not yet occurred.</p>
<p>Note that additional plugins may be registered during program runtime. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="plug_page_front.html#Plug_Discovery">Plug-In Discovery &amp; Registration</a> </dd></dl>

</div>
</div>
<a id="ad656572db5fa6cb4d0a4b7ab17b3880f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad656572db5fa6cb4d0a4b7ab17b3880f">&#9670;&nbsp;</a></span>FindDerivedTypeByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_tf_type.html">TfType</a> FindDerivedTypeByName </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> that derives from <code>Base</code> and has the given alias or type name <code>typeName</code>. </p>
<p>See the documentation for <code><a class="el" href="class_tf_type.html#ac2acc8a814d948d5444aba8852db5bcf" title="Retrieve the TfType that derives from this type and has the given alias or typename.">TfType::FindDerivedByName</a></code> for more information. Use this function if you expect that the derived type may be provided by a plugin. Calling this function will incur plugin discovery (but not loading) if plugin discovery has not yet occurred.</p>
<p>Note that additional plugins may be registered during program runtime. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="plug_page_front.html#Plug_Discovery">Plug-In Discovery &amp; Registration</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2plug_2registry_8h_source.html#l00393">393</a> of file <a class="el" href="base_2plug_2registry_8h_source.html">registry.h</a>.</p>

</div>
</div>
<a id="ad4b3d4cb0992361d63ea170161fc6171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b3d4cb0992361d63ea170161fc6171">&#9670;&nbsp;</a></span>FindTypeByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PLUG_API <a class="el" href="class_tf_type.html">TfType</a> FindTypeByName </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to the given <code>name</code>. </p>
<p>See the documentation for <code><a class="el" href="class_tf_type.html#a73035766205949ad12cc23ebf622e07e" title="Retrieve the TfType corresponding to the given name.">TfType::FindByName</a></code> for more information. Use this function if you expect that <code>name</code> may name a type provided by a plugin. Calling this function will incur plugin discovery (but not loading) if plugin discovery has not yet occurred.</p>
<p>Note that additional plugins may be registered during program runtime. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="plug_page_front.html#Plug_Discovery">Plug-In Discovery &amp; Registration</a> </dd></dl>

</div>
</div>
<a id="af859ac657fb599ad71583621d0cf805b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af859ac657fb599ad71583621d0cf805b">&#9670;&nbsp;</a></span>GetAllDerivedTypes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PLUG_API void GetAllDerivedTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_type.html">TfType</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt; *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the set of all types derived (directly or indirectly) from <em>base</em>. </p>
<p>Use this function if you expect that plugins may provide types derived from <em>base</em>. Otherwise, use <em><a class="el" href="class_tf_type.html#aa596041c67273d15501bef32540094fd" title="Return the set of all types derived (directly or indirectly) from this type.">TfType::GetAllDerivedTypes</a></em>.</p>
<p>Note that additional plugins may be registered during program runtime. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="plug_page_front.html#Plug_Discovery">Plug-In Discovery &amp; Registration</a> </dd></dl>

</div>
</div>
<a id="a07bd4722b659ca5c2ee2dd93ec79db67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bd4722b659ca5c2ee2dd93ec79db67">&#9670;&nbsp;</a></span>GetAllDerivedTypes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void GetAllDerivedTypes </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt; *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the set of all types derived (directly or indirectly) from <em>Base</em>. </p>
<p>Use this function if you expect that plugins may provide types derived from <em>base</em>. Otherwise, use <em><a class="el" href="class_tf_type.html#aa596041c67273d15501bef32540094fd" title="Return the set of all types derived (directly or indirectly) from this type.">TfType::GetAllDerivedTypes</a></em>.</p>
<p>Note that additional plugins may be registered during program runtime. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="plug_page_front.html#Plug_Discovery">Plug-In Discovery &amp; Registration</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2plug_2registry_8h_source.html#l00423">423</a> of file <a class="el" href="base_2plug_2registry_8h_source.html">registry.h</a>.</p>

</div>
</div>
<a id="aa395fd445592f25012f9406b155431d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa395fd445592f25012f9406b155431d7">&#9670;&nbsp;</a></span>GetAllPlugins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLUG_API PlugPluginPtrVector GetAllPlugins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all registered plug-ins. </p>
<p>Note that additional plugins may be registered during program runtime. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="plug_page_front.html#Plug_Discovery">Plug-In Discovery &amp; Registration</a> </dd></dl>

</div>
</div>
<a id="a51a448ab0535968b4b3f1ef497322398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a448ab0535968b4b3f1ef497322398">&#9670;&nbsp;</a></span>GetDataFromPluginMetaData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLUG_API <a class="el" href="class_js_value.html">JsValue</a> GetDataFromPluginMetaData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_type.html">TfType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for a <a class="el" href="class_js_value.html" title="A discriminated union type for JSON values.">JsValue</a> associated with <em>type</em> and <em>key</em> and returns it, or a null <a class="el" href="class_js_value.html" title="A discriminated union type for JSON values.">JsValue</a> if <em>type</em> or <em>key</em> are not found. </p>

</div>
</div>
<a id="a491223b1f382752c136b50925cbc6d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491223b1f382752c136b50925cbc6d07">&#9670;&nbsp;</a></span>GetDirectlyDerivedTypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PLUG_API std::vector&lt;<a class="el" href="class_tf_type.html">TfType</a>&gt; GetDirectlyDerivedTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_type.html">TfType</a>&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector of types derived directly from <em>base</em>. </p>
<p>Use this function if you expect that plugins may provide types derived from <em>base</em>. Otherwise, use <em><a class="el" href="class_tf_type.html#aa37b02659aa00a6f6f098acd1bff3a41" title="Return a vector of types derived directly from this type.">TfType::GetDirectlyDerivedTypes</a></em>. </p>

</div>
</div>
<a id="a8b287622f64269e7f9edd1410436d805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b287622f64269e7f9edd1410436d805">&#9670;&nbsp;</a></span>GetInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PLUG_API <a class="el" href="class_plug_registry.html">PlugRegistry</a>&amp; GetInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the singleton <code><a class="el" href="class_plug_registry.html" title="Defines an interface for registering plugins.">PlugRegistry</a></code> instance. </p>

</div>
</div>
<a id="a4c5dfc1c3b55017173c9df93b091424c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5dfc1c3b55017173c9df93b091424c">&#9670;&nbsp;</a></span>GetPluginForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLUG_API PlugPluginPtr GetPluginForType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_type.html">TfType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the plug-in for the given type, or a null pointer if there is no registered plug-in. </p>

</div>
</div>
<a id="abab64fbe6f5a8d113e4f31a3bde0959a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab64fbe6f5a8d113e4f31a3bde0959a">&#9670;&nbsp;</a></span>GetPluginWithName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLUG_API PlugPluginPtr GetPluginWithName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a plugin with the specified library name. </p>
<p>Note that additional plugins may be registered during program runtime. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="plug_page_front.html#Plug_Discovery">Plug-In Discovery &amp; Registration</a> </dd></dl>

</div>
</div>
<a id="a545f23185a7f34a760b125daa5a6698a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545f23185a7f34a760b125daa5a6698a">&#9670;&nbsp;</a></span>GetStringFromPluginMetaData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLUG_API std::string GetStringFromPluginMetaData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_type.html">TfType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for a string associated with <em>type</em> and <em>key</em> and returns it, or an empty string if <em>type</em> or <em>key</em> are not found. </p>

</div>
</div>
<a id="ada54bcdd334de360eddab430894dd5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada54bcdd334de360eddab430894dd5ac">&#9670;&nbsp;</a></span>RegisterPlugins() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLUG_API PlugPluginPtrVector RegisterPlugins </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathToPlugInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers all plug-ins discovered at <em>pathToPlugInfo</em>. </p>
<p>Sends <a class="el" href="class_plug_notice_1_1_did_register_plugins.html" title="Notice sent after new plugins have been registered with the Plug registry.">PlugNotice::DidRegisterPlugins</a> with any newly registered plugins. </p>

</div>
</div>
<a id="a43fe0749d24f0dd2a909a6abf2d427f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fe0749d24f0dd2a909a6abf2d427f9">&#9670;&nbsp;</a></span>RegisterPlugins() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PLUG_API PlugPluginPtrVector RegisterPlugins </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>pathsToPlugInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers all plug-ins discovered in any of <em>pathsToPlugInfo</em>. </p>
<p>Sends <a class="el" href="class_plug_notice_1_1_did_register_plugins.html" title="Notice sent after new plugins have been registered with the Plug registry.">PlugNotice::DidRegisterPlugins</a> with any newly registered plugins. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pxr/base/plug/<a class="el" href="base_2plug_2registry_8h_source.html">registry.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_plug_registry.html">PlugRegistry</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:03 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>