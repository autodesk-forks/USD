<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: UsdGeom : USD Geometry Schema</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('usd_geom_page_front.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">UsdGeom : USD Geometry Schema </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#UsdGeom_Structure">Geometric Primitive Schemas</a><ul><li class="level2"><a href="#UsdGeom_Imageable">UsdGeomImageable</a></li>
<li class="level2"><a href="#UsdGeom_Xformable">UsdGeomXformable</a></li>
<li class="level2"><a href="#UsdGeom_Gprim">UsdGeomGprim</a></li>
<li class="level2"><a href="#UsdGeom_PointInstancer">UsdGeomPointInstancer</a></li>
<li class="level2"><a href="#UsdGeom_Camera">UsdGeomCamera</a></li>
<li class="level2"><a href="#UsdGeom_ModelAPI">UsdGeomModelAPI</a></li>
</ul>
</li>
<li class="level1"><a href="#UsdGeom_PrimvarsOverview">Primvars (Primitive Variables)</a></li>
<li class="level1"><a href="#UsdGeom_ImageablePurpose">Imageable Purpose</a></li>
<li class="level1"><a href="#UsdGeom_LinAlgBasics">Linear Algebra in UsdGeom</a></li>
<li class="level1"><a href="#UsdGeom_WindingOrder">Coordinate System, Winding Order, Orientation, and Surface Normals</a></li>
<li class="level1"><a href="#UsdGeom_VelocityInterpolation">Applying Timesampled Velocities to Geometry</a><ul><li class="level2"><a href="#UsdGeom_VelocityAtOneSample">Computing a Single Requested Position</a></li>
<li class="level2"><a href="#UsdGeom_VelocityAtMultipleSamples">Computing a Range of Requested Positions</a></li>
</ul>
</li>
<li class="level1"><a href="#UsdGeom_MotionAPI">MotionAPI: Modulating Motion and Motion Blur</a><ul><li class="level2"><a href="#UsdGeomMotionAPI_blurScale">Effectively Applying motion:blurScale</a></li>
</ul>
</li>
<li class="level1"><a href="#UsdGeom_StageMetrics">Stage Metrics</a></li>
</ul>
</div>
<div class="textblock"><p><b>UsdGeom</b> defines the 3D graphics-related prim and property schemas that together form a basis for interchanging geometry between DCC tools in a graphics pipeline.</p>
<h1><a class="anchor" id="UsdGeom_Structure"></a>
Geometric Primitive Schemas</h1>
<h2><a class="anchor" id="UsdGeom_Imageable"></a>
UsdGeomImageable</h2>
<p>Currently, all classes in UsdGeom inherit from <a class="el" href="class_usd_geom_imageable.html" title="Base class for all prims that may require rendering or visualization of some sort.">UsdGeomImageable</a> , whose intent is to capture any prim type that might want to be rendered or visualized. This distinction is made for two reasons:</p>
<ul>
<li>so that there <em>could</em> be types that would never want to be renderered, and can thus be optimized around, for traversals, and also to enable validation: for example, in a compatible shading schema, only UsdGeomImageable-derived prims should be able to express a look/material binding.</li>
<li>for the common properties described in <a class="el" href="class_usd_geom_imageable.html" title="Base class for all prims that may require rendering or visualization of some sort.">UsdGeomImageable</a>, including visibility, <a class="el" href="usd_geom_page_front.html#UsdGeom_ImageablePurpose">purpose</a>, and the attribute schema for <a class="el" href="usd_geom_page_front.html#UsdGeom_PrimvarsOverview">primvars</a>.</li>
</ul>
<p>Admittedly, not all of the classes inheriting from <a class="el" href="class_usd_geom_imageable.html" title="Base class for all prims that may require rendering or visualization of some sort.">UsdGeomImageable</a> really need to be imageable - they are grouped as they are to avoid the need for multiple-inheritance, which would arise because some classes that may not necessarily be imageable are definitely transformable.</p>
<h2><a class="anchor" id="UsdGeom_Xformable"></a>
UsdGeomXformable</h2>
<p>In UsdGeom, all geometry prims are directly transformable. This is primarily a scalability and complexity management decision, since prim-count has a strong correlation to total scene composition time and memory footprint, and eliminating the need for a "shape" node for every piece of geometry generally reduces overall prim count by anywhere from 30% to 50%, depending on depth and branching factor of a scene's namespace hierarchy.</p>
<p><a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable</a> encapsulates the schema for a prim that is transformable. Readers familiar with AbcGeom's Xform schema will find Xformable familiar, but more easily introspectable. Xformable decomposes a transformation into an ordered sequence of <a class="el" href="class_usd_geom_xform_op.html">ops</a>; unlike AbcGeom::Xform, which packs the op data into static and varying arrays, <a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable</a> expresses each op as an independent <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a>. This data layout, while somewhat more expensive to extract, is much more conducive to "composed scene
description" because it allows individual ops to be overridden in stronger layers independently of all other ops. We provide facilities leveraging core Usd features that help mitigate the extra cost of reading more attributes per-prim for performance-sensitive clients.</p>
<p>Of course, UsdGeom still requires a prim schema that simply represents a transformable prim that scopes other child prims, which is fulfilled by <a class="el" href="class_usd_geom_xform.html" title="Concrete prim schema for a transform, which implements Xformable.">UsdGeomXform</a> .</p>
<dl class="section note"><dt>Note</dt><dd>You may find it useful to digest the basic assumptions of UsdGeom linear algebra</dd></dl>
<h2><a class="anchor" id="UsdGeom_Gprim"></a>
UsdGeomGprim</h2>
<p><a class="el" href="class_usd_geom_gprim.html" title="Base class for all geometric primitives.">UsdGeomGprim</a> is the base class for all "geometric primitives", which encodes several per-primitive graphics-related properties. Defined Gprims currently include:</p><ul>
<li><a class="el" href="class_usd_geom_mesh.html" title="Encodes a mesh with optional subdivision properties and features.">UsdGeomMesh</a></li>
<li><a class="el" href="class_usd_geom_nurbs_patch.html" title="Encodes a rational or polynomial non-uniform B-spline surface, with optional trim curves.">UsdGeomNurbsPatch</a></li>
<li><a class="el" href="class_usd_geom_basis_curves.html" title="BasisCurves are a batched curve representation analogous to the classic RIB definition via Basis and ...">UsdGeomBasisCurves</a></li>
<li><a class="el" href="class_usd_geom_nurbs_curves.html" title="This schema is analagous to NURBS Curves in packages like Maya and Houdini, often used for interchang...">UsdGeomNurbsCurves</a></li>
<li><a class="el" href="class_usd_geom_points.html" title="Points are analogous to the RiPoints spec.">UsdGeomPoints</a></li>
<li><a class="el" href="class_usd_geom_capsule.html" title="Defines a primitive capsule, i.e.">UsdGeomCapsule</a></li>
<li><a class="el" href="class_usd_geom_cone.html" title="Defines a primitive cone, centered at the origin, whose spine is along the specified axis,...">UsdGeomCone</a></li>
<li><a class="el" href="class_usd_geom_cube.html" title="Defines a primitive rectilinear cube centered at the origin.">UsdGeomCube</a></li>
<li><a class="el" href="class_usd_geom_cylinder.html" title="Defines a primitive cylinder with closed ends, centered at the origin, whose spine is along the speci...">UsdGeomCylinder</a></li>
<li><a class="el" href="class_usd_geom_sphere.html" title="Defines a primitive sphere centered at the origin.">UsdGeomSphere</a></li>
</ul>
<p>We expect there to be some debate around the last five "intrinsic" Gprims: Capsule, Cone, Cube, Cylinder, and Sphere, as not all DCC's support them as primitives. In Pixar's pipeline, we in fact rarely render these primitives, but find them highly useful for their fast inside/outside tests in defining volumes for lighting effects, procedural modifiers (such as "kill spheres" for instancers), and colliders. The last, in particular, is quite useful for interchanging data with rigid-body simulators. It is necessary to be able to transmit these volumes from dressing/animation tools to simulation/lighting/rendering tools, thus their presence in our schema. We expect to support these and other "non-native" schema types as some form of proxy or "pass through" prim in DCC's that do not understand them.</p>
<h2><a class="anchor" id="UsdGeom_PointInstancer"></a>
UsdGeomPointInstancer</h2>
<p><a class="el" href="class_usd_geom_point_instancer.html" title="Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters)...">UsdGeomPointInstancer</a> provides a powerful, scalable encoding for scattering many instances of multiple prototype objects (which can be arbitrary subtrees of the <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> that contains the PointInstancer), animating both the instances and prototypes, and pruning/masking instances based on integer ID.</p>
<h2><a class="anchor" id="UsdGeom_Camera"></a>
UsdGeomCamera</h2>
<p><a class="el" href="class_usd_geom_camera.html" title="Transformable camera.">UsdGeomCamera</a> encodes a transformable camera.</p>
<h2><a class="anchor" id="UsdGeom_ModelAPI"></a>
UsdGeomModelAPI</h2>
<p><a class="el" href="class_usd_geom_model_a_p_i.html" title="UsdGeomModelAPI extends the generic UsdModelAPI schema with geometry specific concepts such as cached...">UsdGeomModelAPI</a> is an API schema that extends the basic <a class="el" href="class_usd_model_a_p_i.html" title="UsdModelAPI is an API schema that provides an interface to a prim&#39;s model qualities,...">UsdModelAPI</a> API with concepts unique to models that contain 3D geometry. This includes:</p><ul>
<li><a class="el" href="class_usd_geom_model_a_p_i.html#a4aa8b1f29a3097fe08da868bd2b8b259">cached extent hints encompassing an entire model</a></li>
<li>API for collecting and extracting all <a class="el" href="class_usd_geom_constraint_target.html">constraint targets</a> for a model from the model's root prim.</li>
</ul>
<h1><a class="anchor" id="UsdGeom_PrimvarsOverview"></a>
Primvars (Primitive Variables)</h1>
<p>"Primvars" are an important concept in UsdGeom. Primvars are attributes with a number of extra features that address the following problems in computer graphics:</p>
<ol type="1">
<li>The need to "bind" user data on geometric primitives that becomes available to shaders during rendering.</li>
<li>The need to specify a set of values associated with vertices or faces of a primitive that will interpolate across the primitive's surface under subdivision or shading.</li>
<li>The need to <em>inherit</em> attributes down namespace to allow sparse authoring of sharable data that is compatible with <a class="el" href="_usd__page__scenegraph_instancing.html#Usd_ScenegraphInstancing_Overview">native scenegraph instancing</a></li>
</ol>
<p>One example that involves the first two problems is <em>texture coordinates</em> (commonly referred to as "uv's"), which are cast as primvars in UsdGeom. <a class="el" href="class_usd_geom_primvar.html" title="Schema wrapper for UsdAttribute for authoring and introspecting attributes that are primvars.">UsdGeomPrimvar</a> encapsulates a single primvar, and provides the features associated with interpolating data across a surface. <a class="el" href="class_usd_geom_primvars_a_p_i.html" title="UsdGeomPrimvarsAPI encodes geometric &quot;primitive variables&quot;, as UsdGeomPrimvar, which interpolate acro...">UsdGeomPrimvarsAPI</a> provides the interface for creating and querying primvars on a prim, as well as the computations related to primvar inheritance.</p>
<h1><a class="anchor" id="UsdGeom_ImageablePurpose"></a>
Imageable Purpose</h1>
<p>Purpose is a concept we have found useful in our pipeline for classifying geometry into categories that can each be independently included or excluded from traversals of prims on a stage, such as rendering or bounding-box computation traversals. The fallback purpose, <em>default</em> indicates that a prim has "no special purpose" and should generally be included in all traversals. Prims with purpose <em>render</em> should generally only be included when performing a "final 
quality" render. Prims with purpose <em>proxy</em> should generally only be included when performing a lightweight proxy render (such as openGL).</p>
<p>Finally, prims with purpose <em>guide</em> should generally only be included when an interactive application has been explicitly asked to "show guides".</p>
<p>A prim that is Imageable with an authored opinion about its purpose will always have the same effective purpose as its authored value. If the prim is not Imageable or does not have an authored opinion about its own purpose, then it will inherit the purpose of the closest Imageable ancestor with an authored purpose opinion. If there are no Imageable ancestors with an authored purpose opinion then this prim uses its fallback purpose.</p>
<p>For example, if you have a prim tree like such </p><div class="fragment"><div class="line">def <span class="stringliteral">&quot;Root&quot;</span> {</div><div class="line">    token purpose = <span class="stringliteral">&quot;proxy&quot;</span></div><div class="line"></div><div class="line">    def Xform <span class="stringliteral">&quot;RenderXform&quot;</span> {</div><div class="line">        token purpose = <span class="stringliteral">&quot;render&quot;</span></div><div class="line"></div><div class="line">        def <span class="stringliteral">&quot;Prim&quot;</span> {</div><div class="line">            token purpose = <span class="stringliteral">&quot;default&quot;</span></div><div class="line"></div><div class="line">            def Xform <span class="stringliteral">&quot;InheritXform&quot;</span> {</div><div class="line">            }</div><div class="line"></div><div class="line">            def Xform <span class="stringliteral">&quot;GuideXform&quot;</span> {</div><div class="line">                token purpose = <span class="stringliteral">&quot;guide&quot;</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    def Xform <span class="stringliteral">&quot;Xform&quot;</span> {</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><ul>
<li>&lt;/Root&gt; is not Imageable so its purpose attribute is ignored and its effective purpose is <em>default</em>. </li>
<li>&lt;/Root/RenderXform&gt; is Imageable and has an authored purpose of <em>render</em> so its effective purpose is <em>render</em>. </li>
<li>&lt;/Root/RenderXform/Prim&gt; is not Imageable so its purpose attribute is ignored. ComputePurpose will return the effective purpose of <em>render</em>, inherited from its parent Imageable's authored purpose. </li>
<li>&lt;/Root/RenderXform/Prim/InheritXform&gt; is Imageable but with no authored purpose. Its effective purpose is <em>render</em>, inherited from the authored purpose of &lt;/Root/RenderXform&gt; </li>
<li>&lt;/Root/RenderXform/Prim/GuideXform&gt; is Imageable and has an authored purpose of <em>guide</em> so its effective purpose is <em>guide</em>. </li>
<li>&lt;/Root/Xform&gt; is Imageable but with no authored purpose. It also has no Imageable ancestor with an authored purpose its effective purpose is its fallback value of <em>default</em>.</li>
</ul>
<p>Purpose <em>render</em> can be useful in creating "light blocker" geometry for raytracing interior scenes. Purposes <em>render</em> and <em>proxy</em> can be used together to partition a complicated model into a lightweight proxy representation for interactive use, and a fully realized, potentially quite heavy, representation for rendering. One can use <a class="el" href="class_usd_variant_sets.html" title="UsdVariantSets represents the collection of VariantSets that are present on a UsdPrim.">UsdVariantSets</a> to create proxy representations, but doing so requires that we recompose parts of the <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> in order to change to a different runtime level of detail, and that does not interact well with the needs of multithreaded rendering. Purpose provides us with a better tool for dynamic, interactive complexity management.</p>
<p>As demonstrated in <a class="el" href="class_usd_geom_b_box_cache.html" title="Caches bounds by recursively computing and aggregating bounds of children in world space and aggregat...">UsdGeomBBoxCache</a>, a traverser should be ready to accept combinations of included purposes as an input.</p>
<h1><a class="anchor" id="UsdGeom_LinAlgBasics"></a>
Linear Algebra in UsdGeom</h1>
<p>To ensure reliable interchange, we stipulate the following foundational mathematical assumptions, which are codified in the <a class="el" href="gf_page_front.html#gf_overview">Graphics Foundations (Gf) math module</a>:</p><ul>
<li>Matrices are laid out and indexed in row-major order, such that, given a <code><a class="el" href="class_gf_matrix4d.html" title="Stores a 4x4 matrix of double elements.">GfMatrix4d</a></code> datum <em>mat</em>, <em>mat</em>[3][1] denotes the second column of the fourth row.</li>
<li>GfVec datatypes are row vectors that <b>pre-multiply</b> matrices to effect transformations, which implies, for example, that it is the fourth row of a <a class="el" href="class_gf_matrix4d.html" title="Stores a 4x4 matrix of double elements.">GfMatrix4d</a> that specifies the translation of the transformation.</li>
<li>All rotation angles are expressed in degrees, not radians.</li>
<li>Vector cross-products and rotations intrinsically follow the <a href="https://en.wikipedia.org/wiki/Right-hand_rule">right hand rule.</a></li>
</ul>
<p>So, for example, transforming a vector <b>v</b> by first a Scale matrix <b>S</b>, then a Rotation matrix <b>R</b>, and finally a Translation matrix <b>T</b> can be written as the following mathematical expression:</p>
<dl class="section user"><dt></dt><dd><b>vt</b> = <b>v</b> &times; <b>S</b> &times; <b>R</b> &times; <b>T</b></dd></dl>
<p>Because Gf exposes transformation methods on Matrices, not Vectors, to effect this transformation in Python, one would write: </p><div class="fragment"><div class="line">vt = (S * R * T).Transform(v)</div></div><!-- fragment --><h1><a class="anchor" id="UsdGeom_WindingOrder"></a>
Coordinate System, Winding Order, Orientation, and Surface Normals</h1>
<p>Deriving from the mathematical assumptions in the preceding section, UsdGeom positions objects in a <b>right handed coordinate system</b>, and a <a class="el" href="class_usd_geom_camera.html" title="Transformable camera.">UsdGeomCamera</a> views the scene in a right-handed coordinate system where <b>up is +Y, right is +X, and the forward viewing direction is -Z</b> - this is explained and diagrammed in <a class="el" href="usd_render_page_front.html#UsdRender_Camera">UsdRenderCamera</a>. If you find yourself needing to import USD into a system that operates in a left-handed coordinate system, you may find <a href="https://towardsdatascience.com/change-of-basis-3909ef4bed43">this article</a> useful.</p>
<p>UsdGeom also, by default, applies the right hand rule to compute the "intrinsic", <em>surface normal</em> (also sometimes referred to as the <em>geometric normal</em>) for all non-implicit surface and solid types.</p>
<p>That is, the normal computed from (e.g.) a polygon's sequential vertices using the right handed winding rule determines the "front" or "outward" facing direction, that typically, when rendered will receive lighting calculations and shading.</p>
<p>Since not all modeling and animation packages agree on the right hand rule, <a class="el" href="class_usd_geom_gprim.html" title="Base class for all geometric primitives.">UsdGeomGprim</a> introduces the <a class="el" href="class_usd_geom_gprim.html#a6d7f451cf0aa27125cc118b030ebb735">orientation</a> attribute to enable individual gprims to select the left hand winding rule, instead. So, gprims whose <em>orientation</em> is "rightHanded" (which is the fallback) must use the right hand rule to compute their surface normal, while gprims whose <em>orientation</em> is "leftHanded" must use the left hand rule.</p>
<p>However, any given gprim's <a class="el" href="class_usd_geom_imageable.html#a8e3fb09253ba63d63921f665d63cd270">local-to-world transformation</a> can <em>flip</em> its effective orientation, when it contains an odd number of negative scales. This condition can be reliably detected using the (Jacobian) determinant of the local-to-world transform: if the determinant is <b>less than zero</b>, then the gprim's orientation has been flipped, and therefore one must apply the <b>opposite</b> handedness rule when computing its surface normals (or just flip the computed normals) for the purposes of hidden surface detection and lighting calculations.</p>
<h1><a class="anchor" id="UsdGeom_VelocityInterpolation"></a>
Applying Timesampled Velocities to Geometry</h1>
<p><a class="el" href="class_usd_geom_point_based.html" title="Base class for all UsdGeomGprims that possess points, providing common attributes such as normals and...">UsdGeomPointBased</a> primitives and <a class="el" href="class_usd_geom_point_instancer.html" title="Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters)...">UsdGeomPointInstancer</a> primitives all allow the specification of <a class="el" href="class_usd_geom_point_based.html#a2840a996c8a768ecea390147390dc222">velocities</a> and <a class="el" href="class_usd_geom_point_instancer.html#abf4df1035f2f759d5119392f94a73626">accelerations</a> to describe point (or instance) motion at off-sample <a class="el" href="class_usd_time_code.html" title="Represent a time value, which may be either numeric, holding a double value, or a sentinel value UsdT...">UsdTimeCode</a> s, as an alternative to relying on native <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> linear sample interpolation.</p>
<p>Using velocities is the <b>only reliable way</b> of encoding the motion of primitives whose topology is varying over time, as adjacent samples' indices may be unrelated to each other, and the samples themselves may not even possess the same number of elements.</p>
<p>To help ensure that all consumers of UsdGeom data will compute identical posing from the same dataset, we describe how the position, velocity, and acceleration data should be sampled and combined to produce "interpolated" positions. There are several cases to consider, for which we stipulate the following logic:</p>
<ul>
<li>If no <em>velocities</em> are authored, then we fall back to the "standard" position computation logic: if the timeSamples bracketing a requested sample have the same number of elements, apply linear interpolation between the two samples; otherwise, use the value of the sample with the lower/earlier ordinate.</li>
<li>If the bracketing timeSamples for <em>velocities</em> from the requested timeSample have the <em>same ordinates</em> as those for <em>points</em> then <b>use the lower <em>velocities</em> timeSample and the lower <em>points</em> timeSample</b> for the computations described below.</li>
<li>If <em>velocities</em> are authored, but the sampling does not line up with that of <em>points</em>, fall back to standard position computation logic, as if no <em>velocities</em> were authored. This is effectively a silent error case.</li>
<li>If no <em>accelerations</em> are authored, <b>use the lower <em>velocities</em> timeSample and the lower <em>points</em> timeSample</b> for the computations described below. <em>accelerations</em> are set to 0 in all dimensions for the computations.</li>
<li>If the bracketing timeSamples for <em>accelerations</em> from the requested timeSample have the <em>same ordinates</em> as those for <em>velocities</em> and <em>points</em> then <b>use the lower <em>accelerations</em> timeSample, the lower <em>velocities</em> timeSample and the lower <em>points</em> timeSample</b> for the computations described below.</li>
<li>If <em>accelerations</em> are authored but the sampling does not line up with that of <em>velocities</em>, if the sampling of <em>velocities</em> lines up with that of <em>positions</em> <b>use the lower <em>velocities</em> timeSample and the lower <em>points</em> timeSample</b> for the computations described below, as if no <em>accelerations</em> were authored. If the sampling of <em>velocities</em> does not line up with that of <em>positions</em>, fall back to the "standard" position computation logic as if no <em>velocities</em> or <em>accelerations</em> were authored.</li>
</ul>
<p><b>In summary,</b> we stipulate that the sample-placement of the <em>points</em>, <em>velocities</em>, and <em>accelerations</em> attributes be identical in each range over which we want to compute motion samples. We do not allow velocities to be recorded at times at which there is not a corresponding <em>points</em> sample.</p>
<p>This is to simplify and expedite the calculations required to compute a position at any requested time. Since most simulators produce both a position and velocity at each timeStep, we do not believe this restriction should impose an undue burden.</p>
<p>Note that the sampling requirements are applied to each requested motion sampling interval independently. So, for example, if <em>points</em> and <em>velocities</em> have samples at times 0, 1, 2, 3, but then <em>velocities</em> has an extra sample at 2.5, and we are computing forward motion blur on each frame, then we should get velocity-interpolated positions for the motion-blocks for frames 0, 1, and 3, but no interpolation for frame 2.</p>
<h2><a class="anchor" id="UsdGeom_VelocityAtOneSample"></a>
Computing a Single Requested Position</h2>
<p>If one requires a pose at only a single point in time, <em>sampleTime</em>, such as when stepping through "sub-frames" in an application like <em>usdview</em>, then we need simply apply the above rules, and if we successfully sample <em>points</em>, <em>velocities</em>, and <em>accelerations</em>, let:</p>
<dl class="section user"><dt></dt><dd><em>t<sub>points</sub></em> = the lower bracketing time sample for the evaluated <em>points</em> attribute</dd></dl>
<dl class="section user"><dt></dt><dd><em>timeScale</em> = 1.0 / <code>stage-&gt;GetTimeCodesPerSecond()</code></dd></dl>
<p>... then</p>
<dl class="section user"><dt></dt><dd><em> <b>pointsInterpolated</b> = <b>points</b> + (sampleTime - t<sub>points</sub>) * timeScale * (<b>velocities</b> + (0.5 * (sampleTime - t<sub>points</sub>) * timeScale * <b>accelerations</b>))</em></dd></dl>
<h2><a class="anchor" id="UsdGeom_VelocityAtMultipleSamples"></a>
Computing a Range of Requested Positions</h2>
<p>Computer graphics renderers typically simulate the effect of non-zero camera shutter intervals (which introduces <a href="https://en.wikipedia.org/wiki/Motion_blur">motion blur</a> into an image) by sampling moving geometry at multiple, nearby sample times, for each rendered image, linearly blending the results of each sample. Most, if not all renderers introduce the simplifying assumption that for any given image we wish to render, we will not allow the topology of geometry to change over the time-range we sample for motion blur.</p>
<p>Therefore, if we are sampling a topologically varying, <em>velocities</em>-possessing <a class="el" href="class_usd_geom_mesh.html" title="Encodes a mesh with optional subdivision properties and features.">UsdGeomMesh</a> at sample times <em>t<sub>1</sub></em>, <em>t<sub>2</sub></em> ... <em>t<sub>n</sub></em> in order to render the mesh with motion blur, we stipulate that all <em>n</em> samples be computed from <b>the same sampled <em>points</em>, <em>velocities</em>, and <em>accelerations</em> values sampled at_sampleTime_</b>. Therefore, we would compute all <em>n</em> samples using the above formula, but iterating over the <em>n</em> samples, substituting <em>t<sub>i</sub></em> for <em>sampleTime</em>.</p>
<p>Two things to note:</p>
<ul>
<li>Since we are applying strictly linear interpolation, why is it useful to compute more than two samples? For <a class="el" href="class_usd_geom_point_based.html" title="Base class for all UsdGeomGprims that possess points, providing common attributes such as normals and...">UsdGeomPointBased</a> primitives, the object-space samples will not require more than two samples, although local-to-world transformations may introduce non-linear motion. For <a class="el" href="class_usd_geom_point_instancer.html" title="Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters)...">UsdGeomPointInstancer</a> primitives, which also possess an <em>angularVelocities</em> attribute for the instances, it may often be desirable to sample the instance matrices (and therefore <em>positions</em>) at a higher frequency since angular motion is non-linear.</li>
<li>If the range of <em>t<sub>1</sub></em> to <em>t<sub>n</sub></em> is greater than the recorded sampling frequency of <em>points</em>, then computing the "singular" value of <em>points</em> at some time <em>t<sub>other</sub></em> that is within the range <em>t<sub>1</sub></em> to <em>t<sub>n</sub></em> may produce a different value (with differing number of elements) than the computed value for the same <b>singular</b> time using the motion blur technique. This derives from our requirement that over the given motion range, the topology must not change, so we specifically ignore any other <em>points</em>, <em>velocities</em>, or <em>accelerations</em> samples that occur in the requested motion range.</li>
</ul>
<h1><a class="anchor" id="UsdGeom_MotionAPI"></a>
MotionAPI: Modulating Motion and Motion Blur</h1>
<p><a class="el" href="class_usd_geom_motion_a_p_i.html" title="UsdGeomMotionAPI encodes data that can live on any prim that may affect computations involving:">UsdGeomMotionAPI</a> is an applied schema whose properties describe how scene sampling should be adjusted to achieve artist-specified changes to perceived motion, such as adjusting the amount of motion-blur differently for different objects in a scene. All of the properties defined by this schema should be inherited down namespace, so that one can adjust the blurring of an entire model with a single statement/opinion on the model's root prim.</p>
<h2><a class="anchor" id="UsdGeomMotionAPI_blurScale"></a>
Effectively Applying motion:blurScale</h2>
<p>The <em>motion:blurScale</em> attribute allows artists to scale the <b>amount</b> of motion blur to be rendered for parts of the scene without changing the recorded animation. We stipulate that this should at least affect the primary geometric properties of prims, such as:</p>
<ul>
<li>Points (<a class="el" href="class_usd_geom_point_based.html" title="Base class for all UsdGeomGprims that possess points, providing common attributes such as normals and...">UsdGeomPointBased</a>)</li>
<li>Normals (<a class="el" href="class_usd_geom_point_based.html" title="Base class for all UsdGeomGprims that possess points, providing common attributes such as normals and...">UsdGeomPointBased</a>)</li>
<li>Transforms (<a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable</a>)</li>
<li>Instance Transforms (<a class="el" href="class_usd_geom_point_instancer.html" title="Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters)...">UsdGeomPointInstancer</a>)</li>
</ul>
<p>Beyond that "geometric motion core" of properties, renderers should apply <em>blurScale</em> to any other attributes that they <em>can</em> blur.</p>
<p>We can implement this feature by either mutating (scaling) the sample values we send to a renderer, or by adjusting our sampling and sample times. We suggest that the latter provides superior results, and therefore describe it in more detail.</p>
<p>We begin by establishing the difference between the <b>sampling window</b> and the <b>shutter window</b> when preparing data for a renderer. The <b>sampling window</b> is the interval in <em>scene time</em> in which we will sample the scene for rendering any particular frame, and changes as we render successive frames. The <b>shutter window</b> (as typically specified via <a class="el" href="class_usd_geom_camera.html" title="Transformable camera.">UsdGeomCamera</a>'s <em>shutter:open</em> and <em>shutter:close</em> properties) is the interval in which the renderer will look for samples to consume, is often centered around zero, and is usually the same for all frames.</p>
<p>This means we translate samples from the sampling domain to the shutter domain by simply subtracting the "current frame time" from the time ordinate of each sample. However, by scaling the sampling window and adding in a compensatory inverse scale to the translation of sample time to shutter time, we can very simply implement the <em>motion:blurScale</em> behavior. More precisely: </p><dl class="section user"><dt></dt><dd>We scale the sampling window by <em>motion:blurScale</em>, pivoting around the current frame time, and then scale the ordinates of the shutter-interval-space samples by 1.0 / <em>motion:blurScale</em>, pivoting around zero.</dd></dl>
<p>For example, let us assume we are rendering a bouncing ball with a sampling window of <code>[frameTime, frameTime+0.5]</code> and a shutter window of <code>[0, 0.5]</code>.</p>
<p>If we want to <b>reduce the blur by a factor of 2</b>, we set <em>motion:blurScale</em> to <code>0.5</code>, <b>scaling</b> the sampling window by <code>0.5</code> (around the pivot of <code>frameTime</code>), and "pushing out" the smaller window of samples by a factor of two to make them fill the shutter window - we realize less blur by taking samples closer to the shutter-open and "looking at them" longer. Concretely, if we are taking the usual two samples, the first sample is unchanged (as we would expect since it provides the anchoring pose); however, the <em>second</em> sample is evaluated at scene time <code>frameTime + 0.25</code> instead of <code>frameTime + 0.5</code>, but the time ordinate we attach to it as we hand it to the renderer is <code>0.5</code>.</p>
<p>If we want to <b>increase the blur by a factor of 3</b>, we set <em>motion:blurScale</em> to <code>3.0</code>, <b>scaling</b> the sampling window by a factor of three (around the pivot of <code>frameTime</code>) which, for high-quality render-preppers such as Hydra means that we will prepare <b>all</b> the samples we find in the scene in the interval <code>[frameTime, frameTime+1.5]</code>, which will likely encompass <b>more</b> samples, representing more motion. For those samples to contribute to the render, they must be made to fit within the shutter window, so we rescale the sample times such that, for example, if the final sample were at frame-relative scene time <code>1.5</code>, it would be scaled by 1/3 to rest at shutter time <code>0.5</code>.</p>
<p>This technique works equally well for motion derived from simple, interpolation-based sampling, and also for samples computed using velocities and accelerations, as described in <a class="el" href="usd_geom_page_front.html#UsdGeom_VelocityInterpolation">Applying Timesampled Velocities to Geometry</a> .</p>
<h1><a class="anchor" id="UsdGeom_StageMetrics"></a>
Stage Metrics</h1>
<p>The classes described above are concerned with individual primitives and properties. Some geometic quantities, however, describe aspects of an entire scene, which we encode as <em>stage metadata</em>. For example it is UsdGeom that allows <a class="el" href="group___usd_geom_up_axis__group.html">Encoding Stage UpAxis</a> and <a class="el" href="group___usd_geom_linear_units__group.html">Encoding Stage Linear Units</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:57 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>