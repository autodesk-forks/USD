<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="namespacepxr___c_l_i_1_1_c_l_i_1_1detail" kind="namespace" language="C++">
    <compoundname>pxr_CLI::CLI::detail</compoundname>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1_app_friend" prot="public">pxr_CLI::CLI::detail::AppFriend</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1element__type" prot="public">pxr_CLI::CLI::detail::element_type</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1element__type_3_01_t_00_01typename_01std_1_1enable__if_ae296cb51a40e8413595b04af8f521d4" prot="public">pxr_CLI::CLI::detail::element_type&lt; T, typename std::enable_if&lt; is_copyable_ptr&lt; T &gt;::value &gt;::type &gt;</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1element__value__type" prot="public">pxr_CLI::CLI::detail::element_value_type</innerclass>
    <innerclass refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1_existing_directory_validator" prot="public">pxr_CLI::CLI::detail::ExistingDirectoryValidator</innerclass>
    <innerclass refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1_existing_file_validator" prot="public">pxr_CLI::CLI::detail::ExistingFileValidator</innerclass>
    <innerclass refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1_existing_path_validator" prot="public">pxr_CLI::CLI::detail::ExistingPathValidator</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1has__find" prot="public">pxr_CLI::CLI::detail::has_find</innerclass>
    <innerclass refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1_i_p_v4_validator" prot="public">pxr_CLI::CLI::detail::IPV4Validator</innerclass>
    <innerclass refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__complex" prot="public">pxr_CLI::CLI::detail::is_complex</innerclass>
    <innerclass refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__direct__constructible" prot="public">pxr_CLI::CLI::detail::is_direct_constructible</innerclass>
    <innerclass refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__istreamable" prot="public">pxr_CLI::CLI::detail::is_istreamable</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__mutable__container" prot="public">pxr_CLI::CLI::detail::is_mutable_container</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__mutable__container_3_01_t_00_01conditional__t_3_01f0fc9658eed2515742d284fd189a9eb1d" prot="public">pxr_CLI::CLI::detail::is_mutable_container&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type, decltype(std::declval&lt; T &gt;().end()), decltype(std::declval&lt; T &gt;().clear()), decltype(std::declval&lt; T &gt;().insert(std::declval&lt; decltype(std::declval&lt; T &gt;().end())&gt;(), std::declval&lt; const typename T::value_type &amp; &gt;()))&gt;, void &gt; &gt;</innerclass>
    <innerclass refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__ostreamable" prot="public">pxr_CLI::CLI::detail::is_ostreamable</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__readable__container" prot="public">pxr_CLI::CLI::detail::is_readable_container</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__readable__container_3_01_t_00_01conditional__t_3_015deb68487f45037f4ec1002927092177" prot="public">pxr_CLI::CLI::detail::is_readable_container&lt; T, conditional_t&lt; false, void_t&lt; decltype(std::declval&lt; T &gt;().end()), decltype(std::declval&lt; T &gt;().begin())&gt;, void &gt; &gt;</innerclass>
    <innerclass refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__tuple__like" prot="public">pxr_CLI::CLI::detail::is_tuple_like</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__wrapper" prot="public">pxr_CLI::CLI::detail::is_wrapper</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__wrapper_3_01_t_00_01conditional__t_3_01false_00_01vb96019f2edb62df3d854e47ac12f159a" prot="public">pxr_CLI::CLI::detail::is_wrapper&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type &gt;, void &gt; &gt;</innerclass>
    <innerclass refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1_nonexistent_path_validator" prot="public">pxr_CLI::CLI::detail::NonexistentPathValidator</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1pair__adaptor" prot="public">pxr_CLI::CLI::detail::pair_adaptor</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1pair__adaptor_3_01_t_00_01conditional__t_3_01false_00_061b9c0d15beb21e206a58583a1ffa357" prot="public">pxr_CLI::CLI::detail::pair_adaptor&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type::first_type, typename T::value_type::second_type &gt;, void &gt; &gt;</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1subtype__count" prot="public">pxr_CLI::CLI::detail::subtype_count</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1subtype__count__min" prot="public">pxr_CLI::CLI::detail::subtype_count_min</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count" prot="public">pxr_CLI::CLI::detail::type_count</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_4289e7af6fb3d798b82481000c59cc57" prot="public">pxr_CLI::CLI::detail::type_count&lt; T, typename std::enable_if&lt; is_complex&lt; T &gt;::value &gt;::type &gt;</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_1e4545234cac89cab0a985aa37bc8128" prot="public">pxr_CLI::CLI::detail::type_count&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt;</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_295e4dcf84d3724cfa42817f16b67f40" prot="public">pxr_CLI::CLI::detail::type_count&lt; T, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &gt;::type &gt;</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count_3_01_t_00_01typename_01std_1_1enable__if_3_554c9019fc27a3e8df4e129291a5a951" prot="public">pxr_CLI::CLI::detail::type_count&lt; T, typename std::enable_if&lt;!is_wrapper&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt;</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count__base" prot="public">pxr_CLI::CLI::detail::type_count_base</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable_8a13f8fe576a1001c6aca10cb804cab7" prot="public">pxr_CLI::CLI::detail::type_count_base&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt;</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable_92caf551d327eec308ddbeb704795429" prot="public">pxr_CLI::CLI::detail::type_count_base&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &gt;::type &gt;</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count__base_3_01_t_00_01typename_01std_1_1enable_8edce2548eb400550874486844beff0b" prot="public">pxr_CLI::CLI::detail::type_count_base&lt; T, typename std::enable_if&lt;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt;</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1wrapped__type" prot="public">pxr_CLI::CLI::detail::wrapped_type</innerclass>
    <innerclass refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1wrapped__type_3_01_t_00_01def_00_01typename_01std_1_1ena13b56b88558cae053b49c37ac36da7a" prot="public">pxr_CLI::CLI::detail::wrapped_type&lt; T, def, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &gt;::type &gt;</innerclass>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="_c_l_i11_8h_1afa024ebea52a21a5dbbe774795d584ea" prot="public" static="no" strong="yes">
        <type></type>
        <name>enabler</name>
        <briefdescription>
<para>Simple empty scoped class. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="982" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="982" bodyend="982"/>
      </memberdef>
      <memberdef kind="enum" id="_c_l_i11_8h_1ac086f3bdf13b15854b25337f6bebcff4" prot="public" static="no" strong="yes">
        <type></type>
        <name>path_type</name>
        <enumvalue id="_c_l_i11_8h_1ac086f3bdf13b15854b25337f6bebcff4a357f5c155c9da6842b84ad1066996928" prot="public">
          <name>nonexistent</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="_c_l_i11_8h_1ac086f3bdf13b15854b25337f6bebcff4a8c7dd922ad47494fc02c388e12c00eac" prot="public">
          <name>file</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="_c_l_i11_8h_1ac086f3bdf13b15854b25337f6bebcff4a5f8f22b8cdbaeee8cf857673a9b6ba20" prot="public">
          <name>directory</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>CLI enumeration of different file types. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="2963" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="2963" bodyend="2963"/>
      </memberdef>
      <memberdef kind="enum" id="_c_l_i11_8h_1aca4f59026ebd9f0d2a2b9a6f860a6d11" prot="public" static="no" strong="yes">
        <type></type>
        <name>Classifier</name>
        <enumvalue id="_c_l_i11_8h_1aca4f59026ebd9f0d2a2b9a6f860a6d11ab50339a10e1de285ac99d4c3990b8693" prot="public">
          <name>NONE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="_c_l_i11_8h_1aca4f59026ebd9f0d2a2b9a6f860a6d11a2b1681c49e27b242d19b93c5c3620cb6" prot="public">
          <name>POSITIONAL_MARK</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="_c_l_i11_8h_1aca4f59026ebd9f0d2a2b9a6f860a6d11aa35c2b02966b1563e5bf7b81b8b0cf77" prot="public">
          <name>SHORT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="_c_l_i11_8h_1aca4f59026ebd9f0d2a2b9a6f860a6d11ac1fabfea54ec6011e694f211f3ffebf3" prot="public">
          <name>LONG</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="_c_l_i11_8h_1aca4f59026ebd9f0d2a2b9a6f860a6d11a0693f2b4d4f0740bc76a2d65566b4fda" prot="public">
          <name>WINDOWS_STYLE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="_c_l_i11_8h_1aca4f59026ebd9f0d2a2b9a6f860a6d11ac4fb22412f02354dbe5574e37caf50a7" prot="public">
          <name>SUBCOMMAND</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="_c_l_i11_8h_1aca4f59026ebd9f0d2a2b9a6f860a6d11ab447b0bfeb6e4502fb6a0c4223fb8d00" prot="public">
          <name>SUBCOMMAND_TERMINATOR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="5567" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="5567" bodyend="5567"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="_c_l_i11_8h_1af0443f2d53b0114b4d138768ab985f3a" prot="public" static="no" mutable="no">
        <type>constexpr int</type>
        <definition>constexpr int expected_max_vector_size</definition>
        <argsstring></argsstring>
        <name>expected_max_vector_size</name>
        <initializer>{1 &lt;&lt; 29}</initializer>
        <briefdescription>
<para>a constant defining an expected max vector size defined to be a big number that could be multiplied by 4 and not produce overflow for some expected uses </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="216" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="216" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_c_l_i11_8h_1ac1c9e2d00742aeee2b98a35703b39d1f" prot="public" static="no" mutable="no">
        <type>constexpr enabler</type>
        <definition>constexpr enabler dummy</definition>
        <argsstring></argsstring>
        <name>dummy</name>
        <initializer>= {}</initializer>
        <briefdescription>
<para>An instance to use in EnableIf. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="985" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="985" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="_c_l_i11_8h_1ac33883f06a03f5a8efec999d89eedfab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::vector&lt; std::string &gt;</type>
        <definition>CLI11_INLINE std::vector&lt; std::string &gt; split</definition>
        <argsstring>(const std::string &amp;s, char delim)</argsstring>
        <name>split</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>s</declname>
        </param>
        <param>
          <type>char</type>
          <declname>delim</declname>
        </param>
        <briefdescription>
<para>Split a string by a delim. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="219" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="403" bodyend="417"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a5cc8ffd907fc03e4941f2a57ebc12eb9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string pxr_CLI::CLI::detail::join</definition>
        <argsstring>(const T &amp;v, std::string delim=&quot;,&quot;)</argsstring>
        <name>join</name>
        <param>
          <type>const T &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>delim</declname>
          <defval>&quot;,&quot;</defval>
        </param>
        <briefdescription>
<para>Simple function to join a string. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="222" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="222" bodyend="232"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a96d59a05fd18172669cbcc96503cd0e1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Callable</type>
          </param>
          <param>
            <type>typename</type>
            <defval>typename std::enable_if&lt;!std::is_constructible&lt;std::string, Callable&gt;::value&gt;::type</defval>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string pxr_CLI::CLI::detail::join</definition>
        <argsstring>(const T &amp;v, Callable func, std::string delim=&quot;,&quot;)</argsstring>
        <name>join</name>
        <param>
          <type>const T &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>Callable</type>
          <declname>func</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>delim</declname>
          <defval>&quot;,&quot;</defval>
        </param>
        <briefdescription>
<para>Simple function to join a string from processed elements. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="238" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="238" bodyend="252"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a0e4865da698e64a4aeecf045d1198f83" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string pxr_CLI::CLI::detail::rjoin</definition>
        <argsstring>(const T &amp;v, std::string delim=&quot;,&quot;)</argsstring>
        <name>rjoin</name>
        <param>
          <type>const T &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>delim</declname>
          <defval>&quot;,&quot;</defval>
        </param>
        <briefdescription>
<para>Join a string in reverse order. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="255" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="255" bodyend="263"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1af6c42bb23b04432c79edfcd042991a01" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::string &amp;</type>
        <definition>CLI11_INLINE std::string &amp; ltrim</definition>
        <argsstring>(std::string &amp;str)</argsstring>
        <name>ltrim</name>
        <param>
          <type>std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Trim whitespace from left of string. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="268" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="419" bodyend="423"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ac1d976da39cbdc46f6bdff083f128d42" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::string &amp;</type>
        <definition>CLI11_INLINE std::string &amp; ltrim</definition>
        <argsstring>(std::string &amp;str, const std::string &amp;filter)</argsstring>
        <name>ltrim</name>
        <param>
          <type>std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>filter</declname>
        </param>
        <briefdescription>
<para>Trim anything from left of string. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="271" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="425" bodyend="429"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a0f5ba6fa4b9127ba9d7931593cac134c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::string &amp;</type>
        <definition>CLI11_INLINE std::string &amp; rtrim</definition>
        <argsstring>(std::string &amp;str)</argsstring>
        <name>rtrim</name>
        <param>
          <type>std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Trim whitespace from right of string. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="274" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="431" bodyend="435"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ab617a13182c3c18511e3dd9d17417f9b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::string &amp;</type>
        <definition>CLI11_INLINE std::string &amp; rtrim</definition>
        <argsstring>(std::string &amp;str, const std::string &amp;filter)</argsstring>
        <name>rtrim</name>
        <param>
          <type>std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>filter</declname>
        </param>
        <briefdescription>
<para>Trim anything from right of string. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="277" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="437" bodyend="442"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a2b7af34c77c500ebd3ab136b194b95bb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string &amp;</type>
        <definition>std::string&amp; pxr_CLI::CLI::detail::trim</definition>
        <argsstring>(std::string &amp;str)</argsstring>
        <name>trim</name>
        <param>
          <type>std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Trim whitespace from string. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="280" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="280" bodyend="280"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a4b591dfce3660ace60b1556f42bae042" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string &amp;</type>
        <definition>std::string&amp; pxr_CLI::CLI::detail::trim</definition>
        <argsstring>(std::string &amp;str, const std::string filter)</argsstring>
        <name>trim</name>
        <param>
          <type>std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const std::string</type>
          <declname>filter</declname>
        </param>
        <briefdescription>
<para>Trim anything from string. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="283" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="283" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ab9626a7b2603e9517a7beffbe28951b7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string pxr_CLI::CLI::detail::trim_copy</definition>
        <argsstring>(const std::string &amp;str)</argsstring>
        <name>trim_copy</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Make a copy of the string and then trim it. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="286" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="286" bodyend="289"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ac2d945dfcc1e11df6ab0bcbe46ee7850" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::string &amp;</type>
        <definition>CLI11_INLINE std::string &amp; remove_quotes</definition>
        <argsstring>(std::string &amp;str)</argsstring>
        <name>remove_quotes</name>
        <param>
          <type>std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>remove quotes at the front and back of a string either &apos;&quot;&apos; or &apos;\&apos;&apos; </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="292" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="444" bodyend="452"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a932b458875e4f9c54c6f8c5167cbdd60" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::string</type>
        <definition>CLI11_INLINE std::string fix_newlines</definition>
        <argsstring>(const std::string &amp;leader, std::string input)</argsstring>
        <name>fix_newlines</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>leader</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>input</declname>
        </param>
        <briefdescription>
<para>Add a leader to the beginning of all new lines (nothing is added at the start of the first line). </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>&quot;; &quot;</computeroutput> would be for ini files</para>
<para>Can&apos;t use Regex, or this would be a subs. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="298" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="454" bodyend="464"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ab4a581264e9974f0dd6c915faf059ca4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string pxr_CLI::CLI::detail::trim_copy</definition>
        <argsstring>(const std::string &amp;str, const std::string &amp;filter)</argsstring>
        <name>trim_copy</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>filter</declname>
        </param>
        <briefdescription>
<para>Make a copy of the string and then trim it, any filter string can be used (any char in string is filtered) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="301" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="301" bodyend="304"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a93602e32004f4cdc98d09fc16a0333b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::ostream &amp;</type>
        <definition>CLI11_INLINE std::ostream &amp; format_help</definition>
        <argsstring>(std::ostream &amp;out, std::string name, const std::string &amp;description, std::size_t wid)</argsstring>
        <name>format_help</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>description</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>wid</declname>
        </param>
        <briefdescription>
<para>Print a two part &quot;help&quot; string. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="307" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="467" bodyend="482"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1aa7362ddfcc6a00e0cc7583eef094525a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::ostream &amp;</type>
        <definition>CLI11_INLINE std::ostream &amp; format_aliases</definition>
        <argsstring>(std::ostream &amp;out, const std::vector&lt; std::string &gt; &amp;aliases, std::size_t wid)</argsstring>
        <name>format_aliases</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>aliases</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>wid</declname>
        </param>
        <briefdescription>
<para>Print subcommand aliases. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="310" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="484" bodyend="499"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a0e7d1cd3f7142ed3537365d7227dd7bf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool pxr_CLI::CLI::detail::valid_first_char</definition>
        <argsstring>(T c)</argsstring>
        <name>valid_first_char</name>
        <param>
          <type>T</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>Verify the first character of an option. </para>
        </briefdescription>
        <detaileddescription>
<para><itemizedlist>
<listitem><para>is a trigger character, ! has special meaning and new lines would just be annoying to deal with </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="314" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="314" bodyend="314"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a653c98e201da51ac4f5c95d0007385e6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool pxr_CLI::CLI::detail::valid_later_char</definition>
        <argsstring>(T c)</argsstring>
        <name>valid_later_char</name>
        <param>
          <type>T</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>Verify following characters of an option. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="317" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="317" bodyend="322"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ab273d88907ac9feaefc88a4991322384" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE bool</type>
        <definition>CLI11_INLINE bool valid_name_string</definition>
        <argsstring>(const std::string &amp;str)</argsstring>
        <name>valid_name_string</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Verify an option/subcommand name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="325" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="501" bodyend="510"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a6d0004772916533b0e2dd37ce4e3832b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool pxr_CLI::CLI::detail::valid_alias_name_string</definition>
        <argsstring>(const std::string &amp;str)</argsstring>
        <name>valid_alias_name_string</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Verify an app name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="328" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="328" bodyend="331"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ad1d4fc2eb044cf9d76a9d0800d58265d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool pxr_CLI::CLI::detail::is_separator</definition>
        <argsstring>(const std::string &amp;str)</argsstring>
        <name>is_separator</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>check if a string is a container segment separator (empty or &quot;%%&quot;) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="334" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="334" bodyend="337"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ab961594e0f403ff88cb42815f7879b9c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool pxr_CLI::CLI::detail::isalpha</definition>
        <argsstring>(const std::string &amp;str)</argsstring>
        <name>isalpha</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Verify that str consists of letters only. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="340" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="340" bodyend="342"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a8aa11f9f02dd354df593594b8b4401ef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string pxr_CLI::CLI::detail::to_lower</definition>
        <argsstring>(std::string str)</argsstring>
        <name>to_lower</name>
        <param>
          <type>std::string</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Return a lower case version of a string. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="345" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="345" bodyend="350"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a2dfca668bd761e5ae918bf432f765494" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string pxr_CLI::CLI::detail::remove_underscore</definition>
        <argsstring>(std::string str)</argsstring>
        <name>remove_underscore</name>
        <param>
          <type>std::string</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>remove underscores from a string </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="353" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="353" bodyend="356"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a3a0ee3aa31474ea452b0e5ce55de9586" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::string</type>
        <definition>CLI11_INLINE std::string find_and_replace</definition>
        <argsstring>(std::string str, std::string from, std::string to)</argsstring>
        <name>find_and_replace</name>
        <param>
          <type>std::string</type>
          <declname>str</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>from</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>to</declname>
        </param>
        <briefdescription>
<para>Find and replace a substring with another substring. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="359" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="512" bodyend="522"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ae8608f6607a371ae6bef55f1df8b420d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool pxr_CLI::CLI::detail::has_default_flag_values</definition>
        <argsstring>(const std::string &amp;flags)</argsstring>
        <name>has_default_flag_values</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
<para>check if the flag definitions has possible false flags </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="362" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="362" bodyend="364"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ad7f6350a6afc065bce148734d625c327" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE void</type>
        <definition>CLI11_INLINE void remove_default_flag_values</definition>
        <argsstring>(std::string &amp;flags)</argsstring>
        <name>remove_default_flag_values</name>
        <param>
          <type>std::string &amp;</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="366" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="524" bodyend="535"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a65bcba1a54461fee9cf95fdeb2afa307" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::ptrdiff_t</type>
        <definition>CLI11_INLINE std::ptrdiff_t find_member</definition>
        <argsstring>(std::string name, const std::vector&lt; std::string &gt; names, bool ignore_case=false, bool ignore_underscore=false)</argsstring>
        <name>find_member</name>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt;</type>
          <declname>names</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>ignore_case</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>ignore_underscore</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Check if a string is a member of a list of strings and optionally ignore case or ignore underscores. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="369" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="538" bodyend="563"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1add78f7d25cc16f79768bcecfcb3d07ee" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Callable</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string pxr_CLI::CLI::detail::find_and_modify</definition>
        <argsstring>(std::string str, std::string trigger, Callable modify)</argsstring>
        <name>find_and_modify</name>
        <param>
          <type>std::string</type>
          <declname>str</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>trigger</declname>
        </param>
        <param>
          <type>Callable</type>
          <declname>modify</declname>
        </param>
        <briefdescription>
<para>Find a trigger string and call a modify callable function that takes the current string and starting position of the trigger and returns the position in the string to search for the next trigger string. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="376" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="376" bodyend="382"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ad32374046641a5c64f85eeb37671c5de" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::vector&lt; std::string &gt;</type>
        <definition>CLI11_INLINE std::vector&lt; std::string &gt; split_up</definition>
        <argsstring>(std::string str, char delimiter=&apos;\0&apos;)</argsstring>
        <name>split_up</name>
        <param>
          <type>std::string</type>
          <declname>str</declname>
        </param>
        <param>
          <type>char</type>
          <declname>delimiter</declname>
          <defval>&apos;\0&apos;</defval>
        </param>
        <briefdescription>
<para>Split a string &apos;&quot;one two&quot; &quot;three&quot;&apos; into &apos;one two&apos;, &apos;three&apos; Quote characters can be <lsquo/> <rsquo/> or ". </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="386" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="565" bodyend="615"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a580e358ed81dcc182a6e7dca27eb2ebd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::size_t</type>
        <definition>CLI11_INLINE std::size_t escape_detect</definition>
        <argsstring>(std::string &amp;str, std::size_t offset)</argsstring>
        <name>escape_detect</name>
        <param>
          <type>std::string &amp;</type>
          <declname>str</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>offset</declname>
        </param>
        <briefdescription>
<para>This function detects an equal or colon followed by an escaped quote after an argument then modifies the string to replace the equality with a space. </para>
        </briefdescription>
        <detaileddescription>
<para>This is needed to allow the split up function to work properly and is intended to be used with the find_and_modify function the return value is the offset+1 which is required by the find_and_modify function. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="392" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="617" bodyend="627"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a3189aa2410300be3c61ad3e1302ccd3d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::string &amp;</type>
        <definition>CLI11_INLINE std::string &amp; add_quotes_if_needed</definition>
        <argsstring>(std::string &amp;str)</argsstring>
        <name>add_quotes_if_needed</name>
        <param>
          <type>std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Add quotes if the string contains spaces. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="395" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="629" bodyend="638"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a82ca7c62680b82fa4ced7b88cc782ef6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>enable_if_t&lt; is_istreamable&lt; T &gt;::value, detail::enabler &gt;</type>
            <defval>detail::dummy</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool from_stream</definition>
        <argsstring>(const std::string &amp;istring, T &amp;obj)</argsstring>
        <name>from_stream</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>istring</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>obj</declname>
        </param>
        <briefdescription>
<para>Templated operation to get a value from a stream. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="1158" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="1158" bodyend="1163"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a8a20772df8009de4e6ba2177c98e9ead" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>enable_if_t&lt; std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;</type>
            <defval>detail::dummy</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto pxr_CLI::CLI::detail::to_string</definition>
        <argsstring>(T &amp;&amp;value) -&gt; decltype(std::forward&lt; T &gt;(value))</argsstring>
        <name>to_string</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Convert an object to a string (directly forward if this can become a string) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="1221" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="1221" bodyend="1223"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a22d636b5ab102cb9f919e6ba09e66a6b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>enable_if_t&lt; std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;!std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;</type>
            <defval>detail::dummy</defval>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string pxr_CLI::CLI::detail::to_string</definition>
        <argsstring>(const T &amp;value)</argsstring>
        <name>to_string</name>
        <param>
          <type>const T &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Construct a string from the object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="1229" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="1229" bodyend="1231"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a2a46e705fb31d0ba68d78c03c916eda0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>enable_if_t&lt;!std::is_convertible&lt; std::string, T &gt;::value &amp;&amp;!std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;is_ostreamable&lt; T &gt;::value, detail::enabler &gt;</type>
            <defval>detail::dummy</defval>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string to_string</definition>
        <argsstring>(T &amp;&amp;value)</argsstring>
        <name>to_string</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Convert an object to a string (streaming must be supported for that type) </para>
        </briefdescription>
        <detaileddescription>
<para>convert a readable container to a string</para>
<para>If conversion is not supported, return an empty string (streaming is not supported for that type) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="1238" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="1238" bodyend="1242"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a74197f237a34d6482d84aeece018f988" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>enable_if_t&lt; std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;</type>
            <defval>detail::dummy</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto pxr_CLI::CLI::detail::checked_to_string</definition>
        <argsstring>(T &amp;&amp;value) -&gt; decltype(to_string(std::forward&lt; T &gt;(value)))</argsstring>
        <name>checked_to_string</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>special template overload </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="1277" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="1277" bodyend="1279"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1aac6f1dbca4ad1062bda882faf8ce96ca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>enable_if_t&lt;!std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;</type>
            <defval>detail::dummy</defval>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string pxr_CLI::CLI::detail::checked_to_string</definition>
        <argsstring>(T &amp;&amp;)</argsstring>
        <name>checked_to_string</name>
        <param>
          <type>T &amp;&amp;</type>
        </param>
        <briefdescription>
<para>special template overload </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="1286" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="1286" bodyend="1288"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a11e91680ff5cd32faacbaf6e151aa5ae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;</type>
            <defval>detail::dummy</defval>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string value_string</definition>
        <argsstring>(const T &amp;value)</argsstring>
        <name>value_string</name>
        <param>
          <type>const T &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>get a string as a convertible value for arithmetic types </para>
        </briefdescription>
        <detaileddescription>
<para>get a string as a convertible value for enumerations </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="1291" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="1291" bodyend="1293"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ad3e4e7b511c66b6fe65651b8e5a6fdef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>enable_if_t&lt;!std::is_enum&lt; T &gt;::value &amp;&amp;!std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;</type>
            <defval>detail::dummy</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto pxr_CLI::CLI::detail::value_string</definition>
        <argsstring>(const T &amp;value) -&gt; decltype(to_string(value))</argsstring>
        <name>value_string</name>
        <param>
          <type>const T &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>for other types just use the regular to_string function </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="1302" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="1302" bodyend="1304"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ae9e07981e9fc959ae6f1909b4949709e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>I</declname>
            <defname>I</defname>
          </param>
        </templateparamlist>
        <type>constexpr std::enable_if&lt; I==<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count__base" kindref="compound">type_count_base</ref>&lt; T &gt;::value, int &gt;::type</type>
        <definition>constexpr std::enable_if&lt;I == type_count_base&lt;T&gt;::value, int&gt;::type pxr_CLI::CLI::detail::tuple_type_size</definition>
        <argsstring>()</argsstring>
        <name>tuple_type_size</name>
        <briefdescription>
<para>0 if the index &gt; tuple size </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="1375" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="1375" bodyend="1377"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a520a7c314b3036e3e7c7a4ee56c0e75d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>I</declname>
            <defname>I</defname>
          </param>
        </templateparamlist>
        <type>constexpr std::enable_if&lt; I&lt; <ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count__base" kindref="compound">type_count_base</ref>&lt; T &gt;::value, int &gt;::type tuple_type_size() { return <ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1subtype__count" kindref="compound">subtype_count</ref>&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+tuple_type_size&lt; T, I+1 &gt;);}template&lt; typename T &gt; struct <ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count" kindref="compound">type_count</ref>&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{tuple_type_size&lt; T, 0 &gt;)};};template&lt; typename T &gt; struct <ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1subtype__count" kindref="compound">subtype_count</ref> { static constexpr int value{is_mutable_container&lt; T &gt;::value ? expected_max_vector_size :<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count" kindref="compound">type_count</ref>&lt; T &gt;::value};};template&lt; typename T, typename Enable=void &gt; struct type_count_min { static const int value{0};};template&lt; typename T &gt;struct type_count_min&lt; T, typename std::enable_if&lt;!is_mutable_container&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;!<ref refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__complex" kindref="compound">is_complex</ref>&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count" kindref="compound">type_count</ref>&lt; T &gt;::value};};template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; <ref refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__complex" kindref="compound">is_complex</ref>&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{1};};template&lt; typename T &gt;struct type_count_min&lt; T, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &amp;&amp;!<ref refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__complex" kindref="compound">is_complex</ref>&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1subtype__count__min" kindref="compound">subtype_count_min</ref>&lt; typename T::value_type &gt;::value};};template&lt; typename T, std::size_t I &gt;constexpr typename std::enable_if&lt; I==<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count__base" kindref="compound">type_count_base</ref>&lt; T &gt;::value, int &gt;::type tuple_type_size_min() { return 0;}template&lt; typename T, std::size_t I &gt; constexpr typename std::enable_if&lt; I&lt; <ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count__base" kindref="compound">type_count_base</ref>&lt; T &gt;::value, int &gt;::type tuple_type_size_min() { return <ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1subtype__count__min" kindref="compound">subtype_count_min</ref>&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+tuple_type_size_min&lt; T, I+1 &gt;);}template&lt; typename T &gt; struct type_count_min&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{tuple_type_size_min&lt; T, 0 &gt;)};};template&lt; typename T &gt; struct <ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1subtype__count__min" kindref="compound">subtype_count_min</ref> { static constexpr int value{is_mutable_container&lt; T &gt;::value ?((<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count" kindref="compound">type_count</ref>&lt; T &gt;::value&lt; expected_max_vector_size) ? <ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count" kindref="compound">type_count</ref>&lt; T &gt;::value :0) :type_count_min&lt; T &gt;::value};};template&lt; typename T, typename Enable=void &gt; struct expected_count { static const int value{0};};template&lt; typename T &gt;struct expected_count&lt; T, typename std::enable_if&lt;!is_mutable_container&lt; T &gt;::value &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{1};};template&lt; typename T &gt; struct expected_count&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{expected_max_vector_size};};template&lt; typename T &gt;struct expected_count&lt; T, typename std::enable_if&lt;!is_mutable_container&lt; T &gt;::value &amp;&amp;is_wrapper&lt; T &gt;::value &gt;::type &gt; { static constexpr int value{expected_count&lt; typename T::value_type &gt;::value};};enum class object_category :int { char_value=1, integral_value=2, unsigned_integral=4, enumeration=6, boolean_value=8, floating_point=10, number_constructible=12, double_constructible=14, integer_constructible=16, string_assignable=23, string_constructible=24, other=45, wrapper_value=50, complex_number=60, tuple_value=70, container_value=80,};template&lt; typename T, typename Enable=void &gt; struct classify_object { static constexpr object_category value{object_category::other};};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, char &gt;::value &amp;&amp;std::is_signed&lt; T &gt;::value &amp;&amp;!<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1is__bool" kindref="compound">is_bool</ref>&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::integral_value};};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_unsigned&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, char &gt;::value &amp;&amp;!<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1is__bool" kindref="compound">is_bool</ref>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::unsigned_integral};};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; std::is_same&lt; T, char &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::char_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <ref refid="structpxr___c_l_i_1_1_c_l_i_1_1is__bool" kindref="compound">is_bool</ref>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::boolean_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::floating_point};};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;std::is_assignable&lt; T &amp;, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::string_assignable};};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;(<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count" kindref="compound">type_count</ref>&lt; T &gt;::value==1) &amp;&amp;std::is_constructible&lt; T, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::string_constructible};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::enumeration};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; <ref refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__complex" kindref="compound">is_complex</ref>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::complex_number};};template&lt; typename T &gt; struct uncommon_type { using type=typename std::conditional&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::string &gt;::value &amp;&amp;!<ref refid="classpxr___c_l_i_1_1_c_l_i_1_1detail_1_1is__complex" kindref="compound">is_complex</ref>&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value, std::true_type, std::false_type &gt;::type;static constexpr bool value=type::value;};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt;(!is_mutable_container&lt; T &gt;::value &amp;&amp;is_wrapper&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;uncommon_type&lt; T &gt;::value)&gt;::type &gt; { static constexpr object_category value{object_category::wrapper_value};};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count" kindref="compound">type_count</ref>&lt; T &gt;::value==1 &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;is_direct_constructible&lt; T, double &gt;::value &amp;&amp;is_direct_constructible&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::number_constructible};};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count" kindref="compound">type_count</ref>&lt; T &gt;::value==1 &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;!is_direct_constructible&lt; T, double &gt;::value &amp;&amp;is_direct_constructible&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::integer_constructible};};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count" kindref="compound">type_count</ref>&lt; T &gt;::value==1 &amp;&amp;!is_wrapper&lt; T &gt;::value &amp;&amp;is_direct_constructible&lt; T, double &gt;::value &amp;&amp;!is_direct_constructible&lt; T, int &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::double_constructible};};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &amp;&amp;((<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count" kindref="compound">type_count</ref>&lt; T &gt;::value &gt;=2 &amp;&amp;!is_wrapper&lt; T &gt;::value)||(uncommon_type&lt; T &gt;::value &amp;&amp;!is_direct_constructible&lt; T, double &gt;::value &amp;&amp;!is_direct_constructible&lt; T, int &gt;::value)||(uncommon_type&lt; T &gt;::value &amp;&amp;<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count" kindref="compound">type_count</ref>&lt; T &gt;::value &gt;=2))&gt;::type &gt; { static constexpr object_category value{object_category::tuple_value};};template&lt; typename T &gt; struct classify_object&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value{object_category::container_value};};template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::char_value, detail::enabler &gt;=detail::dummy &gt;constexpr const char *type_name() { return &quot;CHAR&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::integer_constructible, detail::enabler &gt;=detail::dummy &gt;constexpr const char *type_name() { return &quot;INT&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::unsigned_integral, detail::enabler &gt;=detail::dummy &gt;constexpr const char *type_name() { return &quot;UINT&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::floating_point||classify_object&lt; T &gt;::value==object_category::number_constructible||classify_object&lt; T &gt;::value==object_category::double_constructible, detail::enabler &gt;=detail::dummy &gt;constexpr const char *type_name() { return &quot;FLOAT&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::enumeration, detail::enabler &gt;=detail::dummy &gt;constexpr const char *type_name() { return &quot;ENUM&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::boolean_value, detail::enabler &gt;=detail::dummy &gt;constexpr const char *type_name() { return &quot;BOOLEAN&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::complex_number, detail::enabler &gt;=detail::dummy &gt;constexpr const char *type_name() { return &quot;COMPLEX&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value &gt;=object_category::string_assignable &amp;&amp;classify_object&lt; T &gt;::value&lt;=object_category::other, detail::enabler &gt;=detail::dummy &gt;constexpr const char *type_name() { return &quot;TEXT&quot;;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count__base" kindref="compound">type_count_base</ref>&lt; T &gt;::value &gt;=2, detail::enabler &gt;=detail::dummy &gt;std::string type_name();template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, detail::enabler &gt;=detail::dummy &gt;std::string type_name();template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count__base" kindref="compound">type_count_base</ref>&lt; T &gt;::value==1, detail::enabler &gt;=detail::dummy &gt;inline std::string type_name() { return type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; 0, T &gt;::type &gt;::type &gt;);}template&lt; typename T, std::size_t I &gt;inline typename std::enable_if&lt; I==<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count__base" kindref="compound">type_count_base</ref>&lt; T &gt;::value, std::string &gt;::type tuple_name() { return std::string{};}template&lt; typename T, std::size_t I &gt;inline typename std::enable_if&lt;(I&lt; <ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count__base" kindref="compound">type_count_base</ref>&lt; T &gt;::value), std::string &gt;::type tuple_name() { auto str=std::string{type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::type &gt;)}+&apos;,&apos;+tuple_name&lt; T, I+1 &gt;);if(str.back()==&apos;,&apos;) str.pop_back();return str;}template&lt; typename T, enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<ref refid="structpxr___c_l_i_1_1_c_l_i_1_1detail_1_1type__count__base" kindref="compound">type_count_base</ref>&lt; T &gt;::value &gt;=2, detail::enabler &gt; &gt; std::string</type>
        <definition>constexpr std::enable_if&lt; I&lt;type_count_base&lt;T&gt;::value, int&gt;::type tuple_type_size() { return subtype_count&lt;typename std::tuple_element&lt;I, T&gt;::type&gt;::value + tuple_type_size&lt;T, I + 1&gt;);}template &lt;typename T&gt; struct type_count&lt;T, typename std::enable_if&lt;is_tuple_like&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{tuple_type_size&lt;T, 0&gt;)};};template &lt;typename T&gt; struct subtype_count { static constexpr int value{is_mutable_container&lt;T&gt;::value ? expected_max_vector_size : type_count&lt;T&gt;::value};};template &lt;typename T, typename Enable = void&gt; struct type_count_min { static const int value{0}; };template &lt;typename T&gt;struct type_count_min&lt; T, typename std::enable_if&lt;!is_mutable_container&lt;T&gt;::value &amp;&amp; !is_tuple_like&lt;T&gt;::value &amp;&amp; !is_wrapper&lt;T&gt;::value &amp;&amp; !is_complex&lt;T&gt;::value &amp;&amp; !std::is_void&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{type_count&lt;T&gt;::value};};template &lt;typename T&gt; struct type_count_min&lt;T, typename std::enable_if&lt;is_complex&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{1};};template &lt;typename T&gt;struct type_count_min&lt; T, typename std::enable_if&lt;is_wrapper&lt;T&gt;::value &amp;&amp; !is_complex&lt;T&gt;::value &amp;&amp; !is_tuple_like&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{subtype_count_min&lt;typename T::value_type&gt;::value};};template &lt;typename T, std::size_t I&gt;constexpr typename std::enable_if&lt;I == type_count_base&lt;T&gt;::value, int&gt;::type tuple_type_size_min() { return 0;}template &lt;typename T, std::size_t I&gt; constexpr typename std::enable_if &lt; I&lt;type_count_base&lt;T&gt;::value, int&gt;::type tuple_type_size_min() { return subtype_count_min&lt;typename std::tuple_element&lt;I, T&gt;::type&gt;::value + tuple_type_size_min&lt;T, I + 1&gt;);}template &lt;typename T&gt; struct type_count_min&lt;T, typename std::enable_if&lt;is_tuple_like&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{tuple_type_size_min&lt;T, 0&gt;)};};template &lt;typename T&gt; struct subtype_count_min { static constexpr int value{is_mutable_container&lt;T&gt;::value ? ((type_count&lt;T&gt;::value &lt; expected_max_vector_size) ? type_count&lt;T&gt;::value : 0) : type_count_min&lt;T&gt;::value};};template &lt;typename T, typename Enable = void&gt; struct expected_count { static const int value{0}; };template &lt;typename T&gt;struct expected_count&lt;T, typename std::enable_if&lt;!is_mutable_container&lt;T&gt;::value &amp;&amp; !is_wrapper&lt;T&gt;::value &amp;&amp; !std::is_void&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{1};};template &lt;typename T&gt; struct expected_count&lt;T, typename std::enable_if&lt;is_mutable_container&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{expected_max_vector_size};};template &lt;typename T&gt;struct expected_count&lt;T, typename std::enable_if&lt;!is_mutable_container&lt;T&gt;::value &amp;&amp; is_wrapper&lt;T&gt;::value&gt;::type&gt; { static constexpr int value{expected_count&lt;typename T::value_type&gt;::value};};enum class object_category : int { char_value = 1, integral_value = 2, unsigned_integral = 4, enumeration = 6, boolean_value = 8, floating_point = 10, number_constructible = 12, double_constructible = 14, integer_constructible = 16, string_assignable = 23, string_constructible = 24, other = 45, wrapper_value = 50, complex_number = 60, tuple_value = 70, container_value = 80,};template &lt;typename T, typename Enable = void&gt; struct classify_object { static constexpr object_category value{object_category::other};};template &lt;typename T&gt;struct classify_object&lt; T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, char&gt;::value &amp;&amp; std::is_signed&lt;T&gt;::value &amp;&amp; !is_bool&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::integral_value};};template &lt;typename T&gt;struct classify_object&lt;T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; std::is_unsigned&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, char&gt;::value &amp;&amp; !is_bool&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::unsigned_integral};};template &lt;typename T&gt;struct classify_object&lt;T, typename std::enable_if&lt;std::is_same&lt;T, char&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::char_value};};template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;is_bool&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::boolean_value};};template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::floating_point};};template &lt;typename T&gt;struct classify_object&lt;T, typename std::enable_if&lt;!std::is_floating_point&lt;T&gt;::value &amp;&amp; !std::is_integral&lt;T&gt;::value &amp;&amp; std::is_assignable&lt;T &amp;, std::string&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::string_assignable};};template &lt;typename T&gt;struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt;T&gt;::value &amp;&amp; !std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_assignable&lt;T &amp;, std::string&gt;::value &amp;&amp; (type_count&lt;T&gt;::value == 1) &amp;&amp; std::is_constructible&lt;T, std::string&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::string_constructible};};template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;std::is_enum&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::enumeration};};template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;is_complex&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::complex_number};};template &lt;typename T&gt; struct uncommon_type { using type = typename std::conditional&lt;!std::is_floating_point&lt;T&gt;::value &amp;&amp; !std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_assignable&lt;T &amp;, std::string&gt;::value &amp;&amp; !std::is_constructible&lt;T, std::string&gt;::value &amp;&amp; !is_complex&lt;T&gt;::value &amp;&amp; !is_mutable_container&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value, std::true_type, std::false_type&gt;::type; static constexpr bool value = type::value;};template &lt;typename T&gt;struct classify_object&lt;T, typename std::enable_if&lt;(!is_mutable_container&lt;T&gt;::value &amp;&amp; is_wrapper&lt;T&gt;::value &amp;&amp; !is_tuple_like&lt;T&gt;::value &amp;&amp; uncommon_type&lt;T&gt;::value)&gt;::type&gt; { static constexpr object_category value{object_category::wrapper_value};};template &lt;typename T&gt;struct classify_object&lt;T, typename std::enable_if&lt;uncommon_type&lt;T&gt;::value &amp;&amp; type_count&lt;T&gt;::value == 1 &amp;&amp; !is_wrapper&lt;T&gt;::value &amp;&amp; is_direct_constructible&lt;T, double&gt;::value &amp;&amp; is_direct_constructible&lt;T, int&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::number_constructible};};template &lt;typename T&gt;struct classify_object&lt;T, typename std::enable_if&lt;uncommon_type&lt;T&gt;::value &amp;&amp; type_count&lt;T&gt;::value == 1 &amp;&amp; !is_wrapper&lt;T&gt;::value &amp;&amp; !is_direct_constructible&lt;T, double&gt;::value &amp;&amp; is_direct_constructible&lt;T, int&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::integer_constructible};};template &lt;typename T&gt;struct classify_object&lt;T, typename std::enable_if&lt;uncommon_type&lt;T&gt;::value &amp;&amp; type_count&lt;T&gt;::value == 1 &amp;&amp; !is_wrapper&lt;T&gt;::value &amp;&amp; is_direct_constructible&lt;T, double&gt;::value &amp;&amp; !is_direct_constructible&lt;T, int&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::double_constructible};};template &lt;typename T&gt;struct classify_object&lt; T, typename std::enable_if&lt;is_tuple_like&lt;T&gt;::value &amp;&amp; ((type_count&lt;T&gt;::value &gt;= 2 &amp;&amp; !is_wrapper&lt;T&gt;::value) || (uncommon_type&lt;T&gt;::value &amp;&amp; !is_direct_constructible&lt;T, double&gt;::value &amp;&amp; !is_direct_constructible&lt;T, int&gt;::value) || (uncommon_type&lt;T&gt;::value &amp;&amp; type_count&lt;T&gt;::value &gt;= 2))&gt;::type&gt; { static constexpr object_category value{object_category::tuple_value}; };template &lt;typename T&gt; struct classify_object&lt;T, typename std::enable_if&lt;is_mutable_container&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value{object_category::container_value};};template &lt;typename T, enable_if_t&lt;classify_object&lt;T&gt;::value == object_category::char_value, detail::enabler&gt; = detail::dummy&gt;constexpr const char *type_name() { return &quot;CHAR&quot;;}template &lt;typename T, enable_if_t&lt;classify_object&lt;T&gt;::value == object_category::integral_value || classify_object&lt;T&gt;::value == object_category::integer_constructible, detail::enabler&gt; = detail::dummy&gt;constexpr const char *type_name() { return &quot;INT&quot;;}template &lt;typename T, enable_if_t&lt;classify_object&lt;T&gt;::value == object_category::unsigned_integral, detail::enabler&gt; = detail::dummy&gt;constexpr const char *type_name() { return &quot;UINT&quot;;}template &lt;typename T, enable_if_t&lt;classify_object&lt;T&gt;::value == object_category::floating_point || classify_object&lt;T&gt;::value == object_category::number_constructible || classify_object&lt;T&gt;::value == object_category::double_constructible, detail::enabler&gt; = detail::dummy&gt;constexpr const char *type_name() { return &quot;FLOAT&quot;;}template &lt;typename T, enable_if_t&lt;classify_object&lt;T&gt;::value == object_category::enumeration, detail::enabler&gt; = detail::dummy&gt;constexpr const char *type_name() { return &quot;ENUM&quot;;}template &lt;typename T, enable_if_t&lt;classify_object&lt;T&gt;::value == object_category::boolean_value, detail::enabler&gt; = detail::dummy&gt;constexpr const char *type_name() { return &quot;BOOLEAN&quot;;}template &lt;typename T, enable_if_t&lt;classify_object&lt;T&gt;::value == object_category::complex_number, detail::enabler&gt; = detail::dummy&gt;constexpr const char *type_name() { return &quot;COMPLEX&quot;;}template &lt;typename T, enable_if_t&lt;classify_object&lt;T&gt;::value &gt;= object_category::string_assignable &amp;&amp; classify_object&lt;T&gt;::value &lt;= object_category::other, detail::enabler&gt; = detail::dummy&gt;constexpr const char *type_name() { return &quot;TEXT&quot;;}template &lt;typename T, enable_if_t&lt;classify_object&lt;T&gt;::value == object_category::tuple_value &amp;&amp; type_count_base&lt;T&gt;::value &gt;= 2, detail::enabler&gt; = detail::dummy&gt;std::string type_name(); template &lt;typename T, enable_if_t&lt;classify_object&lt;T&gt;::value == object_category::container_value || classify_object&lt;T&gt;::value == object_category::wrapper_value, detail::enabler&gt; = detail::dummy&gt;std::string type_name(); template &lt;typename T, enable_if_t&lt;classify_object&lt;T&gt;::value == object_category::tuple_value &amp;&amp; type_count_base&lt;T&gt;::value == 1, detail::enabler&gt; = detail::dummy&gt;inline std::string type_name() { return type_name&lt;typename std::decay&lt;typename std::tuple_element&lt;0, T&gt;::type&gt;::type&gt;);}template &lt;typename T, std::size_t I&gt;inline typename std::enable_if&lt;I == type_count_base&lt;T&gt;::value, std::string&gt;::type tuple_name() { return std::string{};}template &lt;typename T, std::size_t I&gt;inline typename std::enable_if&lt;(I &lt; type_count_base&lt;T&gt;::value), std::string&gt;::type tuple_name() { auto str = std::string{type_name&lt;typename std::decay&lt;typename std::tuple_element&lt;I, T&gt;::type&gt;::type&gt;)} + &apos;,&apos; + tuple_name&lt;T, I + 1&gt;); if(str.back() == &apos;,&apos;) str.pop_back(); return str;}template &lt;typename T, enable_if_t&lt;classify_object&lt;T&gt;::value == object_category::tuple_value &amp;&amp; type_count_base&lt;T&gt;::value &gt;= 2, detail::enabler&gt; &gt; std::string pxr_CLI::CLI::detail::type_name</definition>
        <argsstring>()</argsstring>
        <name>type_name</name>
        <briefdescription>
<para>Recursively generate the tuple type name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="1729" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="1729" bodyend="1733"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1af6230465022b3afd50a81885048afece" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, detail::enabler &gt;</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string pxr_CLI::CLI::detail::type_name</definition>
        <argsstring>()</argsstring>
        <name>type_name</name>
        <briefdescription>
<para>get the type name for a type that has a value_type member </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="1740" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="1740" bodyend="1742"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a0d527d542d5e596f3e1b161a36aa3cae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>enable_if_t&lt; std::is_unsigned&lt; T &gt;::value, detail::enabler &gt;</type>
            <defval>detail::dummy</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool integral_conversion</definition>
        <argsstring>(const std::string &amp;input, T &amp;output) noexcept</argsstring>
        <name>integral_conversion</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>output</declname>
        </param>
        <briefdescription>
<para>Convert to an unsigned integral. </para>
        </briefdescription>
        <detaileddescription>
<para>Convert to a signed integral. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="1748" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="1748" bodyend="1765"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a369689f3808f4549f5eecac2ab398e70" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::int64_t</type>
        <definition>std::int64_t pxr_CLI::CLI::detail::to_flag_value</definition>
        <argsstring>(std::string val)</argsstring>
        <name>to_flag_value</name>
        <param>
          <type>std::string</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Convert a flag into an integer value typically binary flags. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="1788" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="1788" bodyend="1828"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ab764cbfdac78a288cb68329069c45626" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::unsigned_integral, detail::enabler &gt;</type>
            <defval>detail::dummy</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool lexical_cast</definition>
        <argsstring>(const std::string &amp;input, T &amp;output)</argsstring>
        <name>lexical_cast</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>output</declname>
        </param>
        <briefdescription>
<para>Integer conversion. </para>
        </briefdescription>
        <detaileddescription>
<para>Non-string parsable by a stream.</para>
<para>Non-string convertible from an int.</para>
<para>Assignable from double.</para>
<para>Assignable from int.</para>
<para>Assignable from double or int.</para>
<para>wrapper types</para>
<para>Enumerations.</para>
<para>String and similar constructible and copy assignment.</para>
<para>String and similar direct assignment.</para>
<para>complex</para>
<para>Floats.</para>
<para>Boolean values.</para>
<para>char values </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="1835" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="1835" bodyend="1837"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ab154a3bf0fa7677a9a743b5a5c07871e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename AssignTo</type>
          </param>
          <param>
            <type>typename ConvertTo</type>
          </param>
          <param>
            <type>enable_if_t&lt; std::is_same&lt; AssignTo, ConvertTo &gt;::value &amp;&amp;(classify_object&lt; AssignTo &gt;::value==object_category::string_assignable||classify_object&lt; AssignTo &gt;::value==object_category::string_constructible), detail::enabler &gt;</type>
            <defval>detail::dummy</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool lexical_assign</definition>
        <argsstring>(const std::string &amp;input, AssignTo &amp;output)</argsstring>
        <name>lexical_assign</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>AssignTo &amp;</type>
          <declname>output</declname>
        </param>
        <briefdescription>
<para>Assign a value through lexical cast operations Strings can be empty so we need to do a little different. </para>
        </briefdescription>
        <detaileddescription>
<para>Assign a value from a lexical cast through constructing a value and move assigning it.</para>
<para>Assign a value converted from a string in lexical cast to the output value directly.</para>
<para>Assign a value through lexical cast operations for int compatible values mainly for atomic operations on some compilers.</para>
<para>Assign a value through lexical cast operations. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="2060" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="2060" bodyend="2062"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a7a8b3381a4b343e645eb10a8996767c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE bool</type>
        <definition>CLI11_INLINE bool split_short</definition>
        <argsstring>(const std::string &amp;current, std::string &amp;name, std::string &amp;rest)</argsstring>
        <name>split_short</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>current</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>rest</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="2516" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="2540" bodyend="2547"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a895168f49b3716e56fd2f8b3fea91fb0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE bool</type>
        <definition>CLI11_INLINE bool split_long</definition>
        <argsstring>(const std::string &amp;current, std::string &amp;name, std::string &amp;value)</argsstring>
        <name>split_long</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>current</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="2519" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="2549" bodyend="2562"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1acd5dc85e715d357b5617310e662025f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE bool</type>
        <definition>CLI11_INLINE bool split_windows_style</definition>
        <argsstring>(const std::string &amp;current, std::string &amp;name, std::string &amp;value)</argsstring>
        <name>split_windows_style</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>current</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="2522" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="2564" bodyend="2577"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1acc35e3c00142b6e55f70e54fa95b9528" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::vector&lt; std::string &gt;</type>
        <definition>CLI11_INLINE std::vector&lt; std::string &gt; split_names</definition>
        <argsstring>(std::string current)</argsstring>
        <name>split_names</name>
        <param>
          <type>std::string</type>
          <declname>current</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="2525" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="2579" bodyend="2588"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1aa9292fa75e00355a6933c2307127768f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;</type>
        <definition>CLI11_INLINE std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; get_default_flag_values</definition>
        <argsstring>(const std::string &amp;str)</argsstring>
        <name>get_default_flag_values</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>extract default flag values either {def} or starting with a ! </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="2528" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="2590" bodyend="2614"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a7cef629e88cfb6d5e311344e0ea55bee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::tuple&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt;, std::string &gt;</type>
        <definition>CLI11_INLINE std::tuple&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt;, std::string &gt; get_names</definition>
        <argsstring>(const std::vector&lt; std::string &gt; &amp;input)</argsstring>
        <name>get_names</name>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>input</declname>
        </param>
        <briefdescription>
<para>Get a vector of short names, one of long names, and a single name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="2532" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="2617" bodyend="2648"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a1ad9a24102aef5470f20b2212e640acf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE path_type</type>
        <definition>CLI11_INLINE path_type check_path</definition>
        <argsstring>(const char *file) noexcept</argsstring>
        <name>check_path</name>
        <param>
          <type>const char *</type>
          <declname>file</declname>
        </param>
        <briefdescription>
<para>get the type of the path from a file name </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="2966" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="3783" bodyend="3796"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a0b45ad6ac4e4960a41adffbbeb351fa1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>enable_if_t&lt; is_copyable_ptr&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, detail::enabler &gt;</type>
            <defval>detail::dummy</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto pxr_CLI::CLI::detail::smart_deref</definition>
        <argsstring>(T value) -&gt; decltype(*value)</argsstring>
        <name>smart_deref</name>
        <param>
          <type>T</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="3115" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="3115" bodyend="3117"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a0b2a2179a8f0a894b893c655a9870843" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>enable_if_t&lt;!is_copyable_ptr&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, detail::enabler &gt;</type>
            <defval>detail::dummy</defval>
          </param>
        </templateparamlist>
        <type>std::remove_reference&lt; T &gt;::type &amp;</type>
        <definition>std::remove_reference&lt;T&gt;::type&amp; pxr_CLI::CLI::detail::smart_deref</definition>
        <argsstring>(T &amp;value)</argsstring>
        <name>smart_deref</name>
        <param>
          <type>T &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="3122" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="3122" bodyend="3124"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1aa020c8664da0b2de0580f238fc0c0801" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string pxr_CLI::CLI::detail::generate_set</definition>
        <argsstring>(const T &amp;set)</argsstring>
        <name>generate_set</name>
        <param>
          <type>const T &amp;</type>
          <declname>set</declname>
        </param>
        <briefdescription>
<para>Generate a string representation of a set. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="3126" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="3126" bodyend="3136"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ac5646ec4990ce94f3d737fd15d052421" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string pxr_CLI::CLI::detail::generate_map</definition>
        <argsstring>(const T &amp;map, bool key_only=false)</argsstring>
        <name>generate_map</name>
        <param>
          <type>const T &amp;</type>
          <declname>map</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>key_only</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Generate a string representation of a map. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="3139" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="3139" bodyend="3157"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1aa593251442ca982a483a2c007f309faf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename V</type>
          </param>
          <param>
            <type>enable_if_t&lt;!has_find&lt; T, V &gt;::value, detail::enabler &gt;</type>
            <defval>detail::dummy</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto search</definition>
        <argsstring>(const T &amp;set, const V &amp;val) -&gt; std::pair&lt; bool, decltype(std::begin(detail::smart_deref(set)))&gt;</argsstring>
        <name>search</name>
        <param>
          <type>const T &amp;</type>
          <declname>set</declname>
        </param>
        <param>
          <type>const V &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>A search function. </para>
        </briefdescription>
        <detaileddescription>
<para>A search function that uses the built in find function. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="3170" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="3170" bodyend="3177"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ae23497eb7c9d4421c3781e4c49e0bfc7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename V</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto pxr_CLI::CLI::detail::search</definition>
        <argsstring>(const T &amp;set, const V &amp;val, const std::function&lt; V(V)&gt; &amp;filter_function) -&gt; std::pair&lt; bool, decltype(std::begin(detail::smart_deref(set)))&gt;</argsstring>
        <name>search</name>
        <param>
          <type>const T &amp;</type>
          <declname>set</declname>
        </param>
        <param>
          <type>const V &amp;</type>
          <declname>val</declname>
        </param>
        <param>
          <type>const std::function&lt; V(V)&gt; &amp;</type>
          <declname>filter_function</declname>
        </param>
        <briefdescription>
<para>A search function with a filter function. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="3189" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="3189" bodyend="3205"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1afd868ac411cdfe2afc47cc8934778274" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; std::is_signed&lt; T &gt;::value, T &gt;::type</type>
        <definition>std::enable_if&lt;std::is_signed&lt;T&gt;::value, T&gt;::type pxr_CLI::CLI::detail::overflowCheck</definition>
        <argsstring>(const T &amp;a, const T &amp;b)</argsstring>
        <name>overflowCheck</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Do a check for overflow on signed numbers. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="3212" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="3212" bodyend="3217"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a29d5d1cfbb639224aa73aa3ae1728fcd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt;!std::is_signed&lt; T &gt;::value, T &gt;::type</type>
        <definition>std::enable_if&lt;!std::is_signed&lt;T&gt;::value, T&gt;::type pxr_CLI::CLI::detail::overflowCheck</definition>
        <argsstring>(const T &amp;a, const T &amp;b)</argsstring>
        <name>overflowCheck</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Do a check for overflow on unsigned numbers. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="3220" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="3220" bodyend="3222"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a02116c48b532765a1b95a419c8429e4e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; std::is_integral&lt; T &gt;::value, bool &gt;::type</type>
        <definition>std::enable_if&lt;std::is_integral&lt;T&gt;::value, bool&gt;::type pxr_CLI::CLI::detail::checked_multiply</definition>
        <argsstring>(T &amp;a, T b)</argsstring>
        <name>checked_multiply</name>
        <param>
          <type>T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Performs a *= b; if it doesn&apos;t cause integer overflow. Returns false otherwise. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="3225" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="3225" bodyend="3238"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a3da5569be93f060bb356e6258e20151d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; std::is_floating_point&lt; T &gt;::value, bool &gt;::type</type>
        <definition>std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, bool&gt;::type pxr_CLI::CLI::detail::checked_multiply</definition>
        <argsstring>(T &amp;a, T b)</argsstring>
        <name>checked_multiply</name>
        <param>
          <type>T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Performs a *= b; if it doesn&apos;t equal infinity. Returns false otherwise. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="3242" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="3242" bodyend="3249"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1af4b87a823decb8364838dc11f832b9d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>CLI11_INLINE std::pair&lt; std::string, std::string &gt;</type>
        <definition>CLI11_INLINE std::pair&lt; std::string, std::string &gt; split_program_name</definition>
        <argsstring>(std::string commandline)</argsstring>
        <name>split_program_name</name>
        <param>
          <type>std::string</type>
          <declname>commandline</declname>
        </param>
        <briefdescription>
<para>Split a string into a program name and command line arguments the string is assumed to contain a file name followed by other arguments the return value contains is a pair with the first argument containing the program name and the second everything else. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="3647" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="3928" bodyend="3971"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1ad616c7051c6d61ca7d829351ff1883f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>Option *</type>
        <definition>Option* pxr_CLI::CLI::detail::default_flag_modifiers</definition>
        <argsstring>(Option *opt)</argsstring>
        <name>default_flag_modifiers</name>
        <param>
          <type>Option *</type>
          <declname>opt</declname>
        </param>
        <briefdescription>
<para>helper functions for adding in appropriate flag modifiers for add_flag </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="5588" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="5588" bodyend="5590"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a2ed4c4a42b776e6ee8b532873298c2df" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>enable_if_t&lt; std::is_integral&lt; T &gt;::value &amp;&amp;(sizeof(T) &gt;</type>
            <declname>1U</declname>
            <defname>1U</defname>
          </param>
        </templateparamlist>
        <type>Option *</type>
        <definition>Option* pxr_CLI::CLI::detail::default_flag_modifiers</definition>
        <argsstring>(Option *opt)</argsstring>
        <name>default_flag_modifiers</name>
        <param>
          <type>Option *</type>
          <declname>opt</declname>
        </param>
        <briefdescription>
<para>summing modifiers </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="5594" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="5594" bodyend="5596"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a471a4573917aafb58178be2812d3f4f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>CLI11_INLINE std::string convert_arg_for_ini</definition>
        <argsstring>(const std::string &amp;arg, char stringQuote=&apos;&quot;&apos;, char characterQuote = &apos;\&apos;&apos;)</argsstring>
        <name>convert_arg_for_ini</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>arg</declname>
        </param>
        <param>
          <type>char</type>
          <declname>stringQuote</declname>
          <defval>&apos;&quot;&apos;</defval>
        </param>
        <param>
          <type>char</type>
          <declname>characterQuote</declname>
          <defval>&apos;\&apos;&apos;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="8991" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="9012" bodyend="9053"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a58851a72b093f2618a857ebbb94f404e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>CLI11_INLINE std::string ini_join</definition>
        <argsstring>(const std::vector&lt; std::string &gt; &amp;args, char sepChar=&apos;,&apos;, char arrayStart=&apos;[&apos;, char arrayEnd=&apos;]&apos;, char stringQuote=&apos;&quot;&apos;, char characterQuote = &apos;\&apos;&apos;)</argsstring>
        <name>ini_join</name>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>args</declname>
        </param>
        <param>
          <type>char</type>
          <declname>sepChar</declname>
          <defval>&apos;,&apos;</defval>
        </param>
        <param>
          <type>char</type>
          <declname>arrayStart</declname>
          <defval>&apos;[&apos;</defval>
        </param>
        <param>
          <type>char</type>
          <declname>arrayEnd</declname>
          <defval>&apos;]&apos;</defval>
        </param>
        <param>
          <type>char</type>
          <declname>stringQuote</declname>
          <defval>&apos;&quot;&apos;</defval>
        </param>
        <param>
          <type>char</type>
          <declname>characterQuote</declname>
          <defval>&apos;\&apos;&apos;</defval>
        </param>
        <briefdescription>
<para>Comma separated join, adds quotes if needed. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="8994" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="9055" bodyend="9079"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1aefea086f029cec2581730184d377636f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::string &gt;</type>
        <definition>CLI11_INLINE std::vector&lt; std::string &gt; generate_parents</definition>
        <argsstring>(const std::string &amp;section, std::string &amp;name, char parentSeparator)</argsstring>
        <name>generate_parents</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>section</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>char</type>
          <declname>parentSeparator</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="9001" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="9082" bodyend="9104"/>
      </memberdef>
      <memberdef kind="function" id="_c_l_i11_8h_1a56ab5303bd13bf8f53d0f1217d1744c3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>CLI11_INLINE void checkParentSegments</definition>
        <argsstring>(std::vector&lt; ConfigItem &gt; &amp;output, const std::string &amp;currentSection, char parentSeparator)</argsstring>
        <name>checkParentSegments</name>
        <param>
          <type>std::vector&lt; <ref refid="structpxr___c_l_i_1_1_c_l_i_1_1_config_item" kindref="compound">ConfigItem</ref> &gt; &amp;</type>
          <declname>output</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>currentSection</declname>
        </param>
        <param>
          <type>char</type>
          <declname>parentSeparator</declname>
        </param>
        <briefdescription>
<para>assuming non default segments do a check on the close and open of the segments in a configItem structure </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="9004" column="1" bodyfile="pxr/base/tf/pxrCLI11/CLI11.h" bodystart="9107" bodyend="9153"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="pxr/base/tf/pxrCLI11/CLI11.h" line="213" column="1"/>
  </compounddef>
</doxygen>
