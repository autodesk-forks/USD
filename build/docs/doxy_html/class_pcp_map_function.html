<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: PcpMapFunction Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_pcp_map_function.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_pcp_map_function-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PcpMapFunction Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A function that maps values from one namespace (and time domain) to another.  
 <a href="class_pcp_map_function.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa5a61a41bdea2c241a4c3ca2ef92bfcd"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="class_sdf_path.html">SdfPath</a>, <a class="el" href="class_sdf_path.html">SdfPath</a>, SdfPath::FastLessThan &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#aa5a61a41bdea2c241a4c3ca2ef92bfcd">PathMap</a></td></tr>
<tr class="memdesc:aa5a61a41bdea2c241a4c3ca2ef92bfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping from path to path.  <a href="#aa5a61a41bdea2c241a4c3ca2ef92bfcd">More...</a><br /></td></tr>
<tr class="separator:aa5a61a41bdea2c241a4c3ca2ef92bfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2361dcef0d6c89864842539b9db291d"><td class="memItemLeft" align="right" valign="top"><a id="ad2361dcef0d6c89864842539b9db291d"></a>
typedef std::pair&lt; <a class="el" href="class_sdf_path.html">SdfPath</a>, <a class="el" href="class_sdf_path.html">SdfPath</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PathPair</b></td></tr>
<tr class="separator:ad2361dcef0d6c89864842539b9db291d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf41e6f81a51ea2bc96a23c1c03d0c92"><td class="memItemLeft" align="right" valign="top"><a id="adf41e6f81a51ea2bc96a23c1c03d0c92"></a>
typedef std::vector&lt; PathPair &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PathPairVector</b></td></tr>
<tr class="separator:adf41e6f81a51ea2bc96a23c1c03d0c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8daa0689921d038a9ac23bc847c10ad3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a8daa0689921d038a9ac23bc847c10ad3">PcpMapFunction</a> ()=default</td></tr>
<tr class="memdesc:a8daa0689921d038a9ac23bc847c10ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a null function.  <a href="#a8daa0689921d038a9ac23bc847c10ad3">More...</a><br /></td></tr>
<tr class="separator:a8daa0689921d038a9ac23bc847c10ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac5ce505d3f9c0398a7b009b9f1530d"><td class="memItemLeft" align="right" valign="top">PCP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a1ac5ce505d3f9c0398a7b009b9f1530d">Swap</a> (<a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> &amp;map)</td></tr>
<tr class="memdesc:a1ac5ce505d3f9c0398a7b009b9f1530d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of this map function with <code>map</code>.  <a href="#a1ac5ce505d3f9c0398a7b009b9f1530d">More...</a><br /></td></tr>
<tr class="separator:a1ac5ce505d3f9c0398a7b009b9f1530d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f017efb6acae58eb3e7b242640e5690"><td class="memItemLeft" align="right" valign="top"><a id="a6f017efb6acae58eb3e7b242640e5690"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> &amp;map)</td></tr>
<tr class="separator:a6f017efb6acae58eb3e7b242640e5690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b591785e8d874df12b2e75aedac68b"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#ae1b591785e8d874df12b2e75aedac68b">operator==</a> (const <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> &amp;map) const</td></tr>
<tr class="memdesc:ae1b591785e8d874df12b2e75aedac68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality.  <a href="#ae1b591785e8d874df12b2e75aedac68b">More...</a><br /></td></tr>
<tr class="separator:ae1b591785e8d874df12b2e75aedac68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8bf539ffebf7215af7d6a57df73a4d"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a9f8bf539ffebf7215af7d6a57df73a4d">operator!=</a> (const <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> &amp;map) const</td></tr>
<tr class="memdesc:a9f8bf539ffebf7215af7d6a57df73a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality.  <a href="#a9f8bf539ffebf7215af7d6a57df73a4d">More...</a><br /></td></tr>
<tr class="separator:a9f8bf539ffebf7215af7d6a57df73a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3873c7231b7d7075d2f37dddbe26629"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#af3873c7231b7d7075d2f37dddbe26629">IsNull</a> () const</td></tr>
<tr class="memdesc:af3873c7231b7d7075d2f37dddbe26629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this map function is the null function.  <a href="#af3873c7231b7d7075d2f37dddbe26629">More...</a><br /></td></tr>
<tr class="separator:af3873c7231b7d7075d2f37dddbe26629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f4c15babb0622984d8d1410aaa70a2"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a56f4c15babb0622984d8d1410aaa70a2">IsIdentity</a> () const</td></tr>
<tr class="memdesc:a56f4c15babb0622984d8d1410aaa70a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the map function is the identity function.  <a href="#a56f4c15babb0622984d8d1410aaa70a2">More...</a><br /></td></tr>
<tr class="separator:a56f4c15babb0622984d8d1410aaa70a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7119f36346e0d3ecd8baf2a83eee987"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#ad7119f36346e0d3ecd8baf2a83eee987">IsIdentityPathMapping</a> () const</td></tr>
<tr class="memdesc:ad7119f36346e0d3ecd8baf2a83eee987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the map function uses the identity path mapping.  <a href="#ad7119f36346e0d3ecd8baf2a83eee987">More...</a><br /></td></tr>
<tr class="separator:ad7119f36346e0d3ecd8baf2a83eee987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5307b27d7e4bf0da9b4d73195bd9c4ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a5307b27d7e4bf0da9b4d73195bd9c4ff">HasRootIdentity</a> () const</td></tr>
<tr class="memdesc:a5307b27d7e4bf0da9b4d73195bd9c4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the map function maps the absolute root path to the absolute root path, false otherwise.  <a href="#a5307b27d7e4bf0da9b4d73195bd9c4ff">More...</a><br /></td></tr>
<tr class="separator:a5307b27d7e4bf0da9b4d73195bd9c4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517c37a14bf2c8412836ede455adb5c1"><td class="memItemLeft" align="right" valign="top">PCP_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a517c37a14bf2c8412836ede455adb5c1">MapSourceToTarget</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path) const</td></tr>
<tr class="memdesc:a517c37a14bf2c8412836ede455adb5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a path in the source namespace to the target.  <a href="#a517c37a14bf2c8412836ede455adb5c1">More...</a><br /></td></tr>
<tr class="separator:a517c37a14bf2c8412836ede455adb5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aef0054e2ea858f5a9ceee469a4458a"><td class="memItemLeft" align="right" valign="top">PCP_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a9aef0054e2ea858f5a9ceee469a4458a">MapTargetToSource</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path) const</td></tr>
<tr class="memdesc:a9aef0054e2ea858f5a9ceee469a4458a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a path in the target namespace to the source.  <a href="#a9aef0054e2ea858f5a9ceee469a4458a">More...</a><br /></td></tr>
<tr class="separator:a9aef0054e2ea858f5a9ceee469a4458a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7126cf5696aedccaed2c5dd41c569108"><td class="memItemLeft" align="right" valign="top">PCP_API <a class="el" href="class_sdf_path_expression.html">SdfPathExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a7126cf5696aedccaed2c5dd41c569108">MapSourceToTarget</a> (const <a class="el" href="class_sdf_path_expression.html">SdfPathExpression</a> &amp;pathExpr, std::vector&lt; SdfPathExpression::PathPattern &gt; *unmappedPatterns=nullptr, std::vector&lt; SdfPathExpression::ExpressionReference &gt; *unmappedRefs=nullptr) const</td></tr>
<tr class="memdesc:a7126cf5696aedccaed2c5dd41c569108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map all path pattern prefix paths and expression reference paths in the source namespace to the target.  <a href="#a7126cf5696aedccaed2c5dd41c569108">More...</a><br /></td></tr>
<tr class="separator:a7126cf5696aedccaed2c5dd41c569108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263a940d85ec63cc7a0bef8a5698292b"><td class="memItemLeft" align="right" valign="top">PCP_API <a class="el" href="class_sdf_path_expression.html">SdfPathExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a263a940d85ec63cc7a0bef8a5698292b">MapTargetToSource</a> (const <a class="el" href="class_sdf_path_expression.html">SdfPathExpression</a> &amp;pathExpr, std::vector&lt; SdfPathExpression::PathPattern &gt; *unmappedPatterns=nullptr, std::vector&lt; SdfPathExpression::ExpressionReference &gt; *unmappedRefs=nullptr) const</td></tr>
<tr class="memdesc:a263a940d85ec63cc7a0bef8a5698292b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map all path pattern prefix paths and expression reference paths in the target namespace to the source.  <a href="#a263a940d85ec63cc7a0bef8a5698292b">More...</a><br /></td></tr>
<tr class="separator:a263a940d85ec63cc7a0bef8a5698292b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4138392d5099973351bb5ac19d5aa8b"><td class="memItemLeft" align="right" valign="top">PCP_API <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#ad4138392d5099973351bb5ac19d5aa8b">Compose</a> (const <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> &amp;f) const</td></tr>
<tr class="memdesc:ad4138392d5099973351bb5ac19d5aa8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose this map over the given map function.  <a href="#ad4138392d5099973351bb5ac19d5aa8b">More...</a><br /></td></tr>
<tr class="separator:ad4138392d5099973351bb5ac19d5aa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefa3c59abcf52e0020fecf18cbef223"><td class="memItemLeft" align="right" valign="top">PCP_API <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#abefa3c59abcf52e0020fecf18cbef223">ComposeOffset</a> (const <a class="el" href="class_sdf_layer_offset.html">SdfLayerOffset</a> &amp;newOffset) const</td></tr>
<tr class="memdesc:abefa3c59abcf52e0020fecf18cbef223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose this map function over a hypothetical map function that has an identity path mapping and <code>offset</code>.  <a href="#abefa3c59abcf52e0020fecf18cbef223">More...</a><br /></td></tr>
<tr class="separator:abefa3c59abcf52e0020fecf18cbef223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04053267fd79a637116d7b3d432fe4b"><td class="memItemLeft" align="right" valign="top">PCP_API <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#ad04053267fd79a637116d7b3d432fe4b">GetInverse</a> () const</td></tr>
<tr class="memdesc:ad04053267fd79a637116d7b3d432fe4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse of this map function.  <a href="#ad04053267fd79a637116d7b3d432fe4b">More...</a><br /></td></tr>
<tr class="separator:ad04053267fd79a637116d7b3d432fe4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99302b54721f70402f7107d19799f21"><td class="memItemLeft" align="right" valign="top">PCP_API <a class="el" href="class_pcp_map_function.html#aa5a61a41bdea2c241a4c3ca2ef92bfcd">PathMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#af99302b54721f70402f7107d19799f21">GetSourceToTargetMap</a> () const</td></tr>
<tr class="memdesc:af99302b54721f70402f7107d19799f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of path mappings, from source to target.  <a href="#af99302b54721f70402f7107d19799f21">More...</a><br /></td></tr>
<tr class="separator:af99302b54721f70402f7107d19799f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8113b7544dcabb159bc75671a5197ed0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sdf_layer_offset.html">SdfLayerOffset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a8113b7544dcabb159bc75671a5197ed0">GetTimeOffset</a> () const</td></tr>
<tr class="memdesc:a8113b7544dcabb159bc75671a5197ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time offset of the mapping.  <a href="#a8113b7544dcabb159bc75671a5197ed0">More...</a><br /></td></tr>
<tr class="separator:a8113b7544dcabb159bc75671a5197ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771051ad27e94c42008b9631a1fc102a"><td class="memItemLeft" align="right" valign="top">PCP_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a771051ad27e94c42008b9631a1fc102a">GetString</a> () const</td></tr>
<tr class="memdesc:a771051ad27e94c42008b9631a1fc102a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of this mapping for debugging purposes.  <a href="#a771051ad27e94c42008b9631a1fc102a">More...</a><br /></td></tr>
<tr class="separator:a771051ad27e94c42008b9631a1fc102a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9ac6edfcc7117909418b3eadd3b797"><td class="memItemLeft" align="right" valign="top">PCP_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a6f9ac6edfcc7117909418b3eadd3b797">Hash</a> () const</td></tr>
<tr class="memdesc:a6f9ac6edfcc7117909418b3eadd3b797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a size_t hash for this map function.  <a href="#a6f9ac6edfcc7117909418b3eadd3b797">More...</a><br /></td></tr>
<tr class="separator:a6f9ac6edfcc7117909418b3eadd3b797"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a19f1e74bfdc3162e464edcfa98d9ebd5"><td class="memItemLeft" align="right" valign="top">static PCP_API <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a19f1e74bfdc3162e464edcfa98d9ebd5">Create</a> (const <a class="el" href="class_pcp_map_function.html#aa5a61a41bdea2c241a4c3ca2ef92bfcd">PathMap</a> &amp;sourceToTargetMap, const <a class="el" href="class_sdf_layer_offset.html">SdfLayerOffset</a> &amp;offset)</td></tr>
<tr class="memdesc:a19f1e74bfdc3162e464edcfa98d9ebd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a map function with the given arguments.  <a href="#a19f1e74bfdc3162e464edcfa98d9ebd5">More...</a><br /></td></tr>
<tr class="separator:a19f1e74bfdc3162e464edcfa98d9ebd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cac88e657aab74c7c1e93ed88a33a91"><td class="memItemLeft" align="right" valign="top">static PCP_API const <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a8cac88e657aab74c7c1e93ed88a33a91">Identity</a> ()</td></tr>
<tr class="memdesc:a8cac88e657aab74c7c1e93ed88a33a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an identity map function.  <a href="#a8cac88e657aab74c7c1e93ed88a33a91">More...</a><br /></td></tr>
<tr class="separator:a8cac88e657aab74c7c1e93ed88a33a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0899753655a62da8127bc14949d185e6"><td class="memItemLeft" align="right" valign="top">static PCP_API const <a class="el" href="class_pcp_map_function.html#aa5a61a41bdea2c241a4c3ca2ef92bfcd">PathMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_map_function.html#a0899753655a62da8127bc14949d185e6">IdentityPathMap</a> ()</td></tr>
<tr class="memdesc:a0899753655a62da8127bc14949d185e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an identity path mapping.  <a href="#a0899753655a62da8127bc14949d185e6">More...</a><br /></td></tr>
<tr class="separator:a0899753655a62da8127bc14949d185e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:acd18821661a699941c6624a4d682335f"><td class="memTemplParams" colspan="2"><a id="acd18821661a699941c6624a4d682335f"></a>
template&lt;typename HashState &gt; </td></tr>
<tr class="memitem:acd18821661a699941c6624a4d682335f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TfHashAppend</b> (HashState &amp;h, const <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> &amp;x)</td></tr>
<tr class="separator:acd18821661a699941c6624a4d682335f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A function that maps values from one namespace (and time domain) to another. </p>
<p>It represents the transformation that an arc such as a reference arc applies as it incorporates values across the arc.</p>
<p>Take the example of a reference arc, where a source path &lt;/Model&gt; is referenced as a target path, &lt;/Model_1&gt;. The source path &lt;/Model&gt; is the source of the opinions; the target path &lt;/Model_1&gt; is where they are incorporated in the scene. Values in the model that refer to paths relative to &lt;/Model&gt; must be transformed to be relative to &lt;/Model_1&gt; instead. The <a class="el" href="class_pcp_map_function.html" title="A function that maps values from one namespace (and time domain) to another.">PcpMapFunction</a> for the arc provides this service.</p>
<p>Map functions have a specific <em>domain</em>, or set of values they can operate on. Any values outside the domain cannot be mapped. The domain precisely tracks what areas of namespace can be referred to across various forms of arcs.</p>
<p>Map functions can be chained to represent a series of map operations applied in sequence. The map function represent the cumulative effect as efficiently as possible. For example, in the case of a chained reference from &lt;/Model&gt; to &lt;/Model&gt; to &lt;/Model&gt; to &lt;/Model_1&gt;, this is effectively the same as a mapping directly from &lt;/Model&gt; to &lt;/Model_1&gt;. Representing the cumulative effect of arcs in this way is important for handling larger scenes efficiently.</p>
<p>Map functions can be <em>inverted</em>. Formally, map functions are bijections (one-to-one and onto), which ensures that they can be inverted. Put differently, no information is lost by applying a map function to set of values within its domain; they retain their distinct identities and can always be mapped back.</p>
<p>One analogy that may or may not be helpful: In the same way a geometric transform maps a model's points in its rest space into the world coordinates for a particular instance, a <a class="el" href="class_pcp_map_function.html" title="A function that maps values from one namespace (and time domain) to another.">PcpMapFunction</a> maps values about a referenced model into the composed scene for a particular instance of that model. But rather than translating and rotating points, the map function shifts the values in namespace (and time). </p>

<p class="definition">Definition at line <a class="el" href="map_function_8h_source.html#l00081">81</a> of file <a class="el" href="map_function_8h_source.html">mapFunction.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa5a61a41bdea2c241a4c3ca2ef92bfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a61a41bdea2c241a4c3ca2ef92bfcd">&#9670;&nbsp;</a></span>PathMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="class_sdf_path.html">SdfPath</a>, <a class="el" href="class_sdf_path.html">SdfPath</a>, SdfPath::FastLessThan&gt; <a class="el" href="class_pcp_map_function.html#aa5a61a41bdea2c241a4c3ca2ef92bfcd">PathMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mapping from path to path. </p>

<p class="definition">Definition at line <a class="el" href="map_function_8h_source.html#l00085">85</a> of file <a class="el" href="map_function_8h_source.html">mapFunction.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8daa0689921d038a9ac23bc847c10ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8daa0689921d038a9ac23bc847c10ad3">&#9670;&nbsp;</a></span>PcpMapFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a null function. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad4138392d5099973351bb5ac19d5aa8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4138392d5099973351bb5ac19d5aa8b">&#9670;&nbsp;</a></span>Compose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> Compose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose this map over the given map function. </p>
<p>The result will represent the application of f followed by the application of this function. </p>

</div>
</div>
<a id="abefa3c59abcf52e0020fecf18cbef223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefa3c59abcf52e0020fecf18cbef223">&#9670;&nbsp;</a></span>ComposeOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> ComposeOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_layer_offset.html">SdfLayerOffset</a> &amp;&#160;</td>
          <td class="paramname"><em>newOffset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose this map function over a hypothetical map function that has an identity path mapping and <code>offset</code>. </p>
<p>This is equivalent to building such a map function and invoking <a class="el" href="class_pcp_map_function.html#ad4138392d5099973351bb5ac19d5aa8b" title="Compose this map over the given map function.">Compose()</a>, but is faster. </p>

</div>
</div>
<a id="a19f1e74bfdc3162e464edcfa98d9ebd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f1e74bfdc3162e464edcfa98d9ebd5">&#9670;&nbsp;</a></span>Create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PCP_API <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> Create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pcp_map_function.html#aa5a61a41bdea2c241a4c3ca2ef92bfcd">PathMap</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceToTargetMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_layer_offset.html">SdfLayerOffset</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a map function with the given arguments. </p>
<p>Returns a null map function on error (see <a class="el" href="class_pcp_map_function.html#af3873c7231b7d7075d2f37dddbe26629" title="Return true if this map function is the null function.">IsNull()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceToTargetMap</td><td>The map from source paths to target paths. </td></tr>
    <tr><td class="paramname">offset</td><td>The time offset to apply from source to target. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad04053267fd79a637116d7b3d432fe4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04053267fd79a637116d7b3d432fe4b">&#9670;&nbsp;</a></span>GetInverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> GetInverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the inverse of this map function. </p>
<p>This returns a true inverse <code>inv:</code> for any path p in this function's domain that it maps to p', inv(p') -&gt; p. </p>

</div>
</div>
<a id="af99302b54721f70402f7107d19799f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af99302b54721f70402f7107d19799f21">&#9670;&nbsp;</a></span>GetSourceToTargetMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API <a class="el" href="class_pcp_map_function.html#aa5a61a41bdea2c241a4c3ca2ef92bfcd">PathMap</a> GetSourceToTargetMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The set of path mappings, from source to target. </p>

</div>
</div>
<a id="a771051ad27e94c42008b9631a1fc102a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771051ad27e94c42008b9631a1fc102a">&#9670;&nbsp;</a></span>GetString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API std::string GetString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of this mapping for debugging purposes. </p>

</div>
</div>
<a id="a8113b7544dcabb159bc75671a5197ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8113b7544dcabb159bc75671a5197ed0">&#9670;&nbsp;</a></span>GetTimeOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sdf_layer_offset.html">SdfLayerOffset</a>&amp; GetTimeOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The time offset of the mapping. </p>

<p class="definition">Definition at line <a class="el" href="map_function_8h_source.html#l00223">223</a> of file <a class="el" href="map_function_8h_source.html">mapFunction.h</a>.</p>

</div>
</div>
<a id="a6f9ac6edfcc7117909418b3eadd3b797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9ac6edfcc7117909418b3eadd3b797">&#9670;&nbsp;</a></span>Hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API size_t Hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a size_t hash for this map function. </p>

</div>
</div>
<a id="a5307b27d7e4bf0da9b4d73195bd9c4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5307b27d7e4bf0da9b4d73195bd9c4ff">&#9670;&nbsp;</a></span>HasRootIdentity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HasRootIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the map function maps the absolute root path to the absolute root path, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="map_function_8h_source.html#l00142">142</a> of file <a class="el" href="map_function_8h_source.html">mapFunction.h</a>.</p>

</div>
</div>
<a id="a8cac88e657aab74c7c1e93ed88a33a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cac88e657aab74c7c1e93ed88a33a91">&#9670;&nbsp;</a></span>Identity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PCP_API const <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a>&amp; Identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an identity map function. </p>

</div>
</div>
<a id="a0899753655a62da8127bc14949d185e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0899753655a62da8127bc14949d185e6">&#9670;&nbsp;</a></span>IdentityPathMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PCP_API const <a class="el" href="class_pcp_map_function.html#aa5a61a41bdea2c241a4c3ca2ef92bfcd">PathMap</a>&amp; IdentityPathMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an identity path mapping. </p>

</div>
</div>
<a id="a56f4c15babb0622984d8d1410aaa70a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f4c15babb0622984d8d1410aaa70a2">&#9670;&nbsp;</a></span>IsIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool IsIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the map function is the identity function. </p>
<p>The identity function has an identity path mapping and time offset. </p>

</div>
</div>
<a id="ad7119f36346e0d3ecd8baf2a83eee987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7119f36346e0d3ecd8baf2a83eee987">&#9670;&nbsp;</a></span>IsIdentityPathMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool IsIdentityPathMapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the map function uses the identity path mapping. </p>
<p>If true, <a class="el" href="class_pcp_map_function.html#a517c37a14bf2c8412836ede455adb5c1" title="Map a path in the source namespace to the target.">MapSourceToTarget()</a> always returns the path unchanged. However, this map function may have a non-identity time offset. </p>

</div>
</div>
<a id="af3873c7231b7d7075d2f37dddbe26629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3873c7231b7d7075d2f37dddbe26629">&#9670;&nbsp;</a></span>IsNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool IsNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this map function is the null function. </p>
<p>For a null function, <a class="el" href="class_pcp_map_function.html#a517c37a14bf2c8412836ede455adb5c1" title="Map a path in the source namespace to the target.">MapSourceToTarget()</a> always returns an empty path. </p>

</div>
</div>
<a id="a517c37a14bf2c8412836ede455adb5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517c37a14bf2c8412836ede455adb5c1">&#9670;&nbsp;</a></span>MapSourceToTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API <a class="el" href="class_sdf_path.html">SdfPath</a> MapSourceToTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a path in the source namespace to the target. </p>
<p>If the path is not in the domain, returns an empty path. </p>

</div>
</div>
<a id="a7126cf5696aedccaed2c5dd41c569108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7126cf5696aedccaed2c5dd41c569108">&#9670;&nbsp;</a></span>MapSourceToTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API <a class="el" href="class_sdf_path_expression.html">SdfPathExpression</a> MapSourceToTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path_expression.html">SdfPathExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>pathExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SdfPathExpression::PathPattern &gt; *&#160;</td>
          <td class="paramname"><em>unmappedPatterns</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SdfPathExpression::ExpressionReference &gt; *&#160;</td>
          <td class="paramname"><em>unmappedRefs</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map all path pattern prefix paths and expression reference paths in the source namespace to the target. </p>
<p>For any references or patterns with prefix paths that are not in the domain, replace with an SdfPathPattern::Nothing() subexpression, to be simplified.</p>
<p>For example, if the mapping specifies /Foo -&gt; /World/Foo_1, and the expression is '/Foo/Bar//Baz + /Something/Else//Entirely', the resulting expression will be '/World/Foo_1/Bar//Baz', since the /Something/Else prefix is outside the domain.</p>
<p>If <code>excludedPatterns</code> and/or <code>excludedReferences</code> are supplied, they are populated with those patterns &amp; references that could not be translated and were replaced with SdfPathPattern::Nothing(). </p>

</div>
</div>
<a id="a9aef0054e2ea858f5a9ceee469a4458a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aef0054e2ea858f5a9ceee469a4458a">&#9670;&nbsp;</a></span>MapTargetToSource() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API <a class="el" href="class_sdf_path.html">SdfPath</a> MapTargetToSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a path in the target namespace to the source. </p>
<p>If the path is not in the co-domain, returns an empty path. </p>

</div>
</div>
<a id="a263a940d85ec63cc7a0bef8a5698292b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263a940d85ec63cc7a0bef8a5698292b">&#9670;&nbsp;</a></span>MapTargetToSource() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API <a class="el" href="class_sdf_path_expression.html">SdfPathExpression</a> MapTargetToSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path_expression.html">SdfPathExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>pathExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SdfPathExpression::PathPattern &gt; *&#160;</td>
          <td class="paramname"><em>unmappedPatterns</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SdfPathExpression::ExpressionReference &gt; *&#160;</td>
          <td class="paramname"><em>unmappedRefs</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map all path pattern prefix paths and expression reference paths in the target namespace to the source. </p>
<p>For any references or patterns with prefix paths that are not in the co-domain, replace with an SdfPathPattern::Nothing() subexpression, to be simplified.</p>
<p>For example, if the mapping specifies /World/Foo_1 -&gt; /Foo, and the expression is '/World/Foo_1/Bar//Baz + /World/Bar//', the resulting expression will be '/Foo/Bar//Baz', since the /World/Bar prefix is outside the co-domain.</p>
<p>If <code>excludedPatterns</code> and/or <code>excludedReferences</code> are supplied, they are populated with those patterns &amp; references that could not be translated and were replaced with SdfPathPattern::Nothing(). </p>

</div>
</div>
<a id="a9f8bf539ffebf7215af7d6a57df73a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8bf539ffebf7215af7d6a57df73a4d">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality. </p>

</div>
</div>
<a id="ae1b591785e8d874df12b2e75aedac68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b591785e8d874df12b2e75aedac68b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality. </p>

</div>
</div>
<a id="a1ac5ce505d3f9c0398a7b009b9f1530d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac5ce505d3f9c0398a7b009b9f1530d">&#9670;&nbsp;</a></span>Swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API void Swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pcp_map_function.html">PcpMapFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the contents of this map function with <code>map</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pxr/usd/pcp/<a class="el" href="map_function_8h_source.html">mapFunction.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_pcp_map_function.html">PcpMapFunction</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:03 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>