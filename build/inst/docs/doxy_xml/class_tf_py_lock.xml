<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="class_tf_py_lock" kind="class" language="C++" prot="public">
    <compoundname>TfPyLock</compoundname>
    <includes refid="py_lock_8h" local="no">pyLock.h</includes>
      <sectiondef kind="private-type">
      <memberdef kind="enum" id="class_tf_py_lock_1a936767119f62537e24b1835d223c548e" prot="private" static="no" strong="no">
        <type></type>
        <name>_UnlockedTag</name>
        <enumvalue id="class_tf_py_lock_1a936767119f62537e24b1835d223c548ea016bb137b5a2b95bb07c61cff2dd7239" prot="private">
          <name>_ConstructUnlocked</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pyLock.h" line="148" column="1" bodyfile="pxr/base/tf/pyLock.h" bodystart="148" bodyend="148"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="class_tf_py_lock_1a4338f16846e06b3e0cd66e74fb893e84" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend struct</type>
        <definition>friend struct TfPyEnsureGILUnlockedObj</definition>
        <argsstring></argsstring>
        <name>TfPyEnsureGILUnlockedObj</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pyLock.h" line="147" column="1" bodyfile="pxr/base/tf/pyLock.h" bodystart="147" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_tf_py_lock_1a5d5821cb4917dbbe1b2f9746a5b0a1c0" prot="private" static="no" mutable="no">
        <type>PyGILState_STATE</type>
        <definition>PyGILState_STATE _gilState</definition>
        <argsstring></argsstring>
        <name>_gilState</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pyLock.h" line="151" column="1" bodyfile="pxr/base/tf/pyLock.h" bodystart="151" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_tf_py_lock_1a055f0680fe7e575a564c383a5ae73d5d" prot="private" static="no" mutable="no">
        <type>PyThreadState *</type>
        <definition>PyThreadState* _savedState</definition>
        <argsstring></argsstring>
        <name>_savedState</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pyLock.h" line="152" column="1" bodyfile="pxr/base/tf/pyLock.h" bodystart="152" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_tf_py_lock_1a07d8249246e8ce11bfffcf7c36ac534d" prot="private" static="no" mutable="no">
        <type>bool</type>
        <definition>bool _acquired</definition>
        <argsstring></argsstring>
        <name>_acquired</name>
        <bitfield>1</bitfield>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pyLock.h" line="153" column="1" bodyfile="pxr/base/tf/pyLock.h" bodystart="153" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_tf_py_lock_1ae3fb86a49d7ba7fcaef5a238266523a1" prot="private" static="no" mutable="no">
        <type>bool</type>
        <definition>bool _allowingThreads</definition>
        <argsstring></argsstring>
        <name>_allowingThreads</name>
        <bitfield>1</bitfield>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pyLock.h" line="154" column="1" bodyfile="pxr/base/tf/pyLock.h" bodystart="154" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="class_tf_py_lock_1a4f3168623f7499bec5c1f985fc7caa2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API</type>
        <definition>TF_API TfPyLock</definition>
        <argsstring>()</argsstring>
        <name>TfPyLock</name>
        <briefdescription>
<para>Acquires the Python GIL and swaps in callers thread state. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pyLock.h" line="125" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_py_lock_1a13d6f5a7ac732617d5866d69a657e46d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API</type>
        <definition>TF_API ~TfPyLock</definition>
        <argsstring>()</argsstring>
        <name>~TfPyLock</name>
        <briefdescription>
<para>Releases Python GIL and restores prior threads state. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pyLock.h" line="128" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_py_lock_1a6cf8254141b024900e65240fda06d4b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API void</type>
        <definition>TF_API void Acquire</definition>
        <argsstring>()</argsstring>
        <name>Acquire</name>
        <briefdescription>
<para>(Re)acquires GIL and thread state, if previously released. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pyLock.h" line="131" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_py_lock_1a8543275817d667ae015ccf2d261bd105" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API void</type>
        <definition>TF_API void Release</definition>
        <argsstring>()</argsstring>
        <name>Release</name>
        <briefdescription>
<para>Explicitly releases GIL and thread state. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pyLock.h" line="134" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_py_lock_1a1733c7e9bdad231ce5fcab3118a9ebff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API void</type>
        <definition>TF_API void BeginAllowThreads</definition>
        <argsstring>()</argsstring>
        <name>BeginAllowThreads</name>
        <briefdescription>
<para>Unlock the GIL temporarily to allow other threads to use python. </para>
        </briefdescription>
        <detaileddescription>
<para>Typically this is used to unblock threads during operations like blocking I/O. The lock must be acquired when called. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pyLock.h" line="139" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_py_lock_1a671cdd8b28ea97c35e890d100af8aeea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API void</type>
        <definition>TF_API void EndAllowThreads</definition>
        <argsstring>()</argsstring>
        <name>EndAllowThreads</name>
        <briefdescription>
<para>End allowing other threads, reacquiring the lock state. </para>
        </briefdescription>
        <detaileddescription>
<para><emphasis>BeginAllowThreads</emphasis> must have been successfully called first. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pyLock.h" line="143" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="class_tf_py_lock_1ab9b26a0fcf33b49cf4f5ff27a0472169" prot="private" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>TfPyLock</definition>
        <argsstring>(_UnlockedTag)</argsstring>
        <name>TfPyLock</name>
        <param>
          <type>_UnlockedTag</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/pyLock.h" line="149" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Convenience class for accessing the Python Global Interpreter Lock. </para>
    </briefdescription>
    <detaileddescription>
<para>The Python API is not thread-safe. Accessing the Python API from outside the context of Python execution requires extra care when multiple threads may be present. There are various schemes for how this should be done, and the conventions have been changing with Python versions through 2.X.</para>
<para>This class provides a convenient and centralized location for managing the Python Global Interpreter Lock and related Python Thread State.</para>
<para>The easiest way to use this class is to simply create a local variable in any function that will access the Python API. Upon construction, this will acquire the Python lock and establish the correct thread state for the caller. Upon exit from the current scope, when the instance is destroyed, the thread state will be restored and the lock will be released.</para>
<para><programlisting><codeline><highlight class="normal">void<sp/>MyFunc()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TfPyLock<sp/>dummy;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...(access<sp/>Python<sp/>API)...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>If you need to temporarily release the lock during execution, (to perform blocking I/O for example), you can call <ref refid="class_tf_py_lock_1a8543275817d667ae015ccf2d261bd105" kindref="member">Release()</ref> explicitly, then call <ref refid="class_tf_py_lock_1a6cf8254141b024900e65240fda06d4b9" kindref="member">Acquire()</ref> again to reclaim the lock.</para>
<para><programlisting><codeline><highlight class="normal">void<sp/>MyFunc()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TfPyLock<sp/>pyLock;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...(access<sp/>Python<sp/>API)...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pyLock.Release();<sp/><sp/>//<sp/>let<sp/>other<sp/>threads<sp/>run<sp/>while<sp/>we&apos;re<sp/>blocked</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...(some<sp/>blocking<sp/>I/O<sp/>or<sp/>long<sp/>running<sp/>operation)...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pyLock.Acquire();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...(more<sp/>access<sp/>to<sp/>Python<sp/>API)...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Note that it IS EXPLICITLY OK to recursively create instances of this class, and thus recursively acquire the GIL and thread state. It is NOT OK to recursively attempt to <ref refid="class_tf_py_lock_1a6cf8254141b024900e65240fda06d4b9" kindref="member">Acquire()</ref> the same instance, that will have no effect and will generate a diagnostic warning.</para>
<para>This class also provides an exception-safe way to release the GIL temporarily for blocking calls, like Py_BEGIN/END_ALLOW_THREADS in the Python C API.</para>
<para><programlisting><codeline><highlight class="normal">void<sp/>MyFunc()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TfPyLock<sp/>lock;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...(access<sp/>Python<sp/>API)...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lock.BeginAllowThreads();<sp/>//<sp/>totally<sp/>unlock<sp/>the<sp/>GIL<sp/>temporarily.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...(some<sp/>blocking<sp/>I/O<sp/>or<sp/>long<sp/>running<sp/>operation)...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lock.EndAllowThreads();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...(more<sp/>access<sp/>to<sp/>Python<sp/>API)...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This looks similar to the above example using <emphasis><ref refid="class_tf_py_lock_1a8543275817d667ae015ccf2d261bd105" kindref="member">Release()</ref></emphasis>, but it is different. The Python lock is recursive, so the call to <emphasis><ref refid="class_tf_py_lock_1a8543275817d667ae015ccf2d261bd105" kindref="member">Release()</ref></emphasis> is not guaranteed to actually release the lock, it just releases the deepest lock. In contrast <emphasis><ref refid="class_tf_py_lock_1a1733c7e9bdad231ce5fcab3118a9ebff" kindref="member">BeginAllowThreads()</ref></emphasis> will fully unlock the GIL so that other threads can run temporarily regardless of how many times the lock is recursively taken.</para>
<para>The valid states and transitions for this class are as follows.</para>
<para><heading level="2">State Valid Transitions </heading>
</para>
<para>Released <ref refid="class_tf_py_lock_1a6cf8254141b024900e65240fda06d4b9" kindref="member">Acquire()</ref> -&gt; Acquired Acquired <ref refid="class_tf_py_lock_1a8543275817d667ae015ccf2d261bd105" kindref="member">Release()</ref> -&gt; Released, <ref refid="class_tf_py_lock_1a1733c7e9bdad231ce5fcab3118a9ebff" kindref="member">BeginAllowThreads()</ref> -&gt; AllowsThreads AllowsThreads <ref refid="class_tf_py_lock_1a671cdd8b28ea97c35e890d100af8aeea" kindref="member">EndAllowThreads()</ref> -&gt; Acquired</para>
<para>Note that upon construction the class is in the Acquired state. Upon destruction, the class will move to the Released state.</para>
<para><simplesect kind="warning"><para>Instances of this class should only be used as automatic (stack) variables, or in thread local storage. DO NOT create a single instance that could be shared across multiple threads. </para>
</simplesect>
</para>
    </detaileddescription>
    <location file="pxr/base/tf/pyLock.h" line="122" column="1" bodyfile="pxr/base/tf/pyLock.h" bodystart="122" bodyend="155"/>
    <listofallmembers>
      <member refid="class_tf_py_lock_1a07d8249246e8ce11bfffcf7c36ac534d" prot="private" virt="non-virtual"><scope>TfPyLock</scope><name>_acquired</name></member>
      <member refid="class_tf_py_lock_1ae3fb86a49d7ba7fcaef5a238266523a1" prot="private" virt="non-virtual"><scope>TfPyLock</scope><name>_allowingThreads</name></member>
      <member refid="class_tf_py_lock_1a936767119f62537e24b1835d223c548ea016bb137b5a2b95bb07c61cff2dd7239" prot="private" virt="non-virtual"><scope>TfPyLock</scope><name>_ConstructUnlocked</name></member>
      <member refid="class_tf_py_lock_1a5d5821cb4917dbbe1b2f9746a5b0a1c0" prot="private" virt="non-virtual"><scope>TfPyLock</scope><name>_gilState</name></member>
      <member refid="class_tf_py_lock_1a055f0680fe7e575a564c383a5ae73d5d" prot="private" virt="non-virtual"><scope>TfPyLock</scope><name>_savedState</name></member>
      <member refid="class_tf_py_lock_1a936767119f62537e24b1835d223c548e" prot="private" virt="non-virtual"><scope>TfPyLock</scope><name>_UnlockedTag</name></member>
      <member refid="class_tf_py_lock_1a6cf8254141b024900e65240fda06d4b9" prot="public" virt="non-virtual"><scope>TfPyLock</scope><name>Acquire</name></member>
      <member refid="class_tf_py_lock_1a1733c7e9bdad231ce5fcab3118a9ebff" prot="public" virt="non-virtual"><scope>TfPyLock</scope><name>BeginAllowThreads</name></member>
      <member refid="class_tf_py_lock_1a671cdd8b28ea97c35e890d100af8aeea" prot="public" virt="non-virtual"><scope>TfPyLock</scope><name>EndAllowThreads</name></member>
      <member refid="class_tf_py_lock_1a8543275817d667ae015ccf2d261bd105" prot="public" virt="non-virtual"><scope>TfPyLock</scope><name>Release</name></member>
      <member refid="class_tf_py_lock_1a4338f16846e06b3e0cd66e74fb893e84" prot="private" virt="non-virtual"><scope>TfPyLock</scope><name>TfPyEnsureGILUnlockedObj</name></member>
      <member refid="class_tf_py_lock_1a4f3168623f7499bec5c1f985fc7caa2b" prot="public" virt="non-virtual"><scope>TfPyLock</scope><name>TfPyLock</name></member>
      <member refid="class_tf_py_lock_1ab9b26a0fcf33b49cf4f5ff27a0472169" prot="private" virt="non-virtual"><scope>TfPyLock</scope><name>TfPyLock</name></member>
      <member refid="class_tf_py_lock_1a13d6f5a7ac732617d5866d69a657e46d" prot="public" virt="non-virtual"><scope>TfPyLock</scope><name>~TfPyLock</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
