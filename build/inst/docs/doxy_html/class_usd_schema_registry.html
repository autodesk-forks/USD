<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: UsdSchemaRegistry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_usd_schema_registry.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_usd_schema_registry-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">UsdSchemaRegistry Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Singleton registry that provides access to schema type information and the prim definitions for registered Usd "IsA" and applied API schema types.  
 <a href="class_usd_schema_registry.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for UsdSchemaRegistry:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_usd_schema_registry__inherit__graph.png" border="0" usemap="#_usd_schema_registry_inherit__map" alt="Inheritance graph"/></div>
<map name="_usd_schema_registry_inherit__map" id="_usd_schema_registry_inherit__map">
<area shape="rect"  title="Singleton registry that provides access to schema type information and the prim definitions for regis..." alt="" coords="5,80,157,107"/>
<area shape="rect"  href="class_tf_weak_base.html" title="Enable a concrete base class for use with TfWeakPtr." alt="" coords="30,5,132,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:struct_usd_schema_registry_1_1_schema_info"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#struct_usd_schema_registry_1_1_schema_info">SchemaInfo</a></td></tr>
<tr class="memdesc:struct_usd_schema_registry_1_1_schema_info"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that holds the information about a schema that is registered with the schema registry.  <a href="class_usd_schema_registry.html#struct_usd_schema_registry_1_1_schema_info">More...</a><br /></td></tr>
<tr class="separator:struct_usd_schema_registry_1_1_schema_info"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a49aaa704be3b21aaf43f12da6412ca6c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a49aaa704be3b21aaf43f12da6412ca6c">VersionPolicy</a> { <br />
&#160;&#160;<b>All</b>, 
<b>GreaterThan</b>, 
<b>GreaterThanOrEqual</b>, 
<b>LessThan</b>, 
<br />
&#160;&#160;<b>LessThanOrEqual</b>
<br />
 }</td></tr>
<tr class="memdesc:a49aaa704be3b21aaf43f12da6412ca6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A policy for filtering by schema version when querying for schemas in a particular schema family.  <a href="class_usd_schema_registry.html#a49aaa704be3b21aaf43f12da6412ca6c">More...</a><br /></td></tr>
<tr class="separator:a49aaa704be3b21aaf43f12da6412ca6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76d79e9f4f42959f2ec90a1323875b3"><td class="memItemLeft" align="right" valign="top"><a id="aa76d79e9f4f42959f2ec90a1323875b3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TokenToTokenVectorMap</b> = std::unordered_map&lt; <a class="el" href="class_tf_token.html">TfToken</a>, <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a>, <a class="el" href="class_tf_hash.html">TfHash</a> &gt;</td></tr>
<tr class="separator:aa76d79e9f4f42959f2ec90a1323875b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1c4f99bbc9043507e1ed0d495a863d68"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_usd_prim_definition.html">UsdPrimDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a1c4f99bbc9043507e1ed0d495a863d68">FindConcretePrimDefinition</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;typeName) const</td></tr>
<tr class="memdesc:a1c4f99bbc9043507e1ed0d495a863d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the prim definition for the given <code>typeName</code> token if <code>typeName</code> is a registered concrete typed schema type.  <a href="#a1c4f99bbc9043507e1ed0d495a863d68">More...</a><br /></td></tr>
<tr class="separator:a1c4f99bbc9043507e1ed0d495a863d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583796fd498889a71e6754513e42b2a8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_usd_prim_definition.html">UsdPrimDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a583796fd498889a71e6754513e42b2a8">FindAppliedAPIPrimDefinition</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;typeName) const</td></tr>
<tr class="memdesc:a583796fd498889a71e6754513e42b2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the prim definition for the given <code>typeName</code> token if <code>typeName</code> is a registered applied API schema type.  <a href="#a583796fd498889a71e6754513e42b2a8">More...</a><br /></td></tr>
<tr class="separator:a583796fd498889a71e6754513e42b2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33f0a62b2726b87600661010d6f249e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_usd_prim_definition.html">UsdPrimDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#af33f0a62b2726b87600661010d6f249e">GetEmptyPrimDefinition</a> () const</td></tr>
<tr class="memdesc:af33f0a62b2726b87600661010d6f249e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the empty prim definition.  <a href="#af33f0a62b2726b87600661010d6f249e">More...</a><br /></td></tr>
<tr class="separator:af33f0a62b2726b87600661010d6f249e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac530df3c1845d5fe237163a815439500"><td class="memItemLeft" align="right" valign="top">USD_API std::unique_ptr&lt; <a class="el" href="class_usd_prim_definition.html">UsdPrimDefinition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#ac530df3c1845d5fe237163a815439500">BuildComposedPrimDefinition</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;primType, const <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a> &amp;appliedAPISchemas) const</td></tr>
<tr class="memdesc:ac530df3c1845d5fe237163a815439500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes and returns a new <a class="el" href="class_usd_prim_definition.html" title="Class representing the builtin definition of a prim given the schemas registered in the schema regist...">UsdPrimDefinition</a> from the given <code>primType</code> and list of <code>appliedSchemas</code>.  <a href="#ac530df3c1845d5fe237163a815439500">More...</a><br /></td></tr>
<tr class="separator:ac530df3c1845d5fe237163a815439500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93921d1510b463b9eea85de97ea45271"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_vt_dictionary.html">VtDictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a93921d1510b463b9eea85de97ea45271">GetFallbackPrimTypes</a> () const</td></tr>
<tr class="memdesc:a93921d1510b463b9eea85de97ea45271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a dictionary mapping concrete schema prim type names to a VtTokenArray of fallback prim type names if fallback types are defined for the schema type in its registered schema.  <a href="#a93921d1510b463b9eea85de97ea45271">More...</a><br /></td></tr>
<tr class="separator:a93921d1510b463b9eea85de97ea45271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_tf_weak_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_tf_weak_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_tf_weak_base.html">TfWeakBase</a></td></tr>
<tr class="memitem:affc4c00d0bbfdfe4f9e6a8b2e81be368 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="affc4c00d0bbfdfe4f9e6a8b2e81be368"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TfWeakBase</b> (const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;)</td></tr>
<tr class="separator:affc4c00d0bbfdfe4f9e6a8b2e81be368 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aa4c4b93df067f2ec9b9e5fa4c35b3 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a01aa4c4b93df067f2ec9b9e5fa4c35b3"></a>
const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>__GetTfWeakBase__</b> () const</td></tr>
<tr class="separator:a01aa4c4b93df067f2ec9b9e5fa4c35b3 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af890ac314073e903458bf6b2397566b5 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="af890ac314073e903458bf6b2397566b5"></a>
const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;)</td></tr>
<tr class="separator:af890ac314073e903458bf6b2397566b5 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f1e27cc0c7c606ffb397b7d970ed10 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a16f1e27cc0c7c606ffb397b7d970ed10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EnableNotification2</b> () const</td></tr>
<tr class="separator:a16f1e27cc0c7c606ffb397b7d970ed10 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3241c32a82fbed0716a77049f6134e1e inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a3241c32a82fbed0716a77049f6134e1e"></a>
TF_API void const  *&#160;</td><td class="memItemRight" valign="bottom"><b>GetUniqueIdentifier</b> () const</td></tr>
<tr class="separator:a3241c32a82fbed0716a77049f6134e1e inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8e6f6a197e887d8ad51dc9beea507a2a"><td class="memItemLeft" align="right" valign="top"><a id="a8e6f6a197e887d8ad51dc9beea507a2a"></a>
static USD_API <a class="el" href="class_usd_schema_registry.html">UsdSchemaRegistry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetInstance</b> ()</td></tr>
<tr class="separator:a8e6f6a197e887d8ad51dc9beea507a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4430b1590f52919590df0890cea341b3"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a4430b1590f52919590df0890cea341b3">MakeSchemaIdentifierForFamilyAndVersion</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;schemaFamily, UsdSchemaVersion schemaVersion)</td></tr>
<tr class="memdesc:a4430b1590f52919590df0890cea341b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the schema identifier that would be used to define a schema of the given <code>schemaFamily</code> with the given <code>schemaVersion</code>.  <a href="#a4430b1590f52919590df0890cea341b3">More...</a><br /></td></tr>
<tr class="separator:a4430b1590f52919590df0890cea341b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fbde1db9710dfe4859734c53e9e061"><td class="memItemLeft" align="right" valign="top">static USD_API std::pair&lt; <a class="el" href="class_tf_token.html">TfToken</a>, UsdSchemaVersion &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a68fbde1db9710dfe4859734c53e9e061">ParseSchemaFamilyAndVersionFromIdentifier</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;schemaIdentifier)</td></tr>
<tr class="memdesc:a68fbde1db9710dfe4859734c53e9e061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses and returns the schema family and version values from the given <code>schemaIdentifier</code>.  <a href="#a68fbde1db9710dfe4859734c53e9e061">More...</a><br /></td></tr>
<tr class="separator:a68fbde1db9710dfe4859734c53e9e061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0201e4ae1ae41895baa1ead0b23ee937"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a0201e4ae1ae41895baa1ead0b23ee937">IsAllowedSchemaFamily</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;schemaFamily)</td></tr>
<tr class="memdesc:a0201e4ae1ae41895baa1ead0b23ee937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given <code>schemaFamily</code> is an allowed schema family name.  <a href="#a0201e4ae1ae41895baa1ead0b23ee937">More...</a><br /></td></tr>
<tr class="separator:a0201e4ae1ae41895baa1ead0b23ee937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7a09856a130b28651835f63acd9263"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a8a7a09856a130b28651835f63acd9263">IsAllowedSchemaIdentifier</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;schemaIdentifier)</td></tr>
<tr class="memdesc:a8a7a09856a130b28651835f63acd9263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given <code>schemaIdentifier</code> is an allowed schema identifier.  <a href="#a8a7a09856a130b28651835f63acd9263">More...</a><br /></td></tr>
<tr class="separator:a8a7a09856a130b28651835f63acd9263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f322bee01266f96f0cf7f9580a2abd"><td class="memItemLeft" align="right" valign="top">static USD_API const <a class="el" href="class_usd_schema_registry.html#struct_usd_schema_registry_1_1_schema_info">SchemaInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a05f322bee01266f96f0cf7f9580a2abd">FindSchemaInfo</a> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;schemaType)</td></tr>
<tr class="memdesc:a05f322bee01266f96f0cf7f9580a2abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns the schema info for a registered schema with the given <code>schemaType</code>.  <a href="#a05f322bee01266f96f0cf7f9580a2abd">More...</a><br /></td></tr>
<tr class="separator:a05f322bee01266f96f0cf7f9580a2abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d5c54750c583ffbf903d19095aa851"><td class="memTemplParams" colspan="2">template&lt;class SchemaType &gt; </td></tr>
<tr class="memitem:a63d5c54750c583ffbf903d19095aa851"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="class_usd_schema_registry.html#struct_usd_schema_registry_1_1_schema_info">SchemaInfo</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a63d5c54750c583ffbf903d19095aa851">FindSchemaInfo</a> ()</td></tr>
<tr class="memdesc:a63d5c54750c583ffbf903d19095aa851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns the schema info for a registered schema with the C++ schema class <code>SchemaType</code>.  <a href="#a63d5c54750c583ffbf903d19095aa851">More...</a><br /></td></tr>
<tr class="separator:a63d5c54750c583ffbf903d19095aa851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6af910bdba0cf85e64a04af424024d4"><td class="memItemLeft" align="right" valign="top">static USD_API const <a class="el" href="class_usd_schema_registry.html#struct_usd_schema_registry_1_1_schema_info">SchemaInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#ad6af910bdba0cf85e64a04af424024d4">FindSchemaInfo</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;schemaIdentifier)</td></tr>
<tr class="memdesc:ad6af910bdba0cf85e64a04af424024d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns the schema info for a registered schema with the given <code>schemaIdentifier</code>.  <a href="#ad6af910bdba0cf85e64a04af424024d4">More...</a><br /></td></tr>
<tr class="separator:ad6af910bdba0cf85e64a04af424024d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434273588c5222ce452767e75daf2979"><td class="memItemLeft" align="right" valign="top">static USD_API const <a class="el" href="class_usd_schema_registry.html#struct_usd_schema_registry_1_1_schema_info">SchemaInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a434273588c5222ce452767e75daf2979">FindSchemaInfo</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;schemaFamily, UsdSchemaVersion schemaVersion)</td></tr>
<tr class="memdesc:a434273588c5222ce452767e75daf2979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns the schema info for a registered schema in the given <code>schemaFamily</code> with the given <code>schemaVersion</code>.  <a href="#a434273588c5222ce452767e75daf2979">More...</a><br /></td></tr>
<tr class="separator:a434273588c5222ce452767e75daf2979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3891d85a4d5e4e1995759a8a02b57877"><td class="memItemLeft" align="right" valign="top">static USD_API const std::vector&lt; const <a class="el" href="class_usd_schema_registry.html#struct_usd_schema_registry_1_1_schema_info">SchemaInfo</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a3891d85a4d5e4e1995759a8a02b57877">FindSchemaInfosInFamily</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;schemaFamily)</td></tr>
<tr class="memdesc:a3891d85a4d5e4e1995759a8a02b57877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all schemas in the given <code>schemaFamily</code> and returns their their schema info ordered from highest version to lowest version.  <a href="#a3891d85a4d5e4e1995759a8a02b57877">More...</a><br /></td></tr>
<tr class="separator:a3891d85a4d5e4e1995759a8a02b57877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95557d1c6469a09ac5e234c32a134aca"><td class="memItemLeft" align="right" valign="top">static USD_API std::vector&lt; const <a class="el" href="class_usd_schema_registry.html#struct_usd_schema_registry_1_1_schema_info">SchemaInfo</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a95557d1c6469a09ac5e234c32a134aca">FindSchemaInfosInFamily</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;schemaFamily, UsdSchemaVersion schemaVersion, <a class="el" href="class_usd_schema_registry.html#a49aaa704be3b21aaf43f12da6412ca6c">VersionPolicy</a> versionPolicy)</td></tr>
<tr class="memdesc:a95557d1c6469a09ac5e234c32a134aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all schemas in the given <code>schemaFamily</code>, filtered according to the given <code>schemaVersion</code> and <code>versionPolicy</code>, and returns their their schema info ordered from highest version to lowest version.  <a href="#a95557d1c6469a09ac5e234c32a134aca">More...</a><br /></td></tr>
<tr class="separator:a95557d1c6469a09ac5e234c32a134aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08b87e4986cea204d74128ccccd819a"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#ab08b87e4986cea204d74128ccccd819a">GetSchemaTypeName</a> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;schemaType)</td></tr>
<tr class="memdesc:ab08b87e4986cea204d74128ccccd819a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type name in the USD schema for prims or API schemas of the given registered <code>schemaType</code>.  <a href="#ab08b87e4986cea204d74128ccccd819a">More...</a><br /></td></tr>
<tr class="separator:ab08b87e4986cea204d74128ccccd819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdc08410bca10646563b58682b6028c"><td class="memTemplParams" colspan="2">template&lt;class SchemaType &gt; </td></tr>
<tr class="memitem:a9cdc08410bca10646563b58682b6028c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a9cdc08410bca10646563b58682b6028c">GetSchemaTypeName</a> ()</td></tr>
<tr class="memdesc:a9cdc08410bca10646563b58682b6028c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type name in the USD schema for prims or API schemas of the given registered <code>SchemaType</code>.  <a href="#a9cdc08410bca10646563b58682b6028c">More...</a><br /></td></tr>
<tr class="separator:a9cdc08410bca10646563b58682b6028c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a86752feac3ffdda386b45e1e7ae6d6"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a8a86752feac3ffdda386b45e1e7ae6d6">GetConcreteSchemaTypeName</a> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;schemaType)</td></tr>
<tr class="memdesc:a8a86752feac3ffdda386b45e1e7ae6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type name in the USD schema for concrete prim types only from the given registered <code>schemaType</code>.  <a href="#a8a86752feac3ffdda386b45e1e7ae6d6">More...</a><br /></td></tr>
<tr class="separator:a8a86752feac3ffdda386b45e1e7ae6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebadba9689337a5e4eb3374098962b2"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#adebadba9689337a5e4eb3374098962b2">GetAPISchemaTypeName</a> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;schemaType)</td></tr>
<tr class="memdesc:adebadba9689337a5e4eb3374098962b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type name in the USD schema for API schema types only from the given registered <code>schemaType</code>.  <a href="#adebadba9689337a5e4eb3374098962b2">More...</a><br /></td></tr>
<tr class="separator:adebadba9689337a5e4eb3374098962b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d2748301e32877fd2073d840ed3ec9"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="class_tf_type.html">TfType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#ab7d2748301e32877fd2073d840ed3ec9">GetTypeFromSchemaTypeName</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;typeName)</td></tr>
<tr class="memdesc:ab7d2748301e32877fd2073d840ed3ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> of the schema corresponding to the given prim or API schema name <code>typeName</code>.  <a href="#ab7d2748301e32877fd2073d840ed3ec9">More...</a><br /></td></tr>
<tr class="separator:ab7d2748301e32877fd2073d840ed3ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359aad87d918b9bcc3c24026af4c592b"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="class_tf_type.html">TfType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a359aad87d918b9bcc3c24026af4c592b">GetConcreteTypeFromSchemaTypeName</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;typeName)</td></tr>
<tr class="memdesc:a359aad87d918b9bcc3c24026af4c592b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> of the schema corresponding to the given concrete prim type name <code>typeName</code>.  <a href="#a359aad87d918b9bcc3c24026af4c592b">More...</a><br /></td></tr>
<tr class="separator:a359aad87d918b9bcc3c24026af4c592b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce1170bd1d0a4e071cdfd6bf6f0f587"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="class_tf_type.html">TfType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#acce1170bd1d0a4e071cdfd6bf6f0f587">GetAPITypeFromSchemaTypeName</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;typeName)</td></tr>
<tr class="memdesc:acce1170bd1d0a4e071cdfd6bf6f0f587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> of the schema corresponding to the given API schema type name <code>typeName</code>.  <a href="#acce1170bd1d0a4e071cdfd6bf6f0f587">More...</a><br /></td></tr>
<tr class="separator:acce1170bd1d0a4e071cdfd6bf6f0f587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa422270c1807db9cf40912dce3f54f41"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#aa422270c1807db9cf40912dce3f54f41">IsDisallowedField</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;fieldName)</td></tr>
<tr class="memdesc:aa422270c1807db9cf40912dce3f54f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the field <code>fieldName</code> cannot have fallback values specified in schemas.  <a href="#aa422270c1807db9cf40912dce3f54f41">More...</a><br /></td></tr>
<tr class="separator:aa422270c1807db9cf40912dce3f54f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbaefbdd3e0bea0b098c777cd656eb8"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a7bbaefbdd3e0bea0b098c777cd656eb8">IsTyped</a> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;primType)</td></tr>
<tr class="memdesc:a7bbaefbdd3e0bea0b098c777cd656eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the prim type <code>primType</code> inherits from <a class="el" href="class_usd_typed.html">UsdTyped</a>.  <a href="#a7bbaefbdd3e0bea0b098c777cd656eb8">More...</a><br /></td></tr>
<tr class="separator:a7bbaefbdd3e0bea0b098c777cd656eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03cad1878733295c63a5ffed9fc4e1b"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#af03cad1878733295c63a5ffed9fc4e1b">GetSchemaKind</a> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;schemaType)</td></tr>
<tr class="memdesc:af03cad1878733295c63a5ffed9fc4e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kind of the schema the given <code>schemaType</code> represents.  <a href="#af03cad1878733295c63a5ffed9fc4e1b">More...</a><br /></td></tr>
<tr class="separator:af03cad1878733295c63a5ffed9fc4e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda2cb6c71c95f14d484344f824e481b"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#adda2cb6c71c95f14d484344f824e481b">GetSchemaKind</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;typeName)</td></tr>
<tr class="memdesc:adda2cb6c71c95f14d484344f824e481b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kind of the schema the given <code>typeName</code> represents.  <a href="#adda2cb6c71c95f14d484344f824e481b">More...</a><br /></td></tr>
<tr class="separator:adda2cb6c71c95f14d484344f824e481b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbccd46aeee7c8968355ea406636ab7"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a4bbccd46aeee7c8968355ea406636ab7">IsConcrete</a> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;primType)</td></tr>
<tr class="memdesc:a4bbccd46aeee7c8968355ea406636ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the prim type <code>primType</code> is instantiable in scene description.  <a href="#a4bbccd46aeee7c8968355ea406636ab7">More...</a><br /></td></tr>
<tr class="separator:a4bbccd46aeee7c8968355ea406636ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b8d76ddbc860237f845b32ce1717be"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#ac7b8d76ddbc860237f845b32ce1717be">IsConcrete</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;primType)</td></tr>
<tr class="memdesc:ac7b8d76ddbc860237f845b32ce1717be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the prim type <code>primType</code> is instantiable in scene description.  <a href="#ac7b8d76ddbc860237f845b32ce1717be">More...</a><br /></td></tr>
<tr class="separator:ac7b8d76ddbc860237f845b32ce1717be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d34f463c3643cf91bf938dd31c271d"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a50d34f463c3643cf91bf938dd31c271d">IsAbstract</a> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;primType)</td></tr>
<tr class="memdesc:a50d34f463c3643cf91bf938dd31c271d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the prim type <code>primType</code> is an abstract schema type and, unlike a concrete type, is not instantiable in scene description.  <a href="#a50d34f463c3643cf91bf938dd31c271d">More...</a><br /></td></tr>
<tr class="separator:a50d34f463c3643cf91bf938dd31c271d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af144a755603e2ecb0bca600dae8040bf"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#af144a755603e2ecb0bca600dae8040bf">IsAbstract</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;primType)</td></tr>
<tr class="memdesc:af144a755603e2ecb0bca600dae8040bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the prim type <code>primType</code> is an abstract schema type and, unlike a concrete type, is not instantiable in scene description.  <a href="#af144a755603e2ecb0bca600dae8040bf">More...</a><br /></td></tr>
<tr class="separator:af144a755603e2ecb0bca600dae8040bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a2f2592fd8a13dde1ed9ced332b6c5"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a64a2f2592fd8a13dde1ed9ced332b6c5">IsAppliedAPISchema</a> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;apiSchemaType)</td></tr>
<tr class="memdesc:a64a2f2592fd8a13dde1ed9ced332b6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>apiSchemaType</code> is an applied API schema type.  <a href="#a64a2f2592fd8a13dde1ed9ced332b6c5">More...</a><br /></td></tr>
<tr class="separator:a64a2f2592fd8a13dde1ed9ced332b6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d021d2f1f89bd8eaebd7a6c73790b2"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a52d021d2f1f89bd8eaebd7a6c73790b2">IsAppliedAPISchema</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;apiSchemaType)</td></tr>
<tr class="memdesc:a52d021d2f1f89bd8eaebd7a6c73790b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>apiSchemaType</code> is an applied API schema type.  <a href="#a52d021d2f1f89bd8eaebd7a6c73790b2">More...</a><br /></td></tr>
<tr class="separator:a52d021d2f1f89bd8eaebd7a6c73790b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e89b995455f3eb97ad99154e906c34"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a50e89b995455f3eb97ad99154e906c34">IsMultipleApplyAPISchema</a> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;apiSchemaType)</td></tr>
<tr class="memdesc:a50e89b995455f3eb97ad99154e906c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>apiSchemaType</code> is a multiple-apply API schema type.  <a href="#a50e89b995455f3eb97ad99154e906c34">More...</a><br /></td></tr>
<tr class="separator:a50e89b995455f3eb97ad99154e906c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14af24f2a8254087da50e639754bdc9"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#aa14af24f2a8254087da50e639754bdc9">IsMultipleApplyAPISchema</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;apiSchemaType)</td></tr>
<tr class="memdesc:aa14af24f2a8254087da50e639754bdc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>apiSchemaType</code> is a multiple-apply API schema type.  <a href="#aa14af24f2a8254087da50e639754bdc9">More...</a><br /></td></tr>
<tr class="separator:aa14af24f2a8254087da50e639754bdc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa0ce3bcfbb24525289bf110ea7aac0"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="class_tf_type.html">TfType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#aefa0ce3bcfbb24525289bf110ea7aac0">GetTypeFromName</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;typeName)</td></tr>
<tr class="memdesc:aefa0ce3bcfbb24525289bf110ea7aac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> of a schema with <code>typeName</code>.  <a href="#aefa0ce3bcfbb24525289bf110ea7aac0">More...</a><br /></td></tr>
<tr class="separator:aefa0ce3bcfbb24525289bf110ea7aac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea978c41155de744c39fb7a636e3861b"><td class="memItemLeft" align="right" valign="top">static USD_API std::pair&lt; <a class="el" href="class_tf_token.html">TfToken</a>, <a class="el" href="class_tf_token.html">TfToken</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#aea978c41155de744c39fb7a636e3861b">GetTypeNameAndInstance</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;apiSchemaName)</td></tr>
<tr class="memdesc:aea978c41155de744c39fb7a636e3861b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the schema type name and the instance name parsed from the given <code>apiSchemaName</code>.  <a href="#aea978c41155de744c39fb7a636e3861b">More...</a><br /></td></tr>
<tr class="separator:aea978c41155de744c39fb7a636e3861b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583a741dcad67bd1bfb3fc952c3bc15c"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a583a741dcad67bd1bfb3fc952c3bc15c">IsAllowedAPISchemaInstanceName</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;apiSchemaName, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;instanceName)</td></tr>
<tr class="memdesc:a583a741dcad67bd1bfb3fc952c3bc15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <code>instanceName</code> is an allowed instance name for the multiple apply API schema named <code>apiSchemaName</code>.  <a href="#a583a741dcad67bd1bfb3fc952c3bc15c">More...</a><br /></td></tr>
<tr class="separator:a583a741dcad67bd1bfb3fc952c3bc15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111ea128b84b68095e7e63d2a0a3afed"><td class="memItemLeft" align="right" valign="top">static USD_API const <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a111ea128b84b68095e7e63d2a0a3afed">GetAPISchemaCanOnlyApplyToTypeNames</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;apiSchemaName, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;instanceName=<a class="el" href="class_tf_token.html">TfToken</a>())</td></tr>
<tr class="memdesc:a111ea128b84b68095e7e63d2a0a3afed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of prim type names that the given <code>apiSchemaName</code> can only be applied to.  <a href="#a111ea128b84b68095e7e63d2a0a3afed">More...</a><br /></td></tr>
<tr class="separator:a111ea128b84b68095e7e63d2a0a3afed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ab5f4198faff6a61573cf4e5bf7787"><td class="memItemLeft" align="right" valign="top">static USD_API const TokenToTokenVectorMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#aa1ab5f4198faff6a61573cf4e5bf7787">GetAutoApplyAPISchemas</a> ()</td></tr>
<tr class="memdesc:aa1ab5f4198faff6a61573cf4e5bf7787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map of the names of all registered auto apply API schemas to the list of type names each is registered to be auto applied to.  <a href="#aa1ab5f4198faff6a61573cf4e5bf7787">More...</a><br /></td></tr>
<tr class="separator:aa1ab5f4198faff6a61573cf4e5bf7787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d1f1ce4aa848cb34eb0ab45515f37e"><td class="memItemLeft" align="right" valign="top">static USD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#af8d1f1ce4aa848cb34eb0ab45515f37e">CollectAddtionalAutoApplyAPISchemasFromPlugins</a> (TokenToTokenVectorMap *autoApplyAPISchemas)</td></tr>
<tr class="memdesc:af8d1f1ce4aa848cb34eb0ab45515f37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects all the additional auto apply schemas that can be defined in a plugin through "AutoApplyAPISchemas" metadata and adds the mappings to <code>autoApplyAPISchemas</code>.  <a href="#af8d1f1ce4aa848cb34eb0ab45515f37e">More...</a><br /></td></tr>
<tr class="separator:af8d1f1ce4aa848cb34eb0ab45515f37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7847bceb3ebd3efabe3120c27047ed"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#ada7847bceb3ebd3efabe3120c27047ed">MakeMultipleApplyNameTemplate</a> (const std::string &amp;namespacePrefix, const std::string &amp;baseName)</td></tr>
<tr class="memdesc:ada7847bceb3ebd3efabe3120c27047ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a name template that can represent a property or API schema that belongs to a multiple apply schema and will therefore have multiple instances with different names.  <a href="#ada7847bceb3ebd3efabe3120c27047ed">More...</a><br /></td></tr>
<tr class="separator:ada7847bceb3ebd3efabe3120c27047ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7ecf1f83da9b116abc23e28cef727c"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a2d7ecf1f83da9b116abc23e28cef727c">MakeMultipleApplyNameInstance</a> (const std::string &amp;nameTemplate, const std::string &amp;instanceName)</td></tr>
<tr class="memdesc:a2d7ecf1f83da9b116abc23e28cef727c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of a multiple apply schema name from the given <code>nameTemplate</code> for the given <code>instanceName</code>.  <a href="#a2d7ecf1f83da9b116abc23e28cef727c">More...</a><br /></td></tr>
<tr class="separator:a2d7ecf1f83da9b116abc23e28cef727c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6fbfa80a299bb1f0590abe12a00e42"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#a1b6fbfa80a299bb1f0590abe12a00e42">GetMultipleApplyNameTemplateBaseName</a> (const std::string &amp;nameTemplate)</td></tr>
<tr class="memdesc:a1b6fbfa80a299bb1f0590abe12a00e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the base name for the multiple apply schema name template <code>nameTemplate</code>.  <a href="#a1b6fbfa80a299bb1f0590abe12a00e42">More...</a><br /></td></tr>
<tr class="separator:a1b6fbfa80a299bb1f0590abe12a00e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac302f2e9e3c7cf75f3588d8c626a6e4f"><td class="memItemLeft" align="right" valign="top">static USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_registry.html#ac302f2e9e3c7cf75f3588d8c626a6e4f">IsMultipleApplyNameTemplate</a> (const std::string &amp;nameTemplate)</td></tr>
<tr class="memdesc:ac302f2e9e3c7cf75f3588d8c626a6e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>nameTemplate</code> is a multiple apply schema name template.  <a href="#ac302f2e9e3c7cf75f3588d8c626a6e4f">More...</a><br /></td></tr>
<tr class="separator:ac302f2e9e3c7cf75f3588d8c626a6e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a93a851e20098bdf2b8d3fd65db0fe2a7"><td class="memItemLeft" align="right" valign="top"><a id="a93a851e20098bdf2b8d3fd65db0fe2a7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TfSingleton&lt; UsdSchemaRegistry &gt;</b></td></tr>
<tr class="separator:a93a851e20098bdf2b8d3fd65db0fe2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade728bcc7f74163c134889e476241fac"><td class="memItemLeft" align="right" valign="top"><a id="ade728bcc7f74163c134889e476241fac"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UsdPrimDefinition</b></td></tr>
<tr class="separator:ade728bcc7f74163c134889e476241fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_tf_weak_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_tf_weak_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_tf_weak_base.html">TfWeakBase</a></td></tr>
<tr class="memitem:a95139d2f4d04eb706664a4f47eb93918 inherit pro_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a95139d2f4d04eb706664a4f47eb93918"></a>
<a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; Tf_Remnant &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_Register</b> () const</td></tr>
<tr class="separator:a95139d2f4d04eb706664a4f47eb93918 inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memTemplParams" colspan="2"><a id="ac1312732482c8a286522f703f2cf90d1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; Tf_Remnant &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_Register</b> (T *tempRmnt) const</td></tr>
<tr class="separator:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5533162e8efab1be47acd6ccd5254c inherit pro_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a6a5533162e8efab1be47acd6ccd5254c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_HasRemnant</b> () const</td></tr>
<tr class="separator:a6a5533162e8efab1be47acd6ccd5254c inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Singleton registry that provides access to schema type information and the prim definitions for registered Usd "IsA" and applied API schema types. </p>
<p>It also contains the data from the generated schemas that is used by prim definitions to provide properties and fallbacks.</p>
<p>The data contained herein comes from the generatedSchema.usda file (generated when a schema.usda file is processed by <em>usdGenSchema</em>) of each schema-defining module. The registry expects each schema type to be represented as a single prim spec with its inheritance flattened, i.e. the prim spec contains a union of all its local and class inherited property specs and metadata fields.</p>
<p>It is used by the Usd core, via <a class="el" href="class_usd_prim_definition.html" title="Class representing the builtin definition of a prim given the schemas registered in the schema regist...">UsdPrimDefinition</a>, to determine how to create scene description for unauthored "built-in" properties of schema classes, to enumerate all properties for a given schema class, and finally to provide fallback values for unauthored built-in properties. </p>

<p class="definition">Definition at line <a class="el" href="schema_registry_8h_source.html#l00070">70</a> of file <a class="el" href="schema_registry_8h_source.html">schemaRegistry.h</a>.</p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="struct_usd_schema_registry_1_1_schema_info" id="struct_usd_schema_registry_1_1_schema_info"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_usd_schema_registry_1_1_schema_info">&#9670;&nbsp;</a></span>UsdSchemaRegistry::SchemaInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct UsdSchemaRegistry::SchemaInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Structure that holds the information about a schema that is registered with the schema registry. </p>

<p class="definition">Definition at line <a class="el" href="schema_registry_8h_source.html#l00079">79</a> of file <a class="el" href="schema_registry_8h_source.html">schemaRegistry.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a3bf0f09e15b168cc16f891d87ce3228f"></a><a class="el" href="class_tf_token.html">TfToken</a></td>
<td class="fieldname">
family</td>
<td class="fielddoc">
The name of the family of schema's which the schema is a version of. <p>This is the same as the schema identifier with the version suffix removed (or exactly the same as the schema identifier in the case of version 0 of a schema which will not have a version suffix.) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a57d5500412f53145acd56ad3b1712685"></a><a class="el" href="class_tf_token.html">TfToken</a></td>
<td class="fieldname">
identifier</td>
<td class="fielddoc">
The schema's identifier which is how the schema type is referred to in scene description and is also the key used to look up the schema's prim definition. </td></tr>
<tr><td class="fieldtype">
<a id="a7371f39deed3c2c07f95f1d46a343c79"></a><a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a></td>
<td class="fieldname">
kind</td>
<td class="fielddoc">
The schema's kind: ConcreteTyped, SingleApplyAPI, etc. </td></tr>
<tr><td class="fieldtype">
<a id="a1c85ebd22da0454c19c990c6b8512169"></a><a class="el" href="class_tf_type.html">TfType</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
The schema's type as registered with the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> registry. <p>This will correspond to the C++ class of the schema if a class was generated for it. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0951b753bb46dfc64b66824683681330"></a>UsdSchemaVersion</td>
<td class="fieldname">
version</td>
<td class="fielddoc">
The version number of the schema within its schema family. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a49aaa704be3b21aaf43f12da6412ca6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49aaa704be3b21aaf43f12da6412ca6c">&#9670;&nbsp;</a></span>VersionPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_usd_schema_registry.html#a49aaa704be3b21aaf43f12da6412ca6c">VersionPolicy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A policy for filtering by schema version when querying for schemas in a particular schema family. </p>

<p class="definition">Definition at line <a class="el" href="schema_registry_8h_source.html#l00211">211</a> of file <a class="el" href="schema_registry_8h_source.html">schemaRegistry.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac530df3c1845d5fe237163a815439500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac530df3c1845d5fe237163a815439500">&#9670;&nbsp;</a></span>BuildComposedPrimDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USD_API std::unique_ptr&lt;<a class="el" href="class_usd_prim_definition.html">UsdPrimDefinition</a>&gt; BuildComposedPrimDefinition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>primType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a> &amp;&#160;</td>
          <td class="paramname"><em>appliedAPISchemas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes and returns a new <a class="el" href="class_usd_prim_definition.html" title="Class representing the builtin definition of a prim given the schemas registered in the schema regist...">UsdPrimDefinition</a> from the given <code>primType</code> and list of <code>appliedSchemas</code>. </p>
<p>This prim definition will contain a union of properties from the registered prim definitions of each of the provided types. </p>

</div>
</div>
<a id="af8d1f1ce4aa848cb34eb0ab45515f37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d1f1ce4aa848cb34eb0ab45515f37e">&#9670;&nbsp;</a></span>CollectAddtionalAutoApplyAPISchemasFromPlugins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API void CollectAddtionalAutoApplyAPISchemasFromPlugins </td>
          <td>(</td>
          <td class="paramtype">TokenToTokenVectorMap *&#160;</td>
          <td class="paramname"><em>autoApplyAPISchemas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects all the additional auto apply schemas that can be defined in a plugin through "AutoApplyAPISchemas" metadata and adds the mappings to <code>autoApplyAPISchemas</code>. </p>
<p>These are separate from the auto-apply schemas that are built in to the applied API schema types themselves and can be defined in any plugin to map any applied API schema to any concrete prim type.</p>
<p>Note that GetAutoApplyAPISchemas will already include API schemas collected from this method; this function is provided for clients that may want to collect just these plugin API schema mappings. </p>

</div>
</div>
<a id="a583796fd498889a71e6754513e42b2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583796fd498889a71e6754513e42b2a8">&#9670;&nbsp;</a></span>FindAppliedAPIPrimDefinition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_usd_prim_definition.html">UsdPrimDefinition</a>* FindAppliedAPIPrimDefinition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the prim definition for the given <code>typeName</code> token if <code>typeName</code> is a registered applied API schema type. </p>
<p>Returns null if it is not. </p>

<p class="definition">Definition at line <a class="el" href="schema_registry_8h_source.html#l00525">525</a> of file <a class="el" href="schema_registry_8h_source.html">schemaRegistry.h</a>.</p>

</div>
</div>
<a id="a1c4f99bbc9043507e1ed0d495a863d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4f99bbc9043507e1ed0d495a863d68">&#9670;&nbsp;</a></span>FindConcretePrimDefinition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_usd_prim_definition.html">UsdPrimDefinition</a>* FindConcretePrimDefinition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the prim definition for the given <code>typeName</code> token if <code>typeName</code> is a registered concrete typed schema type. </p>
<p>Returns null if it is not. </p>

<p class="definition">Definition at line <a class="el" href="schema_registry_8h_source.html#l00515">515</a> of file <a class="el" href="schema_registry_8h_source.html">schemaRegistry.h</a>.</p>

</div>
</div>
<a id="a05f322bee01266f96f0cf7f9580a2abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f322bee01266f96f0cf7f9580a2abd">&#9670;&nbsp;</a></span>FindSchemaInfo() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API const <a class="el" href="class_usd_schema_registry.html#struct_usd_schema_registry_1_1_schema_info">SchemaInfo</a>* FindSchemaInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td>
          <td class="paramname"><em>schemaType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds and returns the schema info for a registered schema with the given <code>schemaType</code>. </p>
<p>Returns null if no registered schema with the schema type exists. </p>

</div>
</div>
<a id="a63d5c54750c583ffbf903d19095aa851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d5c54750c583ffbf903d19095aa851">&#9670;&nbsp;</a></span>FindSchemaInfo() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_usd_schema_registry.html#struct_usd_schema_registry_1_1_schema_info">SchemaInfo</a>* FindSchemaInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds and returns the schema info for a registered schema with the C++ schema class <code>SchemaType</code>. </p>
<p>All generated C++ schema classes, i.e. classes that derive from <a class="el" href="class_usd_schema_base.html" title="The base class for all schema types in Usd.">UsdSchemaBase</a>, are expected to have their types registered with the schema registry and as such, the return value from this function should never be null. A null return value is indication of a coding error even though this function itself will not report an error. </p>

<p class="definition">Definition at line <a class="el" href="schema_registry_8h_source.html#l00189">189</a> of file <a class="el" href="schema_registry_8h_source.html">schemaRegistry.h</a>.</p>

</div>
</div>
<a id="ad6af910bdba0cf85e64a04af424024d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6af910bdba0cf85e64a04af424024d4">&#9670;&nbsp;</a></span>FindSchemaInfo() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API const <a class="el" href="class_usd_schema_registry.html#struct_usd_schema_registry_1_1_schema_info">SchemaInfo</a>* FindSchemaInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>schemaIdentifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds and returns the schema info for a registered schema with the given <code>schemaIdentifier</code>. </p>
<p>Returns null if no registered schema with the schema identifier exists. </p>

</div>
</div>
<a id="a434273588c5222ce452767e75daf2979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434273588c5222ce452767e75daf2979">&#9670;&nbsp;</a></span>FindSchemaInfo() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API const <a class="el" href="class_usd_schema_registry.html#struct_usd_schema_registry_1_1_schema_info">SchemaInfo</a>* FindSchemaInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>schemaFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UsdSchemaVersion&#160;</td>
          <td class="paramname"><em>schemaVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds and returns the schema info for a registered schema in the given <code>schemaFamily</code> with the given <code>schemaVersion</code>. </p>
<p>Returns null if no registered schema in the schema family with the given version exists. </p>

</div>
</div>
<a id="a3891d85a4d5e4e1995759a8a02b57877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3891d85a4d5e4e1995759a8a02b57877">&#9670;&nbsp;</a></span>FindSchemaInfosInFamily() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API const std::vector&lt;const <a class="el" href="class_usd_schema_registry.html#struct_usd_schema_registry_1_1_schema_info">SchemaInfo</a> *&gt;&amp; FindSchemaInfosInFamily </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>schemaFamily</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all schemas in the given <code>schemaFamily</code> and returns their their schema info ordered from highest version to lowest version. </p>

</div>
</div>
<a id="a95557d1c6469a09ac5e234c32a134aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95557d1c6469a09ac5e234c32a134aca">&#9670;&nbsp;</a></span>FindSchemaInfosInFamily() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API std::vector&lt;const <a class="el" href="class_usd_schema_registry.html#struct_usd_schema_registry_1_1_schema_info">SchemaInfo</a> *&gt; FindSchemaInfosInFamily </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>schemaFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UsdSchemaVersion&#160;</td>
          <td class="paramname"><em>schemaVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_schema_registry.html#a49aaa704be3b21aaf43f12da6412ca6c">VersionPolicy</a>&#160;</td>
          <td class="paramname"><em>versionPolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all schemas in the given <code>schemaFamily</code>, filtered according to the given <code>schemaVersion</code> and <code>versionPolicy</code>, and returns their their schema info ordered from highest version to lowest version. </p>

</div>
</div>
<a id="a111ea128b84b68095e7e63d2a0a3afed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111ea128b84b68095e7e63d2a0a3afed">&#9670;&nbsp;</a></span>GetAPISchemaCanOnlyApplyToTypeNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API const <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a>&amp; GetAPISchemaCanOnlyApplyToTypeNames </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>apiSchemaName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>instanceName</em> = <code><a class="el" href="class_tf_token.html">TfToken</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of prim type names that the given <code>apiSchemaName</code> can only be applied to. </p>
<p>A non-empty list indicates that the API schema can only be applied to prim that are or derive from prim type names in the list. If the list is empty, the API schema can be applied to prims of any type.</p>
<p>If a non-empty <code>instanceName</code> is provided, this will first look for a list of "can only apply to" names specific to that instance of the API schema and return that if found. If a list is not found for the specific instance, it will fall back to looking for a "can only apply to" list for just the schema name itself. </p>

</div>
</div>
<a id="adebadba9689337a5e4eb3374098962b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adebadba9689337a5e4eb3374098962b2">&#9670;&nbsp;</a></span>GetAPISchemaTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API <a class="el" href="class_tf_token.html">TfToken</a> GetAPISchemaTypeName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td>
          <td class="paramname"><em>schemaType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the type name in the USD schema for API schema types only from the given registered <code>schemaType</code>. </p>

</div>
</div>
<a id="acce1170bd1d0a4e071cdfd6bf6f0f587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce1170bd1d0a4e071cdfd6bf6f0f587">&#9670;&nbsp;</a></span>GetAPITypeFromSchemaTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API <a class="el" href="class_tf_type.html">TfType</a> GetAPITypeFromSchemaTypeName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> of the schema corresponding to the given API schema type name <code>typeName</code>. </p>
<p>This the inverse of GetAPISchemaTypeNAme. </p>

</div>
</div>
<a id="aa1ab5f4198faff6a61573cf4e5bf7787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ab5f4198faff6a61573cf4e5bf7787">&#9670;&nbsp;</a></span>GetAutoApplyAPISchemas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API const TokenToTokenVectorMap&amp; GetAutoApplyAPISchemas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a map of the names of all registered auto apply API schemas to the list of type names each is registered to be auto applied to. </p>
<p>The list of type names to apply to will directly match what is specified in the plugin metadata for each schema type. While auto apply schemas do account for the existence and validity of the type names and expand to include derived types of the listed types, the type lists returned by this function do not. </p>

</div>
</div>
<a id="a8a86752feac3ffdda386b45e1e7ae6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a86752feac3ffdda386b45e1e7ae6d6">&#9670;&nbsp;</a></span>GetConcreteSchemaTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API <a class="el" href="class_tf_token.html">TfToken</a> GetConcreteSchemaTypeName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td>
          <td class="paramname"><em>schemaType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the type name in the USD schema for concrete prim types only from the given registered <code>schemaType</code>. </p>

</div>
</div>
<a id="a359aad87d918b9bcc3c24026af4c592b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359aad87d918b9bcc3c24026af4c592b">&#9670;&nbsp;</a></span>GetConcreteTypeFromSchemaTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API <a class="el" href="class_tf_type.html">TfType</a> GetConcreteTypeFromSchemaTypeName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> of the schema corresponding to the given concrete prim type name <code>typeName</code>. </p>
<p>This the inverse of GetConcreteSchemaTypeName. </p>

</div>
</div>
<a id="af33f0a62b2726b87600661010d6f249e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33f0a62b2726b87600661010d6f249e">&#9670;&nbsp;</a></span>GetEmptyPrimDefinition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_usd_prim_definition.html">UsdPrimDefinition</a>* GetEmptyPrimDefinition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the empty prim definition. </p>

<p class="definition">Definition at line <a class="el" href="schema_registry_8h_source.html#l00533">533</a> of file <a class="el" href="schema_registry_8h_source.html">schemaRegistry.h</a>.</p>

</div>
</div>
<a id="a93921d1510b463b9eea85de97ea45271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93921d1510b463b9eea85de97ea45271">&#9670;&nbsp;</a></span>GetFallbackPrimTypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_vt_dictionary.html">VtDictionary</a>&amp; GetFallbackPrimTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a dictionary mapping concrete schema prim type names to a VtTokenArray of fallback prim type names if fallback types are defined for the schema type in its registered schema. </p>
<p>The standard use case for this to provide schema defined metadata that can be saved with a stage to inform an older version of USD - that may not have some schema types - as to which types it can used instead when encountering a prim of one these types.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_stage.html#a14897ca124a0fb4a62e6ed2ccbbdbf4f" title="Writes the fallback prim types defined in the schema registry to the stage as dictionary valued fallb...">UsdStage::WriteFallbackPrimTypes</a> </dd>
<dd>
<a class="el" href="_usd__page__object_model.html#Usd_OM_FallbackPrimTypes">Fallback Prim Types</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="schema_registry_8h_source.html#l00557">557</a> of file <a class="el" href="schema_registry_8h_source.html">schemaRegistry.h</a>.</p>

</div>
</div>
<a id="a1b6fbfa80a299bb1f0590abe12a00e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6fbfa80a299bb1f0590abe12a00e42">&#9670;&nbsp;</a></span>GetMultipleApplyNameTemplateBaseName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API <a class="el" href="class_tf_token.html">TfToken</a> GetMultipleApplyNameTemplateBaseName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nameTemplate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the base name for the multiple apply schema name template <code>nameTemplate</code>. </p>
<p>The base name is the substring of the given name template that comes after the instance name placeholder and the subsequent namespace delimiter. If the given property name does not contain the instance name placeholder, it is not a name template and the name template is returned as is. </p>

</div>
</div>
<a id="af03cad1878733295c63a5ffed9fc4e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03cad1878733295c63a5ffed9fc4e1b">&#9670;&nbsp;</a></span>GetSchemaKind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a> GetSchemaKind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td>
          <td class="paramname"><em>schemaType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the kind of the schema the given <code>schemaType</code> represents. </p>
<p>This returns <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741a4bbb8f967da6d1a610596d7257179c2b" title="Invalid or unknown schema kind.">UsdSchemaKind::Invalid</a> if <code>schemaType</code> is not a valid schema type or if the kind cannot be determined from type's plugin information. </p>

</div>
</div>
<a id="adda2cb6c71c95f14d484344f824e481b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda2cb6c71c95f14d484344f824e481b">&#9670;&nbsp;</a></span>GetSchemaKind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a> GetSchemaKind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the kind of the schema the given <code>typeName</code> represents. </p>
<p>This returns <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741a4bbb8f967da6d1a610596d7257179c2b" title="Invalid or unknown schema kind.">UsdSchemaKind::Invalid</a> if <code>typeName</code> is not a valid schema type name or if the kind cannot be determined from type's plugin information. </p>

</div>
</div>
<a id="ab08b87e4986cea204d74128ccccd819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08b87e4986cea204d74128ccccd819a">&#9670;&nbsp;</a></span>GetSchemaTypeName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API <a class="el" href="class_tf_token.html">TfToken</a> GetSchemaTypeName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td>
          <td class="paramname"><em>schemaType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the type name in the USD schema for prims or API schemas of the given registered <code>schemaType</code>. </p>

</div>
</div>
<a id="a9cdc08410bca10646563b58682b6028c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdc08410bca10646563b58682b6028c">&#9670;&nbsp;</a></span>GetSchemaTypeName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_tf_token.html">TfToken</a> GetSchemaTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the type name in the USD schema for prims or API schemas of the given registered <code>SchemaType</code>. </p>

<p class="definition">Definition at line <a class="el" href="schema_registry_8h_source.html#l00245">245</a> of file <a class="el" href="schema_registry_8h_source.html">schemaRegistry.h</a>.</p>

</div>
</div>
<a id="aefa0ce3bcfbb24525289bf110ea7aac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa0ce3bcfbb24525289bf110ea7aac0">&#9670;&nbsp;</a></span>GetTypeFromName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API <a class="el" href="class_tf_type.html">TfType</a> GetTypeFromName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> of a schema with <code>typeName</code>. </p>
<p>This is primarily for when you have been provided Schema typeName (perhaps from a User Interface or Script) and need to identify if a prim's type inherits/is that typeName. If the type name IS known, then using the schema class is preferred.</p>
<div class="fragment"><div class="line"><span class="comment"># This code attempts to match all prims on a stage to a given</span></div><div class="line"><span class="comment"># user specified type, making the traditional schema based idioms not</span></div><div class="line"><span class="comment"># applicable.</span></div><div class="line">data = parser.parse_args()</div><div class="line">tfType = <a class="code" href="class_usd_schema_registry.html#aefa0ce3bcfbb24525289bf110ea7aac0">UsdSchemaRegistry.GetTypeFromName</a>(data.type)</div><div class="line">matchedPrims = [p <span class="keywordflow">for</span> p <span class="keywordflow">in</span> stage.Traverse() <span class="keywordflow">if</span> p.IsA(tfType)] </div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It's worth noting that GetTypeFromName("Sphere") == GetTypeFromName("UsdGeomSphere"), as this function resolves both the Schema's C++ class name and any registered aliases from a libraries plugInfo.json file. However, GetTypeFromName("Boundable") != GetTypeFromName("UsdGeomBoundable") because type aliases don't get registered for abstract schema types. </dd></dl>

</div>
</div>
<a id="ab7d2748301e32877fd2073d840ed3ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d2748301e32877fd2073d840ed3ec9">&#9670;&nbsp;</a></span>GetTypeFromSchemaTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API <a class="el" href="class_tf_type.html">TfType</a> GetTypeFromSchemaTypeName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> of the schema corresponding to the given prim or API schema name <code>typeName</code>. </p>
<p>This the inverse of GetSchemaTypeName. </p>

</div>
</div>
<a id="aea978c41155de744c39fb7a636e3861b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea978c41155de744c39fb7a636e3861b">&#9670;&nbsp;</a></span>GetTypeNameAndInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API std::pair&lt;<a class="el" href="class_tf_token.html">TfToken</a>, <a class="el" href="class_tf_token.html">TfToken</a>&gt; GetTypeNameAndInstance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>apiSchemaName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the schema type name and the instance name parsed from the given <code>apiSchemaName</code>. </p>
<p><code>apiSchemaName</code> is the name of an applied schema as it appears in the list of applied schemas on a prim. For single-apply API schemas the name will just be the schema type name. For multiple-apply schemas the name should include the schema type name and the applied instance name separated by a namespace delimiter, for example 'CollectionAPI:plasticStuff'.</p>
<p>This function returns the separated schema type name and instance name component tokens if possible, otherwise it returns the <code>apiSchemaName</code> as the type name and an empty instance name.</p>
<p>Note that no validation is done on the returned tokens. Clients are advised to use <a class="el" href="class_usd_schema_registry.html#ab7d2748301e32877fd2073d840ed3ec9" title="Return the TfType of the schema corresponding to the given prim or API schema name typeName.">GetTypeFromSchemaTypeName()</a> to validate the typeName token.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_prim.html#a6a0ea2bd96afa34596c713fa00ee9bee" title="Adds the applied API schema name token appliedSchemaName to the apiSchemas metadata for this prim at ...">UsdPrim::AddAppliedSchema(const TfToken&amp;) const</a> </dd>
<dd>
<a class="el" href="class_usd_prim.html#a42cfbef37f98df2c20c15044c333fe4a" title="Return a vector containing the names of API schemas which have been applied to this prim.">UsdPrim::GetAppliedSchemas() const </a> </dd></dl>

</div>
</div>
<a id="a50d34f463c3643cf91bf938dd31c271d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d34f463c3643cf91bf938dd31c271d">&#9670;&nbsp;</a></span>IsAbstract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsAbstract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td>
          <td class="paramname"><em>primType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the prim type <code>primType</code> is an abstract schema type and, unlike a concrete type, is not instantiable in scene description. </p>

</div>
</div>
<a id="af144a755603e2ecb0bca600dae8040bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af144a755603e2ecb0bca600dae8040bf">&#9670;&nbsp;</a></span>IsAbstract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsAbstract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>primType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the prim type <code>primType</code> is an abstract schema type and, unlike a concrete type, is not instantiable in scene description. </p>

</div>
</div>
<a id="a583a741dcad67bd1bfb3fc952c3bc15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583a741dcad67bd1bfb3fc952c3bc15c">&#9670;&nbsp;</a></span>IsAllowedAPISchemaInstanceName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsAllowedAPISchemaInstanceName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>apiSchemaName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>instanceName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given <code>instanceName</code> is an allowed instance name for the multiple apply API schema named <code>apiSchemaName</code>. </p>
<p>Any instance name that matches the name of a property provided by the API schema is disallowed and will return false. If the schema type has plugin metadata that specifies allowed instance names, then only those specified names are allowed for the schema type. If the instance name is empty or the API is not a multiple apply schema, this will return false. </p>

</div>
</div>
<a id="a0201e4ae1ae41895baa1ead0b23ee937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0201e4ae1ae41895baa1ead0b23ee937">&#9670;&nbsp;</a></span>IsAllowedSchemaFamily()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsAllowedSchemaFamily </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>schemaFamily</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given <code>schemaFamily</code> is an allowed schema family name. </p>
<p>A schema family is allowed if it's a <a class="el" href="class_sdf_path.html#a1499271167c20dd276d87693b18f5226">valid identifier</a> and does not itself contain a <a class="el" href="class_usd_schema_registry.html#a68fbde1db9710dfe4859734c53e9e061">version suffix</a>. </p>

</div>
</div>
<a id="a8a7a09856a130b28651835f63acd9263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7a09856a130b28651835f63acd9263">&#9670;&nbsp;</a></span>IsAllowedSchemaIdentifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsAllowedSchemaIdentifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>schemaIdentifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given <code>schemaIdentifier</code> is an allowed schema identifier. </p>
<p>A schema identifier is allowed if it can be</p>
<p><a class="el" href="class_usd_schema_registry.html#a68fbde1db9710dfe4859734c53e9e061">parsed</a> into a <a class="el" href="class_usd_schema_registry.html#a0201e4ae1ae41895baa1ead0b23ee937">allowed schema family</a> and schema version and it is the identifier that would be <a class="el" href="class_usd_schema_registry.html#a4430b1590f52919590df0890cea341b3">created</a> from that parsed family and version. </p>

</div>
</div>
<a id="a64a2f2592fd8a13dde1ed9ced332b6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a2f2592fd8a13dde1ed9ced332b6c5">&#9670;&nbsp;</a></span>IsAppliedAPISchema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsAppliedAPISchema </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td>
          <td class="paramname"><em>apiSchemaType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>apiSchemaType</code> is an applied API schema type. </p>

</div>
</div>
<a id="a52d021d2f1f89bd8eaebd7a6c73790b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d021d2f1f89bd8eaebd7a6c73790b2">&#9670;&nbsp;</a></span>IsAppliedAPISchema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsAppliedAPISchema </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>apiSchemaType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>apiSchemaType</code> is an applied API schema type. </p>

</div>
</div>
<a id="a4bbccd46aeee7c8968355ea406636ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbccd46aeee7c8968355ea406636ab7">&#9670;&nbsp;</a></span>IsConcrete() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsConcrete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td>
          <td class="paramname"><em>primType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the prim type <code>primType</code> is instantiable in scene description. </p>

</div>
</div>
<a id="ac7b8d76ddbc860237f845b32ce1717be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b8d76ddbc860237f845b32ce1717be">&#9670;&nbsp;</a></span>IsConcrete() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsConcrete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>primType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the prim type <code>primType</code> is instantiable in scene description. </p>

</div>
</div>
<a id="aa422270c1807db9cf40912dce3f54f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa422270c1807db9cf40912dce3f54f41">&#9670;&nbsp;</a></span>IsDisallowedField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsDisallowedField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the field <code>fieldName</code> cannot have fallback values specified in schemas. </p>
<p>Fields are generally disallowed because their fallback values aren't used. For instance, fallback values for composition arcs aren't used during composition, so allowing them to be set in schemas would be misleading. </p>

</div>
</div>
<a id="a50e89b995455f3eb97ad99154e906c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e89b995455f3eb97ad99154e906c34">&#9670;&nbsp;</a></span>IsMultipleApplyAPISchema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsMultipleApplyAPISchema </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td>
          <td class="paramname"><em>apiSchemaType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>apiSchemaType</code> is a multiple-apply API schema type. </p>

</div>
</div>
<a id="aa14af24f2a8254087da50e639754bdc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14af24f2a8254087da50e639754bdc9">&#9670;&nbsp;</a></span>IsMultipleApplyAPISchema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsMultipleApplyAPISchema </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>apiSchemaType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>apiSchemaType</code> is a multiple-apply API schema type. </p>

</div>
</div>
<a id="ac302f2e9e3c7cf75f3588d8c626a6e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac302f2e9e3c7cf75f3588d8c626a6e4f">&#9670;&nbsp;</a></span>IsMultipleApplyNameTemplate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsMultipleApplyNameTemplate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nameTemplate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>nameTemplate</code> is a multiple apply schema name template. </p>
<p>The given <code>nameTemplate</code> is a name template if and only if it contains the instance name place holder "__INSTANCE_NAME__" as an exact match as one of the tokenized components of the name tokenized by the namespace delimiter. </p>

</div>
</div>
<a id="a7bbaefbdd3e0bea0b098c777cd656eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbaefbdd3e0bea0b098c777cd656eb8">&#9670;&nbsp;</a></span>IsTyped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API bool IsTyped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td>
          <td class="paramname"><em>primType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the prim type <code>primType</code> inherits from <a class="el" href="class_usd_typed.html">UsdTyped</a>. </p>

</div>
</div>
<a id="a2d7ecf1f83da9b116abc23e28cef727c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7ecf1f83da9b116abc23e28cef727c">&#9670;&nbsp;</a></span>MakeMultipleApplyNameInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API <a class="el" href="class_tf_token.html">TfToken</a> MakeMultipleApplyNameInstance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nameTemplate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instanceName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an instance of a multiple apply schema name from the given <code>nameTemplate</code> for the given <code>instanceName</code>. </p>
<p>The returned name is created by replacing the instance name placeholder "__INSTANCE_NAME__" in the name template with the given instance name. If the instance name placeholder is not found in <code>nameTemplate</code>, then the name template is not multiple apply name template and is returned as is.</p>
<p>Note that the instance name placeholder must be found as an exact full word match with one of the tokenized components of the name template, when tokenized by the namespace delimiter, in order for it to be treated as a placeholder and substituted with the instance name. </p>

</div>
</div>
<a id="ada7847bceb3ebd3efabe3120c27047ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7847bceb3ebd3efabe3120c27047ed">&#9670;&nbsp;</a></span>MakeMultipleApplyNameTemplate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API <a class="el" href="class_tf_token.html">TfToken</a> MakeMultipleApplyNameTemplate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>namespacePrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baseName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a name template that can represent a property or API schema that belongs to a multiple apply schema and will therefore have multiple instances with different names. </p>
<p>The name template is created by joining the <code>namespacePrefix</code>, the instance name placeholder "__INSTANCE_NAME__", and the <code>baseName</code> using the namespace delimiter. Therefore the returned name template will be of one of the following forms depending on whether either of the inputs is empty:</p><ol type="1">
<li>namespacePrefix:<b>INSTANCE_NAME</b>:baseName</li>
<li>namespacePrefix:<b>INSTANCE_NAME</b></li>
<li><b>INSTANCE_NAME</b>:baseName</li>
<li><b>INSTANCE_NAME</b></li>
</ol>
<p>Name templates can be passed to MakeMultipleApplyNameInstance along with an instance name to create the name for a particular instance. </p>

</div>
</div>
<a id="a4430b1590f52919590df0890cea341b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4430b1590f52919590df0890cea341b3">&#9670;&nbsp;</a></span>MakeSchemaIdentifierForFamilyAndVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API <a class="el" href="class_tf_token.html">TfToken</a> MakeSchemaIdentifierForFamilyAndVersion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>schemaFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UsdSchemaVersion&#160;</td>
          <td class="paramname"><em>schemaVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the schema identifier that would be used to define a schema of the given <code>schemaFamily</code> with the given <code>schemaVersion</code>. </p>
<p>If the provided schema version is zero, the returned identifier will be the schema family itself. For all other versions, the returned identifier will be the family followed by an underscore and the version number.</p>
<p>If <code>schemaFamily</code> is not an <a class="el" href="class_usd_schema_registry.html#a0201e4ae1ae41895baa1ead0b23ee937">allowed schema family</a>, this function will append the appropriate version suffix, but the returned identifier will not be an <a class="el" href="class_usd_schema_registry.html#a8a7a09856a130b28651835f63acd9263">allowed schema identifier</a>. </p>

</div>
</div>
<a id="a68fbde1db9710dfe4859734c53e9e061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fbde1db9710dfe4859734c53e9e061">&#9670;&nbsp;</a></span>ParseSchemaFamilyAndVersionFromIdentifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USD_API std::pair&lt;<a class="el" href="class_tf_token.html">TfToken</a>, UsdSchemaVersion&gt; ParseSchemaFamilyAndVersionFromIdentifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>schemaIdentifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses and returns the schema family and version values from the given <code>schemaIdentifier</code>. </p>
<p>A schema identifier's version is indicated by a suffix consisting of an underscore followed by a positive integer which is its version. The schema family is the string before this suffix. If the identifier does not have a suffix matching this pattern, then the schema version is zero and the schema family is the identifier itself.</p>
<p>For example: Identifier "FooAPI_1" returns ("FooAPI", 1) Identifier "FooAPI" returns ("FooAPI", 0)</p>
<p>Note that this function only parses what the schema family and version would be for the given schema identifier and does not require that <code>schemaIdentifier</code> be a registered schema itself or even an <a class="el" href="class_usd_schema_registry.html#a8a7a09856a130b28651835f63acd9263">allowed schema identifier</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pxr/usd/usd/<a class="el" href="schema_registry_8h_source.html">schemaRegistry.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_usd_schema_registry.html">UsdSchemaRegistry</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:10 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>