<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="class_sdf_predicate_expression" kind="class" language="C++" prot="public">
    <compoundname>SdfPredicateExpression</compoundname>
    <includes refid="predicate_expression_8h" local="no">predicateExpression.h</includes>
    <innerclass refid="struct_sdf_predicate_expression_1_1_fn_arg" prot="public">SdfPredicateExpression::FnArg</innerclass>
    <innerclass refid="struct_sdf_predicate_expression_1_1_fn_call" prot="public">SdfPredicateExpression::FnCall</innerclass>
      <sectiondef kind="public-type">
      <memberdef kind="enum" id="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45ab" prot="public" static="no" strong="no">
        <type></type>
        <name>Op</name>
        <enumvalue id="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45aba59b9abc46faffa225d20abc5e5252417" prot="public">
          <name>Call</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45abaa60891460e284e663f5060208f72870b" prot="public">
          <name>Not</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45aba9f241eb40e955079e1f45d865e0d1e50" prot="public">
          <name>ImpliedAnd</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45aba60b042c2c7da21af2ed42f8cc27e7ff8" prot="public">
          <name>And</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45aba5d66935f41f1e80990e8bf3349074fe1" prot="public">
          <name>Or</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumerant describing a subexpression operation. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="179" column="1" bodyfile="pxr/usd/sdf/predicateExpression.h" bodystart="179" bodyend="179"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_sdf_predicate_expression_1a0bee7d43f1a78b949189304ff5d859e7" prot="private" static="no" mutable="no">
        <type>std::vector&lt; <ref refid="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45ab" kindref="member">Op</ref> &gt;</type>
        <definition>std::vector&lt;Op&gt; _ops</definition>
        <argsstring></argsstring>
        <name>_ops</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="300" column="1" bodyfile="pxr/usd/sdf/predicateExpression.h" bodystart="300" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_sdf_predicate_expression_1a58d8f0f87a6482351f2c1d8300acddf0" prot="private" static="no" mutable="no">
        <type>std::vector&lt; <ref refid="struct_sdf_predicate_expression_1_1_fn_call" kindref="compound">FnCall</ref> &gt;</type>
        <definition>std::vector&lt;FnCall&gt; _calls</definition>
        <argsstring></argsstring>
        <name>_calls</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="304" column="1" bodyfile="pxr/usd/sdf/predicateExpression.h" bodystart="304" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_sdf_predicate_expression_1a6138c8fafa2c2246ec28e08d9b4905ae" prot="private" static="no" mutable="no">
        <type>std::string</type>
        <definition>std::string _parseError</definition>
        <argsstring></argsstring>
        <name>_parseError</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="308" column="1" bodyfile="pxr/usd/sdf/predicateExpression.h" bodystart="308" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="class_sdf_predicate_expression_1a00cf42d2c7ad480558ccc421ac51a451" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>SdfPredicateExpression</definition>
        <argsstring>()=default</argsstring>
        <name>SdfPredicateExpression</name>
        <briefdescription>
<para>Construct the empty expression whose bool-operator returns false. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="155" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_predicate_expression_1ac7962b67351fea52db46989b5456558d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>SdfPredicateExpression</definition>
        <argsstring>(SdfPredicateExpression const &amp;)=default</argsstring>
        <name>SdfPredicateExpression</name>
        <param>
          <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> const &amp;</type>
        </param>
        <briefdescription>
<para>Copy construct from another expression. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="158" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_predicate_expression_1a76f814ee8352c647393880eea6c04207" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>SdfPredicateExpression</definition>
        <argsstring>(SdfPredicateExpression &amp;&amp;)=default</argsstring>
        <name>SdfPredicateExpression</name>
        <param>
          <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> &amp;&amp;</type>
        </param>
        <briefdescription>
<para>Move construct from another expression. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="161" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_predicate_expression_1afe4a71ff954f56dd027cbf5d386e210e" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type>SDF_API</type>
        <definition>SDF_API SdfPredicateExpression</definition>
        <argsstring>(std::string const &amp;expr, std::string const &amp;context={})</argsstring>
        <name>SdfPredicateExpression</name>
        <param>
          <type>std::string const &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>context</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Construct an expression by parsing <computeroutput>expr</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>If provided, <computeroutput>context</computeroutput> appears in a parse error, if one is generated. See <ref refid="class_sdf_predicate_expression_1a230b1b2d7246855d5d02d1c6b5a925ee" kindref="member">GetParseError()</ref>. See the class documentation for details on expression syntax. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="167" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_predicate_expression_1a854a3c69600d8f30d5ed4a1e738e87af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> &amp;</type>
        <definition>SdfPredicateExpression&amp; operator=</definition>
        <argsstring>(SdfPredicateExpression const &amp;)=default</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> const &amp;</type>
        </param>
        <briefdescription>
<para>Copy assign from another expression. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="172" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_predicate_expression_1aa9bcd0d7b3a057711f298ffa7e13d34f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> &amp;</type>
        <definition>SdfPredicateExpression&amp; operator=</definition>
        <argsstring>(SdfPredicateExpression &amp;&amp;)=default</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> &amp;&amp;</type>
        </param>
        <briefdescription>
<para>Move assign from another expression. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="176" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_predicate_expression_1a5ddbd0abb5a2d4688671d1e5f3e091bb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API void</type>
        <definition>SDF_API void Walk</definition>
        <argsstring>(TfFunctionRef&lt; void(Op, int)&gt; logic, TfFunctionRef&lt; void(FnCall const &amp;)&gt; call) const</argsstring>
        <name>Walk</name>
        <param>
          <type><ref refid="class_tf_function_ref" kindref="compound">TfFunctionRef</ref>&lt; void(<ref refid="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45ab" kindref="member">Op</ref>, int)&gt;</type>
          <declname>logic</declname>
        </param>
        <param>
          <type><ref refid="class_tf_function_ref" kindref="compound">TfFunctionRef</ref>&lt; void(<ref refid="struct_sdf_predicate_expression_1_1_fn_call" kindref="compound">FnCall</ref> const &amp;)&gt;</type>
          <declname>call</declname>
        </param>
        <briefdescription>
<para>Walk this expression&apos;s syntax tree in depth-first order, calling <computeroutput>call</computeroutput> with the current function call when a function call is encountered, and calling <computeroutput>logic</computeroutput> multiple times for each logical operation encountered. </para>
        </briefdescription>
        <detaileddescription>
<para>When calling <computeroutput>logic</computeroutput>, the logical operation is passed as the <computeroutput>Op</computeroutput> parameter, and an integer indicating &quot;where&quot; we are in the set of operands is passed as the int parameter. For a &apos;not&apos;, call <computeroutput>logic</computeroutput>(Op=Not, int=0) to start, then after the subexpression that the &apos;not&apos; applies to is walked, call <computeroutput>logic</computeroutput>(Op=Not, int=1). For the binary operators like &apos;and&apos; and &apos;or&apos;, call <computeroutput>logic(Op, 0)</computeroutput> before the first argument, then <computeroutput>logic(Op, 1)</computeroutput> after the first subexpression, then <computeroutput>logic(Op, 2)</computeroutput> after the second subexpression. For a concrete example, consider the following expression: <verbatim>(foo or bar) and not baz
</verbatim></para>
<para>The sequence of calls from <ref refid="class_sdf_predicate_expression_1a5ddbd0abb5a2d4688671d1e5f3e091bb" kindref="member">Walk()</ref> will be: <verbatim>logic(And, 0)
logic(Or, 0)
call(&quot;foo&quot;)
logic(Or, 1)
call(&quot;bar&quot;)
logic(Or, 2)
logic(And, 1)
logic(Not, 0)
call(&quot;baz&quot;)
logic(Not, 1)
logic(And, 2)
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="229" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_predicate_expression_1aeb61b3ba6cc1977f089a2018bc1e6def" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API void</type>
        <definition>SDF_API void WalkWithOpStack</definition>
        <argsstring>(TfFunctionRef&lt; void(std::vector&lt; std::pair&lt; Op, int &gt;&gt; const &amp;)&gt; logic, TfFunctionRef&lt; void(FnCall const &amp;)&gt; call) const</argsstring>
        <name>WalkWithOpStack</name>
        <briefdescription>
<para>Equivalent to <ref refid="class_sdf_predicate_expression_1a5ddbd0abb5a2d4688671d1e5f3e091bb" kindref="member">Walk()</ref>, except that the <computeroutput>logic</computeroutput> function is called with a const reference to the current Op stack instead of just the top of it. </para>
        </briefdescription>
        <detaileddescription>
<para>The top of the Op stack is the vector&apos;s back. This is useful in case the processing code needs to understand the context in which an Op appears. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="238" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_predicate_expression_1a454ec81c69a61bdf6b51db0a10d51b80" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API std::string</type>
        <definition>SDF_API std::string GetText</definition>
        <argsstring>() const</argsstring>
        <name>GetText</name>
        <briefdescription>
<para>Return a text representation of this expression that parses to the same expression. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="245" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_predicate_expression_1a8e12342fc420701fbffd97025421575a" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool IsEmpty</definition>
        <argsstring>() const</argsstring>
        <name>IsEmpty</name>
        <briefdescription>
<para>Return true if this is the empty expression; i.e. </para>
        </briefdescription>
        <detaileddescription>
<para>default-constructed or constructed from a string with invalid syntax. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="249" column="1" bodyfile="pxr/usd/sdf/predicateExpression.h" bodystart="249" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_predicate_expression_1a67b76affb3b5d35fa419ac234144038b" prot="public" static="no" const="yes" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>operator bool</definition>
        <argsstring>() const</argsstring>
        <name>operator bool</name>
        <briefdescription>
<para>Return true if this expression contains any operations, false otherwise. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="254" column="1" bodyfile="pxr/usd/sdf/predicateExpression.h" bodystart="254" bodyend="256"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_predicate_expression_1a230b1b2d7246855d5d02d1c6b5a925ee" prot="public" static="no" const="yes" explicit="no" inline="yes" refqual="lvalue" virt="non-virtual">
        <type>std::string const  &amp;</type>
        <definition>std::string const&amp; GetParseError</definition>
        <argsstring>() const &amp;</argsstring>
        <name>GetParseError</name>
        <briefdescription>
<para>Return parsing errors as a string if this function was constructed from a string and parse errors were encountered. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="260" column="1" bodyfile="pxr/usd/sdf/predicateExpression.h" bodystart="260" bodyend="262"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_predicate_expression_1a3d5dccd0548d93734790b7f60b36afce" prot="public" static="no" const="yes" explicit="no" inline="yes" refqual="rvalue" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string GetParseError</definition>
        <argsstring>() const &amp;&amp;</argsstring>
        <name>GetParseError</name>
        <briefdescription>
<para>Return parsing errors as a string if this function was constructed from a string and parse errors were encountered. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="266" column="1" bodyfile="pxr/usd/sdf/predicateExpression.h" bodystart="266" bodyend="268"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="class_sdf_predicate_expression_1a7055191a022f285a076bb5b7c31f3bef" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API <ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref></type>
        <definition>static SDF_API SdfPredicateExpression MakeNot</definition>
        <argsstring>(SdfPredicateExpression &amp;&amp;right)</argsstring>
        <name>MakeNot</name>
        <param>
          <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> &amp;&amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
<para>Produce a new expression by prepending the &apos;not&apos; operator onto <computeroutput>right</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="184" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_predicate_expression_1a6b1b067ecc4aec8a436d4c39e2e1460e" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API <ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref></type>
        <definition>static SDF_API SdfPredicateExpression MakeOp</definition>
        <argsstring>(Op op, SdfPredicateExpression &amp;&amp;left, SdfPredicateExpression &amp;&amp;right)</argsstring>
        <name>MakeOp</name>
        <param>
          <type><ref refid="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45ab" kindref="member">Op</ref></type>
          <declname>op</declname>
        </param>
        <param>
          <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> &amp;&amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> &amp;&amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
<para>Produce a new expression by combining <computeroutput>left</computeroutput> and <computeroutput>right</computeroutput> with the operator <computeroutput>op</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The <computeroutput>op</computeroutput> must be one of ImpliedAnd, And, or Or. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="190" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_predicate_expression_1ab61972aa01b493d3130d2570273389b9" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API <ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref></type>
        <definition>static SDF_API SdfPredicateExpression MakeCall</definition>
        <argsstring>(FnCall &amp;&amp;call)</argsstring>
        <name>MakeCall</name>
        <param>
          <type><ref refid="struct_sdf_predicate_expression_1_1_fn_call" kindref="compound">FnCall</ref> &amp;&amp;</type>
          <declname>call</declname>
        </param>
        <briefdescription>
<para>Produce a new expression containing just a the function call <computeroutput>call</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="197" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="class_sdf_predicate_expression_1a1b50f97c5715bb4783c8a453a6a998f7" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class HashState</type>
          </param>
        </templateparamlist>
        <type>friend void</type>
        <definition>void TfHashAppend</definition>
        <argsstring>(HashState &amp;h, SdfPredicateExpression const &amp;expr)</argsstring>
        <name>TfHashAppend</name>
        <param>
          <type>HashState &amp;</type>
          <declname>h</declname>
        </param>
        <param>
          <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="272" column="1" bodyfile="pxr/usd/sdf/predicateExpression.h" bodystart="272" bodyend="274"/>
      </memberdef>
      <memberdef kind="friend" id="class_sdf_predicate_expression_1a9f04c7e3740adacecfb39e3884755af1" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>friend bool</type>
        <definition>bool operator==</definition>
        <argsstring>(SdfPredicateExpression const &amp;l, SdfPredicateExpression const &amp;r)</argsstring>
        <name>operator==</name>
        <param>
          <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> const &amp;</type>
          <declname>l</declname>
        </param>
        <param>
          <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> const &amp;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="277" column="1" bodyfile="pxr/usd/sdf/predicateExpression.h" bodystart="277" bodyend="281"/>
      </memberdef>
      <memberdef kind="friend" id="class_sdf_predicate_expression_1aa33a3031df0b750b86c4a40539221d67" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>friend bool</type>
        <definition>bool operator!=</definition>
        <argsstring>(SdfPredicateExpression const &amp;l, SdfPredicateExpression const &amp;r)</argsstring>
        <name>operator!=</name>
        <param>
          <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> const &amp;</type>
          <declname>l</declname>
        </param>
        <param>
          <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> const &amp;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="284" column="1" bodyfile="pxr/usd/sdf/predicateExpression.h" bodystart="284" bodyend="287"/>
      </memberdef>
      <memberdef kind="friend" id="class_sdf_predicate_expression_1ae9fc1f1aba4aab1a221f521efe00a082" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API friend std::ostream &amp;</type>
        <definition>SDF_API friend std::ostream&amp; operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;, SdfPredicateExpression const &amp;)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
        </param>
        <param>
          <type><ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> const &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/predicateExpression.h" line="290" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Represents a logical expression syntax tree consisting of predicate function calls joined by the logical operators &apos;and&apos;, &apos;or&apos;, &apos;not&apos;, and an implied-and operator that represents two subexpressions joined by only whitespace. </para>
    </briefdescription>
    <detaileddescription>
<para>An <ref refid="class_sdf_predicate_expression" kindref="compound">SdfPredicateExpression</ref> can be constructed with a string, which will parse an expression. The syntax for an expression is as follows:</para>
<para>The fundamental building blocks are calls to predicate functions. There are three syntaxes for function calls.</para>
<para><itemizedlist>
<listitem><para>Bare call: just a function name: <computeroutput>isDefined</computeroutput> </para>
</listitem>
<listitem><para>Colon call: name, colon, positional arguments: <computeroutput>isa:mammal,bird</computeroutput> </para>
</listitem>
<listitem><para>Paren call: name and parenthesized positional and keyword args: <computeroutput>isClose(1.23, tolerance=0.01)</computeroutput></para>
</listitem>
</itemizedlist>
Colon call arguments are all positional and must be separated by commas with no spaces between arguments. In paren calls, positional arguments must precede keyword arguments, and whitespace is allowed between arguments.</para>
<para>The string parser supports argument values of the following types: double-quoted &quot;strings&quot;, unquoted strings, integers, floating-point numbers, and boolean values &apos;true&apos; and &apos;false&apos;.</para>
<para>The unary operator &apos;not&apos; may appear preceding a function call, or a subexpresion enclosed in parentheses. The binary operators &apos;and&apos; and &apos;or&apos; may appear between subexpressions. If subexpressions appear adjacent to each other (other than possible whitespace), this is considered an implied &apos;and&apos; operator.</para>
<para>Operator precedence in order from highest to lowest is: &apos;not&apos;, &lt;implied-and&gt;, &apos;and&apos;, &apos;or&apos;.</para>
<para>Here are some examples of valid predicate expression syntax:</para>
<para><itemizedlist>
<listitem><para><computeroutput>foo</computeroutput> (call &quot;foo&quot; with no arguments) </para>
</listitem>
<listitem><para><computeroutput>foo bar</computeroutput> (implicit &apos;and&apos; of &quot;foo&quot; and &quot;bar&quot;) </para>
</listitem>
<listitem><para><computeroutput>foo not bar</computeroutput> (implicit &apos;and&apos; of &quot;foo&quot; and &quot;not bar&quot;) </para>
</listitem>
<listitem><para><computeroutput>color:red (shiny or matte)</computeroutput> </para>
</listitem>
<listitem><para><computeroutput>animal or mineral or vegetable</computeroutput> </para>
</listitem>
<listitem><para><computeroutput>(mammal or bird) and (tame or small)</computeroutput> </para>
</listitem>
<listitem><para><computeroutput>isClose(100, tolerance=3.0) or negative</computeroutput> </para>
</listitem>
</itemizedlist>
</para>
    </detaileddescription>
    <location file="pxr/usd/sdf/predicateExpression.h" line="85" column="1" bodyfile="pxr/usd/sdf/predicateExpression.h" bodystart="84" bodyend="309"/>
    <listofallmembers>
      <member refid="class_sdf_predicate_expression_1a58d8f0f87a6482351f2c1d8300acddf0" prot="private" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>_calls</name></member>
      <member refid="class_sdf_predicate_expression_1a0bee7d43f1a78b949189304ff5d859e7" prot="private" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>_ops</name></member>
      <member refid="class_sdf_predicate_expression_1a6138c8fafa2c2246ec28e08d9b4905ae" prot="private" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>_parseError</name></member>
      <member refid="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45aba60b042c2c7da21af2ed42f8cc27e7ff8" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>And</name></member>
      <member refid="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45aba59b9abc46faffa225d20abc5e5252417" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>Call</name></member>
      <member refid="class_sdf_predicate_expression_1a230b1b2d7246855d5d02d1c6b5a925ee" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>GetParseError</name></member>
      <member refid="class_sdf_predicate_expression_1a3d5dccd0548d93734790b7f60b36afce" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>GetParseError</name></member>
      <member refid="class_sdf_predicate_expression_1a454ec81c69a61bdf6b51db0a10d51b80" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>GetText</name></member>
      <member refid="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45aba9f241eb40e955079e1f45d865e0d1e50" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>ImpliedAnd</name></member>
      <member refid="class_sdf_predicate_expression_1a8e12342fc420701fbffd97025421575a" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>IsEmpty</name></member>
      <member refid="class_sdf_predicate_expression_1ab61972aa01b493d3130d2570273389b9" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>MakeCall</name></member>
      <member refid="class_sdf_predicate_expression_1a7055191a022f285a076bb5b7c31f3bef" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>MakeNot</name></member>
      <member refid="class_sdf_predicate_expression_1a6b1b067ecc4aec8a436d4c39e2e1460e" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>MakeOp</name></member>
      <member refid="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45abaa60891460e284e663f5060208f72870b" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>Not</name></member>
      <member refid="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45ab" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>Op</name></member>
      <member refid="class_sdf_predicate_expression_1a67b76affb3b5d35fa419ac234144038b" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>operator bool</name></member>
      <member refid="class_sdf_predicate_expression_1aa33a3031df0b750b86c4a40539221d67" prot="private" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>operator!=</name></member>
      <member refid="class_sdf_predicate_expression_1ae9fc1f1aba4aab1a221f521efe00a082" prot="private" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>operator&lt;&lt;</name></member>
      <member refid="class_sdf_predicate_expression_1a854a3c69600d8f30d5ed4a1e738e87af" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>operator=</name></member>
      <member refid="class_sdf_predicate_expression_1aa9bcd0d7b3a057711f298ffa7e13d34f" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>operator=</name></member>
      <member refid="class_sdf_predicate_expression_1a9f04c7e3740adacecfb39e3884755af1" prot="private" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>operator==</name></member>
      <member refid="class_sdf_predicate_expression_1a588e6b56097e045c733b60d25c4d45aba5d66935f41f1e80990e8bf3349074fe1" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>Or</name></member>
      <member refid="class_sdf_predicate_expression_1a00cf42d2c7ad480558ccc421ac51a451" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>SdfPredicateExpression</name></member>
      <member refid="class_sdf_predicate_expression_1ac7962b67351fea52db46989b5456558d" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>SdfPredicateExpression</name></member>
      <member refid="class_sdf_predicate_expression_1a76f814ee8352c647393880eea6c04207" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>SdfPredicateExpression</name></member>
      <member refid="class_sdf_predicate_expression_1afe4a71ff954f56dd027cbf5d386e210e" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>SdfPredicateExpression</name></member>
      <member refid="class_sdf_predicate_expression_1a1b50f97c5715bb4783c8a453a6a998f7" prot="private" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>TfHashAppend</name></member>
      <member refid="class_sdf_predicate_expression_1a5ddbd0abb5a2d4688671d1e5f3e091bb" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>Walk</name></member>
      <member refid="class_sdf_predicate_expression_1aeb61b3ba6cc1977f089a2018bc1e6def" prot="public" virt="non-virtual"><scope>SdfPredicateExpression</scope><name>WalkWithOpStack</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
