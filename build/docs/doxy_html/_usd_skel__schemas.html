<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: Schemas In-Depth</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_usd_skel__schemas.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Schemas In-Depth </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Data in UsdSkel is stored in modular, reusable, instanceable parts, adhering to the following design principles:</p>
<ul>
<li><em>Skeleton</em> "rigs" can be defined and published, to be referenced in wherever needed. Encapsulating skeletons this way is not necessarily a requirement for the interchange of skeletal data, but facilitates scalability and maintainability when deploying directly-rendered, skinned crowds at scale in VFX pipelines.</li>
<li><em>Animations</em> can be published individually and referenced back into scenes. This not only allows re-use, but also enables sequencing of animations as <a href="http://openusd.org/docs/USD-Glossary.html#USDGlossary-ValueClips">Value Clips</a>.</li>
<li>Separating the binding of a <em>skeleton</em> and its <em>animation</em> as bound to geometry allows assets to be published with a bound <em>skeleton</em>, inside of a <a class="el" href="_usd__page__scenegraph_instancing.html#Usd_ScenegraphInstancing_Overview">instance primitive</a>, which can still be driven by a separate animation.</li>
<li><p class="startli">All posing and animation data is vectorized. This encoding is concise and ideal for scalability and speed of data consumption in the USD APIs.</p>
<p class="startli">Although vectorization may seem unnecessary to the client attempting to interchange individual models only, it is an important consideration for achieving a scalable encoding of crowds in VFX pipelines.</p>
</li>
</ul>
<p>Following these principles, UsdSkel defines skeletal data using the following schema types:</p>
<ul>
<li><p class="startli"><a class="el" href="_usd_skel__schemas.html#UsdSkel_SkelRoot">Skel Root</a>:</p>
<p class="startli">Identifies where in a scene graph skeletal processing takes place, in addition to providing bounds for skinned models.</p>
</li>
<li><p class="startli"><a class="el" href="_usd_skel__schemas.html#UsdSkel_Skeleton">Skeleton</a>:</p>
<p class="startli">Defines the <a class="el" href="_usd_skel__intro.html#UsdSkel_Term_SkeletonTopology">topology</a> of the skeleton, as well as storing a <em>bind pose</em>. Skeletons are animated by attaching a SkelAnimation.</p>
</li>
<li><p class="startli"><a class="el" href="_usd_skel__schemas.html#UsdSkel_SkelAnimation">Skel Animation</a>:</p>
<p class="startli">Stores joint and blend shape animations, which may be applied to any <em>Skeleton</em>.</p>
</li>
<li><p class="startli"><a class="el" href="_usd_skel__schemas.html#UsdSkel_BlendShape">Blend Shape</a>:</p>
<p class="startli">Stores an individual blend shape, and optional in-betweens, for a geometric primitive.</p>
</li>
<li><p class="startli"><a class="el" href="_usd_skel__schemas.html#UsdSkel_BindingAPI">Binding API</a>:</p>
<p class="startli">API schema used to describe which skeletons affect which primitives, as well as basic skinning properties like joint influences. The BindingAPI is also used to attach a <em>SkelAnimation</em> to a <em>Skeleton</em>.</p>
</li>
</ul>
<h1><a class="anchor" id="UsdSkel_JointOrder"></a>
Joint Order</h1>
<p>Joint data in UsdSkel is stored in vectorized arrays. Throughout UsdSkel, these arrays may be ordered in slightly different ways. For instance, a <em>skeleton</em> has its own explicit joint ordering, but an <em>animation</em> may have another order, representing either a different ordering of joints, or a sparse subset of joints.</p>
<p>These data orderings are referred to as a primitive's <b>joint order</b>, and are defined using token arrays.</p>
<p>The tokens in a joint array are given as Sdf-style paths, where parent-child relationships in the given paths establish a <a class="el" href="_usd_skel__schemas.html#UsdSkel_JointHierarchy">joint hierarchy.</a> Note that these paths do not need to refer to actual primitives in the scene. They are used as a way to name and order joints in vectorized data. For example:</p>
<div class="fragment"><div class="line">def SkelAnimation <span class="stringliteral">&quot;Anim&quot;</span> {</div><div class="line">    uniform token[] = [<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;A/B&quot;</span>]</div><div class="line">}</div><div class="line">def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {</div><div class="line">    uniform token[] = [<span class="stringliteral">&quot;A/B&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>]</div><div class="line">}</div></div><!-- fragment --><p>Note that in both example primitives above, the given paths do not reference any real primitives. Also note that each primitive has its own joint ordering, and that those orders need not be identical.</p>
<p>The purpose of encoding orderings in this manner is to allow for the creation of <b>self-contained</b> assets. For example, it is possible to construct a <a class="el" href="_usd_skel__schemas.html#UsdSkel_SkelAnimation">skel animation</a> primitive independently from any skeleton definitions, which will remain valid even if a <em>skeleton</em> that the animation is mapped to has a slightly different ordering.</p>
<p>Part of the motivation for this is to allow for more robust, composed assets. When orderings are required to remain fixed, maintenance difficulties may arise. For example, if animation assets are produced through a process independent from the process that produces a shared definition of a <em>skeleton asset</em>, data can easily get out of sync.</p>
<p>On top of allowing for more robust assets, these flexible joint orderings allow for additional features like sparse authoring of animation data.</p>
<p>Data can be remapped from one joint ordering to another using a UsdSkelAnimMapper, and is done so by matching joint names.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_skel_anim_query.html#aab38abf001974901d97c0d9e07006262" title="Returns an array of tokens describing the ordering of joints in the animation.">UsdSkelAnimQuery::GetJointOrder</a>, <a class="el" href="class_usd_skel_skeleton_query.html#aab38abf001974901d97c0d9e07006262" title="Returns an array of joint paths, given as tokens, describing the order and parent-child relationships...">UsdSkelSkeletonQuery::GetJointOrder</a>, <a class="el" href="class_usd_skel_skinning_query.html#aea958370dc06691a3c1740e87bfde910" title="Get the custom joint order for this skinning site, if any.">UsdSkelSkinningQuery::GetJointOrder</a></dd></dl>
<h1><a class="anchor" id="UsdSkel_SkelRoot"></a>
Skeleton Root Schema</h1>
<p>The <a class="el" href="class_usd_skel_root.html" title="Boundable prim type used to identify a scope beneath which skeletally-posed primitives are defined.">UsdSkelRoot</a> schema is used to <b>encapsulate</b> primitives with skeletal skinning behaviors, and is required when authoring skeletal data.</p>
<p>A SkelRoot is a boundable primitive, and provides a place to encode the extents of all skinned primitives beneath it. It is neither expected nor required the descendent primitives that are being skinned will encode their own skinned extents. These extents are made available to renders to enable operations like out-of-camera culling, without requiring that skinned geometry be computed first.</p>
<p>A SkelRoot additionally gives DCC apps a way of identifying which parts of a scene graph require skeletal processing, so that they can take different code paths, as is often required to consume skeletal data.</p>
<p>It is possible to override a primitive's composed type in USD, in order to either enable or disable skeletal processing. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// Enable skeletal processing by setting the type to UsdSkelRoot.</span></div><div class="line">UsdSkel.Root.Define(prim.GetStage(), prim.GetPath());</div><div class="line"><span class="comment">// Disable skeletal processing by changing the type to a normal transform.</span></div><div class="line">UsdGeomTransform.Define(prim.GetStage(), prim.GetPath());</div></div><!-- fragment --><h1><a class="anchor" id="UsdSkel_Skeleton"></a>
Skeleton Schema</h1>
<p>The <a class="el" href="class_usd_skel_skeleton.html" title="Describes a skeleton.">UsdSkelSkeleton</a> schema describes a skeleton. This schema is responsible both for establishing the <em>topology</em> of a skeleton, as well as for identifying a <em>bind pose</em>.</p>
<p>A skeleton itself provides only structure. Meshes are posed with a skeleton by way of <a class="el" href="_usd_skel__schemas.html#UsdSkel_BindingAPI">skeletal bindings</a> inside of the "geometry hierarchy" of primitives.</p>
<h2><a class="anchor" id="UsdSkel_JointHierarchy"></a>
Skeleton Schema: Joint Hierarchy</h2>
<p>The joints of a Skeleton are defined by the <em>joints</em> attribute. This attribute encodes joint paths &ndash; each of which is a valid <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> strings. The parent-child relationships that these paths describe are used to define the parent-child relationships of the joints themselves.</p>
<p>For example:</p>
<div class="fragment"><div class="line">def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {</div><div class="line">    uniform token[] joints = [<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;A/B&quot;</span>,  <span class="stringliteral">&quot;C&quot;</span>, <span class="stringliteral">&quot;C/D/E&quot;</span>]</div><div class="line">}</div></div><!-- fragment --><p>In the above example, there are four joints:</p><ul>
<li><code>A</code>: A root joint (no parent)</li>
<li><code>A/B</code>: A joint parented beneath joint <code>A</code></li>
<li><code>C</code>: Another root joint (no parent). There can be any number of root joints.</li>
<li><code>C/D/E</code>: A joint which, since <code>C/D</code> has not been defined, will be parented beneath joint <code>C</code>.</li>
</ul>
<p>In addition to providing parent-child relationships, this token array also establishes the <a class="el" href="_usd_skel__schemas.html#UsdSkel_JointOrder">joint order</a> of the skeleton.</p>
<p>The targets of the <em>joints</em> attribute are required to be authored such that all parent joints come before any of their children in the array. This is a requirement because it simplifies some computations without necessitating the creation of additional data structures. This ordering can most easily be achieved by simply sorting the array.</p>
<p>It's possible to test whether or not an array of joint paths defines a valid topology as follows:</p>
<ul>
<li>C++: <div class="fragment"><div class="line">std::string whyNot;</div><div class="line"><span class="keywordtype">bool</span> isValid = <a class="code" href="class_usd_skel_topology.html">UsdSkelTopology</a>(paths).<a class="code" href="class_usd_skel_topology.html#ab8dd322bd2af52830487af0d2de84371">Validate</a>(&amp;whyNot);</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">(isValid,whyNot) = UsdSkel.Topology(paths).Validate()</div></div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="UsdSkel_SkelAnimation"></a>
Skel Animation Schema</h1>
<p>Schema describing skeletal animation, within which joint animations and blend shapes are stored in a vecorized form. A SkelAnimation encodes the animation of a Skeleton as a separate primitive to facilitate instancing workflows.</p>
<p>Both as a storage optimization and to allow for value interpolation that preserves transform orthogonality, joint transforms are encoded as separate translate, rotate and scale components, given in <em>joint local</em> space. Transforms are constructed from components using an order of scale-rotate-translate. Client code may make use of the <a class="el" href="group___usd_skel___transform_composition_utils.html">transform composition utilities</a> for converting transforms to and from this component form.</p>
<p>Joint data is stored in arrays, using the <a class="el" href="_usd_skel__schemas.html#UsdSkel_JointOrder">joint order</a> specified by the <em>joints</em> attribute. This ordering may be different from the Skeletons that the animation maps to, and may also only identify a sparse subset of the joints in a skeleton. When an animation provides sparse data, fallback values are taken from the rest pose on the <a class="el" href="class_usd_skel_skeleton.html" title="Describes a skeleton.">UsdSkelSkeleton</a> primitive to which they apply.</p>
<p>An animation source is only valid if its <em>translation</em>, <em>rotation</em>, and <em>scale</em> components are all authored, storing arrays size to the same size as the authored <em>joints</em> array. The effect of a skel animation prim may also be directly nullified by either deactivating the primitive, or by blocking the component attributes.</p>
<p>In addition to providing joint animations, a SkelAnimation may also provide blend shape weight animations. Blend shape weights are specified in a vectorized form using the <em>blendShapeWeights</em> attribute. The <em>blendShapes</em> attribute holds a token array which, for every element authored in <em>blendShapeWeights</em>, identifies which blend shape each weight value applies to.</p>
<p>The point of this encoding is to decouple the blendshape weight animation from the description of how that animation maps to different skinnable shapes. Refer to the <a class="el" href="_usd_skel__schemas.html#UsdSkel_BindingAPI_BlendShapes">BindingAPI: Binding Blend Shapes</a> 'BindingAPI: Blend Shapes' documentation for information on how these weights are mapped to skinnable primitives.</p>
<h1><a class="anchor" id="UsdSkel_SkelAnimation_Binding"></a>
Skel Animation Schema: Binding to Skeletons</h1>
<p>A <em>SkelAnimation</em> is made to affect a <em>Skeleton</em> by <em>binding</em> the animation to the skeleton, using the <em>skel:animationSource</em> property of <a class="el" href="class_usd_skel_binding_a_p_i.html" title="Provides API for authoring and extracting all the skinning-related data that lives in the &quot;geometry h...">UsdSkelBindingAPI</a> schema (use <a class="el" href="class_usd_skel_binding_a_p_i.html#a82e008f7c638888bea48d2e6f5172fdb" title="Applies this single-apply API schema to the given prim.">UsdSkelBindingAPI::Apply()</a> to fetch a properly-applied binding API object). For example:</p>
<div class="fragment"><div class="line">def SkelAnimation <span class="stringliteral">&quot;Anim&quot;</span> {}</div><div class="line">def <span class="stringliteral">&quot;Model&quot;</span> (</div><div class="line">    prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">)</div><div class="line">{</div><div class="line">    rel skel:animationSource = &lt;/Anim&gt;</div><div class="line">    </div><div class="line">    def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {}</div><div class="line">}</div></div><!-- fragment --><p>When a <em>skel:animationSource</em> property is defined, it is "inherited" down namespace, onto any <em>Skeleton</em> primitive beneath it. So in the above example, <code>&lt;/Model/Skel&gt;</code> will be affected by the SkelAnimation at <code>&lt;/Anim&gt;</code>.</p>
<p>There are a couple reasons why data is separated in this manner:</p><ul>
<li>Encoding animation separately means that different schemes can be developed for describing the animation of a Skeleton. For example, it is possible to define a "blender" animation type that encodes the blending of animation.</li>
<li>It is possible to apply different animations to <em>instanced assets</em>. <dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd_skel__instancing.html">Instancing in UsdSkel</a></dd></dl>
</li>
</ul>
<h1><a class="anchor" id="UsdSkel_BlendShape"></a>
Blend Shape Schema</h1>
<p>Schema describing a single blend shape.</p>
<p>Blend shapes specify a target shape, in terms of point offsets, for a point-based primitive. The offsets may hold a direct correspondance with the points of the point-based primitive to which they are meant to apply, or the points may specify a shape using a sparse subset of points. The mapping in the latter case is described using the <em>pointIndices</em> attribute. If a blend shape defines any <a class="el" href="_usd_skel__schemas.html#UsdSkel_BlendShape_Inbetweens">in-between shapes</a>, the same pointIndices* mapping additionaly applies to all in-between shapes.</p>
<p>When a mesh is skinned in UsdSkel, blend shape application precedes the effect of skinning using joint transformations. If no in-between shapes are defined, a set of blend shapes is applied against an input point as follows:</p>
<div class="image">
<object type="image/svg+xml" data="blendshapes.svg">blendshapes.svg</object>
</div>
<p>  
<!--
    P' = P +\sum_i{w_ib_i} \\
    \text{where:} \\
    \begin{align*}
       b_i    &= \text{Position offset of shape } i \\
       P      &= \text{Initial point being deformed}
    \end{align*}
-->
</p>
<p>In other words, the position offsets are multiplied against the corresponding weight value, and added against the input positions. Note that the above equation only describes application of blend shapes in the absence of in-between shapes.</p>
<h2><a class="anchor" id="UsdSkel_BlendShape_Inbetweens"></a>
Blend Shape: In-betweens</h2>
<p>Each blend shape prim may define in-between shapes, which specify explicit corrective shape to apply when the blend shape is resolved at different weights.</p>
<p>For example, suppose that a blend shape defines a 'smile' shape. At a weight of 1, we apply the full effect of the shape. At in-between weight values, we linearly interpolate the shape back towards a neutral pose to derive an in-between shape. Using in-betweens, we can instead specify those in-between shapes explicitly. So instead of linearly interpolating to derive a 'half-smile' pose, we might provide an explicit shape corresponding to a weight of 0.5.</p>
<p>Scene description for the scenario described above is as follows:</p>
<div class="fragment"><div class="line">def BlendShape <span class="stringliteral">&quot;Smile&quot;</span> {</div><div class="line">    uniform vector3f[] inbetweens:halfSmile = [...] (weight = 0.5)</div><div class="line">}</div></div><!-- fragment --><p>While an equivalent animation could be defined without in-betweens by animating the weights of two blend shapes separately, using in-betweens provides a more convenient encoding that allows us to decouple the specification of in-betweens from the primary weight animation.</p>
<p>In-between shapes can be created via <a class="el" href="class_usd_skel_blend_shape.html#aabcae2b42b6c45d0f33e758f54cd0ac8" title="Author scene description to create an attribute on this prim that will be recognized as an Inbetween ...">UsdSkelBlendShape::CreateInbetween()</a>, and are manipulated and introspected using <a class="el" href="class_usd_skel_inbetween_shape.html" title="Schema wrapper for UsdAttribute for authoring and introspecting attributes that serve as inbetween sh...">UsdSkelInbetweenShape</a> objects. The in-between shapes themselves are encoded as attributes in the 'inbetweens:' namespace, using the 'weight' metadata field to indicate the weight value at which they apply.</p>
<p>The in-between shapes corresponding to <code>weight = 0</code> and <code>weight = 1</code> are <b>implicitly</b> defined on a blend shape. The former defines the null shape, for which all shape offset are zero, while the latter is the shape given by the <em>offsets</em> property of the <a class="el" href="class_usd_skel_blend_shape.html" title="Describes a target blend shape, possibly containing inbetween shapes.">UsdSkelBlendShape</a> primitive. Because the existence of those in-betweens is implied, it is considered an authoring error for any in-betweens to specify a weight of 0 or 1.</p>
<p>We must also consider the behavior when multiple in-betweens have matching weight values. Although it would be possible to adopt an interpretation that allows all shapes to have meaning &ndash; such as averaging across all shapes &ndash; this introduces some ambiguity for interchange: If the in-betweens are averaged together, it's unclear what the <em>name</em> should be given to the resulting shape. To avoid this ambiguous interpretation, in addition to treating in-betweens with a weight value of 0 or 1 as an authoring error, it is also considered an error for any two in-betweens of a blend shape to have the same weight value. Typical run-time behavior for these malformed in-betweens is to produce an error, but continue to process the blend shape while ignoring the malformed in-betweens.</p>
<p>If we consider only the set of valid in-betweens, a set of blend shapes containing in-betweens are applied to a point as follows:</p>
<div class="image">
<object type="image/svg+xml" data="blendshapesWithInbetweens.svg">blendshapesWithInbetweens.svg</object>
</div>
<p>  
<!--
    P' = P + \sum_i{ [b_l(1 - \frac{w_i-\alpha_l}{\alpha_u-\alpha_l}) +
                     b_u\frac{w_i-\alpha_l}{\alpha_u-\alpha_l}] } \\
    \text{where:} \\
    \begin{align*}
        P        &= \text{Initial point being deformed} \\
        w_i      &= \text{Weight value of blendshape } i \\
        b_i      &= \text{Position offsets of blendshape } i \\
        \alpha_i &= \text{Weight location of in-between blendshape } i \\
        l        &= \text{The index of the nearest weight with weight } \leq w, \\
                 & \text{or the index of the in-between with  the lowest weight value otherwise} \\
        u        &= \text{The index of the next in-between with weight} \geq w_l, l \neq u \\
    \end{align*}
-->
</p>
<p>For example, given in-between weights of <code>[0.25, 0.5]</code>, if a blendshape weight is greater than 0.5, we interpolate between the shape at 0.5 and the implicit primary shape (<code>weight = 1</code>), adding the result to the base shape. If the weight is in the <code>[0.25,0.5]</code> interval, we interpolate between the shapes at 0.25 and 0.5, adding the result to the base shape. Finally, if the weight is less than 0.25, we interpolate between the implicit null shape (<code>weight = 0</code>) and the shape at 0.25. Note also that this interpolation is <em>unbounded</em>, so if the input weight is, say, -0.25, then we have:</p>
<div class="image">
<object type="image/svg+xml" data="unboundedInterpolationExample.svg">unboundedInterpolationExample.svg</object>
</div>
<p>  
<!--
\frac{w_i-\alpha_l}{\alpha_u-\alpha_l} = \frac{-0.25 - 0}{0.25 - 0} = -1
-->
</p>
<p>So at a weight value of -0.25, the shape at 0.25 is applied with a weight of -1.</p>
<h1><a class="anchor" id="UsdSkel_BindingAPI"></a>
Binding API Schema</h1>
<p>The <a class="el" href="class_usd_skel_binding_a_p_i.html" title="Provides API for authoring and extracting all the skinning-related data that lives in the &quot;geometry h...">UsdSkelBindingAPI</a> schema provides a means of binding both <em>Skeleton</em> and <em>SkelAnimation</em> into a geometry hierarchy. This schema is also responsible for defining joint influences, as well as an optional <em>geomBindTransform</em> property to define the space for skinning. Whenever using a <a class="el" href="class_usd_skel_binding_a_p_i.html" title="Provides API for authoring and extracting all the skinning-related data that lives in the &quot;geometry h...">UsdSkelBindingAPI</a> to <b>author</b> data, make sure to "apply" it properly, using <a class="el" href="class_usd_skel_binding_a_p_i.html#a82e008f7c638888bea48d2e6f5172fdb" title="Applies this single-apply API schema to the given prim.">UsdSkelBindingAPI::Apply()</a>.</p>
<p>Since a <a class="el" href="class_usd_skel_root.html" title="Boundable prim type used to identify a scope beneath which skeletally-posed primitives are defined.">UsdSkelRoot</a> primitive provides encapsulation of skeletal data, bindings defined on any primitives that do not have a <a class="el" href="class_usd_skel_root.html" title="Boundable prim type used to identify a scope beneath which skeletally-posed primitives are defined.">UsdSkelRoot</a> primitive as one of their ancestors have no meaning, and should be ignored.</p>
<h2><a class="anchor" id="UsdSkel_BindingAPI_Skeletons"></a>
BindingAPI: Binding Skeletons</h2>
<p>Meshes are skinned based on skinning transforms, computed from a <a class="el" href="class_usd_skel_skeleton_query.html" title="Primary interface to reading bound skeleton data.">UsdSkelSkeletonQuery</a>, which is bound hierarchically using the <em>skel:skeleton</em> relationship. The transforms for a bound skeleton are driven from an animation source, such as a <a class="el" href="_usd_skel__schemas.html#UsdSkel_SkelAnimation">skel animation</a>, which is also bound hierarchically, via the <em>skel:animationSource</em> binding relationship.</p>
<p>By defining bindings hierarchically, it is possible to define models that each have unique skeletal animations, while also being <a class="el" href="_usd__page__scenegraph_instancing.html#Usd_ScenegraphInstancing_Overview">instanced</a>. For example:</p>
<div class="fragment"><div class="line">def <span class="stringliteral">&quot;Character&quot;</span> (</div><div class="line">    prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">)</div><div class="line">{</div><div class="line">    rel skel:skeleton = &lt;Skel&gt;</div><div class="line">    def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {}</div><div class="line">}</div><div class="line"></div><div class="line">def SkelAnimation <span class="stringliteral">&quot;Anim&quot;</span> {}</div><div class="line"></div><div class="line">over <span class="stringliteral">&quot;Instance&quot;</span> (</div><div class="line">    prepend references = &lt;/Character&gt;</div><div class="line">    instanceable=true</div><div class="line">) {</div><div class="line">    rel skel:animationSource = &lt;/Anim&gt;</div><div class="line">}</div></div><!-- fragment --><p>Each <em>skel:skeleton</em> binding may be thought of as identifying a Skeleton Instance, animated according to whichever inherited <em>skel:animationSource</em> is defined at the location at which the <em>skel:skeleton</em> is bound.</p>
<p>Although <em>skel:animationSource</em> bindings are inherited, they only apply when a <em>skel:skeleton</em> is resolved. For example:</p>
<div class="fragment"><div class="line">over <span class="stringliteral">&quot;A&quot;</span> (</div><div class="line">    prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">)</div><div class="line">{</div><div class="line">    rel skel:animationSource = &lt;/Anim&gt;</div><div class="line"></div><div class="line">    over <span class="stringliteral">&quot;B&quot;</span> (</div><div class="line">        prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">    )</div><div class="line">    {</div><div class="line">       rel skel:skeleton = &lt;/Skel1&gt;</div><div class="line">    }</div><div class="line">    over <span class="stringliteral">&quot;C&quot;</span>  (</div><div class="line">        prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        rel skel:skeleton = &lt;/Skel2&gt;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The above example includes two separate <em>skeleton instances</em>, with the same animation being applied to each instance. Contrast that with the following case:</p>
<div class="fragment"><div class="line">over <span class="stringliteral">&quot;A&quot;</span> (</div><div class="line">    prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">)</div><div class="line">{</div><div class="line">    rel skel:skeleton = &lt;/Skel&gt;</div><div class="line"></div><div class="line">    over <span class="stringliteral">&quot;B&quot;</span> (</div><div class="line">        prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">    )</div><div class="line">    {</div><div class="line">       rel skel:animationSource = &lt;/Anim1&gt;</div><div class="line">    }</div><div class="line">    over <span class="stringliteral">&quot;C&quot;</span> (</div><div class="line">        prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        rel skel:animationSource = &lt;/Anim2&gt;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In the above example, there is only a single <em>skeleton instance</em> (at <code>&lt;/A&gt;</code>), which has no animation, because a <em>skel:animationSource</em> binding is not considered to have any effect until the next <em>skel:skeleton</em> binding at or beneath the binding location in namespace.</p>
<p>One final example may clarify behavior:</p>
<div class="fragment"><div class="line">over <span class="stringliteral">&quot;A&quot;</span> (</div><div class="line">    prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">)</div><div class="line">{</div><div class="line">    rel skel:skeleton = &lt;/Skel&gt;</div><div class="line">    rel skel:animationSource = &lt;/Anim1&gt;    </div><div class="line"></div><div class="line">    over <span class="stringliteral">&quot;B&quot;</span> (</div><div class="line">        prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        rel skel:animationSource = &lt;/Anim2&gt;</div><div class="line">    }</div><div class="line">    over <span class="stringliteral">&quot;C&quot;</span> (</div><div class="line">        prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        rel skel:animationSource = &lt;/Anim2&gt;</div><div class="line">        rel skel:skeleton = &lt;/Skel&gt;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In this case, there are two <em>skeleton instances</em>: One at <code>&lt;/A&gt;</code>, referencing the animation at <code>&lt;/Anim1&gt;</code>, and one at <code>&lt;/A/C&gt;</code>, referencing the animation at <code>&lt;/Anim2&gt;</code>. The <em>skel:animationSource</em> relationship at <code>&lt;/A/B&gt;</code> has no effect.</p>
<h2><a class="anchor" id="UsdSkel_BindingAPI_JointInfluences"></a>
BindingAPI: Joint Influences</h2>
<p>Joint influences for skinning points are defined by setting the <em>primvars:skel:jointIndices</em> and <em>primvars:skel:jointWeights</em> <a href="https://openusd.org/release/glossary.html#usdglossary-primvar">primvars</a>, using the <a class="el" href="class_usd_skel_binding_a_p_i.html" title="Provides API for authoring and extracting all the skinning-related data that lives in the &quot;geometry h...">UsdSkelBindingAPI</a>. The <em>jointIndices</em> primvar provides an array giving the joint index of an influence, while the <em>jointWeights</em> primvar provides a weight value corresponding to each of those indices.</p>
<p>Above, since <code>&lt;/MeshA&gt;</code> does not specify a <em>skel:joints</em> ordering of its own, the joint indices refer to the ordering of the bound Skeleton, and so the joint indices refer to joints <code>A/B</code> and <code>A</code>, respectively. However, <code>&lt;/MeshB&gt;</code> specifies a <code>skel:joints</code> property that gives an alternate joint ordering. Using that, the indices of <code>&lt;/MeshB&gt;</code> refer to joints <code>A/B/C</code> and <code>A/B</code>, in that order.</p>
<p>In the common case, the joint influence primvars are configured with <em>vertex</em> interpolation, and define a fixed number of contiguous influences per point. The primvar's <em>elementSize</em> defines the fixed number of influences for each point.</p>
<p><em>elementSize</em> of the primvar. I.e., </p><div class="image">
<object type="image/svg+xml" data="influencesPrimvarLayout.svg">influencesPrimvarLayout.svg</object>
</div>
<p>  
<!--
    \begin{bmatrix}
        w(point_0,influence_0) & w(point_0,influence_1) & \dots & w(point_0,influnce_M) \\
        w(point_1,influence_1) & \dots & & w(point_1,influence_M) \\
        \vdots \\
        w(point_N,influence_0) & \dots & & w(point_N,influence_M)
    \end{bmatrix} \\
    \text{where:} \\
    \begin{align*}
        w(i,j)   &= \text{weight value of the } j\text{'th influence of point } i \\
        M        &= \text{primvar elementSize} \\
        N        &= \text{number of points}
    \end{align*}
-->
</p>
<p>If a point has fewer influences than are needed for other points, the unused array elements of that point should be filled with 0, both for joint indices and for weights.</p>
<p>See <a class="el" href="class_usd_geom_primvar.html">UsdGeomPrimvar</a> for more information on the meaning of primvar interpolation and elementSize.</p>
<p>No restrictions are placed on the <em>elementSize</em> when defining joint influences. Because such a limit may vary among different DCC applications, we feel that it is inappropriate to hard-code any such restrictions at the file storage level. Instead, for clients that require a strict limit on the number of influences per point, UsdSkel provides helper method, <a class="el" href="group___usd_skel___joint_influence_utils.html#gaae0d70275a200052d4c1dba80fe388f4">UsdSkelResizeInfluences</a>, that can be used to enforce such limits within each client, as necessary.</p>
<p>See the skinning coding examples for an example of how resolved joint influences may be read.</p>
<p>The interpolation, element size and the size of the stored arrays must be consistent across both the <em>joindIndices</em> and <em>jointWeights</em> primvars.</p>
<p>Aside from <em>vertex</em> interpolation, the only other valid primvar interpolation for joint influences is <em>constant</em> interpolation, which is used in defining rigid deformations. It is considered an error to apply any other type of interpolation.</p>
<h2><a class="anchor" id="UsdSkel_BindingAPI_RigidDeformations"></a>
BindingAPI: Rigid Deformations</h2>
<p>In addition to defining influences that vary per point, joint influences may also be defined with <em>constant</em> interpolation. In this form, the <em>jointIndices</em> and <em>jointWeights</em> arrays define a set of influences that apply the same way to all points. Constant joint influences are supported both as a form of storage optimization, as well as for the sake of encoding <em>rigid deformations</em>. By identifying rigid deformations, some clients may be able to retain instancing properties that would otherwise be lost by skinning, by affecting only the transform of an instance rather than the deforming points of that instance.</p>
<p>For example:</p>
<div class="fragment"><div class="line">def <span class="stringliteral">&quot;MeshA&quot;</span> (</div><div class="line">    prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span>[] primvars:skel:jointIndices = [0] (interpolation = <span class="stringliteral">&quot;constant&quot;</span>)</div><div class="line">    <span class="keywordtype">float</span>[] primvars:skel:jointWeights = [1] (interpolation = <span class="stringliteral">&quot;constant&quot;</span>)</div><div class="line">}</div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;MeshB&quot;</span> (</div><div class="line">    prepend apiSchemas = [<span class="stringliteral">&quot;SkelBindingAPI&quot;</span>]</div><div class="line">)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span>[] primvars:skel:jointIndices = [0,1] (interpolation = <span class="stringliteral">&quot;constant&quot;</span>)</div><div class="line">    <span class="keywordtype">float</span>[] primvars:skel:jointWeights = [0.5,0.5] (interpolation = <span class="stringliteral">&quot;constant&quot;</span>)</div><div class="line">}</div></div><!-- fragment --><p>In the example above, <code>&lt;/MeshA&gt;</code> can be seen as being ridigly constrained to infuence 0. <code>&lt;/MeshB&gt;</code> is rigidly deformed, but it's also important to note that even though it is rigidly deformed, it is still influenced by more than one joint.</p>
<p>It is not expected that all applications know how to deal with rigid deformations. For applications that don't understand them, UsdSkel provides the helper methods <a class="el" href="class_usd_skel_skinning_query.html#ae9c6fae1e6724c31e15f04295da5e976" title="Convenience method for computing joint influence, where constant influences are expanded to hold valu...">UsdSkelSkinningQuery::ComputeVaryingJointInfluences</a> and <a class="el" href="group___usd_skel___joint_influence_utils.html#gaa59dc369a78f21fbeeda0ee11292650f">UsdSkelExpandConstantInfluencesToVarying</a>, which both provide a means of querying rigid deformations as if they had been encoded with per-point influences.</p>
<h2><a class="anchor" id="UsdSkel_BindingAPI_StoringInfluences"></a>
BindingAPI: Storing Influences</h2>
<p>To ensure correct skinning, joint influences should be normalized when they are written using the <a class="el" href="class_usd_skel_binding_a_p_i.html" title="Provides API for authoring and extracting all the skinning-related data that lives in the &quot;geometry h...">UsdSkelBindingAPI</a>. UsdSkel does <em>not</em> automatically normalize weights when reading data. Clients should instead use the <a class="el" href="group___usd_skel___joint_influence_utils.html#ga3021d3989a6265f6bbf09d72114edfed">UsdSkelNormalizeWeights</a> helper method to normalize weights prior to storing them.</p>
<p>Additionally, as part of our <a class="el" href="_usd_skel__best_practices.html">best practices</a>, we suggest that joint influences be sorted from largest weight value to smallest. The <a class="el" href="group___usd_skel___joint_influence_utils.html#ga58fea609ea13eb8b9f8c6fe7ab709307">UsdSkelSortInfluences</a> utility can be used to do so. UsdSkel does not currently <em>require</em> sorted joint influences, but may later add such restrictions, since they enable some skinning optimizations, such as allowing a skinning kernel to exit from a point-deformation loop early.</p>
<h2><a class="anchor" id="UsdSkel_BindingAPI_GeomBindTransform"></a>
BindingAPI: GeomBindTransform</h2>
<p>For skinning to apply correctly, the constant <em>primvars:skel:geomBindTransform</em> <a href="https://openusd.org/release/glossary.html#usdglossary-primvar">primvar</a> should be authored on each skinnable primitive, using the <a class="el" href="class_usd_skel_binding_a_p_i.html" title="Provides API for authoring and extracting all the skinning-related data that lives in the &quot;geometry h...">UsdSkelBindingAPI</a>. This primvar stores the world space transform of a skinned primitive at bind time. When skinning is applied, points of each skinnable primitive are trasnformed by their <em>geomBindTransform</em> into bind space, after which joint transforms are applied, placing the result in either <em>skeleton space</em> or <em>world space</em>.</p>
<p>When a primitive is skinned, any transform on the prim authored by way of the typical <a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable</a> schema has <b>no effect</b> on the rendered results. Skinned geometry primitives are rendered in <em>skeleton space</em>, rather than being transformed back into local gprim space. This avoids double-transform problems that can otherwise occur, for example, if an ancestor of both a skinnable primitive and its driving Skeleton is moved.</p>
<h2><a class="anchor" id="UsdSkel_BindingAPI_BlendShapes"></a>
BindingAPI: Binding Blend Shapes</h2>
<p>UsdSkel decouples the encoding of blend shape animations from the description of how those animations map to skinnable primitives. This has numerous advantages, such as allowing the set of primitives skinned by a particular Skeleton Instance to be swapped out &ndash; via variants or other composition features &ndash; with a different set of skinnable primitives, holding different blend shapes. This decoupling also means that an existing blend shape animation is not necessarily invalidated by asset changes that alter the set of shapes defined for a character.</p>
<p>Given a skinnable primitive, the <em>skel:blendShapes</em> and <em>skel:blendShapeTargets</em> properties of the <a class="el" href="class_usd_skel_binding_a_p_i.html" title="Provides API for authoring and extracting all the skinning-related data that lives in the &quot;geometry h...">UsdSkelBindingAPI</a> specify a mapping from the animation of the bound Skeleton Instance to different skinnable primitives.</p>
<p>Note that because blend shapes are usually tightly coupled with individual geometric primitives, whereas other properties of <a class="el" href="class_usd_skel_binding_a_p_i.html" title="Provides API for authoring and extracting all the skinning-related data that lives in the &quot;geometry h...">UsdSkelBindingAPI</a> are hierarchically inherited, these blendshape-related properties are <em>not</em> inherited from ancestor primitives in namespace, and are relevant only when specified directly on primitives.</p>
<p>To bind blend shapes, the <em>skel:blendShapeTargets</em> rel should be created, and set to target <a class="el" href="class_usd_skel_blend_shape.html" title="Describes a target blend shape, possibly containing inbetween shapes.">UsdSkelBlendShape</a> primitives, which define each shape. Additionally, the <em>skel:blendShapes</em> array should also be defined, providing a unique token per bound blend shape. For example:</p>
<div class="fragment"><div class="line">def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {}</div><div class="line"></div><div class="line">def SkelAnimation <span class="stringliteral">&quot;Anim&quot;</span></div><div class="line">{</div><div class="line">    uniform token[] blendShapes = [<span class="stringliteral">&quot;A&quot;</span>,<span class="stringliteral">&quot;B&quot;</span>,<span class="stringliteral">&quot;C&quot;</span>,<span class="stringliteral">&quot;D&quot;</span>]</div><div class="line">    <span class="keywordtype">float</span>[] blendShapeWeights = [1,0.75,0,0]</div><div class="line">}</div><div class="line"></div><div class="line">def Mesh <span class="stringliteral">&quot;Mesh (</span></div><div class="line"><span class="stringliteral">    prepend apiSchemas = [&quot;</span>SkelBindingAPI<span class="stringliteral">&quot;]</span></div><div class="line"><span class="stringliteral">)</span></div><div class="line"><span class="stringliteral">{</span></div><div class="line"><span class="stringliteral">    def BlendShape &quot;</span>Foo<span class="stringliteral">&quot; {}</span></div><div class="line"><span class="stringliteral">    def BlendShape &quot;</span>Bar<span class="stringliteral">&quot; {}</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">    uniform token[] skel:blendShapes = [&quot;</span>B<span class="stringliteral">&quot;, &quot;</span>A<span class="stringliteral">&quot;]</span></div><div class="line"><span class="stringliteral">    rel skel:blendShapeTargets = [&lt;Foo&gt;, &lt;Bar&gt;]</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">    rel skel:skeleton = &lt;/Skel&gt;</span></div><div class="line"><span class="stringliteral">    rel skel:animationSource = &lt;/Anim&gt;</span></div><div class="line"><span class="stringliteral">}</span></div></div><!-- fragment --><p>In the above example, note that the <code>&lt;/Anim&gt;</code> primitive specifies more blend shapes than are actually used on <code>&lt;/Mesh&gt;</code>. This is because an animation source is providing animation data for a <b>complete model</b> (I.e., multiple geometric primitives). The <em>skel:blendShape</em> attribute, as defined on <code>&lt;/Mesh&gt;</code>, provides a mapping between the <em>blendShapeWeights</em> animation data on <code>&lt;/Anim</code>&gt; &ndash; which holds weight animation for multiple geometric primitives (although in this example <em>blendShapeWeights</em> is not animated). The set of blend shape targets specified by the <em>skel:blendShapeTargets</em> rel identifies, for each mapped blend shape token in <em>skel:blendShapes</em>, the target <a class="el" href="class_usd_skel_blend_shape.html" title="Describes a target blend shape, possibly containing inbetween shapes.">UsdSkelBlendShape</a> primitive to which animation data should apply.</p>
<p>From the example above, <code>&lt;/Mesh&gt;</code> is using shapes mapped to &lsquo;['B&rsquo;, 'A']` (in that order). First we map the <em>blendShapeWeights</em> from the ordering specified by <code>&lt;/Anim.blendShapes&gt;</code> to the ordering on <code>&lt;/Mesh.blendShapes&gt;</code>, which gives local weight values of [0.75,1.0]. For each token in <code>&lt;/Mesh.blendShapes&gt;</code>, the <code>&lt;/Mesh.blendShapeTargets&gt;</code> rel identifies which <a class="el" href="class_usd_skel_blend_shape.html" title="Describes a target blend shape, possibly containing inbetween shapes.">UsdSkelBlendShape</a> primitive that token maps to. So <code>B = &lt;/Mesh/Foo&gt;</code> and <code>A = &lt;/Mesh/Bar&gt;</code>. From this, we find that we our final blend shapes and weights, as pairs, are <code>[(&lt;/Mesh/Foo&gt;, 0.75), (&lt;/Mesh/Bar&gt;, 1.0)</code>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="usd_skel_page_front.html">UsdSkel : USD Skeleton Schema and API</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:57 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>