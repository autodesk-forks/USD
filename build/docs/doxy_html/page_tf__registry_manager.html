<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: The TfRegistryManager Registry Initialization System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('page_tf__registry_manager.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The <a class="el" href="class_tf_registry_manager.html" title="Manage initialization of registries.">TfRegistryManager</a> Registry Initialization System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="RegistryManagerContents"></a>
Contents</h1>
<ul>
<li><a class="el" href="page_tf__registry_manager.html#RegistryManagerRationale">Rationale</a> </li>
<li><a class="el" href="page_tf__registry_manager.html#RegistryManagerPushModel">Pushing Data</a> </li>
<li><a class="el" href="page_tf__registry_manager.html#RegistryManagerPitfalls">Pitfalls of Static Constructors</a> </li>
<li><a class="el" href="page_tf__registry_manager.html#RegistryManagerDefiningRegistryFunctions">Defining Registry Functions</a> </li>
<li><a class="el" href="page_tf__registry_manager.html#RegistryManagerSubscribing">Subscribing to Registry Functions</a> </li>
<li><a class="el" href="page_tf__registry_manager.html#RegistryManagerSingletons">Registry Singletons</a> </li>
<li><a class="el" href="page_tf__registry_manager.html#RegistryManagerUnloadingCode">Unloading Code</a></li>
</ul>
<h1><a class="anchor" id="RegistryManagerRationale"></a>
Rationale</h1>
<p>A common C++ design pattern is embedding global objects with constructors in libraries, to ensure that certain initialization takes place at program startup time. Often the actual global object is not of any importance; rather, the side-effect of executing the function sometime before main is the goal. This is typically the case when it is necessary to advertise a facility that is not necessarily known to the application (for example, capabilities that a library provides). The <a class="el" href="class_tf_registry_manager.html" title="Manage initialization of registries.">TfRegistryManager</a> was written to avoid the necessity of embedding libraries and binaries with so-called "static constructors," which is the phrase used to describe any function which is run before main to initialize an object.</p>
<p>If you want simply want to use <a class="el" href="class_tf_registry_manager.html" title="Manage initialization of registries.">TfRegistryManager</a>, skip the next section and go directly to the <a class="el" href="page_tf__registry_manager.html#tf_RegistryManager_DefiningRegistryFunctions">tf_RegistryManager_DefiningRegistryFunctions</a> Defining Registry Functions section.</p>
<p>However, if you want to understand the "traditional" technique that <a class="el" href="class_tf_registry_manager.html" title="Manage initialization of registries.">TfRegistryManager</a> replaces (and why this replacement is necessary), read on!</p>
<h1><a class="anchor" id="RegistryManagerPushModel"></a>
Pushing Data</h1>
<p>As an example, consider a facility for registering image transformation functions:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ImageTransformer;</div><div class="line"></div><div class="line"><span class="keyword">class </span>ImageTransformerRegistry </div><div class="line">{</div><div class="line">    <span class="keywordtype">void</span> Add(ImageTransformer*, <span class="keyword">const</span> std::string&amp; name);</div><div class="line"></div><div class="line">    ImageTransformer* GetByName(<span class="keyword">const</span> std::string&amp; name);</div><div class="line">};</div></div><!-- fragment --><p>Suppose a library Xyz wishes to make available a new image transformation. Imagine that there is a function XyzInit() which you could call to ask the Xyz library to add its image transformations to the registry. This is an example of data "pulling": given that you explicitly know that library Xyz exists, you can pull its data by calling XyzInit() prior to actually using any of Xyz's transforms.</p>
<p>However, you often don't know what libraries may be linked into our program, and keeping track can be quite difficult. Additionally, a library might not even be linked into a program: it might be loaded manually, as in the case of plugins. The usual solution is to add a static constructor into the Xyz library, to "push" data into the registry at startup time:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>XyzTransformer : <span class="keyword">public</span> ImageTransformer </div><div class="line">{</div><div class="line">     ...</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> XyzInit() </div><div class="line">{</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">if</span> (initialized)</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    XyzTransformer* transformer = <span class="keyword">new</span> XyzTransformer;</div><div class="line">    ImageTransformerRegistry.GetInstance().Add(transformer, <span class="stringliteral">&quot;XyzTransformer&quot;</span>);</div><div class="line">    initialized = <span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Xyz_GlobalObject </div><div class="line">{</div><div class="line">    Xyz_GlobalObject() {</div><div class="line">       XyzInit();</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> Xyz_GlobalObject forceInit;</div></div><!-- fragment --><p>Here, the global object forceInit exists only to have the side effect of running XyzInit(). If Xyz is linked into a program, then at program startup-time (that is, sometime before main), Xyz_StartupFunction() will be run. Alternately, if loaded as a plugin, at load time forceInit will be constructed, causing XyzInit() to be run.</p>
<p>Thus, even without anyone knowing about library Xyz, it has managed to advertise its presence. Is this a good idea?</p>
<h1><a class="anchor" id="RegistryManagerPitfalls"></a>
Pitfalls of Static Constructors</h1>
<p>There are many problems with the approach described above.</p>
<p>First, the C++ standard is quite vague about exactly when a global object such as forceInit is constructed. While many implementations will construct forceInit before main() if Xyz is linked into an application, other implementations (specifically Darwin) can be quite lazy about it, and will not construct <code>forceInit</code> until just before it is first referenced. This can be well after main(), or perhaps even never! (And this behavior is well within the C++ standard.)</p>
<p>Second, even if forceInit is constructed before main(), it is impossible in any implementation to control precisely when it will be constructed. For an image transformation library, construction "sometime" before main is quite acceptable. However, for more core facilities (a run-time object-type registry, for example) construction of the facility "sometime" before main() is not nearly precise enough. Typically, a variety of facilities all compete for construction before main(), and if the facilities depend on one another, it can be quite difficult to ensure they are initialized in a suitable order.</p>
<p>Third, suppose that the program never actually makes use of any image transformations. It seems a waste to put information into a registry if the registry is never queried. Even worse, the following call (presumably) creates an ImageTransformerRegistry():</p>
<div class="fragment"><div class="line">ImageTransformerRegistry.GetInstance().Add(transformer, <span class="stringliteral">&quot;XyzTransformer&quot;</span>);</div></div><!-- fragment --><p>It would be better to not even create the registry (let alone populate it) if nobody cares. While the savings may seem small, eliminating a large number of these initializations can allow a program to start up much faster.</p>
<p>Finally, adding insult to injury, the above naive design isn't thread safe.</p>
<p><a class="anchor" id="tf_RegistryManager_DefiningRegistryFunctions"></a></p>
<h1><a class="anchor" id="RegistryManagerDefiningRegistryFunctions"></a>
Defining Registry Functions</h1>
<p>A far better design is for an interested registry to pull data at the time the registry is constructed. The question is how to do this without requiring explicit knowledge of the data available in a program. This is the job of the <a class="el" href="class_tf_registry_manager.html" title="Manage initialization of registries.">TfRegistryManager</a>. Here is how you would use <a class="el" href="class_tf_registry_manager.html" title="Manage initialization of registries.">TfRegistryManager</a> for the case of image transformations and the Xyz library (discussed in the previous section).</p>
<p>First, let us start with the Xyz library. The library needs to define a function that is only to be run when the image transformation registry asks for it. This is done using the <a class="el" href="registry_manager_8h.html#aaa45cccc805d88e7201906f64f57ca18" title="Define a function that is called on demand by TfRegistryManager.">TF_REGISTRY_FUNCTION_WITH_TAG()</a> macro, as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="registry_manager_8h.html">pxr/base/tf/registryManager.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>XyzTransformer : <span class="keyword">public</span> ImageTransformer </div><div class="line">{</div><div class="line">     ...</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="registry_manager_8h.html#aaa45cccc805d88e7201906f64f57ca18">TF_REGISTRY_FUNCTION_WITH_TAG</a>(ImageTransformerRegistry, XyzTransformer)</div><div class="line">{</div><div class="line">    ImageTransformer* transformer = <span class="keyword">new</span> XyzTransformer;</div><div class="line">    ImageTransformerRegistry.GetInstance().Add(transformer, <span class="stringliteral">&quot;XyzTransformer&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>The first argument to the <a class="el" href="registry_manager_8h.html#aaa45cccc805d88e7201906f64f57ca18" title="Define a function that is called on demand by TfRegistryManager.">TF_REGISTRY_FUNCTION_WITH_TAG()</a> macro in the above example marks the function body below as belonging to the domain ImageTransformerRegistry; this function will not be run until the <a class="el" href="class_tf_registry_manager.html" title="Manage initialization of registries.">TfRegistryManager</a> is told to ininitialize this domain. The second parameter must be a type-name, but it does not matter what type-name is used as long as each call of <a class="el" href="registry_manager_8h.html#aaa45cccc805d88e7201906f64f57ca18" title="Define a function that is called on demand by TfRegistryManager.">TF_REGISTRY_FUNCTION_WITH_TAG(ImageTransformerRegistry,T)</a> uses a different type T. Also, both type-names used in the macro must be free from using the "&lt;", "&gt;" or ":" characters (i.e. no templated, nested, or name-space qualified types). Thus, in some other file, we might also have the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="registry_manager_8h.html">pxr/base/tf/registryManager.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>OtherTransformer : <span class="keyword">public</span> ImageTransformer </div><div class="line">{</div><div class="line">     ...</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="registry_manager_8h.html#aaa45cccc805d88e7201906f64f57ca18">TF_REGISTRY_FUNCTION_WITH_TAG</a>(ImageTransformerRegistry, OtherTransformer)</div><div class="line">{</div><div class="line">    ImageTransformer* transformer = <span class="keyword">new</span> OtherTransformer;</div><div class="line">    ImageTransformerRegistry.GetInstance().Add(transformer, <span class="stringliteral">&quot;OtherTransformer&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// we could also put even more stuff in the registry here</span></div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="RegistryManagerSubscribing"></a>
Subscribing to Registry Functions</h1>
<p>Now let us see how the ImageTransformerRegistry facility uses <a class="el" href="class_tf_registry_manager.html" title="Manage initialization of registries.">TfRegistryManager</a>. At the time that ImageTransformerRegistry wants the <a class="el" href="registry_manager_8h.html#aaa45cccc805d88e7201906f64f57ca18" title="Define a function that is called on demand by TfRegistryManager.">TF_REGISTRY_FUNCTION_WITH_TAG()</a> functions it cares about to run, it makes the following call:</p>
<div class="fragment"><div class="line"><a class="code" href="class_tf_registry_manager.html#a0c26566e590d0fefdbb5c1d6470e0244">TfRegistryManager::GetInstance</a>().<a class="code" href="class_tf_registry_manager.html#aa8dae7698202454aac66be4be3c21a5f">SubscribeTo</a>&lt;ImageTransformerRegistry&gt;();</div></div><!-- fragment --><p>(Note that the class <a class="el" href="class_tf_registry_manager.html" title="Manage initialization of registries.">TfRegistryManager</a> is a singleton and <a class="el" href="class_tf_registry_manager.html#a0c26566e590d0fefdbb5c1d6470e0244" title="Return the singleton TfRegistryManager instance.">TfRegistryManager::GetInstance()</a> returns a reference to this singleton.)</p>
<p>When SubscribeTo&lt;T&gt;() is called it causes all <a class="el" href="registry_manager_8h.html#ab1604c7efa4277ed6ee17fddaf70075f" title="Define a function that is called on demand by TfRegistryManager.">TF_REGISTRY_FUNCTION()</a> functions whose first key is T to be run. Additionally, any subsequently loaded code will immediately run all of its <a class="el" href="registry_manager_8h.html#ab1604c7efa4277ed6ee17fddaf70075f" title="Define a function that is called on demand by TfRegistryManager.">TF_REGISTRY_FUNCTION()</a> functions whose first key is T. It is safe to multiply describe to the same service, as subsequent subscriptions to the same service are ignored.</p>
<h1><a class="anchor" id="RegistryManagerSingletons"></a>
Registry Singletons</h1>
<p>Usually the registries being managed are singletons. In this case, assuming you are using the <a class="el" href="class_tf_singleton.html" title="Manage a single instance of an object (see.">TfSingleton</a> design pattern, your final code should look like this:</p>
<div class="fragment"><div class="line">ImageTransformerRegistry&amp;</div><div class="line">ImageTransformerRegistry::GetInstance()</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="class_tf_singleton.html#a0866aab4257483326c469dcef942f0e1">TfSingleton&lt;ImageTransformerRegistry&gt;::GetInstance</a>();</div><div class="line">}</div><div class="line"></div><div class="line">ImageTransformerRegistry::ImageTransformerRegistry()</div><div class="line">{</div><div class="line">    <span class="comment">// initialize all variables, etc. for the class</span></div><div class="line">    ...</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// this next call makes it possible to call</span></div><div class="line">    <span class="comment">// ImageTransformerRegistry::GetInstance() before this constructor</span></div><div class="line">    <span class="comment">// has finished.</span></div><div class="line"></div><div class="line">    <a class="code" href="class_tf_singleton.html#a26a188beb27db06db83e59ef88bf563f">TfSingleton&lt;ImageTransformerRegistry&gt;::SetInstanceConstructed</a>(*<span class="keyword">this</span>);    </div><div class="line"></div><div class="line">    <span class="comment">// now pull the data (i.e. run</span></div><div class="line">    <span class="comment">//    TF_REGISTRY_FUNCTION_WITH_TAG(ImageTransformerRegistry,T) for all T.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <a class="code" href="class_tf_registry_manager.html#a0c26566e590d0fefdbb5c1d6470e0244">TfRegistryManager::GetInstance</a>().<a class="code" href="class_tf_registry_manager.html#aa8dae7698202454aac66be4be3c21a5f">SubscribeTo</a>&lt;ImageTransformerRegistry&gt;();</div><div class="line">}</div><div class="line"></div><div class="line">ImageTransformerRegistry::~ImageTransformerRegistry()</div><div class="line">{</div><div class="line">    <span class="comment">// don&#39;t run subscriptions on my account any longer...</span></div><div class="line">    <a class="code" href="class_tf_registry_manager.html#a0c26566e590d0fefdbb5c1d6470e0244">TfRegistryManager::GetInstance</a>().<a class="code" href="class_tf_registry_manager.html#ab10386b343e3b59e339a477d7da75a84">UnsubscribeFrom</a>&lt;ImageTransformerRegistry&gt;();</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="class_tf_singleton.html#a26a188beb27db06db83e59ef88bf563f">TfSingleton&lt;ImageTransformerRegistry&gt;::SetInstanceConstructed</a>(*<span class="keyword">this</span>);</div></div><!-- fragment --><p>The line of code above (located just before the call to SubscribeTo() in the previous example) is vital. The reason is that the call to SubscribeTo() will immediately cause various <a class="el" href="registry_manager_8h.html#ab1604c7efa4277ed6ee17fddaf70075f" title="Define a function that is called on demand by TfRegistryManager.">TF_REGISTRY_FUNCTION()</a> functions to be called, which in turn will usually call ImageTransformerRegistry::GetInstance(). However, without first calling SetInstanceConstructed(), calling GetInstance() cannot return, since the constructor for ImageTransformerRegistry hasn't yet completed and the code would deadlock (or fatally abort).</p>
<h1><a class="anchor" id="RegistryManagerUnloadingCode"></a>
Unloading Code</h1>
<p>It may be necessary for a registry to be depopulated when code unloads. In the case of the image transformer library, we probably want to remove items from the registry when plugins defining image transformations are unloaded. This is done as follows:</p>
<div class="fragment"><div class="line">ImageTransformerRegistry::Remove(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name)</div><div class="line">{</div><div class="line">    <span class="comment">// removes name as a known transformer type</span></div><div class="line">    _transformerMap.erase(name);</div><div class="line">}</div><div class="line"></div><div class="line">ImageTransformerRegistry::Add(ImageTransformer* transformer, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name)</div><div class="line">{</div><div class="line">    <span class="comment">// add data into table</span></div><div class="line">    _transformerMap[name] = transformer;</div><div class="line"></div><div class="line">    <span class="comment">// schedule removal:</span></div><div class="line">    <span class="keyword">auto</span> cl = std::bind(&amp;ImageTransferRegistry::Remove, <span class="keyword">this</span>, name);</div><div class="line">    <a class="code" href="class_tf_registry_manager.html#a0c26566e590d0fefdbb5c1d6470e0244">TfRegistryManager::GetInstance</a>().<a class="code" href="class_tf_registry_manager.html#a73d6da3ea581776ba21c307e463cc23f">AddFunctionForUnload</a>(cl);</div><div class="line">}</div></div><!-- fragment --><p>The above call to AddFunctionForUnload() schedules that the given callback (effectively, the call this-&gt;Remove(name)) be run when the code from which Add() was itself called is unloaded. If Add() was called from within a <a class="el" href="registry_manager_8h.html#ab1604c7efa4277ed6ee17fddaf70075f" title="Define a function that is called on demand by TfRegistryManager.">TF_REGISTRY_FUNCTION()</a> function, then when the library or module defining this <a class="el" href="registry_manager_8h.html#ab1604c7efa4277ed6ee17fddaf70075f" title="Define a function that is called on demand by TfRegistryManager.">TF_REGISTRY_FUNCTION()</a> function is unloaded, the callback is called. (Note however that as an optimization, no callbacks are run when code is unloaded because exit() has been called. Callbacks are executed though, for code that is unloaded without the rest of the program terminating.) </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tf_page_front.html">Tf: Tools Foundations</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:57 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>