<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="usd_physics_page_front" kind="page">
    <compoundname>usdPhysics_page_front</compoundname>
    <title>UsdPhysics : USD Physics Schema</title>
    <tableofcontents>
      <tocsect>
        <name>Purpose and Scope</name>
        <reference>usd_physics_page_front_1usdPhysics_purpose_and_scope</reference>
    </tocsect>
      <tocsect>
        <name>Overall Design Concerns</name>
        <reference>usd_physics_page_front_1usdPhysics_overall_design</reference>
    <tableofcontents>
      <tocsect>
        <name>Rigid Body Simulation Primer</name>
        <reference>usd_physics_page_front_1usdPhysics_rigid_body</reference>
    </tocsect>
      <tocsect>
        <name>USD Implementation</name>
        <reference>usd_physics_page_front_1usdPhysics_usd_implementation</reference>
    <tableofcontents>
      <tocsect>
        <name>Disambiguation</name>
        <reference>usd_physics_page_front_1usdPhysics_disambiguation</reference>
    </tocsect>
      <tocsect>
        <name>Fundamental Editing Capabilities</name>
        <reference>usd_physics_page_front_1usdPhysics_fundamental_editing</reference>
    </tocsect>
      <tocsect>
        <name>Physics Scenes</name>
        <reference>usd_physics_page_front_1usdPhysics_physics_scenes</reference>
    </tocsect>
      <tocsect>
        <name>Types</name>
        <reference>usd_physics_page_front_1usdPhysics_types</reference>
    </tocsect>
      <tocsect>
        <name>Units</name>
        <reference>usd_physics_page_front_1usdPhysics_units</reference>
    </tocsect>
      <tocsect>
        <name>Default Values</name>
        <reference>usd_physics_page_front_1usdPhysics_default_values</reference>
    </tocsect>
      <tocsect>
        <name>Rigid Bodies</name>
        <reference>usd_physics_page_front_1usdPhysics_rigid_bodies</reference>
    </tocsect>
      <tocsect>
        <name>Interaction with the USD hierarchy</name>
        <reference>usd_physics_page_front_1usdPhysics_interaction_with_usd</reference>
    </tocsect>
      <tocsect>
        <name>Sleep</name>
        <reference>usd_physics_page_front_1usdPhysics_rb_sleep</reference>
    </tocsect>
      <tocsect>
        <name>Kinematic Bodies</name>
        <reference>usd_physics_page_front_1usdPhysics_kinematic_bodies</reference>
    </tocsect>
      <tocsect>
        <name>Animation of Attributes</name>
        <reference>usd_physics_page_front_1usdPhysics_animation_of_attributes</reference>
    </tocsect>
      <tocsect>
        <name>Body Mass Properties</name>
        <reference>usd_physics_page_front_1usdPhysics_body_mass_properties</reference>
    </tocsect>
      <tocsect>
        <name>Collision Shapes</name>
        <reference>usd_physics_page_front_1usdPhysics_collision_shapes</reference>
    </tocsect>
      <tocsect>
        <name>Turning Meshes into Shapes</name>
        <reference>usd_physics_page_front_1usdPhysics_mesh_into_shapes</reference>
    </tocsect>
      <tocsect>
        <name>Physics Materials</name>
        <reference>usd_physics_page_front_1usdPhysics_physics_materials</reference>
    </tocsect>
      <tocsect>
        <name>Plane Shapes</name>
        <reference>usd_physics_page_front_1usdPhysics_plane_shapes</reference>
    </tocsect>
      <tocsect>
        <name>Collision Filtering</name>
        <reference>usd_physics_page_front_1usdPhysics_collision_filtering</reference>
    </tocsect>
      <tocsect>
        <name>Pairwise Filtering</name>
        <reference>usd_physics_page_front_1usdPhysics_pairwise_filtering</reference>
    </tocsect>
      <tocsect>
        <name>Joints</name>
        <reference>usd_physics_page_front_1usdPhysics_joints</reference>
    </tocsect>
      <tocsect>
        <name>Joint Reference Frames</name>
        <reference>usd_physics_page_front_1usdPhysics_joint_reference_frames</reference>
    </tocsect>
      <tocsect>
        <name>Jointed Bodies</name>
        <reference>usd_physics_page_front_1usdPhysics_jointed_bodies</reference>
    </tocsect>
      <tocsect>
        <name>Joint Collision Filtering</name>
        <reference>usd_physics_page_front_1usdPhysics_joint_collision_filtering</reference>
    </tocsect>
      <tocsect>
        <name>Breaking and Disabling Joints</name>
        <reference>usd_physics_page_front_1usdPhysics_breaking_disabling_joints</reference>
    </tocsect>
      <tocsect>
        <name>Joint Subtypes</name>
        <reference>usd_physics_page_front_1usdPhysics_joint_subtypes</reference>
    </tocsect>
      <tocsect>
        <name>Joint Limits and Drives</name>
        <reference>usd_physics_page_front_1usdPhysics_limits_drives</reference>
    </tocsect>
      <tocsect>
        <name>Articulations</name>
        <reference>usd_physics_page_front_1usdPhysics_articulations</reference>
    </tocsect>
    </tableofcontents>
    </tocsect>
      <tocsect>
        <name>Examples</name>
        <reference>usd_physics_page_front_1usdPhysics_examples</reference>
    <tableofcontents>
      <tocsect>
        <name>Box on Box</name>
        <reference>usd_physics_page_front_1usdPhysics_box_on_box</reference>
    </tocsect>
      <tocsect>
        <name>Box on Quad</name>
        <reference>usd_physics_page_front_1usdPhysics_box_on_quad</reference>
    </tocsect>
      <tocsect>
        <name>Spheres with Materials</name>
        <reference>usd_physics_page_front_1usdPhysics_spheres_with_material</reference>
    </tocsect>
      <tocsect>
        <name>Group Filtering</name>
        <reference>usd_physics_page_front_1usdPhysics_group_filtering</reference>
    </tocsect>
      <tocsect>
        <name>Pair Filtering</name>
        <reference>usd_physics_page_front_1usdPhysics_pair_filtering</reference>
    </tocsect>
      <tocsect>
        <name>Joint</name>
        <reference>usd_physics_page_front_1usdPhysics_joint_example</reference>
    </tocsect>
      <tocsect>
        <name>Distance Joint</name>
        <reference>usd_physics_page_front_1usdPhysics_distance_joint_example</reference>
    </tocsect>
    </tableofcontents>
    </tocsect>
    </tableofcontents>
    </tocsect>
    </tableofcontents>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><bold>UsdPhysics</bold> defines the physics-related prim and property schemas that together form a physics simulation representation.</para>
<para><bold>Rigid Body Physics in USD Overview.</bold></para>
<sect1 id="usd_physics_page_front_1usdPhysics_purpose_and_scope">
<title>Purpose and Scope</title>
<para>While at its launch USD was primarily targeted at film and VFX pipelines, it has been adopted into many other spaces and applications, including the authoring, interchange, and delivery of interactive 3D graphics content. Computer games and 3D web applications are examples of new domains for the integration of this content. In these consumer-facing applications, real-time physics allows realistic user interaction with virtual objects. In professional and academic applications, there are a number of use cases for real-time physics in areas such as mechanical engineering, architecture, artificial intelligence and robotics where vehicles or robots are designed, tested and trained in simulation. This schema extends USD to represent the real-time physics data required to enable these applications.</para>
<para>The realm of simulation is broad. This schema is intended as a baseline initial extension to USD that enables the minimum set of common concepts required to represent rigid body physics. Future iterations and extensions will incrementally add capabilities as needs are identified.</para>
</sect1>
<sect1 id="usd_physics_page_front_1usdPhysics_overall_design">
<title>Overall Design Concerns</title>
<para>The initial usdPhysics schema concerns rigid body simulations. Rigid body simulations are the most broadly applicable category we could identify, with common and long standing uses across all disciplines described above.</para>
<sect2 id="usd_physics_page_front_1usdPhysics_rigid_body">
<title>Rigid Body Simulation Primer</title>
<para>Rigid body simulators take as input a list of rigid bodies and a list of constraints. Given the state, or the state history of the bodies at a specific time, they compute the updated state of the bodies a moment in time later, with the general desire being that the bodies&apos; movement while constrained by the constraints obeys the laws of physics. One can invoke a sequence of such simulation updates to generate an animation.</para>
<para>A rigid body can be described by its pose (position and orientation in a well defined frame of reference), as well as its mass distribution (specified by a center of mass position, total mass, and an inertia tensor). The body will also have a velocity (linear and angular vectors). Pose and velocity are both inputs and outputs of the simulation update.</para>
<para>Constraints describe physical limits between bodies. They can take many forms, but fall primarily into two categories:</para>
<para><itemizedlist>
<listitem><para><bold>Explicit constraints</bold>, often called joints, which create a fixed spatial relationship between two rigid bodies. One example is a requirement that one body never rotate relative to the other body, even if relative translation is possible.</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem><para><bold>Implicit constraints</bold>, most commonly contacts, which are generally created &apos;behind the scenes&apos; by the simulator to ensure that e.g. solid objects do not pass through each other. For the simulator to derive these constraints, each body must be provided with a collision representation (called &apos;collision shape&apos; or &apos;collider&apos;) and physical material properties.</para>
</listitem>
</itemizedlist>
Simulations often share a set of global parameters that influence the simulation of all bodies. It is generally possible to simultaneously create multiple simulations, each with their own set of parameter settings.</para>
</sect2>
<sect2 id="usd_physics_page_front_1usdPhysics_usd_implementation">
<title>USD Implementation</title>
<sect3 id="usd_physics_page_front_1usdPhysics_disambiguation">
<title>Disambiguation</title>
<para>First, it is clear that some terminology commonly used by the physics simulation community, such as &apos;scene&apos;, &apos;joint&apos;, and &apos;material&apos; have different meanings than in VFX, and are already in use in other contexts by USD, so all of the usdPhysics schema classes are prefixed with &apos;Physics&apos; and make use of namespacing to avoid any ambiguity.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_fundamental_editing">
<title>Fundamental Editing Capabilities</title>
<para>A primary assumption in designing this schema was that one of the most common use cases will be to add physics behavior to existing USD content. Furthermore, the conventional wisdom was that to maximize the performance of USD implementations, it is best to avoid inflating the number of USD objects in a scene. Accordingly, the best approach is to attach new API schemas that contain physics attributes to existing USD objects whenever this makes sense. In rare cases there is no object already available to which simulation attributes can be attached in a rational manner, and in these cases, usdPhysics makes use of new USD IsA schemas.</para>
<para>It is vital that any operation to add physics can also be undone, which can be accomplished in most cases using <ref refid="class_usd_prim_1aab70d4fa20d53a6675734205ded2da22" kindref="member">UsdPrim::RemoveAPI()</ref>.</para>
<para>Similarly, in editor use cases it is a common capability to temporarily be able to mute/disable properties, without deleting them outright. Removing an API will make it be no longer &quot;present&quot;, but all data authored to that API still remains. USD allows entire objects to deactivate via an active flag, but it can not be animated over time - which cannot be done with just RemoveAPI(). For a few cases where animating mute behavior is a really common use case, we have defined a boolean enable attribute. (Note that we initially wanted to have the enable flag in a base class for the classes that need it, but this creates problems when multiple enableable APIs are applied to an object. In this case USD only creates a single shared enable flag, which is not what we want.)</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_physics_scenes">
<title>Physics Scenes</title>
<para>A primary requirement is that multiple independent physics simulations can be described within a single USD stage. We found the best way to do this is to create a <ref refid="class_usd_physics_scene" kindref="compound">UsdPhysicsScene</ref> class. It was proposed to use the USD layers concept to partition physics into separate scenes, but the dominant layering idioms are workflow oriented, as opposed to primitive organization. It makes sense to leave those operational principles to a a studio&apos;s data design, rather than overload the concept for simulations. In case there are multiple scenes in a stage, bodies are assigned to specific scenes using a rel from body to scene. If there is only one unique scene, an explicit rel is unnecessary, and bodies are assumed to be associated with the singleton scene. It is not possible to put a single body into multiple scenes, as data races could occur, and it would be impossible to resolve the correct state of body given conflicting simulation.</para>
<para>Scenes can define a gravity vector attribute which accelerates all contained bodies appropriately. Gravity is provided as a separate direction vector and magnitude. This allows for the independent specification of default direction (which is opposite the stage up axis), and default magnitude (earth gravity).</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_types">
<title>Types</title>
<para>USD differentiates between base and role value types. We tried to use the available role types whenever applicable. For example, a velocity is a vector3f rather than a float3.</para>
<para>We chose to use single rather than double precision floats as widely available real time physics simulation software universally use single precision types for best performance, and the use of double or extended precision is only warranted for positions in extremely large spaces, which is already accommodated through the use of USD&apos;s built-in <ref refid="class_usd_geom_xformable" kindref="compound">UsdGeomXformable</ref> type.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_units">
<title>Units</title>
<para>In terms of units, physics makes use of USD&apos;s established concepts of distance and time, and also adds the concept of mass. All of the physical quantities we use can be decomposed into a product of these three basic types. USD does not in general prescribe units for distance and time. It however has the concept of metersPerUnit (<ref refid="struct_usd_geom_tokens_type_1abb367d764f195f37437cf61190f8260b" kindref="member">UsdGeomTokensType::metersPerUnit</ref>) and timeCodesPerSecond (<ref refid="class_usd_stage_1a61c421fcf601c28f2efc5597b8058e22" kindref="member">UsdStage::SetTimeCodesPerSecond()</ref>) metadata which makes it possible to scale content authored at different scales correctly relative to each other when bringing them into a shared scene. However, the class <ref refid="class_usd_geom_point_instancer" kindref="compound">UsdGeomPointInstancer</ref> stores velocity and angular velocity attributes that are specified in units per second and degrees per second, respectively. This indicates a particular preference for degrees and seconds in USD, and we wish to stay consistent with this. This physics extension therefore adopts degrees as the standard angular unit, seconds as the standard time unit, and continues to respect arbitrary units for distance. Additionally we adopt arbitrary mass units and add a kilogramsPerUnit (<ref refid="struct_usd_physics_tokens_type_1a24c37003b1414e39167b1132f765dfec" kindref="member">UsdPhysicsTokensType::kilogramsPerUnit</ref>) metadata which remains consistent with scaling conversions into the International System of Units.</para>
<para>In the schema we indicate the units for each specified quantity as an expression using the terms &apos;distance&apos;, &apos;degrees&apos;, &apos;mass&apos; and &apos;seconds&apos; as defined above. A USD stage can be composed by referencing a number of USD files that may each have differing units; however, the specification of unit is per-stage**, so correctives must be applied to referenced data to bring it into the units of the referencing stage, as part of the act of adding the reference. In the case of linear units, given the hierarchical nature of both references and composition of transformations in a scenegraph, it is possible to &quot;correct&quot; for differing units by applying a scale transformation on the prim where the reference is added. However, for a change of mass units, no such easy corrective is possible; instead, each measurement must be adjusted in an overriding opinion.</para>
<para>Similarly, any simulation outputs can be converted back into their original units before being written back to USD.</para>
<para>A few metric helper APIs (<ref refid="usd_physics_2metrics_8h_1a63ba908d086f1124ede1061c390c2e15" kindref="member">UsdPhysicsGetStageKilogramsPerUnit()</ref>, <ref refid="usd_physics_2metrics_8h_1a1a8f0d08d433f5e0cab9e07982b592ce" kindref="member">UsdPhysicsStageHasAuthoredKilogramsPerUnit()</ref>, <ref refid="usd_physics_2metrics_8h_1a7e2ade44ed9ee0214aafa30e48044a90" kindref="member">UsdPhysicsSetStageKilogramsPerUnit()</ref>, <ref refid="usd_physics_2metrics_8h_1a02be613a54c2a8d537c861a42a3ba474" kindref="member">UsdPhysicsMassUnitsAre()</ref>) are provided to access and set the stage level kilogramsPerUnit metadata.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_default_values">
<title>Default Values</title>
<para>For some attributes in these schemas we desire the ability to signal that we want the simulator to supply a reasonable default value, whatever that may be for the particular simulator. Since USD prefers for all schema attributes to provide &quot;fallback&quot; (i.e. default) values, we specify default values for these attributes explicitly, typically with sentinel values that lie outside of the legal range of values for each particular attribute. For example, if an attribute is normally required to be non-negative, we use -1.0 to request a certain default behavior. Sometimes the attribute can use the entire floating point range, in which case we reserve what is effectively +/- infinity at the edges of this range as sentinels. We will use the floating point &apos;inf&apos; literal which USD supports in files and schemas to denote this. We document such default sentinel behavior on a case by case basis in the schema.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_rigid_bodies">
<title>Rigid Bodies</title>
<para>We represent physics rigid bodies using the <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref>, which can be applied to any <ref refid="class_usd_geom_xformable" kindref="compound">UsdGeomXformable</ref>. <ref refid="class_usd_geom_xformable" kindref="compound">UsdGeomXformable</ref> is the suitable base class as it provides a placement in space via the xform which is also a fundamental property of physics bodies.</para>
<para>Rigid bodies have linear and angular velocity attributes that are specified in local space, to be consistent with velocities in point instancers and a prim&apos;s xform.</para>
<para>Bodies can specify a simulationOwner scene rel for the aforementioned multi-scene simulation scenario.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_interaction_with_usd">
<title>Interaction with the USD hierarchy</title>
<para>If a prim in a USD scene graph hierarchy is marked with <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref>, the behavior is such that with <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref>, all chidlren of the marked prim are assumed to be part of this rigid body, and move rigidly along with the body. This is consistent with the common behavior one expects during hand-animation of a sub-tree. If aggregate properties of the entire rigid body must be computed, such as total mass or the entirety of its collision volume, then the contents of the entire subtree are considered.</para>
<para>Note that it is of course permitted to change/animate the transforms in such a sub-tree, in which case any derived quantities in the physics engine such as center of mass or relative shape poses will be updated. Such animation will however not generate momentum. For example, rapidly animating rigid portions of Luxo Jr. will not cause the lamp to jump, since to compute such behavior we would need to capture the relative masses of multiple independent portions of the lamp, which is not possible if the whole is treated as a single rigid assembly. The correct approach would be to model each of the rigid portions of the lamp as independent rigid bodies, and connect these with joints, which we will discuss later.</para>
<para>It is not possible to have nested bodies. PhysicsRigidBodyAPIs applied to anything in the subtree under a prim that already has a <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref> are ignored. An exception is if a prim has an resetXformStack op. In this case it ignores rigid body parenting, and a rigid body API can then be used to make it dynamic.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_rb_sleep">
<title>Sleep</title>
<para>Large terrestrial simulations have the common property that all objects will eventually fall to the ground and come to rest. It is common for rigid body simulation software to have a notion of &apos;sleeping&apos; such bodies to improve performance. This means that interactions cease to be updated when an equilibrium state is reached, and start to be updated again once the equilibrium state has somehow been disturbed. It is also possible to start off simulations in a sleeping state. We provide <ref refid="struct_usd_physics_tokens_type_1a661e1647f4571f1d5f741917848fac0c" kindref="member">UsdPhysicsTokensType::physicsStartsAsleep</ref> to support this. We have considered exposing the runtime sleep state of each body in the simulation so that it would be visible to USD when the simulation deactivated a body, and to let USD force a body to sleep during simulation. We decided against this since the precise deactivation rules are an implementation detail that can vary significantly between simulations, so we prefer to keep this as a hidden implementation detail for the time being.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_kinematic_bodies">
<title>Kinematic Bodies</title>
<para>In games and VFX it is often desirable to have an animator take full control over a body, even as it interacts with other physics driven bodies. We call such bodies &apos;kinematic&apos;. Kinematic bodies still &apos;pull on&apos; joints and &apos;push on&apos; touching rigid bodies, but their xform is only read, but not written, by the physics simulator, letting the animation system write their xforms. We support such bodies using the <ref refid="struct_usd_physics_tokens_type_1a480125ca509f610a9cd2de8540ec0795" kindref="member">UsdPhysicsTokensType::physicsKinematicEnabled</ref> attribute. Kinematic bodies are not exactly the same thing as an animated static body with a collider: The simulation infers a continuous velocity for the kinematic body from the keyframing, and this velocity will be imparted to dynamic bodies during collisions.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_animation_of_attributes">
<title>Animation of Attributes</title>
<para>We worked with the assumption that every attribute on every class that is not explicitly marked with &quot;uniform&quot; can be animated. Obviously erratic changing of some parameters could make some simulations explode in practice, we believe this is highly implementation dependent and not a reason to generally forbid attribute animation.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_body_mass_properties">
<title>Body Mass Properties</title>
<para>We opted to decouple mass properties from <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref> and place them in a separate <ref refid="class_usd_physics_mass_a_p_i" kindref="compound">UsdPhysicsMassAPI</ref>. <ref refid="class_usd_physics_mass_a_p_i" kindref="compound">UsdPhysicsMassAPI</ref> is not required in cases where the mass properties of an object can be derived from collision geometry (discussed further down in this document) and the <ref refid="class_usd_physics_material_a_p_i" kindref="compound">UsdPhysicsMaterialAPI</ref>. Most commonly, <ref refid="class_usd_physics_mass_a_p_i" kindref="compound">UsdPhysicsMassAPI</ref> is applied in addition to <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref>.</para>
<para>Unlike <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref>, it is also possible to apply <ref refid="class_usd_physics_mass_a_p_i" kindref="compound">UsdPhysicsMassAPI</ref> multiple times in a USD scene graph subtree, in order to make it possible to accumulate the mass of rigid components.</para>
<para>The mass of an object may be specified in multiple ways, and several conflicting settings are resolved using a precedence system that will initially seem rather complex yet but is actually intuitive and practical:</para>
<para><itemizedlist>
<listitem><para>Parents&apos; explicit total masses override any mass properties specified further down in the subtree.</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem><para>Density has lower precedence than mass, so explicit mass always overrides implicit mass that can be computed from volume and density.</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem><para>A density in a child overrides a density specified in a parent for all of the subtree under the child.</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem><para>A density specified via <ref refid="class_usd_physics_mass_a_p_i" kindref="compound">UsdPhysicsMassAPI</ref>, even if it is inherited from a prim higher in the tree, overrides any density specified via a material (see <ref refid="class_usd_physics_material_a_p_i" kindref="compound">UsdPhysicsMaterialAPI</ref> later in this document).</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem><para>Implicit mass at any prim is the computed volume of collision geometry at that prim times the locally effective density, plus the implicit masses of all children in the subtree.</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem><para>Density is assumed to be 1000.0 kg/m3 (approximately the density of water) for volume computation when no other density is specified locally, or in bound materials either locally or higher up in the tree, and this value is converted into the collider&apos;s native units prior to being used for mass computation.</para>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem><para>Mass is assumed to be 1.0 in the mass units used when none is provided explicitly, and there are no collision volumes to derive from.</para>
</listitem>
</itemizedlist>
Implementing this rule set is potentially nontrivial, but it&apos;s important to get right. We plan to make the pseudocode of a mass computation system available that relies on the underlying physics system to compute the volume of collision geometry.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_collision_shapes">
<title>Collision Shapes</title>
<para>Our design for collision shapes defines a <ref refid="class_usd_physics_collision_a_p_i" kindref="compound">UsdPhysicsCollisionAPI</ref> that may be attached to objects of type <ref refid="class_usd_geom_gprim" kindref="compound">UsdGeomGprim</ref> representing graphics geometry. Specifically, we suggest the support of <ref refid="class_usd_geom_capsule" kindref="compound">UsdGeomCapsule</ref>, <ref refid="class_usd_geom_cone" kindref="compound">UsdGeomCone</ref>, <ref refid="class_usd_geom_cube" kindref="compound">UsdGeomCube</ref>, <ref refid="class_usd_geom_cylinder" kindref="compound">UsdGeomCylinder</ref>, <ref refid="class_usd_geom_sphere" kindref="compound">UsdGeomSphere</ref> and <ref refid="class_usd_geom_mesh" kindref="compound">UsdGeomMesh</ref>, though the precise set of supported geoms might be implementation specific. Note also that some implementations might support some of these shapes using potentially faceted convex approximations.</para>
<para>As we have alluded to earlier, a subtree under a <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref> prim may contain multiple collision shape prims (or &apos;colliders&apos;) that are required to resolve the motion of the body as it touches other bodies. For example, a teapot is a single rigid body (the top level prim is marked with <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref>), but it may be composed of multiple Mesh and other Geoms at and under this prim. Each of these parts can gain a <ref refid="class_usd_physics_collision_a_p_i" kindref="compound">UsdPhysicsCollisionAPI</ref> which instructs the system to make this shape&apos;s geom into a collider for the purposes of physics simulation.</para>
<para>It is also possible to have PhysicsCollisionAPIs on prims that are not under a <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref>. These are treated as static colliders <ndash/> shapes that are not moved by physics, but they can still collide with bodies, at which point they are interpreted as having zero velocity and infinite mass. Since static colliders do not have a corresponding <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref>, in this case it is possible for the <ref refid="class_usd_physics_collision_a_p_i" kindref="compound">UsdPhysicsCollisionAPI</ref> <bold>itself</bold> to specify a simulationOwner scene. For any collider that <bold>is</bold> associated with a <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref>, the collider&apos;s simulation owner attribute is ignored.</para>
<para>According to USD rules, <ref refid="class_usd_geom_gprim" kindref="compound">UsdGeomGprim(s)</ref> must generally be leaf prims, and because <ref refid="class_usd_physics_collision_a_p_i" kindref="compound">UsdPhysicsCollisionAPI</ref> can only be applied to <ref refid="class_usd_geom_gprim" kindref="compound">UsdGeomGprim</ref>, it means that there is no opportunity to inherit <ref refid="class_usd_physics_collision_a_p_i" kindref="compound">UsdPhysicsCollisionAPI</ref> attributes down the scene graph. If a mesh is composed of submeshes, all of the submeshes are considered to be part of the collider.</para>
<para>The current design has the drawback that it is not possible to add multiple colliders to a single geom object directly. To add multiple colliders one must create a parent Xform (which receives the <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref>), and then add the original geom as a child, and add any additional colliders as additional children. This is a bit more invasive than we would prefer, but the only alternative would be to make colliders Is-A schemas rather than APIs, which there was a desire to avoid to prevent the number of USD objects from increasing a great deal.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_mesh_into_shapes">
<title>Turning Meshes into Shapes</title>
<para>Simple USD Prims like Sphere, Cylinder, Cube, Cone and Capsule can be used for physics simulation directly with the simple addition of a <ref refid="class_usd_physics_collision_a_p_i" kindref="compound">UsdPhysicsCollisionAPI</ref>. <ref refid="class_usd_geom_mesh" kindref="compound">UsdGeomMesh</ref> is a bit tricky because the state of the art in simulating arbitrary meshes in real time comes with some tradeoffs that users generally want control over. To support this, we allow <ref refid="class_usd_physics_mesh_collision_a_p_i" kindref="compound">UsdPhysicsMeshCollisionAPI</ref> to be applied to <ref refid="class_usd_geom_mesh" kindref="compound">UsdGeomMesh(es)</ref> only, alongside the <ref refid="class_usd_physics_collision_a_p_i" kindref="compound">UsdPhysicsCollisionAPI</ref>. This API has an approximation attribute that lets the user choose between no approximation (generally lowest performance), a simplified mesh, a set of convex hulls, a single convex hull, a bounding box or a bounding sphere. If an implementation does not support a particular kind of approximation, it is recommended that it falls back to the most similar supported option.</para>
<para>Note that use of the subdivision attribute (<ref refid="class_usd_geom_mesh_1a01c7ff0dc2e9b6be9f09db6cfafb7c0a" kindref="member">UsdGeomMesh::GetSubdivisionSchemeAttr()</ref>) can cause features such as corners and edges to be removed from the graphical representation. In order to ensure the physics representation accurately matches the graphical representation, this attribute should be accounted for when generating physics colliders.</para>
<para>Collision meshes may be specified explicitly (for example one that was processed by a particular decimator) by adding the custom collider mesh as a sibling to the original graphics mesh, <ref refid="class_usd_geom_imageable" kindref="compound">UsdGeomImageable</ref> <emphasis>purpose</emphasis> to &quot;guide&quot; so it does not render, and apply <ref refid="class_usd_physics_collision_a_p_i" kindref="compound">UsdPhysicsCollisionAPI</ref> and <ref refid="class_usd_physics_mesh_collision_a_p_i" kindref="compound">UsdPhysicsMeshCollisionAPI</ref> to it specifying no approximation.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_physics_materials">
<title>Physics Materials</title>
<para>Just like graphics, physics uses material properties. These are primarily used to inform friction and collision restitution behavior, in addition to being one of several ways to specify object density as discussed earlier. All these properties are stored in the <ref refid="class_usd_physics_material_a_p_i" kindref="compound">UsdPhysicsMaterialAPI</ref>, which can be applied to a USDShadeMaterial prim as we believe it to be practical to add physics properties to an established USD material library.</para>
<para>USD Physics materials are bound in the same way as graphics materials using <ref refid="class_usd_shade_material_binding_a_p_i" kindref="compound">UsdShadeMaterialBindingAPI</ref>, either wih no material purpose or with a specific &quot;physics&quot; purpose. Note that this approach also permits binding different materials to <ref refid="class_usd_geom_subset" kindref="compound">UsdGeomSubset(s)</ref>. Not all physics simulations support different materials per <ref refid="class_usd_geom_subset" kindref="compound">UsdGeomSubset</ref>, and it&apos;s possible that all but one subset per collider will be ignored by the implementation.</para>
<para>The unitless coefficients dynamicFriction and staticFriction are defined by the Coulomb friction model. The coefficient of restitution is the ratio of the final to initial relative velocity between two objects after they collide. These three properties actually should be defined for each combination of two materials, but this is generally considered impractical. Common practice in real time physics is to define them on each material and then to use a simple formula to combine them, for example by taking the product or the minimum. Currently the default behavior we propose is to average the values, which is the default behavior in popular real time game engines. In the future other combine modes should be exposed.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_plane_shapes">
<title>Plane Shapes</title>
<para>Implicit plane shapes are a very common physics primitive used primarily for testing simple simulations. There are plans to add a Plane class to USD as a UsdGeomGPrim. We look forward to supporting such plane shapes as static colliders when they become available.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_collision_filtering">
<title>Collision Filtering</title>
<para>Even in the simplest practical applications, the need to ignore some collisions occurs often. One might need the sword of a game character to pass through an enemy rather than to bounce off, while wanting it to bounce off walls, for example.</para>
<para>We define a CollisionGroup as an IsA schema with a <ref refid="class_usd_collection_a_p_i" kindref="compound">UsdCollectionAPI</ref> applied, that defines the membership of colliders (objects with a <ref refid="class_usd_physics_collision_a_p_i" kindref="compound">UsdPhysicsCollisionAPI</ref>) in the group. Each group also has a multi-target relationship to other groups (potentially including itself) with which it needs to not collide. Colliders not in any CollisionGroup collide with all other colliders in the scene, except for those colliders which have disabled collision by default.</para>
<para>For behavioral or performance reasons, it is sometimes useful to configure a collider whose collision is disabled by default. To support this, the CollisionGroup has an invertFilteredGroups option; when this value is set, an implementation should disable collisions against all other colliders except for those in the referenced filteredGroups. Note that the collisions which were not disabled may still be further restricted by additional collision groups or pair filters.</para>
<para>When composing a stage from multiple USD scenes, it may be desirable to merge CollisionGroups, particularly if the stage composition is not known ahead of time. For example, a stage composed of multiple characters, each with a ragdoll as well as a character &quot;controller&quot; - the character controllers should not collide with the ragdoll instances. A CollisionGroup contains an optional mergeGroupName, and all groups with matching name should be considered to be part of a single group, whose members and filter groups should be the union of the merged groups. This allows the character file to define a group which disables the controller-versus-ragdoll collisions; by assigning a mergeGroupName to this group, the controller can be filtered against ragdoll bodies in all other instances of the character.</para>
<para>Care should be taken when merging groups with differing invertFilteredGroups options; merging of groups should only ever cause collision pairs to become disabled - i.e. a filter cannot re-enable a pair that has been disabled by any other group. Consider an inverted group which references only GroupX (i.e. disables collisions with everything except those in GroupX). When merging this group with a non-inverting group referencing the same GroupX (i.e. disables collisions against GroupX) - the merged group will collide with nothing, since the combined rules of the merged groups will filter out any other body.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_pairwise_filtering">
<title>Pairwise Filtering</title>
<para>Sometimes group based filtering is insufficiently powerful to take care of some filtering special cases. One would for example set up group based filtering such that bodies of human characters collide against extremities like arms and legs, generally assuming that these arms and legs belong to different humans than the bodies. One however often doesn&apos;t want the extremities of a particular human to collide with its own body, which is hard to avoid during a lot of constant close proximity movement. To cover this case we have the FilteringPairsAPI, which specifies a multi-target relationship to other objects with which collisions are explicitly disabled. This pairwise filtering has precedence over group based filtering.</para>
<para>The FilteringPairsAPI can be applied to objects with a <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref>, <ref refid="class_usd_physics_collision_a_p_i" kindref="compound">UsdPhysicsCollisionAPI</ref>, or UsdPhysicsArticulationAPI.</para>
<para>It is sufficient to have a rel from an object A to an object B, to get the filtering behavior. In this case the backwards rel from B to A is implicit and not necessary.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_joints">
<title>Joints</title>
<para>Joints are generally fixed attachments that can represent the way a drawer is attached to a cabinet, a wheel to a car, or links of a robot to each-other. Here we try to focus on a set of capabilities that are common to most simulation packages and sufficiently expressive for a large number of applications.</para>
<para>Mathematically, jointed assemblies can be modeled either in maximal (world space) or reduced (relative to other bodies) coordinates. Both representations have pros and cons. We are proposing a USD representation that will work with both approaches.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_joint_reference_frames">
<title>Joint Reference Frames</title>
<para>The joint base type is the IsA class <ref refid="class_usd_physics_joint" kindref="compound">UsdPhysicsJoint</ref>. Joints don&apos;t necessarily have a single unique Xform in space, rather, they are defined by two distinct frames, one relative to each of the two bodies which they connect.</para>
<para>These two frames might not work out to be the same position and orientation in world space because of either the permitted relative movement of the joint (think of a car suspension moving up and down: the joint frame of the suspension is constant relative to both the car body and the car axle, yet the axle and undercarriage move relative to each other) or the error of approximate simulations that can permit the joint to slightly pull apart when subjected to significant forces or velocities.</para>
<para>It does not make sense to derive <ref refid="class_usd_physics_joint" kindref="compound">UsdPhysicsJoint</ref> from <ref refid="class_usd_geom_xformable" kindref="compound">UsdGeomXformable</ref> because <ref refid="class_usd_geom_xformable" kindref="compound">UsdGeomXformable</ref> has only a single Xform, and a joint has many. We could have created an asymmetrical solution where the secondary xform is added on, or split the joint object into two separate joint frames that are parented into the scene graph and are then somehow pairwise cross referenced, but we opted to go with an entirely new class that has all the information we need in a symmetrical fashion.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_jointed_bodies">
<title>Jointed Bodies</title>
<para>A joint defines a pair of relationships to <ref refid="class_usd_geom_xformable" kindref="compound">UsdGeomXformable(s)</ref>, to which we will refer as the &apos;bodies&apos;. Simulation of the joint is possible if at least one of these has a <ref refid="class_usd_physics_rigid_body_a_p_i" kindref="compound">UsdPhysicsRigidBodyAPI</ref> on it, or on an ancestor. If either rel is not defined, it is treated as equivalent to attaching to the static world frame, though it is recommended to always work with two well defined <ref refid="class_usd_geom_xformable" kindref="compound">UsdGeomXformable(s)</ref>.</para>
<para>The joint space relative to each body is a translation and orientation only, scaling is not supported. (This is a general tension between graphics and physics. Real world objects cannot scale arbitrarily, and simulations therefore tend to not support scaling during rigid body simulation). For this reason we don&apos;t use a general USD xform that is too flexible for our needs, but rather a separate position and orientation quaternion. (Note however that this local joint space is fixed in the prim&apos;s local space, which of course CAN be scaled using the prim&apos;s own Xform scaling. This means that if a doorknob is attached to a door at a particular position, it will continue to appear in the same correct position on the door regardless of how the door is scaled, without having to adjust the joint position.)</para>
<para>We generally desire to have the two joint frames line up in world space, at least along their constrained degrees of freedom. This condition can be violated if either body is moved in world space, either by changing its own or one of its parents&apos; transforms, or if either body rels is changed. As a result it is desirable to recompute the joint frames when the connected bodies or their world space transforms have changed.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_joint_collision_filtering">
<title>Joint Collision Filtering</title>
<para>It is common practice to disable collisions between the jointed bodies so that their collision shapes don&apos;t interfere. It is therefore the default behavior that collisions between the two subtrees indicated by the two body rel-s are ignored. This default filtering behavior can be opted out of using the joint&apos;s collisionEnabled attribute. No filtering occurs if either rel is undefined.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_breaking_disabling_joints">
<title>Breaking and Disabling Joints</title>
<para>Breaking force is a practical property useful for all joints; joints can break when sufficient force is applied. For example a door can be ripped off its hinges. This can be modeled using the breakForce and breakTorque attributes.</para>
<para>Joints can entirely be temporarily disabled just like rigid bodies or colliders. Contrary to breaking, which is a (within a simulation run irreversible) simulated behavior, disabling is a request to not simulate the joint at all.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_joint_subtypes">
<title>Joint Subtypes</title>
<para>It is possible to derive a number of specific joint types, however the Joint API itself can represent a generic configurable joint, so in that sense it is not an abstract type.</para>
<para>The subtypes <ref refid="class_usd_physics_spherical_joint" kindref="compound">UsdPhysicsSphericalJoint</ref>, <ref refid="class_usd_physics_revolute_joint" kindref="compound">UsdPhysicsRevoluteJoint</ref> and <ref refid="class_usd_physics_prismatic_joint" kindref="compound">UsdPhysicsPrismaticJoint</ref> both define a primary axis (Following the USD axis definition pattern established in e.g. <ref refid="class_usd_geom_capsule" kindref="compound">UsdGeomCapsule</ref> and <ref refid="class_usd_geom_cylinder" kindref="compound">UsdGeomCylinder</ref>) and a top and bottom motion limit along it.</para>
<para><ref refid="class_usd_physics_distance_joint" kindref="compound">UsdPhysicsDistanceJoint</ref> defines a min and max distance between the attachment points. The <ref refid="class_usd_physics_fixed_joint" kindref="compound">UsdPhysicsFixedJoint</ref> has no additional properties and simply locks all relative degrees of freedom.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_limits_drives">
<title>Joint Limits and Drives</title>
<para>Instead of using one of the predefined joint subtypes, it is also possible to compose a custom joint from a set of limits and drives. Limits and drives are multi-apply schemas, so one can apply multiple instances, one for each degree of freedom. The degree of freedom is specified via the <ref refid="class_tf_token" kindref="compound">TfToken</ref> (effectively a string, one of &quot;transX&quot;, &quot;transY&quot;, &quot;transZ&quot;, &quot;rotX&quot;, &quot;rotY&quot;, &quot;rotZ&quot;, &quot;distance&quot;, that is postpended after the class name.)</para>
<para>The limit API further contains optional low and high limit attributes.</para>
<para>The drive API allows joints to be motorized along degrees of freedom. It may specify either a force or acceleration drive (The strength of force drives is impacted by the mass of the bodies attached to the joint, an acceleration drive is not). It also has a target value to reach, and one can specify if the target is a goal position or velocity. One can limit the maximum force the drive can apply, and one can specify a spring and damping coefficient.</para>
<para>The resulting drive force or acceleration is proportional to <programlisting><codeline><highlight class="normal">stiffness<sp/>*<sp/>(targetPosition<sp/>-<sp/>p)<sp/>+<sp/>damping<sp/>*<sp/>(targetVelocity<sp/>-<sp/>v)</highlight></codeline>
</programlisting> where p is the relative pose space motion of the joint (the axial rotation of a revolute joint, or axial translation for a prismatic joint) and v is the rate of change of this motion.</para>
<para>For all limits that specify ranges, a &quot;low&quot; limit larger than the &quot;high&quot; limit means the joint motion along that axis is locked.</para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_articulations">
<title>Articulations</title>
<para>Earlier we mentioned that we support reduced coordinate joints, which require some additional specification. We decided to do this with a minimal extension of the above maximal joints. Any prim of the USD scene graph hierarchy may be marked with an <ref refid="class_usd_physics_articulation_root_a_p_i" kindref="compound">UsdPhysicsArticulationRootAPI</ref>. This informs the simulation that any joints found in the subtree should preferentially be simulated using a reduced coordinate approach. For floating articulations (robotics jargon for something not bolted down, e.g. a wheeled robot or a quadcopter), this API should be used on the root body (typically the central mass the wheels or rotors are attached to), or a direct or indirect parent prim. For fixed articulations (robotics jargon for e.g. a robot arm for welding that is bolted to the floor), this API can be on a direct or indirect parent of the root joint which is connected to the world, or on the joint itself. If there are multiple qualifying bodies or joints under an <ref refid="class_usd_physics_articulation_root_a_p_i" kindref="compound">UsdPhysicsArticulationRootAPI</ref> prim, each is made into a separate articulation root.</para>
<para>This should in general make it possible to uniquely identify a distinguished root body or root joint for the articulation. From this root, a tree of bodies and joints is identified that is not to contain loops (which may be closed by joint collections). If loops are found, they may be broken at an arbitrary location. Alternatively, a joint in the loop may use its excludeFromArticulation attribute flag to denote that it wishes to remain a maximal joint, and at this point the loop is then broken.</para>
</sect3>
</sect2>
<sect2 id="usd_physics_page_front_1usdPhysics_examples">
<title>Examples</title>
<sect3 id="usd_physics_page_front_1usdPhysics_box_on_box">
<title>Box on Box</title>
<para><programlisting filename="examples/usdPhysicsBoxOnBox2.usda"></programlisting></para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_box_on_quad">
<title>Box on Quad</title>
<para><programlisting filename="examples/usdPhysicsBoxOnQuad.usda"><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal">#More<sp/>advanced<sp/>example<sp/>showing<sp/>mesh<sp/>collisions</highlight></codeline>
<codeline><highlight class="normal">#and<sp/>center<sp/>of<sp/>mass<sp/>offset.<sp/><sp/>We<sp/>expect<sp/>to<sp/>have<sp/>the</highlight></codeline>
<codeline><highlight class="normal">#quad<sp/>be<sp/>represented<sp/>as<sp/>a<sp/>convex<sp/>mesh<sp/>and<sp/>have<sp/>the<sp/></highlight></codeline>
<codeline><highlight class="normal">#cube<sp/>come<sp/>to<sp/>rest<sp/>on<sp/>it,<sp/>balanced<sp/>on<sp/>one<sp/>of<sp/>its<sp/>corners.</highlight></codeline>
<codeline><highlight class="normal">(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>defaultPrim<sp/>=<sp/>&quot;World&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>endTimeCode<sp/>=<sp/>100</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>metersPerUnit<sp/>=<sp/>0.01</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>startTimeCode<sp/>=<sp/>0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>timeCodesPerSecond<sp/>=<sp/>24</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>upAxis<sp/>=<sp/>&quot;Z&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>kilogramsPerUnit<sp/>=<sp/>1</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">def<sp/>Xform<sp/>&quot;World&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>PhysicsScene<sp/>&quot;PhysicsScene&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#Added<sp/>a<sp/>mass<sp/>API<sp/>so<sp/>we<sp/>can<sp/>offset<sp/>the<sp/>center<sp/>of<sp/>mass.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Cube<sp/>&quot;BoxActor&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;,<sp/>&quot;PhysicsRigidBodyAPI&quot;,<sp/>&quot;PhysicsMassAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#explicit<sp/>mass</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>physics:mass<sp/>=<sp/>10.0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#Offset<sp/>center<sp/>of<sp/>mass<sp/>so<sp/>the<sp/>cube<sp/>settles<sp/>on<sp/>its<sp/>corner</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>point3f<sp/>physics:centerOfMass<sp/>=<sp/>(40.0,<sp/>40.0,<sp/>40.0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.2784314,<sp/>0.4117647,<sp/>1)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>size<sp/>=<sp/>25</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(0,<sp/>0,<sp/>500)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#A<sp/>quad<sp/>mesh<sp/>that<sp/>serves<sp/>as<sp/>the<sp/>ground.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Mesh<sp/>&quot;Ground&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;,<sp/>&quot;PhysicsMeshCollisionAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#Approximate<sp/>with<sp/>a<sp/>convex<sp/>hull,<sp/>if<sp/>we<sp/>remove<sp/>this,<sp/>it<sp/>will</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#be<sp/>used<sp/>directly</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token<sp/>physics:approximation<sp/>=<sp/>&quot;convexHull&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token<sp/>subdivisionScheme<sp/>=<sp/>&quot;none&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>bool<sp/>doubleSided<sp/>=<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int[]<sp/>faceVertexCounts<sp/>=<sp/>[4]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int[]<sp/>faceVertexIndices<sp/>=<sp/>[0,<sp/>1,<sp/>2,<sp/>3]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>normal3f[]<sp/>normals<sp/>=<sp/>[(0,<sp/>0,<sp/>1),<sp/>(0,<sp/>0,<sp/>1),<sp/>(0,<sp/>0,<sp/>1),<sp/>(0,<sp/>0,<sp/>1)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>point3f[]<sp/>points<sp/>=<sp/>[(-1,<sp/>1,<sp/>0),<sp/>(1,<sp/>1,<sp/>0),<sp/>(1,<sp/>-1,<sp/>0),<sp/>(-1,<sp/>-1,<sp/>0)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.5,<sp/>0.5,<sp/>0.5)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>texCoord2f[]<sp/>primvars:st<sp/>=<sp/>[(0,<sp/>1),<sp/>(1,<sp/>1),<sp/>(1,<sp/>0),<sp/>(0,<sp/>0)]<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>interpolation<sp/>=<sp/>&quot;varying&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float3<sp/>xformOp:scale<sp/>=<sp/>(750,<sp/>750,<sp/>750)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:scale&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>SphereLight<sp/>&quot;SphereLight&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>intensity<sp/>=<sp/>30000</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>radius<sp/>=<sp/>150</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(650,<sp/>0,<sp/>1150)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_spheres_with_material">
<title>Spheres with Materials</title>
<para><programlisting filename="examples/usdPhysicsSpheresWithMaterial.usda"><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal">#Shows<sp/>two<sp/>spheres,<sp/>one<sp/>with<sp/>high</highlight></codeline>
<codeline><highlight class="normal">#and<sp/>one<sp/>with<sp/>low<sp/>bounce,<sp/>by<sp/>using<sp/>materials.</highlight></codeline>
<codeline><highlight class="normal">#Also<sp/>uses<sp/>a<sp/>trimesh<sp/>ground<sp/>quad.</highlight></codeline>
<codeline><highlight class="normal">(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>defaultPrim<sp/>=<sp/>&quot;World&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>endTimeCode<sp/>=<sp/>100</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>metersPerUnit<sp/>=<sp/>0.01</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>startTimeCode<sp/>=<sp/>0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>timeCodesPerSecond<sp/>=<sp/>24</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>upAxis<sp/>=<sp/>&quot;Z&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#New<sp/>mass<sp/>scaling</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>kilogramsPerUnit<sp/>=<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">def<sp/>Xform<sp/>&quot;World&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>PhysicsScene<sp/>&quot;PhysicsScene&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Sphere<sp/>&quot;RegularSphere&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;,<sp/>&quot;PhysicsRigidBodyAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rel<sp/>material:binding:physics<sp/>=<sp/>&lt;/World/Looks/RegularMaterial&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.2784314,<sp/>0.4117647,<sp/>1)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(0,<sp/>0,<sp/>500)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float3<sp/>xformOp:scale<sp/>=<sp/>(25,<sp/>25,<sp/>25)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;,<sp/>&quot;xformOp:scale&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Sphere<sp/>&quot;BouncySphere&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;,<sp/>&quot;PhysicsRigidBodyAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rel<sp/>material:binding:physics<sp/>=<sp/>&lt;/World/Looks/BouncyMaterial&gt;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bindMaterialAs<sp/>=<sp/>&quot;weakerThanDescendants&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.8784314,<sp/>0.2117647,<sp/>0.1)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(300,<sp/>0,<sp/>500)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float3<sp/>xformOp:scale<sp/>=<sp/>(25,<sp/>25,<sp/>25)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;,<sp/>&quot;xformOp:scale&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Mesh<sp/>&quot;Ground&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int[]<sp/>faceVertexCounts<sp/>=<sp/>[4]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int[]<sp/>faceVertexIndices<sp/>=<sp/>[3,<sp/>2,<sp/>1,<sp/>0]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token<sp/>subdivisionScheme<sp/>=<sp/>&quot;none&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>normal3f[]<sp/>normals<sp/>=<sp/>[(0,<sp/>0,<sp/>1),<sp/>(0,<sp/>0,<sp/>1),<sp/>(0,<sp/>0,<sp/>1),<sp/>(0,<sp/>0,<sp/>1)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>point3f[]<sp/>points<sp/>=<sp/>[(-1,<sp/>1,<sp/>0),<sp/>(1,<sp/>1,<sp/>0),<sp/>(1,<sp/>-1,<sp/>0),<sp/>(-1,<sp/>-1,<sp/>0)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.5,<sp/>0.5,<sp/>0.5)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>texCoord2f[]<sp/>primvars:st<sp/>=<sp/>[(0,<sp/>1),<sp/>(1,<sp/>1),<sp/>(1,<sp/>0),<sp/>(0,<sp/>0)]<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>interpolation<sp/>=<sp/>&quot;varying&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float3<sp/>xformOp:scale<sp/>=<sp/>(750,<sp/>750,<sp/>750)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:scale&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Scope<sp/>&quot;Looks&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>def<sp/>Material<sp/>&quot;RegularMaterial&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsMaterialAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>physics:density<sp/>=<sp/>10</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>physics:restitution<sp/>=<sp/>0.1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>def<sp/>Material<sp/>&quot;BouncyMaterial&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsMaterialAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>physics:density<sp/>=<sp/>10</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>physics:restitution<sp/>=<sp/>0.8</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>SphereLight<sp/>&quot;SphereLight&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>intensity<sp/>=<sp/>30000</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>radius<sp/>=<sp/>150</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(650,<sp/>0,<sp/>1150)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_group_filtering">
<title>Group Filtering</title>
<para><programlisting filename="examples/usdPhysicsGroupFiltering.usda"><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal">#Shows<sp/>two<sp/>boxes<sp/>that<sp/>collide<sp/>with<sp/>a<sp/>ground<sp/>box</highlight></codeline>
<codeline><highlight class="normal">#but<sp/>do<sp/>not<sp/>collide<sp/>with<sp/>each<sp/>other<sp/>thanks<sp/>to</highlight></codeline>
<codeline><highlight class="normal">#group<sp/>based<sp/>filtering.</highlight></codeline>
<codeline><highlight class="normal">(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>defaultPrim<sp/>=<sp/>&quot;World&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>endTimeCode<sp/>=<sp/>100</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>metersPerUnit<sp/>=<sp/>0.01</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>startTimeCode<sp/>=<sp/>0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>timeCodesPerSecond<sp/>=<sp/>24</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>upAxis<sp/>=<sp/>&quot;Z&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>kilogramsPerUnit<sp/>=<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">def<sp/>Xform<sp/>&quot;World&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>PhysicsScene<sp/>&quot;PhysicsScene&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Cube<sp/>&quot;Box1&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;,<sp/>&quot;PhysicsRigidBodyAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.2784314,<sp/>0.4117647,<sp/>1)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>size<sp/>=<sp/>25</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(0,<sp/>0,<sp/>50)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Cube<sp/>&quot;Box2&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;,<sp/>&quot;PhysicsRigidBodyAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.2784314,<sp/>0.4117647,<sp/>1)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>size<sp/>=<sp/>25</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(0,<sp/>0,<sp/>100)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>PhysicsCollisionGroup<sp/>&quot;DynamicGroup&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;CollectionAPI:colliders&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>rel<sp/>collection:colliders:includes<sp/>=<sp/>[</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;/World/Box1&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;/World/Box2&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>rel<sp/>physics:filteredGroups<sp/>=<sp/>[</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;/World/DynamicGroup&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Cube<sp/>&quot;Ground&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.5,<sp/>0.5,<sp/>0.5)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float3<sp/>xformOp:scale<sp/>=<sp/>(750,<sp/>750,<sp/>10)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:scale&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>SphereLight<sp/>&quot;SphereLight&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>intensity<sp/>=<sp/>30000</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>radius<sp/>=<sp/>150</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(650,<sp/>0,<sp/>1150)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_pair_filtering">
<title>Pair Filtering</title>
<para><programlisting filename="examples/usdPhysicsPairFiltering.usda"><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal">(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>defaultPrim<sp/>=<sp/>&quot;World&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>endTimeCode<sp/>=<sp/>100</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>metersPerUnit<sp/>=<sp/>0.01</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>startTimeCode<sp/>=<sp/>0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>timeCodesPerSecond<sp/>=<sp/>24</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>upAxis<sp/>=<sp/>&quot;Z&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>kilogramsPerUnit<sp/>=<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">def<sp/>Xform<sp/>&quot;World&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>PhysicsScene<sp/>&quot;PhysicsScene&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Cube<sp/>&quot;Box1&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;,<sp/>&quot;PhysicsRigidBodyAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.2784314,<sp/>0.4117647,<sp/>1)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>size<sp/>=<sp/>25</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(0,<sp/>0,<sp/>50)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Cube<sp/>&quot;Box2&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;,<sp/>&quot;PhysicsRigidBodyAPI&quot;,<sp/>&quot;PhysicsFilteredPairsAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>rel<sp/>physics:filteredPairs<sp/>=<sp/>&lt;/World/Box1&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.2784314,<sp/>0.4117647,<sp/>1)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>size<sp/>=<sp/>25</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(0,<sp/>0,<sp/>100)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Cube<sp/>&quot;Ground&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.5,<sp/>0.5,<sp/>0.5)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float3<sp/>xformOp:scale<sp/>=<sp/>(750,<sp/>750,<sp/>10)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:scale&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>SphereLight<sp/>&quot;SphereLight&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>intensity<sp/>=<sp/>30000</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>radius<sp/>=<sp/>150</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(650,<sp/>0,<sp/>1150)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_joint_example">
<title>Joint</title>
<para><programlisting filename="examples/usdPhysicsJoints.usda"><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal">#Shows<sp/>a<sp/>joint<sp/>which<sp/>is<sp/>driven<sp/>to<sp/>rotate</highlight></codeline>
<codeline><highlight class="normal">#around<sp/>the<sp/>vertical<sp/>axis<sp/>with<sp/>a<sp/>constant</highlight></codeline>
<codeline><highlight class="normal">#speed.</highlight></codeline>
<codeline><highlight class="normal">(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>defaultPrim<sp/>=<sp/>&quot;World&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>endTimeCode<sp/>=<sp/>100</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>metersPerUnit<sp/>=<sp/>0.01</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>startTimeCode<sp/>=<sp/>0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>timeCodesPerSecond<sp/>=<sp/>24</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>upAxis<sp/>=<sp/>&quot;Z&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>kilogramsPerUnit<sp/>=<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">def<sp/>Xform<sp/>&quot;World&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>PhysicsScene<sp/>&quot;physicsScene&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float3<sp/>gravity<sp/>=<sp/>(0,<sp/>0,<sp/>-1000)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Cube<sp/>&quot;StaticBox&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.64705884,<sp/>0.08235294,<sp/>0.08235294)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>size<sp/>=<sp/>100</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>quatf<sp/>xformOp:orient<sp/>=<sp/>(1,<sp/>0,<sp/>0,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float3<sp/>xformOp:scale<sp/>=<sp/>(0.1,<sp/>1,<sp/>0.1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(0,<sp/>0,<sp/>1000)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;,<sp/>&quot;xformOp:orient&quot;,<sp/>&quot;xformOp:scale&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Cube<sp/>&quot;DynamicBox&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;,<sp/>&quot;PhysicsRigidBodyAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.2784314,<sp/>0.64705884,<sp/>1)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>size<sp/>=<sp/>100</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>quatf<sp/>xformOp:orient<sp/>=<sp/>(1,<sp/>0,<sp/>0,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float3<sp/>xformOp:scale<sp/>=<sp/>(0.1,<sp/>1,<sp/>0.1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(0,<sp/>120,<sp/>1000)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;,<sp/>&quot;xformOp:orient&quot;,<sp/>&quot;xformOp:scale&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#Joint<sp/>with<sp/>5<sp/>limits<sp/>and<sp/>one<sp/>drive</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>PhysicsJoint<sp/>&quot;D6Joint&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsLimitAPI:transX&quot;,<sp/>&quot;PhysicsLimitAPI:transY&quot;,<sp/>&quot;PhysicsLimitAPI:transZ&quot;,<sp/>&quot;PhysicsLimitAPI:rotX&quot;,<sp/>&quot;PhysicsLimitAPI:rotY&quot;,<sp/>&quot;PhysicsDriveAPI:rotZ&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rel<sp/>physics:body0<sp/>=<sp/>&lt;/World/StaticBox&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rel<sp/>physics:body1<sp/>=<sp/>&lt;/World/DynamicBox&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>limit:rotX:physics:high<sp/>=<sp/>-1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>limit:rotX:physics:low<sp/>=<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>limit:rotY:physics:high<sp/>=<sp/>-1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>limit:rotY:physics:low<sp/>=<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>limit:transX:physics:high<sp/>=<sp/>-1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>limit:transX:physics:low<sp/>=<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>limit:transY:physics:high<sp/>=<sp/>-1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>limit:transY:physics:low<sp/>=<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>limit:transZ:physics:high<sp/>=<sp/>-1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>limit:transZ:physics:low<sp/>=<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>drive:rotZ:physics:targetVelocity<sp/>=<sp/>10.0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>drive:rotZ:physics:damping<sp/>=<sp/>9999.0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>point3f<sp/>physics:localPos0<sp/>=<sp/>(0,<sp/>60,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>point3f<sp/>physics:localPos1<sp/>=<sp/>(0,<sp/>-60,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>quatf<sp/>physics:localRot0<sp/>=<sp/>(1,<sp/>0,<sp/>0,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>quatf<sp/>physics:localRot1<sp/>=<sp/>(1,<sp/>0,<sp/>0,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>SphereLight<sp/>&quot;SphereLight&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>intensity<sp/>=<sp/>30000</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>radius<sp/>=<sp/>150</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(650,<sp/>0,<sp/>1150)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="usd_physics_page_front_1usdPhysics_distance_joint_example">
<title>Distance Joint</title>
<para><programlisting filename="examples/usdPhysicsDistanceJoint.usda"><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal">#Shows<sp/>a<sp/>dynamic<sp/>box<sp/>connected</highlight></codeline>
<codeline><highlight class="normal">#to<sp/>a<sp/>fixed<sp/>box<sp/>with<sp/>a<sp/>distance<sp/>joint.</highlight></codeline>
<codeline><highlight class="normal">(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>defaultPrim<sp/>=<sp/>&quot;World&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>endTimeCode<sp/>=<sp/>100</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>metersPerUnit<sp/>=<sp/>0.01</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>startTimeCode<sp/>=<sp/>0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>timeCodesPerSecond<sp/>=<sp/>24</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>upAxis<sp/>=<sp/>&quot;Z&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>kilogramsPerUnit<sp/>=<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">def<sp/>Xform<sp/>&quot;World&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>PhysicsScene<sp/>&quot;physicsScene&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Cube<sp/>&quot;StaticBox&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.64705884,<sp/>0.08235294,<sp/>0.08235294)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>size<sp/>=<sp/>100</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>quatf<sp/>xformOp:orient<sp/>=<sp/>(1,<sp/>0,<sp/>0,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float3<sp/>xformOp:scale<sp/>=<sp/>(0.1,<sp/>1,<sp/>0.1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(0,<sp/>0,<sp/>1000)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;,<sp/>&quot;xformOp:orient&quot;,<sp/>&quot;xformOp:scale&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>Cube<sp/>&quot;DynamicBox&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prepend<sp/>apiSchemas<sp/>=<sp/>[&quot;PhysicsCollisionAPI&quot;,<sp/>&quot;PhysicsRigidBodyAPI&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color3f[]<sp/>primvars:displayColor<sp/>=<sp/>[(0.2784314,<sp/>0.64705884,<sp/>1)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>size<sp/>=<sp/>100</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float3<sp/>velocity<sp/>=<sp/>(0,<sp/>0,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>quatf<sp/>xformOp:orient<sp/>=<sp/>(1,<sp/>0,<sp/>0,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float3<sp/>xformOp:scale<sp/>=<sp/>(0.1,<sp/>1,<sp/>0.1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(0,<sp/>120,<sp/>1000)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;,<sp/>&quot;xformOp:orient&quot;,<sp/>&quot;xformOp:scale&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>DistancePhysicsJoint<sp/>&quot;DistanceJoint&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rel<sp/>physics:body0<sp/>=<sp/>&lt;/World/StaticBox&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rel<sp/>physics:body1<sp/>=<sp/>&lt;/World/DynamicBox&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float3<sp/>physics:localPos0<sp/>=<sp/>(0,<sp/>60,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float3<sp/>physics:localPos1<sp/>=<sp/>(0,<sp/>-60,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>quatf<sp/>physics:localRot0<sp/>=<sp/>(1,<sp/>0,<sp/>0,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>quatf<sp/>physics:localRot1<sp/>=<sp/>(1,<sp/>0,<sp/>0,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>physics:maxDistance<sp/>=<sp/>50</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>physics:minDistance<sp/>=<sp/>10</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>SphereLight<sp/>&quot;SphereLight&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>intensity<sp/>=<sp/>30000</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>radius<sp/>=<sp/>150</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double3<sp/>xformOp:translate<sp/>=<sp/>(650,<sp/>0,<sp/>1150)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>token[]<sp/>xformOpOrder<sp/>=<sp/>[&quot;xformOp:translate&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
</sect3>
</sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
