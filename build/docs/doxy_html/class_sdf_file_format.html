<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: SdfFileFormat Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_sdf_file_format.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="class_sdf_file_format-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SdfFileFormat Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for file format implementations.  
 <a href="class_sdf_file_format.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SdfFileFormat:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_sdf_file_format__inherit__graph.png" border="0" usemap="#_sdf_file_format_inherit__map" alt="Inheritance graph"/></div>
<map name="_sdf_file_format_inherit__map" id="_sdf_file_format_inherit__map">
<area shape="rect"  title="Base class for file format implementations." alt="" coords="274,80,384,107"/>
<area shape="rect"  href="class_sdf_text_file_format.html" title="Sdf text file format." alt="" coords="9,155,148,181"/>
<area shape="rect"  href="class_usd_usdc_file_format.html" title="File format for binary Usd files." alt="" coords="172,155,319,181"/>
<area shape="rect"  href="class_usd_usd_file_format.html" title="File format for USD files." alt="" coords="343,155,483,181"/>
<area shape="rect"  href="class_usd_usdz_file_format.html" title="File format for package .usdz files." alt="" coords="508,155,655,181"/>
<area shape="rect"  href="class_tf_ref_base.html" title="Enable a concrete base class for use with TfRefPtr." alt="" coords="225,5,313,32"/>
<area shape="rect"  href="class_tf_weak_base.html" title="Enable a concrete base class for use with TfWeakPtr." alt="" coords="338,5,440,32"/>
<area shape="rect"  href="class_usd_usda_file_format.html" title="File format used by textual USD files." alt="" coords="5,229,152,256"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1dfd2030337b6243cd6424fce7397590"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a></td></tr>
<tr class="memdesc:a1dfd2030337b6243cd6424fce7397590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for specifying additional file format-specific arguments to the various API below.  <a href="#a1dfd2030337b6243cd6424fce7397590">More...</a><br /></td></tr>
<tr class="separator:a1dfd2030337b6243cd6424fce7397590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_tf_ref_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_tf_ref_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_tf_ref_base.html">TfRefBase</a></td></tr>
<tr class="memitem:a86baed63f8017038997266bdd638f65e inherit pub_types_class_tf_ref_base"><td class="memItemLeft" align="right" valign="top"><a id="a86baed63f8017038997266bdd638f65e"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>UniqueChangedFuncPtr</b>) (<a class="el" href="class_tf_ref_base.html">TfRefBase</a> const *, bool)</td></tr>
<tr class="separator:a86baed63f8017038997266bdd638f65e inherit pub_types_class_tf_ref_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a48e9cf3f2434d3311eeb2e04c10e8156"><td class="memItemLeft" align="right" valign="top"><a id="a48e9cf3f2434d3311eeb2e04c10e8156"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SdfFileFormat</b> (const <a class="el" href="class_sdf_file_format.html">SdfFileFormat</a> &amp;)=delete</td></tr>
<tr class="separator:a48e9cf3f2434d3311eeb2e04c10e8156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae044dff6cb8c0aa5231692938ce0d287"><td class="memItemLeft" align="right" valign="top"><a id="ae044dff6cb8c0aa5231692938ce0d287"></a>
<a class="el" href="class_sdf_file_format.html">SdfFileFormat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_sdf_file_format.html">SdfFileFormat</a> &amp;)=delete</td></tr>
<tr class="separator:ae044dff6cb8c0aa5231692938ce0d287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd6905e6ee12562d4702db19fe6cc1f"><td class="memItemLeft" align="right" valign="top">SDF_API const <a class="el" href="class_sdf_schema_base.html">SdfSchemaBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a3bd6905e6ee12562d4702db19fe6cc1f">GetSchema</a> () const</td></tr>
<tr class="memdesc:a3bd6905e6ee12562d4702db19fe6cc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the schema for this format.  <a href="#a3bd6905e6ee12562d4702db19fe6cc1f">More...</a><br /></td></tr>
<tr class="separator:a3bd6905e6ee12562d4702db19fe6cc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94cee934d3f9f57ddec5d6ba4ab0f72"><td class="memItemLeft" align="right" valign="top">SDF_API const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#af94cee934d3f9f57ddec5d6ba4ab0f72">GetFormatId</a> () const</td></tr>
<tr class="memdesc:af94cee934d3f9f57ddec5d6ba4ab0f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the format identifier.  <a href="#af94cee934d3f9f57ddec5d6ba4ab0f72">More...</a><br /></td></tr>
<tr class="separator:af94cee934d3f9f57ddec5d6ba4ab0f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc99189439fce34c0c63d91a476b1b8"><td class="memItemLeft" align="right" valign="top">SDF_API const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#affc99189439fce34c0c63d91a476b1b8">GetTarget</a> () const</td></tr>
<tr class="memdesc:affc99189439fce34c0c63d91a476b1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target for this file format.  <a href="#affc99189439fce34c0c63d91a476b1b8">More...</a><br /></td></tr>
<tr class="separator:affc99189439fce34c0c63d91a476b1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2231eaa1ca0583f91a97f07cd51f731"><td class="memItemLeft" align="right" valign="top">SDF_API const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#ae2231eaa1ca0583f91a97f07cd51f731">GetFileCookie</a> () const</td></tr>
<tr class="memdesc:ae2231eaa1ca0583f91a97f07cd51f731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cookie to be used when writing files with this format.  <a href="#ae2231eaa1ca0583f91a97f07cd51f731">More...</a><br /></td></tr>
<tr class="separator:ae2231eaa1ca0583f91a97f07cd51f731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2060c617124b513ccf799426ce149e1"><td class="memItemLeft" align="right" valign="top">SDF_API const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#ac2060c617124b513ccf799426ce149e1">GetVersionString</a> () const</td></tr>
<tr class="memdesc:ac2060c617124b513ccf799426ce149e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current version of this file format.  <a href="#ac2060c617124b513ccf799426ce149e1">More...</a><br /></td></tr>
<tr class="separator:ac2060c617124b513ccf799426ce149e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92ebb5ec62184ddbc8913e4f05db070"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#ad92ebb5ec62184ddbc8913e4f05db070">IsPrimaryFormatForExtensions</a> () const</td></tr>
<tr class="memdesc:ad92ebb5ec62184ddbc8913e4f05db070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this file format is the primary format for the extensions it handles.  <a href="#ad92ebb5ec62184ddbc8913e4f05db070">More...</a><br /></td></tr>
<tr class="separator:ad92ebb5ec62184ddbc8913e4f05db070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab332582e9e4898a6462207fefe608ba9"><td class="memItemLeft" align="right" valign="top">SDF_API const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#ab332582e9e4898a6462207fefe608ba9">GetFileExtensions</a> () const</td></tr>
<tr class="memdesc:ab332582e9e4898a6462207fefe608ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of extensions that this format supports.  <a href="#ab332582e9e4898a6462207fefe608ba9">More...</a><br /></td></tr>
<tr class="separator:ab332582e9e4898a6462207fefe608ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855ff6edf7f38b3a8863f597ebe557c9"><td class="memItemLeft" align="right" valign="top">SDF_API const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a855ff6edf7f38b3a8863f597ebe557c9">GetPrimaryFileExtension</a> () const</td></tr>
<tr class="memdesc:a855ff6edf7f38b3a8863f597ebe557c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the primary file extension for this format.  <a href="#a855ff6edf7f38b3a8863f597ebe557c9">More...</a><br /></td></tr>
<tr class="separator:a855ff6edf7f38b3a8863f597ebe557c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5349dcbdcfd8c009af50d11c717e071"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#ae5349dcbdcfd8c009af50d11c717e071">IsSupportedExtension</a> (const std::string &amp;extension) const</td></tr>
<tr class="memdesc:ae5349dcbdcfd8c009af50d11c717e071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>extension</code> matches one of the extensions returned by GetFileExtensions.  <a href="#ae5349dcbdcfd8c009af50d11c717e071">More...</a><br /></td></tr>
<tr class="separator:ae5349dcbdcfd8c009af50d11c717e071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688a3cc6628e445cc997e8952a434170"><td class="memItemLeft" align="right" valign="top">virtual SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a688a3cc6628e445cc997e8952a434170">IsPackage</a> () const</td></tr>
<tr class="memdesc:a688a3cc6628e445cc997e8952a434170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this file format is a package containing other assets.  <a href="#a688a3cc6628e445cc997e8952a434170">More...</a><br /></td></tr>
<tr class="separator:a688a3cc6628e445cc997e8952a434170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20721adeae2ab3e3f03b468d7c938c2"><td class="memItemLeft" align="right" valign="top">virtual SDF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#ae20721adeae2ab3e3f03b468d7c938c2">GetPackageRootLayerPath</a> (const std::string &amp;resolvedPath) const</td></tr>
<tr class="memdesc:ae20721adeae2ab3e3f03b468d7c938c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the path of the "root" layer contained in the package layer at <code>resolvedPath</code> produced by this file format.  <a href="#ae20721adeae2ab3e3f03b468d7c938c2">More...</a><br /></td></tr>
<tr class="separator:ae20721adeae2ab3e3f03b468d7c938c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830ffcfcd3441b645265536b05da4412"><td class="memItemLeft" align="right" valign="top">virtual SDF_API <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a830ffcfcd3441b645265536b05da4412">GetDefaultFileFormatArguments</a> () const</td></tr>
<tr class="memdesc:a830ffcfcd3441b645265536b05da4412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the FileFormatArguments that correspond to the default behavior of this file format when no FileFormatArguments are passed to NewLayer or InitData.  <a href="#a830ffcfcd3441b645265536b05da4412">More...</a><br /></td></tr>
<tr class="separator:a830ffcfcd3441b645265536b05da4412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6fe1b90e69c2f271c631b2e0597b23"><td class="memItemLeft" align="right" valign="top">virtual SDF_API SdfAbstractDataRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a7e6fe1b90e69c2f271c631b2e0597b23">InitData</a> (const <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a> &amp;args) const</td></tr>
<tr class="memdesc:a7e6fe1b90e69c2f271c631b2e0597b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows the file format to bind to whatever data container is appropriate.  <a href="#a7e6fe1b90e69c2f271c631b2e0597b23">More...</a><br /></td></tr>
<tr class="separator:a7e6fe1b90e69c2f271c631b2e0597b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9391d69494e36aae0cbb1ca7007526"><td class="memItemLeft" align="right" valign="top">SDF_API SdfAbstractDataRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#adc9391d69494e36aae0cbb1ca7007526">InitDetachedData</a> (const <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a> &amp;args) const</td></tr>
<tr class="memdesc:adc9391d69494e36aae0cbb1ca7007526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="class_sdf_abstract_data.html" title="Interface for scene description data storage.">SdfAbstractData</a> providing access to the layer's data.  <a href="#adc9391d69494e36aae0cbb1ca7007526">More...</a><br /></td></tr>
<tr class="separator:adc9391d69494e36aae0cbb1ca7007526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79344fd3d6748c5beee6198a41fcd141"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_tf_ref_ptr.html">SdfLayerRefPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a79344fd3d6748c5beee6198a41fcd141">NewLayer</a> (const SdfFileFormatConstPtr &amp;fileFormat, const std::string &amp;identifier, const std::string &amp;realPath, const <a class="el" href="class_ar_asset_info.html">ArAssetInfo</a> &amp;assetInfo, const <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a> &amp;args) const</td></tr>
<tr class="memdesc:a79344fd3d6748c5beee6198a41fcd141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate a layer.  <a href="#a79344fd3d6748c5beee6198a41fcd141">More...</a><br /></td></tr>
<tr class="separator:a79344fd3d6748c5beee6198a41fcd141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bee0843fce18d3c607c0b56b118319"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#ae5bee0843fce18d3c607c0b56b118319">ShouldSkipAnonymousReload</a> () const</td></tr>
<tr class="memdesc:ae5bee0843fce18d3c607c0b56b118319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this file format prefers to skip reloading anonymous layers.  <a href="#ae5bee0843fce18d3c607c0b56b118319">More...</a><br /></td></tr>
<tr class="separator:ae5bee0843fce18d3c607c0b56b118319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50928a94b9625eb1a149e07944ddb99d"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a50928a94b9625eb1a149e07944ddb99d">ShouldReadAnonymousLayers</a> () const</td></tr>
<tr class="memdesc:a50928a94b9625eb1a149e07944ddb99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if anonymous layer identifiers should be passed to Read when a layer is opened or reloaded.  <a href="#a50928a94b9625eb1a149e07944ddb99d">More...</a><br /></td></tr>
<tr class="separator:a50928a94b9625eb1a149e07944ddb99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa76b34e13314ffaf726f4799d4161ae"><td class="memItemLeft" align="right" valign="top">virtual SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#afa76b34e13314ffaf726f4799d4161ae">CanRead</a> (const std::string &amp;file) const =0</td></tr>
<tr class="memdesc:afa76b34e13314ffaf726f4799d4161ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>file</code> can be read by this format.  <a href="#afa76b34e13314ffaf726f4799d4161ae">More...</a><br /></td></tr>
<tr class="separator:afa76b34e13314ffaf726f4799d4161ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8621e64c229386ea8e743faaf3f34d68"><td class="memItemLeft" align="right" valign="top">virtual SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a8621e64c229386ea8e743faaf3f34d68">Read</a> (<a class="el" href="class_sdf_layer.html">SdfLayer</a> *layer, const std::string &amp;resolvedPath, bool metadataOnly) const =0</td></tr>
<tr class="memdesc:a8621e64c229386ea8e743faaf3f34d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads scene description from the asset specified by <code>resolvedPath</code> into the layer <code>layer</code>.  <a href="#a8621e64c229386ea8e743faaf3f34d68">More...</a><br /></td></tr>
<tr class="separator:a8621e64c229386ea8e743faaf3f34d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d42db40bca59050733c4b40a818475"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a12d42db40bca59050733c4b40a818475">ReadDetached</a> (<a class="el" href="class_sdf_layer.html">SdfLayer</a> *layer, const std::string &amp;resolvedPath, bool metadataOnly) const</td></tr>
<tr class="memdesc:a12d42db40bca59050733c4b40a818475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads scene description from the asset specified by <code>resolvedPath</code> into the detached layer <code>layer</code>.  <a href="#a12d42db40bca59050733c4b40a818475">More...</a><br /></td></tr>
<tr class="separator:a12d42db40bca59050733c4b40a818475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd911a48918fd2cad75a72f3839f40e"><td class="memItemLeft" align="right" valign="top">virtual SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#aebd911a48918fd2cad75a72f3839f40e">WriteToFile</a> (const <a class="el" href="class_sdf_layer.html">SdfLayer</a> &amp;layer, const std::string &amp;filePath, const std::string &amp;comment=std::string(), const <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a> &amp;args=<a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a>()) const</td></tr>
<tr class="memdesc:aebd911a48918fd2cad75a72f3839f40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the content in <code>layer</code> into the file at <code>filePath</code>.  <a href="#aebd911a48918fd2cad75a72f3839f40e">More...</a><br /></td></tr>
<tr class="separator:aebd911a48918fd2cad75a72f3839f40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bce13cc06020cb090ebe6746208b459"><td class="memItemLeft" align="right" valign="top">virtual SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a6bce13cc06020cb090ebe6746208b459">ReadFromString</a> (<a class="el" href="class_sdf_layer.html">SdfLayer</a> *layer, const std::string &amp;str) const</td></tr>
<tr class="memdesc:a6bce13cc06020cb090ebe6746208b459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data in the string <code>str</code> into the layer <code>layer</code>.  <a href="#a6bce13cc06020cb090ebe6746208b459">More...</a><br /></td></tr>
<tr class="separator:a6bce13cc06020cb090ebe6746208b459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7243749d4e00e091c4df98705316d9"><td class="memItemLeft" align="right" valign="top">virtual SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a3d7243749d4e00e091c4df98705316d9">WriteToStream</a> (const SdfSpecHandle &amp;spec, std::ostream &amp;out, size_t indent) const</td></tr>
<tr class="memdesc:a3d7243749d4e00e091c4df98705316d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the provided <code>spec</code> to <code>out</code> indented <code>indent</code> levels.  <a href="#a3d7243749d4e00e091c4df98705316d9">More...</a><br /></td></tr>
<tr class="separator:a3d7243749d4e00e091c4df98705316d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d36cf09ec2f2556ff6b1cb88823d0d0"><td class="memItemLeft" align="right" valign="top">virtual SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a3d36cf09ec2f2556ff6b1cb88823d0d0">WriteToString</a> (const <a class="el" href="class_sdf_layer.html">SdfLayer</a> &amp;layer, std::string *str, const std::string &amp;comment=std::string()) const</td></tr>
<tr class="memdesc:a3d36cf09ec2f2556ff6b1cb88823d0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the content in <code>layer</code> to the string <code>str</code>.  <a href="#a3d36cf09ec2f2556ff6b1cb88823d0d0">More...</a><br /></td></tr>
<tr class="separator:a3d36cf09ec2f2556ff6b1cb88823d0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848b6bb7cedf72cb78e402c4402fdbc0"><td class="memItemLeft" align="right" valign="top">virtual SDF_API std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a848b6bb7cedf72cb78e402c4402fdbc0">GetExternalAssetDependencies</a> (const <a class="el" href="class_sdf_layer.html">SdfLayer</a> &amp;layer) const</td></tr>
<tr class="memdesc:a848b6bb7cedf72cb78e402c4402fdbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of resolved paths to external asset file dependencies for the given <code>layer</code>.  <a href="#a848b6bb7cedf72cb78e402c4402fdbc0">More...</a><br /></td></tr>
<tr class="separator:a848b6bb7cedf72cb78e402c4402fdbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f99ff74942b86a7aa1ec7c69a617b64"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a5f99ff74942b86a7aa1ec7c69a617b64">SupportsReading</a> () const</td></tr>
<tr class="memdesc:a5f99ff74942b86a7aa1ec7c69a617b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this file format supports reading.  <a href="#a5f99ff74942b86a7aa1ec7c69a617b64">More...</a><br /></td></tr>
<tr class="separator:a5f99ff74942b86a7aa1ec7c69a617b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f2b45688a158acb95d1d00b6d82e0f"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a27f2b45688a158acb95d1d00b6d82e0f">SupportsWriting</a> () const</td></tr>
<tr class="memdesc:a27f2b45688a158acb95d1d00b6d82e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a convenience method for invoking <a class="el" href="class_sdf_file_format.html#add9fecbf8f4a1acac72dd5f9141f97ee">FormatSupportsWriting</a> with this format's extension and target.  <a href="#a27f2b45688a158acb95d1d00b6d82e0f">More...</a><br /></td></tr>
<tr class="separator:a27f2b45688a158acb95d1d00b6d82e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83eab906a0358ebdf94b03316bf66d80"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a83eab906a0358ebdf94b03316bf66d80">SupportsEditing</a> () const</td></tr>
<tr class="memdesc:a83eab906a0358ebdf94b03316bf66d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a convenience method for invoking <a class="el" href="class_sdf_file_format.html#acab8762adf43caac7b35f784babb5ae4">FormatSupportsEditing</a> with this format's extension and target.  <a href="#a83eab906a0358ebdf94b03316bf66d80">More...</a><br /></td></tr>
<tr class="separator:a83eab906a0358ebdf94b03316bf66d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_tf_ref_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_tf_ref_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_tf_ref_base.html">TfRefBase</a></td></tr>
<tr class="memitem:abcd501e4bb37d7a93faa4e625e96ecf7 inherit pub_methods_class_tf_ref_base"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_base.html#abcd501e4bb37d7a93faa4e625e96ecf7">GetCurrentCount</a> () const</td></tr>
<tr class="memdesc:abcd501e4bb37d7a93faa4e625e96ecf7 inherit pub_methods_class_tf_ref_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current reference count of this object.  <a href="class_tf_ref_base.html#abcd501e4bb37d7a93faa4e625e96ecf7">More...</a><br /></td></tr>
<tr class="separator:abcd501e4bb37d7a93faa4e625e96ecf7 inherit pub_methods_class_tf_ref_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8bc91cf9cff7c6e1da23dc59f5ad1f inherit pub_methods_class_tf_ref_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_base.html#aab8bc91cf9cff7c6e1da23dc59f5ad1f">IsUnique</a> () const</td></tr>
<tr class="memdesc:aab8bc91cf9cff7c6e1da23dc59f5ad1f inherit pub_methods_class_tf_ref_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if only one <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code> points to this object.  <a href="class_tf_ref_base.html#aab8bc91cf9cff7c6e1da23dc59f5ad1f">More...</a><br /></td></tr>
<tr class="separator:aab8bc91cf9cff7c6e1da23dc59f5ad1f inherit pub_methods_class_tf_ref_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1926aa1f9b1ad25c5c583b92bcf14b inherit pub_methods_class_tf_ref_base"><td class="memItemLeft" align="right" valign="top"><a id="abc1926aa1f9b1ad25c5c583b92bcf14b"></a>
const <a class="el" href="class_tf_ref_count.html">TfRefCount</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetRefCount</b> () const</td></tr>
<tr class="separator:abc1926aa1f9b1ad25c5c583b92bcf14b inherit pub_methods_class_tf_ref_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee7fb6df1df9be9afbda405643ecb6c inherit pub_methods_class_tf_ref_base"><td class="memItemLeft" align="right" valign="top"><a id="a6ee7fb6df1df9be9afbda405643ecb6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetShouldInvokeUniqueChangedListener</b> (bool shouldCall)</td></tr>
<tr class="separator:a6ee7fb6df1df9be9afbda405643ecb6c inherit pub_methods_class_tf_ref_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_tf_weak_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_tf_weak_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_tf_weak_base.html">TfWeakBase</a></td></tr>
<tr class="memitem:affc4c00d0bbfdfe4f9e6a8b2e81be368 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="affc4c00d0bbfdfe4f9e6a8b2e81be368"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TfWeakBase</b> (const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;)</td></tr>
<tr class="separator:affc4c00d0bbfdfe4f9e6a8b2e81be368 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aa4c4b93df067f2ec9b9e5fa4c35b3 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a01aa4c4b93df067f2ec9b9e5fa4c35b3"></a>
const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>__GetTfWeakBase__</b> () const</td></tr>
<tr class="separator:a01aa4c4b93df067f2ec9b9e5fa4c35b3 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af890ac314073e903458bf6b2397566b5 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="af890ac314073e903458bf6b2397566b5"></a>
const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;)</td></tr>
<tr class="separator:af890ac314073e903458bf6b2397566b5 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f1e27cc0c7c606ffb397b7d970ed10 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a16f1e27cc0c7c606ffb397b7d970ed10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EnableNotification2</b> () const</td></tr>
<tr class="separator:a16f1e27cc0c7c606ffb397b7d970ed10 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3241c32a82fbed0716a77049f6134e1e inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a3241c32a82fbed0716a77049f6134e1e"></a>
TF_API void const  *&#160;</td><td class="memItemRight" valign="bottom"><b>GetUniqueIdentifier</b> () const</td></tr>
<tr class="separator:a3241c32a82fbed0716a77049f6134e1e inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abcbb3a513cf28abac68c32f75dac4de2"><td class="memItemLeft" align="right" valign="top">static SDF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#abcbb3a513cf28abac68c32f75dac4de2">GetFileExtension</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:abcbb3a513cf28abac68c32f75dac4de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the file extension for path or file name <code>s</code>, without the leading dot character.  <a href="#abcbb3a513cf28abac68c32f75dac4de2">More...</a><br /></td></tr>
<tr class="separator:abcbb3a513cf28abac68c32f75dac4de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb382b2d773579a0fc353c2d6c63040"><td class="memItemLeft" align="right" valign="top">static SDF_API std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a3eb382b2d773579a0fc353c2d6c63040">FindAllFileFormatExtensions</a> ()</td></tr>
<tr class="memdesc:a3eb382b2d773579a0fc353c2d6c63040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set containing the extension(s) corresponding to all registered file formats.  <a href="#a3eb382b2d773579a0fc353c2d6c63040">More...</a><br /></td></tr>
<tr class="separator:a3eb382b2d773579a0fc353c2d6c63040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd6d75707af4e54f78e6a47bde4d772"><td class="memItemLeft" align="right" valign="top">static SDF_API std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a2fd6d75707af4e54f78e6a47bde4d772">FindAllDerivedFileFormatExtensions</a> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;baseType)</td></tr>
<tr class="memdesc:a2fd6d75707af4e54f78e6a47bde4d772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set containing the extension(s) corresponding to all registered file formats that derive from <code>baseType</code>.  <a href="#a2fd6d75707af4e54f78e6a47bde4d772">More...</a><br /></td></tr>
<tr class="separator:a2fd6d75707af4e54f78e6a47bde4d772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2c1b75bce2485538862ecddc9285bc"><td class="memItemLeft" align="right" valign="top">static SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#ada2c1b75bce2485538862ecddc9285bc">FormatSupportsReading</a> (const std::string &amp;extension, const std::string &amp;target=std::string())</td></tr>
<tr class="memdesc:ada2c1b75bce2485538862ecddc9285bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the file format for the supplied <code>extension</code> and <code>target</code> pair supports reading.  <a href="#ada2c1b75bce2485538862ecddc9285bc">More...</a><br /></td></tr>
<tr class="separator:ada2c1b75bce2485538862ecddc9285bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9fecbf8f4a1acac72dd5f9141f97ee"><td class="memItemLeft" align="right" valign="top">static SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#add9fecbf8f4a1acac72dd5f9141f97ee">FormatSupportsWriting</a> (const std::string &amp;extension, const std::string &amp;target=std::string())</td></tr>
<tr class="memdesc:add9fecbf8f4a1acac72dd5f9141f97ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the file format for the supplied <code>extension</code> and <code>target</code> pair supports writing.  <a href="#add9fecbf8f4a1acac72dd5f9141f97ee">More...</a><br /></td></tr>
<tr class="separator:add9fecbf8f4a1acac72dd5f9141f97ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab8762adf43caac7b35f784babb5ae4"><td class="memItemLeft" align="right" valign="top">static SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#acab8762adf43caac7b35f784babb5ae4">FormatSupportsEditing</a> (const std::string &amp;extension, const std::string &amp;target=std::string())</td></tr>
<tr class="memdesc:acab8762adf43caac7b35f784babb5ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the file format for the supplied <code>extension</code> and <code>target</code> pair supports editing.  <a href="#acab8762adf43caac7b35f784babb5ae4">More...</a><br /></td></tr>
<tr class="separator:acab8762adf43caac7b35f784babb5ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7217ccb019b97204c7e7cad86ee2fc92"><td class="memItemLeft" align="right" valign="top">static SDF_API SdfFileFormatConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a7217ccb019b97204c7e7cad86ee2fc92">FindById</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;formatId)</td></tr>
<tr class="memdesc:a7217ccb019b97204c7e7cad86ee2fc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the file format instance with the specified <code>formatId</code> identifier.  <a href="#a7217ccb019b97204c7e7cad86ee2fc92">More...</a><br /></td></tr>
<tr class="separator:a7217ccb019b97204c7e7cad86ee2fc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d67519992ef59d03eff5f9b5ca3728"><td class="memItemLeft" align="right" valign="top">static SDF_API SdfFileFormatConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#ab9d67519992ef59d03eff5f9b5ca3728">FindByExtension</a> (const std::string &amp;path, const std::string &amp;target=std::string())</td></tr>
<tr class="memdesc:ab9d67519992ef59d03eff5f9b5ca3728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the file format instance that supports the extension for <code>path</code>.  <a href="#ab9d67519992ef59d03eff5f9b5ca3728">More...</a><br /></td></tr>
<tr class="separator:ab9d67519992ef59d03eff5f9b5ca3728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad700415c499bbb5a7d2a9a7ead748904"><td class="memItemLeft" align="right" valign="top">static SDF_API SdfFileFormatConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#ad700415c499bbb5a7d2a9a7ead748904">FindByExtension</a> (const std::string &amp;path, const <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a> &amp;args)</td></tr>
<tr class="memdesc:ad700415c499bbb5a7d2a9a7ead748904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a file format instance that supports the extension for <code>path</code> and whose target matches one of those specified by the given <code>args</code>.  <a href="#ad700415c499bbb5a7d2a9a7ead748904">More...</a><br /></td></tr>
<tr class="separator:ad700415c499bbb5a7d2a9a7ead748904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_tf_ref_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_tf_ref_base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_tf_ref_base.html">TfRefBase</a></td></tr>
<tr class="memitem:a33e6c8ffe0caf7dac94ba5c4a4485fbd inherit pub_static_methods_class_tf_ref_base"><td class="memItemLeft" align="right" valign="top"><a id="a33e6c8ffe0caf7dac94ba5c4a4485fbd"></a>
static TF_API void&#160;</td><td class="memItemRight" valign="bottom"><b>SetUniqueChangedListener</b> (UniqueChangedListener listener)</td></tr>
<tr class="separator:a33e6c8ffe0caf7dac94ba5c4a4485fbd inherit pub_static_methods_class_tf_ref_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a264d3e88f88f613493c2d7fcfad67e94"><td class="memItemLeft" align="right" valign="top">SDF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a264d3e88f88f613493c2d7fcfad67e94">SdfFileFormat</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;formatId, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;versionString, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;target, const std::string &amp;extension)</td></tr>
<tr class="memdesc:a264d3e88f88f613493c2d7fcfad67e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a264d3e88f88f613493c2d7fcfad67e94">More...</a><br /></td></tr>
<tr class="separator:a264d3e88f88f613493c2d7fcfad67e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75670dd7e233757cafd3c598446c6206"><td class="memItemLeft" align="right" valign="top">SDF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a75670dd7e233757cafd3c598446c6206">SdfFileFormat</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;formatId, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;versionString, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;target, const std::string &amp;extension, const <a class="el" href="class_sdf_schema_base.html">SdfSchemaBase</a> &amp;schema)</td></tr>
<tr class="memdesc:a75670dd7e233757cafd3c598446c6206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a75670dd7e233757cafd3c598446c6206">More...</a><br /></td></tr>
<tr class="separator:a75670dd7e233757cafd3c598446c6206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfad924c4fb5e5789207f149f0db032"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a0bfad924c4fb5e5789207f149f0db032">SdfFileFormat</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;formatId, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;versionString, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;target, const std::string &amp;extension, const <a class="el" href="class_sdf_schema_base.html">SdfSchemaBase</a> &amp;&amp;schema)=delete</td></tr>
<tr class="memdesc:a0bfad924c4fb5e5789207f149f0db032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow temporary <a class="el" href="class_sdf_schema_base.html" title="Generic class that provides information about scene description fields but doesn&#39;t actually provide a...">SdfSchemaBase</a> objects being passed to the c'tor.  <a href="#a0bfad924c4fb5e5789207f149f0db032">More...</a><br /></td></tr>
<tr class="separator:a0bfad924c4fb5e5789207f149f0db032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe62122c83fdaf835755c00fb56e9ae"><td class="memItemLeft" align="right" valign="top">SDF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#aebe62122c83fdaf835755c00fb56e9ae">SdfFileFormat</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;formatId, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;versionString, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;target, const std::vector&lt; std::string &gt; &amp;extensions)</td></tr>
<tr class="memdesc:aebe62122c83fdaf835755c00fb56e9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#aebe62122c83fdaf835755c00fb56e9ae">More...</a><br /></td></tr>
<tr class="separator:aebe62122c83fdaf835755c00fb56e9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb704822963e888102f17369717ecd5c"><td class="memItemLeft" align="right" valign="top">SDF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#aeb704822963e888102f17369717ecd5c">SdfFileFormat</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;formatId, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;versionString, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;target, const std::vector&lt; std::string &gt; &amp;extensions, const <a class="el" href="class_sdf_schema_base.html">SdfSchemaBase</a> &amp;schema)</td></tr>
<tr class="memdesc:aeb704822963e888102f17369717ecd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#aeb704822963e888102f17369717ecd5c">More...</a><br /></td></tr>
<tr class="separator:aeb704822963e888102f17369717ecd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780caf13030dfa6f32cf697f484faf01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a780caf13030dfa6f32cf697f484faf01">SdfFileFormat</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;formatId, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;versionString, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;target, const std::vector&lt; std::string &gt; &amp;extensions, const <a class="el" href="class_sdf_schema_base.html">SdfSchemaBase</a> &amp;&amp;schema)=delete</td></tr>
<tr class="memdesc:a780caf13030dfa6f32cf697f484faf01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow temporary <a class="el" href="class_sdf_schema_base.html" title="Generic class that provides information about scene description fields but doesn&#39;t actually provide a...">SdfSchemaBase</a> objects being passed to the c'tor.  <a href="#a780caf13030dfa6f32cf697f484faf01">More...</a><br /></td></tr>
<tr class="separator:a780caf13030dfa6f32cf697f484faf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9bde194003de8378da0fcbc8e7598d"><td class="memItemLeft" align="right" valign="top">virtual SDF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a6f9bde194003de8378da0fcbc8e7598d">~SdfFileFormat</a> ()</td></tr>
<tr class="memdesc:a6f9bde194003de8378da0fcbc8e7598d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a6f9bde194003de8378da0fcbc8e7598d">More...</a><br /></td></tr>
<tr class="separator:a6f9bde194003de8378da0fcbc8e7598d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb80cd45410b5f68e76996187d69e6a"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a4cb80cd45410b5f68e76996187d69e6a">_ReadAndCopyLayerDataToMemory</a> (<a class="el" href="class_sdf_layer.html">SdfLayer</a> *layer, const std::string &amp;resolvedPath, bool metadataOnly, bool *didCopyData=nullptr) const</td></tr>
<tr class="memdesc:a4cb80cd45410b5f68e76996187d69e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for _ReadDetached.  <a href="#a4cb80cd45410b5f68e76996187d69e6a">More...</a><br /></td></tr>
<tr class="separator:a4cb80cd45410b5f68e76996187d69e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91060b50288c32d054e55c00815f8c4a"><td class="memItemLeft" align="right" valign="top"><a id="a91060b50288c32d054e55c00815f8c4a"></a>
virtual SDF_API <a class="el" href="class_sdf_layer.html">SdfLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_InstantiateNewLayer</b> (const SdfFileFormatConstPtr &amp;fileFormat, const std::string &amp;identifier, const std::string &amp;realPath, const <a class="el" href="class_ar_asset_info.html">ArAssetInfo</a> &amp;assetInfo, const <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a> &amp;args) const</td></tr>
<tr class="separator:a91060b50288c32d054e55c00815f8c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0cbafb2e3b080d9fbcdd93a5e9d967"><td class="memItemLeft" align="right" valign="top"><a id="a3d0cbafb2e3b080d9fbcdd93a5e9d967"></a>
virtual SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>_ShouldSkipAnonymousReload</b> () const</td></tr>
<tr class="separator:a3d0cbafb2e3b080d9fbcdd93a5e9d967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c9e8b7430b2a24447034e0716380aa"><td class="memItemLeft" align="right" valign="top">virtual SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a12c9e8b7430b2a24447034e0716380aa">_ShouldReadAnonymousLayers</a> () const</td></tr>
<tr class="memdesc:a12c9e8b7430b2a24447034e0716380aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">File format subclasses may override this to specify whether Read should be called when creating, opening, or reloading an anonymous layer of this format.  <a href="#a12c9e8b7430b2a24447034e0716380aa">More...</a><br /></td></tr>
<tr class="separator:a12c9e8b7430b2a24447034e0716380aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4999d2f804fbd556476427ef20ea80e"><td class="memItemLeft" align="right" valign="top">virtual SDF_API SdfAbstractDataRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#ab4999d2f804fbd556476427ef20ea80e">_InitDetachedData</a> (const <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a> &amp;args) const</td></tr>
<tr class="separator:ab4999d2f804fbd556476427ef20ea80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903006b206ab7fe0c8f9f645efa9dbc3"><td class="memItemLeft" align="right" valign="top">virtual SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a903006b206ab7fe0c8f9f645efa9dbc3">_ReadDetached</a> (<a class="el" href="class_sdf_layer.html">SdfLayer</a> *layer, const std::string &amp;resolvedPath, bool metadataOnly) const</td></tr>
<tr class="separator:a903006b206ab7fe0c8f9f645efa9dbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_tf_weak_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_tf_weak_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_tf_weak_base.html">TfWeakBase</a></td></tr>
<tr class="memitem:a95139d2f4d04eb706664a4f47eb93918 inherit pro_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a95139d2f4d04eb706664a4f47eb93918"></a>
<a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; Tf_Remnant &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_Register</b> () const</td></tr>
<tr class="separator:a95139d2f4d04eb706664a4f47eb93918 inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memTemplParams" colspan="2"><a id="ac1312732482c8a286522f703f2cf90d1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; Tf_Remnant &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_Register</b> (T *tempRmnt) const</td></tr>
<tr class="separator:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5533162e8efab1be47acd6ccd5254c inherit pro_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a6a5533162e8efab1be47acd6ccd5254c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_HasRemnant</b> () const</td></tr>
<tr class="separator:a6a5533162e8efab1be47acd6ccd5254c inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a8d5aeef83f6b9e72f4b94bcbf5201d9f"><td class="memItemLeft" align="right" valign="top">static SDF_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a8d5aeef83f6b9e72f4b94bcbf5201d9f">_SetLayerData</a> (<a class="el" href="class_sdf_layer.html">SdfLayer</a> *layer, SdfAbstractDataRefPtr &amp;data)</td></tr>
<tr class="memdesc:a8d5aeef83f6b9e72f4b94bcbf5201d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal data for <code>layer</code> to <code>data</code>, possibly transferring ownership of <code>data</code>.  <a href="#a8d5aeef83f6b9e72f4b94bcbf5201d9f">More...</a><br /></td></tr>
<tr class="separator:a8d5aeef83f6b9e72f4b94bcbf5201d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fd5be937c25d4eb1edeb9e8c1b1748"><td class="memItemLeft" align="right" valign="top">static SDF_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a31fd5be937c25d4eb1edeb9e8c1b1748">_SetLayerData</a> (<a class="el" href="class_sdf_layer.html">SdfLayer</a> *layer, SdfAbstractDataRefPtr &amp;data, <a class="el" href="class_sdf_layer_hints.html">SdfLayerHints</a> hints)</td></tr>
<tr class="memdesc:a31fd5be937c25d4eb1edeb9e8c1b1748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal data for <code>layer</code> to <code>data</code>, possibly transferring ownership of <code>data</code>.  <a href="#a31fd5be937c25d4eb1edeb9e8c1b1748">More...</a><br /></td></tr>
<tr class="separator:a31fd5be937c25d4eb1edeb9e8c1b1748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128bdfe095ed866d05dca1422f9136f6"><td class="memItemLeft" align="right" valign="top">static SDF_API SdfAbstractDataConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_file_format.html#a128bdfe095ed866d05dca1422f9136f6">_GetLayerData</a> (const <a class="el" href="class_sdf_layer.html">SdfLayer</a> &amp;layer)</td></tr>
<tr class="memdesc:a128bdfe095ed866d05dca1422f9136f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal data for <code>layer</code>.  <a href="#a128bdfe095ed866d05dca1422f9136f6">More...</a><br /></td></tr>
<tr class="separator:a128bdfe095ed866d05dca1422f9136f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for file format implementations. </p>

<p class="definition">Definition at line <a class="el" href="file_format_8h_source.html#l00064">64</a> of file <a class="el" href="file_format_8h_source.html">fileFormat.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1dfd2030337b6243cd6424fce7397590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfd2030337b6243cd6424fce7397590">&#9670;&nbsp;</a></span>FileFormatArguments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, std::string&gt; <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for specifying additional file format-specific arguments to the various API below. </p>

<p class="definition">Definition at line <a class="el" href="file_format_8h_source.html#l00119">119</a> of file <a class="el" href="file_format_8h_source.html">fileFormat.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a264d3e88f88f613493c2d7fcfad67e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264d3e88f88f613493c2d7fcfad67e94">&#9670;&nbsp;</a></span>SdfFileFormat() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_file_format.html">SdfFileFormat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>formatId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>versionString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="a75670dd7e233757cafd3c598446c6206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75670dd7e233757cafd3c598446c6206">&#9670;&nbsp;</a></span>SdfFileFormat() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_file_format.html">SdfFileFormat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>formatId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>versionString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_schema_base.html">SdfSchemaBase</a> &amp;&#160;</td>
          <td class="paramname"><em>schema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p><code>schema</code> must remain valid for the lifetime of this file format. </p>

</div>
</div>
<a id="a0bfad924c4fb5e5789207f149f0db032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfad924c4fb5e5789207f149f0db032">&#9670;&nbsp;</a></span>SdfFileFormat() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sdf_file_format.html">SdfFileFormat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>formatId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>versionString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_schema_base.html">SdfSchemaBase</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>schema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallow temporary <a class="el" href="class_sdf_schema_base.html" title="Generic class that provides information about scene description fields but doesn&#39;t actually provide a...">SdfSchemaBase</a> objects being passed to the c'tor. </p>

</div>
</div>
<a id="aebe62122c83fdaf835755c00fb56e9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe62122c83fdaf835755c00fb56e9ae">&#9670;&nbsp;</a></span>SdfFileFormat() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_file_format.html">SdfFileFormat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>formatId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>versionString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>extensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="aeb704822963e888102f17369717ecd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb704822963e888102f17369717ecd5c">&#9670;&nbsp;</a></span>SdfFileFormat() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_file_format.html">SdfFileFormat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>formatId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>versionString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>extensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_schema_base.html">SdfSchemaBase</a> &amp;&#160;</td>
          <td class="paramname"><em>schema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p><code>schema</code> must remain valid for the lifetime of this file format. </p>

</div>
</div>
<a id="a780caf13030dfa6f32cf697f484faf01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780caf13030dfa6f32cf697f484faf01">&#9670;&nbsp;</a></span>SdfFileFormat() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sdf_file_format.html">SdfFileFormat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>formatId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>versionString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>extensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_schema_base.html">SdfSchemaBase</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>schema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallow temporary <a class="el" href="class_sdf_schema_base.html" title="Generic class that provides information about scene description fields but doesn&#39;t actually provide a...">SdfSchemaBase</a> objects being passed to the c'tor. </p>

</div>
</div>
<a id="a6f9bde194003de8378da0fcbc8e7598d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9bde194003de8378da0fcbc8e7598d">&#9670;&nbsp;</a></span>~SdfFileFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API ~<a class="el" href="class_sdf_file_format.html">SdfFileFormat</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a128bdfe095ed866d05dca1422f9136f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128bdfe095ed866d05dca1422f9136f6">&#9670;&nbsp;</a></span>_GetLayerData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API SdfAbstractDataConstPtr _GetLayerData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_layer.html">SdfLayer</a> &amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the internal data for <code>layer</code>. </p>

</div>
</div>
<a id="ab4999d2f804fbd556476427ef20ea80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4999d2f804fbd556476427ef20ea80e">&#9670;&nbsp;</a></span>_InitDetachedData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API SdfAbstractDataRefPtr _InitDetachedData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sdf_file_format.html#adc9391d69494e36aae0cbb1ca7007526" title="Returns a new SdfAbstractData providing access to the layer&#39;s data.">InitDetachedData</a></dd></dl>
<p>This function must return a new <a class="el" href="class_sdf_abstract_data.html" title="Interface for scene description data storage.">SdfAbstractData</a> object that is detached, i.e. <a class="el" href="class_sdf_abstract_data.html#a4394939afe9f76296e90fca624064128" title="Returns true if this data object is detached from its serialized data store, false otherwise.">SdfAbstractData::IsDetached</a> returns false.</p>
<p>The default implementation returns an <a class="el" href="class_sdf_data.html" title="SdfData provides concrete scene description data storage.">SdfData</a> object. </p>

<p>Reimplemented in <a class="el" href="class_usd_usd_file_format.html#aa3233c560c8d2398b112a5544c8f8fa9">UsdUsdFileFormat</a>.</p>

</div>
</div>
<a id="a4cb80cd45410b5f68e76996187d69e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb80cd45410b5f68e76996187d69e6a">&#9670;&nbsp;</a></span>_ReadAndCopyLayerDataToMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool _ReadAndCopyLayerDataToMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sdf_layer.html">SdfLayer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>metadataOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>didCopyData</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for _ReadDetached. </p>
<p>Calls Read with the given parameters. If successful and <code>layer</code> is not detached (i.e., <a class="el" href="class_sdf_layer.html#a742d86d8014873ce73a0c74e29f03c22" title="Returns true if this layer is detached from its serialized data store, false otherwise.">SdfLayer::IsDetached</a> returns false) copies the layer data into an <a class="el" href="class_sdf_data.html" title="SdfData provides concrete scene description data storage.">SdfData</a> object and set that into <code>layer</code>. If this copy occurs and <code>didCopyData</code> is given, it will be set to true.</p>
<p>Note that the copying process is a simple spec-by-spec, field-by-field value copy. This process may not produce detached layers if the data object used by <code>layer</code> after the initial call to Read returns VtValues that are not detached. One example is a <a class="el" href="class_vt_value.html" title="Provides a container which may hold any type, and provides introspection and iteration over array typ...">VtValue</a> holding a <a class="el" href="class_vt_array.html" title="Represents an arbitrary dimensional rectangular container class.">VtArray</a> backed by a foreign data source attached to a memory mapping.</p>
<p>Returns true if Read was successful, false otherwise. </p>

</div>
</div>
<a id="a903006b206ab7fe0c8f9f645efa9dbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903006b206ab7fe0c8f9f645efa9dbc3">&#9670;&nbsp;</a></span>_ReadDetached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API bool _ReadDetached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sdf_layer.html">SdfLayer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>metadataOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sdf_file_format.html#a12d42db40bca59050733c4b40a818475" title="Reads scene description from the asset specified by resolvedPath into the detached layer layer.">ReadDetached</a></dd></dl>
<p>Upon completion, <code>layer</code> must have an <a class="el" href="class_sdf_abstract_data.html" title="Interface for scene description data storage.">SdfAbstractData</a> object set that is detached, i.e. <a class="el" href="class_sdf_abstract_data.html#a4394939afe9f76296e90fca624064128" title="Returns true if this data object is detached from its serialized data store, false otherwise.">SdfAbstractData::IsDetached</a> returns false.</p>
<p>The default implementation calls _ReadAndCopyLayerDataToMemory to read the specified layer and copy its data into an <a class="el" href="class_sdf_data.html" title="SdfData provides concrete scene description data storage.">SdfData</a> object if it is not detached. If data is copied, a warning will be issued since this may be an expensive operation. If the above behavior is desired, subclasses can just call _ReadAndCopyLayerDataToMemory to do the same thing but without the warning. </p>

<p>Reimplemented in <a class="el" href="class_usd_usd_file_format.html#a3e56ab56cb1a1b6fe2a15f92c06f5e5c">UsdUsdFileFormat</a>, and <a class="el" href="class_usd_usdz_file_format.html#a3e56ab56cb1a1b6fe2a15f92c06f5e5c">UsdUsdzFileFormat</a>.</p>

</div>
</div>
<a id="a8d5aeef83f6b9e72f4b94bcbf5201d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5aeef83f6b9e72f4b94bcbf5201d9f">&#9670;&nbsp;</a></span>_SetLayerData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API void _SetLayerData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sdf_layer.html">SdfLayer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SdfAbstractDataRefPtr &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the internal data for <code>layer</code> to <code>data</code>, possibly transferring ownership of <code>data</code>. </p>
<p>Existing layer hints are reset to the default hints. </p>

</div>
</div>
<a id="a31fd5be937c25d4eb1edeb9e8c1b1748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fd5be937c25d4eb1edeb9e8c1b1748">&#9670;&nbsp;</a></span>_SetLayerData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API void _SetLayerData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sdf_layer.html">SdfLayer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SdfAbstractDataRefPtr &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sdf_layer_hints.html">SdfLayerHints</a>&#160;</td>
          <td class="paramname"><em>hints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the internal data for <code>layer</code> to <code>data</code>, possibly transferring ownership of <code>data</code>. </p>
<p>Existing layer hints are replaced with <code>hints</code>. </p>

</div>
</div>
<a id="a12c9e8b7430b2a24447034e0716380aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c9e8b7430b2a24447034e0716380aa">&#9670;&nbsp;</a></span>_ShouldReadAnonymousLayers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API bool _ShouldReadAnonymousLayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>File format subclasses may override this to specify whether Read should be called when creating, opening, or reloading an anonymous layer of this format. </p>
<p>Default implementation returns false. </p>

</div>
</div>
<a id="afa76b34e13314ffaf726f4799d4161ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa76b34e13314ffaf726f4799d4161ae">&#9670;&nbsp;</a></span>CanRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API bool CanRead </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>file</code> can be read by this format. </p>

<p>Implemented in <a class="el" href="class_usd_usd_file_format.html#acd3c5cb1abb4535fcde8816507752166">UsdUsdFileFormat</a>, <a class="el" href="class_usd_usdz_file_format.html#acd3c5cb1abb4535fcde8816507752166">UsdUsdzFileFormat</a>, <a class="el" href="class_sdf_text_file_format.html#ac422268041df510f5b991d49cc852bdb">SdfTextFileFormat</a>, and <a class="el" href="class_usd_usdc_file_format.html#a5e1a8b43babf918a7d617452e3afaabd">UsdUsdcFileFormat</a>.</p>

</div>
</div>
<a id="a2fd6d75707af4e54f78e6a47bde4d772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd6d75707af4e54f78e6a47bde4d772">&#9670;&nbsp;</a></span>FindAllDerivedFileFormatExtensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API std::set&lt;std::string&gt; FindAllDerivedFileFormatExtensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td>
          <td class="paramname"><em>baseType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a set containing the extension(s) corresponding to all registered file formats that derive from <code>baseType</code>. </p>
<p><code>baseType</code> must derive from <a class="el" href="class_sdf_file_format.html" title="Base class for file format implementations.">SdfFileFormat</a>. </p>

</div>
</div>
<a id="a3eb382b2d773579a0fc353c2d6c63040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb382b2d773579a0fc353c2d6c63040">&#9670;&nbsp;</a></span>FindAllFileFormatExtensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API std::set&lt;std::string&gt; FindAllFileFormatExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a set containing the extension(s) corresponding to all registered file formats. </p>

</div>
</div>
<a id="ab9d67519992ef59d03eff5f9b5ca3728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d67519992ef59d03eff5f9b5ca3728">&#9670;&nbsp;</a></span>FindByExtension() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API SdfFileFormatConstPtr FindByExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the file format instance that supports the extension for <code>path</code>. </p>
<p>If a format with a matching extension is not found, this returns a null file format pointer.</p>
<p>An extension may be handled by multiple file formats, but each with a different target. In such cases, if no <code>target</code> is specified, the file format that is registered as the primary plugin will be returned. Otherwise, the file format whose target matches <code>target</code> will be returned. </p>

</div>
</div>
<a id="ad700415c499bbb5a7d2a9a7ead748904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad700415c499bbb5a7d2a9a7ead748904">&#9670;&nbsp;</a></span>FindByExtension() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API SdfFileFormatConstPtr FindByExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a file format instance that supports the extension for <code>path</code> and whose target matches one of those specified by the given <code>args</code>. </p>
<p>If the <code>args</code> specify no target, then the file format that is registered as the primary plugin will be returned. If a format with a matching extension is not found, this returns a null file format pointer. </p>

</div>
</div>
<a id="a7217ccb019b97204c7e7cad86ee2fc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7217ccb019b97204c7e7cad86ee2fc92">&#9670;&nbsp;</a></span>FindById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API SdfFileFormatConstPtr FindById </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>formatId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the file format instance with the specified <code>formatId</code> identifier. </p>
<p>If a format with a matching identifier is not found, this returns a null file format pointer. </p>

</div>
</div>
<a id="acab8762adf43caac7b35f784babb5ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab8762adf43caac7b35f784babb5ae4">&#9670;&nbsp;</a></span>FormatSupportsEditing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API bool FormatSupportsEditing </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the file format for the supplied <code>extension</code> and <code>target</code> pair supports editing. </p>
<p>This method will not load the plugin that provides the specified file format. If the extension and target pair is invalid, this method will return false. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sdf_file_format.html#ada2c1b75bce2485538862ecddc9285bc" title="Returns true if the file format for the supplied extension and target pair supports reading.">FormatSupportsReading</a> </dd>
<dd>
<a class="el" href="class_sdf_file_format.html#add9fecbf8f4a1acac72dd5f9141f97ee" title="Returns true if the file format for the supplied extension and target pair supports writing.">FormatSupportsWriting</a> </dd></dl>

</div>
</div>
<a id="ada2c1b75bce2485538862ecddc9285bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2c1b75bce2485538862ecddc9285bc">&#9670;&nbsp;</a></span>FormatSupportsReading()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API bool FormatSupportsReading </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the file format for the supplied <code>extension</code> and <code>target</code> pair supports reading. </p>
<p>This method will not load the plugin that provides the specified file format. If the extension and target pair is invalid, this method will return false. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sdf_file_format.html#add9fecbf8f4a1acac72dd5f9141f97ee" title="Returns true if the file format for the supplied extension and target pair supports writing.">FormatSupportsWriting</a> </dd>
<dd>
<a class="el" href="class_sdf_file_format.html#acab8762adf43caac7b35f784babb5ae4" title="Returns true if the file format for the supplied extension and target pair supports editing.">FormatSupportsEditing</a> </dd></dl>

</div>
</div>
<a id="add9fecbf8f4a1acac72dd5f9141f97ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9fecbf8f4a1acac72dd5f9141f97ee">&#9670;&nbsp;</a></span>FormatSupportsWriting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API bool FormatSupportsWriting </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the file format for the supplied <code>extension</code> and <code>target</code> pair supports writing. </p>
<p>This method will not load the plugin that provides the specified file format. If the extension and target pair is invalid, this method will return false. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sdf_file_format.html#ada2c1b75bce2485538862ecddc9285bc" title="Returns true if the file format for the supplied extension and target pair supports reading.">FormatSupportsReading</a> </dd>
<dd>
<a class="el" href="class_sdf_file_format.html#acab8762adf43caac7b35f784babb5ae4" title="Returns true if the file format for the supplied extension and target pair supports editing.">FormatSupportsEditing</a> </dd></dl>

</div>
</div>
<a id="a830ffcfcd3441b645265536b05da4412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830ffcfcd3441b645265536b05da4412">&#9670;&nbsp;</a></span>GetDefaultFileFormatArguments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a> GetDefaultFileFormatArguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the FileFormatArguments that correspond to the default behavior of this file format when no FileFormatArguments are passed to NewLayer or InitData. </p>

</div>
</div>
<a id="a848b6bb7cedf72cb78e402c4402fdbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848b6bb7cedf72cb78e402c4402fdbc0">&#9670;&nbsp;</a></span>GetExternalAssetDependencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API std::set&lt;std::string&gt; GetExternalAssetDependencies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_layer.html">SdfLayer</a> &amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of resolved paths to external asset file dependencies for the given <code>layer</code>. </p>
<p>These are additional dependencies, specific to the file format, that are needed when generating the layer's contents and would not otherwise be discoverable through composition dependencies (i.e. sublayers, references, and payloads).</p>
<p>The default implementation returns an empty set. Derived file formats that depend on external assets to read and generate layer content should implement this function to return the external asset paths.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sdf_layer.html#ad168f0658add394429de6cc94d5139a0" title="Returns a set of resolved paths to all external asset dependencies the layer needs to generate its co...">SdfLayer::GetExternalAssetDependencies</a> </dd>
<dd>
<a class="el" href="class_sdf_layer.html#aadc795502e58ced5fec2a00cf282f27a" title="Reloads the layer from its persistent representation.">SdfLayer::Reload</a> </dd></dl>

</div>
</div>
<a id="ae2231eaa1ca0583f91a97f07cd51f731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2231eaa1ca0583f91a97f07cd51f731">&#9670;&nbsp;</a></span>GetFileCookie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API const std::string&amp; GetFileCookie </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the cookie to be used when writing files with this format. </p>

</div>
</div>
<a id="abcbb3a513cf28abac68c32f75dac4de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbb3a513cf28abac68c32f75dac4de2">&#9670;&nbsp;</a></span>GetFileExtension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API std::string GetFileExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the file extension for path or file name <code>s</code>, without the leading dot character. </p>

</div>
</div>
<a id="ab332582e9e4898a6462207fefe608ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab332582e9e4898a6462207fefe608ba9">&#9670;&nbsp;</a></span>GetFileExtensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API const std::vector&lt;std::string&gt;&amp; GetFileExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of extensions that this format supports. </p>

</div>
</div>
<a id="af94cee934d3f9f57ddec5d6ba4ab0f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94cee934d3f9f57ddec5d6ba4ab0f72">&#9670;&nbsp;</a></span>GetFormatId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API const <a class="el" href="class_tf_token.html">TfToken</a>&amp; GetFormatId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the format identifier. </p>

</div>
</div>
<a id="ae20721adeae2ab3e3f03b468d7c938c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20721adeae2ab3e3f03b468d7c938c2">&#9670;&nbsp;</a></span>GetPackageRootLayerPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API std::string GetPackageRootLayerPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the path of the "root" layer contained in the package layer at <code>resolvedPath</code> produced by this file format. </p>
<p>If this file format is not a package, returns the empty string.</p>
<p>The package root layer is the layer in the package layer that is used when that package is opened via <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a>. </p>

<p>Reimplemented in <a class="el" href="class_usd_usdz_file_format.html#a9ce9d0e8ec7208d62ee956ebe74815a7">UsdUsdzFileFormat</a>.</p>

</div>
</div>
<a id="a855ff6edf7f38b3a8863f597ebe557c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855ff6edf7f38b3a8863f597ebe557c9">&#9670;&nbsp;</a></span>GetPrimaryFileExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API const std::string&amp; GetPrimaryFileExtension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the primary file extension for this format. </p>
<p>This is the extension that is reported for layers using this file format. </p>

</div>
</div>
<a id="a3bd6905e6ee12562d4702db19fe6cc1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd6905e6ee12562d4702db19fe6cc1f">&#9670;&nbsp;</a></span>GetSchema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API const <a class="el" href="class_sdf_schema_base.html">SdfSchemaBase</a>&amp; GetSchema </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the schema for this format. </p>

</div>
</div>
<a id="affc99189439fce34c0c63d91a476b1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc99189439fce34c0c63d91a476b1b8">&#9670;&nbsp;</a></span>GetTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API const <a class="el" href="class_tf_token.html">TfToken</a>&amp; GetTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the target for this file format. </p>

</div>
</div>
<a id="ac2060c617124b513ccf799426ce149e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2060c617124b513ccf799426ce149e1">&#9670;&nbsp;</a></span>GetVersionString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API const <a class="el" href="class_tf_token.html">TfToken</a>&amp; GetVersionString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current version of this file format. </p>

</div>
</div>
<a id="a7e6fe1b90e69c2f271c631b2e0597b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6fe1b90e69c2f271c631b2e0597b23">&#9670;&nbsp;</a></span>InitData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API SdfAbstractDataRefPtr InitData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method allows the file format to bind to whatever data container is appropriate. </p>
<p>Returns a shared pointer to an <a class="el" href="class_sdf_abstract_data.html" title="Interface for scene description data storage.">SdfAbstractData</a> implementation. </p>

<p>Reimplemented in <a class="el" href="class_usd_usd_file_format.html#a4c75d117fd7aadba7bac14e6d4baecdb">UsdUsdFileFormat</a>, <a class="el" href="class_usd_usdz_file_format.html#a4c75d117fd7aadba7bac14e6d4baecdb">UsdUsdzFileFormat</a>, and <a class="el" href="class_usd_usdc_file_format.html#af4a11abfcd34d5fb2d449601edca3fbb">UsdUsdcFileFormat</a>.</p>

</div>
</div>
<a id="adc9391d69494e36aae0cbb1ca7007526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9391d69494e36aae0cbb1ca7007526">&#9670;&nbsp;</a></span>InitDetachedData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API SdfAbstractDataRefPtr InitDetachedData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="class_sdf_abstract_data.html" title="Interface for scene description data storage.">SdfAbstractData</a> providing access to the layer's data. </p>
<p>This data object is detached from any underlying storage. </p>

</div>
</div>
<a id="a688a3cc6628e445cc997e8952a434170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688a3cc6628e445cc997e8952a434170">&#9670;&nbsp;</a></span>IsPackage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API bool IsPackage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this file format is a package containing other assets. </p>

<p>Reimplemented in <a class="el" href="class_usd_usdz_file_format.html#a22a78b7fcfad11ec89c3fa0d6af3eade">UsdUsdzFileFormat</a>.</p>

</div>
</div>
<a id="ad92ebb5ec62184ddbc8913e4f05db070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92ebb5ec62184ddbc8913e4f05db070">&#9670;&nbsp;</a></span>IsPrimaryFormatForExtensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsPrimaryFormatForExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this file format is the primary format for the extensions it handles. </p>

</div>
</div>
<a id="ae5349dcbdcfd8c009af50d11c717e071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5349dcbdcfd8c009af50d11c717e071">&#9670;&nbsp;</a></span>IsSupportedExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsSupportedExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extension</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>extension</code> matches one of the extensions returned by GetFileExtensions. </p>

</div>
</div>
<a id="a79344fd3d6748c5beee6198a41fcd141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79344fd3d6748c5beee6198a41fcd141">&#9670;&nbsp;</a></span>NewLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_tf_ref_ptr.html">SdfLayerRefPtr</a> NewLayer </td>
          <td>(</td>
          <td class="paramtype">const SdfFileFormatConstPtr &amp;&#160;</td>
          <td class="paramname"><em>fileFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>realPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_asset_info.html">ArAssetInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>assetInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiate a layer. </p>

</div>
</div>
<a id="a8621e64c229386ea8e743faaf3f34d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8621e64c229386ea8e743faaf3f34d68">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API bool Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sdf_layer.html">SdfLayer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>metadataOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads scene description from the asset specified by <code>resolvedPath</code> into the layer <code>layer</code>. </p>
<p><code>metadataOnly</code> is a flag that asks for only the layer metadata to be read in, which can be much faster if that is all that is required. Note that this is just a hint: some FileFormat readers may disregard this flag and still fully populate the layer contents.</p>
<p>Returns true if the asset is successfully read into <code>layer</code>, false otherwise. </p>

<p>Implemented in <a class="el" href="class_usd_usd_file_format.html#a6cbcecd530b507afb144749dc92c3df3">UsdUsdFileFormat</a>, <a class="el" href="class_usd_usdz_file_format.html#a6cbcecd530b507afb144749dc92c3df3">UsdUsdzFileFormat</a>, <a class="el" href="class_sdf_text_file_format.html#a3a7786bd677bf3141266929984f61899">SdfTextFileFormat</a>, and <a class="el" href="class_usd_usdc_file_format.html#a87ee2a2817d4091767361896384f1a08">UsdUsdcFileFormat</a>.</p>

</div>
</div>
<a id="a12d42db40bca59050733c4b40a818475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d42db40bca59050733c4b40a818475">&#9670;&nbsp;</a></span>ReadDetached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool ReadDetached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sdf_layer.html">SdfLayer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>metadataOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads scene description from the asset specified by <code>resolvedPath</code> into the detached layer <code>layer</code>. </p>
<p>After reading is completed, <code>layer</code> must be detached from any underlying storage.</p>
<p><code>metadataOnly</code> is a flag that asks for only the layer metadata to be read in, which can be much faster if that is all that is required. Note that this is just a hint: some FileFormat readers may disregard this flag and still fully populate the layer contents.</p>
<p>Returns true if the asset is successfully read into <code>layer</code>, false if the the asset could not be read or if the resulting layer is not detached. </p>

</div>
</div>
<a id="a6bce13cc06020cb090ebe6746208b459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bce13cc06020cb090ebe6746208b459">&#9670;&nbsp;</a></span>ReadFromString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API bool ReadFromString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sdf_layer.html">SdfLayer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data in the string <code>str</code> into the layer <code>layer</code>. </p>
<p>If the file is successfully read, this method returns true. Otherwise, false is returned and errors are posted. </p>

<p>Reimplemented in <a class="el" href="class_usd_usd_file_format.html#a8ceaeb0ff7db4685cd64ea9268662f0a">UsdUsdFileFormat</a>, <a class="el" href="class_usd_usdz_file_format.html#a8ceaeb0ff7db4685cd64ea9268662f0a">UsdUsdzFileFormat</a>, <a class="el" href="class_sdf_text_file_format.html#a7f3f1032a340c0daae22cb0812405d15">SdfTextFileFormat</a>, and <a class="el" href="class_usd_usdc_file_format.html#a0d4de20ecb24b99445b0e6efd8549e07">UsdUsdcFileFormat</a>.</p>

</div>
</div>
<a id="a50928a94b9625eb1a149e07944ddb99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50928a94b9625eb1a149e07944ddb99d">&#9670;&nbsp;</a></span>ShouldReadAnonymousLayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool ShouldReadAnonymousLayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if anonymous layer identifiers should be passed to Read when a layer is opened or reloaded. </p>
<p>Anonymous layers will not have an asset backing and thus for most file formats there is nothing that can be read for an anonymous layer. However, there are file formats that use Read to generate dynamic layer content without reading any data from the resolved asset associated with the layer's identifier.</p>
<p>For these types of file formats it is useful to be able to open anonymous layers and allow Read to populate them to avoid requiring a placeholder asset to exist just so Read can populate the layer. </p>

</div>
</div>
<a id="ae5bee0843fce18d3c607c0b56b118319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bee0843fce18d3c607c0b56b118319">&#9670;&nbsp;</a></span>ShouldSkipAnonymousReload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool ShouldSkipAnonymousReload </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this file format prefers to skip reloading anonymous layers. </p>

</div>
</div>
<a id="a83eab906a0358ebdf94b03316bf66d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83eab906a0358ebdf94b03316bf66d80">&#9670;&nbsp;</a></span>SupportsEditing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool SupportsEditing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a convenience method for invoking <a class="el" href="class_sdf_file_format.html#acab8762adf43caac7b35f784babb5ae4">FormatSupportsEditing</a> with this format's extension and target. </p>

</div>
</div>
<a id="a5f99ff74942b86a7aa1ec7c69a617b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f99ff74942b86a7aa1ec7c69a617b64">&#9670;&nbsp;</a></span>SupportsReading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool SupportsReading </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this file format supports reading. </p>
<p>This is a convenience method for invoking <a class="el" href="class_sdf_file_format.html#ada2c1b75bce2485538862ecddc9285bc">FormatSupportsReading</a> with this format's extension and target </p>

</div>
</div>
<a id="a27f2b45688a158acb95d1d00b6d82e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f2b45688a158acb95d1d00b6d82e0f">&#9670;&nbsp;</a></span>SupportsWriting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool SupportsWriting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a convenience method for invoking <a class="el" href="class_sdf_file_format.html#add9fecbf8f4a1acac72dd5f9141f97ee">FormatSupportsWriting</a> with this format's extension and target. </p>

</div>
</div>
<a id="aebd911a48918fd2cad75a72f3839f40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd911a48918fd2cad75a72f3839f40e">&#9670;&nbsp;</a></span>WriteToFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API bool WriteToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_layer.html">SdfLayer</a> &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em> = <code><a class="el" href="class_sdf_file_format.html#a1dfd2030337b6243cd6424fce7397590">FileFormatArguments</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the content in <code>layer</code> into the file at <code>filePath</code>. </p>
<p>If the content is successfully written, this method returns true. Otherwise, false is returned and errors are posted. The default implementation returns false. </p>

<p>Reimplemented in <a class="el" href="class_usd_usd_file_format.html#ae3865175b4922f1bd3d96d3da2cda972">UsdUsdFileFormat</a>, <a class="el" href="class_usd_usdz_file_format.html#ae3865175b4922f1bd3d96d3da2cda972">UsdUsdzFileFormat</a>, <a class="el" href="class_sdf_text_file_format.html#aa46231c2bcdf2813f04d416edf95dfba">SdfTextFileFormat</a>, and <a class="el" href="class_usd_usdc_file_format.html#a8c63732a6ba64fedbea88c750cfcad73">UsdUsdcFileFormat</a>.</p>

</div>
</div>
<a id="a3d7243749d4e00e091c4df98705316d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7243749d4e00e091c4df98705316d9">&#9670;&nbsp;</a></span>WriteToStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API bool WriteToStream </td>
          <td>(</td>
          <td class="paramtype">const SdfSpecHandle &amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the provided <code>spec</code> to <code>out</code> indented <code>indent</code> levels. </p>

<p>Reimplemented in <a class="el" href="class_usd_usd_file_format.html#a100b1328d285eb43d51cfe29964f9c15">UsdUsdFileFormat</a>, <a class="el" href="class_usd_usdz_file_format.html#a100b1328d285eb43d51cfe29964f9c15">UsdUsdzFileFormat</a>, <a class="el" href="class_sdf_text_file_format.html#a2d8654690d8f5d79eedd196adac6b10c">SdfTextFileFormat</a>, and <a class="el" href="class_usd_usdc_file_format.html#afda8f65c5c2fea1cfedc0db9efbf7043">UsdUsdcFileFormat</a>.</p>

</div>
</div>
<a id="a3d36cf09ec2f2556ff6b1cb88823d0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d36cf09ec2f2556ff6b1cb88823d0d0">&#9670;&nbsp;</a></span>WriteToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDF_API bool WriteToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_layer.html">SdfLayer</a> &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the content in <code>layer</code> to the string <code>str</code>. </p>
<p>This function should write a textual representation of <code>layer</code> to the stream that can be read back in via ReadFromString. </p>

<p>Reimplemented in <a class="el" href="class_usd_usd_file_format.html#a02499fd71c04b071413f004cad32cc63">UsdUsdFileFormat</a>, <a class="el" href="class_usd_usdz_file_format.html#a02499fd71c04b071413f004cad32cc63">UsdUsdzFileFormat</a>, <a class="el" href="class_sdf_text_file_format.html#aaf98382ff1e14b26d95ab037935db49f">SdfTextFileFormat</a>, and <a class="el" href="class_usd_usdc_file_format.html#a0dc5e36f71d7b1e51d0e46ea66511a60">UsdUsdcFileFormat</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pxr/usd/sdf/<a class="el" href="file_format_8h_source.html">fileFormat.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_sdf_file_format.html">SdfFileFormat</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:03 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>