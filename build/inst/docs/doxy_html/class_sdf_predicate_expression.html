<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: SdfPredicateExpression Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_sdf_predicate_expression.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_sdf_predicate_expression-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SdfPredicateExpression Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a logical expression syntax tree consisting of predicate function calls joined by the logical operators 'and', 'or', 'not', and an implied-and operator that represents two subexpressions joined by only whitespace.  
 <a href="class_sdf_predicate_expression.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sdf_predicate_expression_1_1_fn_arg.html">FnArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a function argument name and value.  <a href="struct_sdf_predicate_expression_1_1_fn_arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sdf_predicate_expression_1_1_fn_call.html">FnCall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a function call in an expression with calling style, function name, and arguments.  <a href="struct_sdf_predicate_expression_1_1_fn_call.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a588e6b56097e045c733b60d25c4d45ab"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#a588e6b56097e045c733b60d25c4d45ab">Op</a> { <br />
&#160;&#160;<b>Call</b>, 
<b>Not</b>, 
<b>ImpliedAnd</b>, 
<b>And</b>, 
<br />
&#160;&#160;<b>Or</b>
<br />
 }</td></tr>
<tr class="memdesc:a588e6b56097e045c733b60d25c4d45ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerant describing a subexpression operation.  <a href="class_sdf_predicate_expression.html#a588e6b56097e045c733b60d25c4d45ab">More...</a><br /></td></tr>
<tr class="separator:a588e6b56097e045c733b60d25c4d45ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a00cf42d2c7ad480558ccc421ac51a451"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#a00cf42d2c7ad480558ccc421ac51a451">SdfPredicateExpression</a> ()=default</td></tr>
<tr class="memdesc:a00cf42d2c7ad480558ccc421ac51a451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the empty expression whose bool-operator returns false.  <a href="#a00cf42d2c7ad480558ccc421ac51a451">More...</a><br /></td></tr>
<tr class="separator:a00cf42d2c7ad480558ccc421ac51a451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7962b67351fea52db46989b5456558d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#ac7962b67351fea52db46989b5456558d">SdfPredicateExpression</a> (<a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> const &amp;)=default</td></tr>
<tr class="memdesc:ac7962b67351fea52db46989b5456558d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construct from another expression.  <a href="#ac7962b67351fea52db46989b5456558d">More...</a><br /></td></tr>
<tr class="separator:ac7962b67351fea52db46989b5456558d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f814ee8352c647393880eea6c04207"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#a76f814ee8352c647393880eea6c04207">SdfPredicateExpression</a> (<a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a76f814ee8352c647393880eea6c04207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construct from another expression.  <a href="#a76f814ee8352c647393880eea6c04207">More...</a><br /></td></tr>
<tr class="separator:a76f814ee8352c647393880eea6c04207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4a71ff954f56dd027cbf5d386e210e"><td class="memItemLeft" align="right" valign="top">SDF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#afe4a71ff954f56dd027cbf5d386e210e">SdfPredicateExpression</a> (std::string const &amp;expr, std::string const &amp;context={})</td></tr>
<tr class="memdesc:afe4a71ff954f56dd027cbf5d386e210e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an expression by parsing <code>expr</code>.  <a href="#afe4a71ff954f56dd027cbf5d386e210e">More...</a><br /></td></tr>
<tr class="separator:afe4a71ff954f56dd027cbf5d386e210e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854a3c69600d8f30d5ed4a1e738e87af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#a854a3c69600d8f30d5ed4a1e738e87af">operator=</a> (<a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> const &amp;)=default</td></tr>
<tr class="memdesc:a854a3c69600d8f30d5ed4a1e738e87af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assign from another expression.  <a href="#a854a3c69600d8f30d5ed4a1e738e87af">More...</a><br /></td></tr>
<tr class="separator:a854a3c69600d8f30d5ed4a1e738e87af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bcd0d7b3a057711f298ffa7e13d34f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#aa9bcd0d7b3a057711f298ffa7e13d34f">operator=</a> (<a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:aa9bcd0d7b3a057711f298ffa7e13d34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assign from another expression.  <a href="#aa9bcd0d7b3a057711f298ffa7e13d34f">More...</a><br /></td></tr>
<tr class="separator:aa9bcd0d7b3a057711f298ffa7e13d34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddbd0abb5a2d4688671d1e5f3e091bb"><td class="memItemLeft" align="right" valign="top">SDF_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#a5ddbd0abb5a2d4688671d1e5f3e091bb">Walk</a> (<a class="el" href="class_tf_function_ref.html">TfFunctionRef</a>&lt; void(<a class="el" href="class_sdf_predicate_expression.html#a588e6b56097e045c733b60d25c4d45ab">Op</a>, int)&gt; logic, <a class="el" href="class_tf_function_ref.html">TfFunctionRef</a>&lt; void(<a class="el" href="struct_sdf_predicate_expression_1_1_fn_call.html">FnCall</a> const &amp;)&gt; call) const</td></tr>
<tr class="memdesc:a5ddbd0abb5a2d4688671d1e5f3e091bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk this expression's syntax tree in depth-first order, calling <code>call</code> with the current function call when a function call is encountered, and calling <code>logic</code> multiple times for each logical operation encountered.  <a href="#a5ddbd0abb5a2d4688671d1e5f3e091bb">More...</a><br /></td></tr>
<tr class="separator:a5ddbd0abb5a2d4688671d1e5f3e091bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb61b3ba6cc1977f089a2018bc1e6def"><td class="memItemLeft" align="right" valign="top">SDF_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#aeb61b3ba6cc1977f089a2018bc1e6def">WalkWithOpStack</a> (<a class="el" href="class_tf_function_ref.html">TfFunctionRef</a>&lt; void(std::vector&lt; std::pair&lt; <a class="el" href="class_sdf_predicate_expression.html#a588e6b56097e045c733b60d25c4d45ab">Op</a>, int &gt;&gt; const &amp;)&gt; logic, <a class="el" href="class_tf_function_ref.html">TfFunctionRef</a>&lt; void(<a class="el" href="struct_sdf_predicate_expression_1_1_fn_call.html">FnCall</a> const &amp;)&gt; call) const</td></tr>
<tr class="memdesc:aeb61b3ba6cc1977f089a2018bc1e6def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="class_sdf_predicate_expression.html#a5ddbd0abb5a2d4688671d1e5f3e091bb" title="Walk this expression&#39;s syntax tree in depth-first order, calling call with the current function call ...">Walk()</a>, except that the <code>logic</code> function is called with a const reference to the current Op stack instead of just the top of it.  <a href="#aeb61b3ba6cc1977f089a2018bc1e6def">More...</a><br /></td></tr>
<tr class="separator:aeb61b3ba6cc1977f089a2018bc1e6def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454ec81c69a61bdf6b51db0a10d51b80"><td class="memItemLeft" align="right" valign="top">SDF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#a454ec81c69a61bdf6b51db0a10d51b80">GetText</a> () const</td></tr>
<tr class="memdesc:a454ec81c69a61bdf6b51db0a10d51b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a text representation of this expression that parses to the same expression.  <a href="#a454ec81c69a61bdf6b51db0a10d51b80">More...</a><br /></td></tr>
<tr class="separator:a454ec81c69a61bdf6b51db0a10d51b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e12342fc420701fbffd97025421575a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#a8e12342fc420701fbffd97025421575a">IsEmpty</a> () const</td></tr>
<tr class="memdesc:a8e12342fc420701fbffd97025421575a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is the empty expression; i.e.  <a href="#a8e12342fc420701fbffd97025421575a">More...</a><br /></td></tr>
<tr class="separator:a8e12342fc420701fbffd97025421575a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b76affb3b5d35fa419ac234144038b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#a67b76affb3b5d35fa419ac234144038b">operator bool</a> () const</td></tr>
<tr class="memdesc:a67b76affb3b5d35fa419ac234144038b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this expression contains any operations, false otherwise.  <a href="#a67b76affb3b5d35fa419ac234144038b">More...</a><br /></td></tr>
<tr class="separator:a67b76affb3b5d35fa419ac234144038b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230b1b2d7246855d5d02d1c6b5a925ee"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#a230b1b2d7246855d5d02d1c6b5a925ee">GetParseError</a> () const &amp;</td></tr>
<tr class="memdesc:a230b1b2d7246855d5d02d1c6b5a925ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return parsing errors as a string if this function was constructed from a string and parse errors were encountered.  <a href="#a230b1b2d7246855d5d02d1c6b5a925ee">More...</a><br /></td></tr>
<tr class="separator:a230b1b2d7246855d5d02d1c6b5a925ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5dccd0548d93734790b7f60b36afce"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#a3d5dccd0548d93734790b7f60b36afce">GetParseError</a> () const &amp;&amp;</td></tr>
<tr class="memdesc:a3d5dccd0548d93734790b7f60b36afce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return parsing errors as a string if this function was constructed from a string and parse errors were encountered.  <a href="#a3d5dccd0548d93734790b7f60b36afce">More...</a><br /></td></tr>
<tr class="separator:a3d5dccd0548d93734790b7f60b36afce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7055191a022f285a076bb5b7c31f3bef"><td class="memItemLeft" align="right" valign="top">static SDF_API <a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#a7055191a022f285a076bb5b7c31f3bef">MakeNot</a> (<a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> &amp;&amp;right)</td></tr>
<tr class="memdesc:a7055191a022f285a076bb5b7c31f3bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a new expression by prepending the 'not' operator onto <code>right</code>.  <a href="#a7055191a022f285a076bb5b7c31f3bef">More...</a><br /></td></tr>
<tr class="separator:a7055191a022f285a076bb5b7c31f3bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1b067ecc4aec8a436d4c39e2e1460e"><td class="memItemLeft" align="right" valign="top">static SDF_API <a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#a6b1b067ecc4aec8a436d4c39e2e1460e">MakeOp</a> (<a class="el" href="class_sdf_predicate_expression.html#a588e6b56097e045c733b60d25c4d45ab">Op</a> op, <a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> &amp;&amp;left, <a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> &amp;&amp;right)</td></tr>
<tr class="memdesc:a6b1b067ecc4aec8a436d4c39e2e1460e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a new expression by combining <code>left</code> and <code>right</code> with the operator <code>op</code>.  <a href="#a6b1b067ecc4aec8a436d4c39e2e1460e">More...</a><br /></td></tr>
<tr class="separator:a6b1b067ecc4aec8a436d4c39e2e1460e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61972aa01b493d3130d2570273389b9"><td class="memItemLeft" align="right" valign="top">static SDF_API <a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_predicate_expression.html#ab61972aa01b493d3130d2570273389b9">MakeCall</a> (<a class="el" href="struct_sdf_predicate_expression_1_1_fn_call.html">FnCall</a> &amp;&amp;call)</td></tr>
<tr class="memdesc:ab61972aa01b493d3130d2570273389b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a new expression containing just a the function call <code>call</code>.  <a href="#ab61972aa01b493d3130d2570273389b9">More...</a><br /></td></tr>
<tr class="separator:ab61972aa01b493d3130d2570273389b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1b50f97c5715bb4783c8a453a6a998f7"><td class="memTemplParams" colspan="2"><a id="a1b50f97c5715bb4783c8a453a6a998f7"></a>
template&lt;class HashState &gt; </td></tr>
<tr class="memitem:a1b50f97c5715bb4783c8a453a6a998f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TfHashAppend</b> (HashState &amp;h, <a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> const &amp;expr)</td></tr>
<tr class="separator:a1b50f97c5715bb4783c8a453a6a998f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f04c7e3740adacecfb39e3884755af1"><td class="memItemLeft" align="right" valign="top"><a id="a9f04c7e3740adacecfb39e3884755af1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> const &amp;l, <a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> const &amp;r)</td></tr>
<tr class="separator:a9f04c7e3740adacecfb39e3884755af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33a3031df0b750b86c4a40539221d67"><td class="memItemLeft" align="right" valign="top"><a id="aa33a3031df0b750b86c4a40539221d67"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> const &amp;l, <a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> const &amp;r)</td></tr>
<tr class="separator:aa33a3031df0b750b86c4a40539221d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fc1f1aba4aab1a221f521efe00a082"><td class="memItemLeft" align="right" valign="top"><a id="ae9fc1f1aba4aab1a221f521efe00a082"></a>
SDF_API friend std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, <a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> const &amp;)</td></tr>
<tr class="separator:ae9fc1f1aba4aab1a221f521efe00a082"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a logical expression syntax tree consisting of predicate function calls joined by the logical operators 'and', 'or', 'not', and an implied-and operator that represents two subexpressions joined by only whitespace. </p>
<p>An <a class="el" href="class_sdf_predicate_expression.html" title="Represents a logical expression syntax tree consisting of predicate function calls joined by the logi...">SdfPredicateExpression</a> can be constructed with a string, which will parse an expression. The syntax for an expression is as follows:</p>
<p>The fundamental building blocks are calls to predicate functions. There are three syntaxes for function calls.</p>
<ul>
<li>Bare call: just a function name: <code>isDefined</code> </li>
<li>Colon call: name, colon, positional arguments: <code>isa:mammal,bird</code> </li>
<li>Paren call: name and parenthesized positional and keyword args: <code>isClose(1.23, tolerance=0.01)</code></li>
</ul>
<p>Colon call arguments are all positional and must be separated by commas with no spaces between arguments. In paren calls, positional arguments must precede keyword arguments, and whitespace is allowed between arguments.</p>
<p>The string parser supports argument values of the following types: double-quoted "strings", unquoted strings, integers, floating-point numbers, and boolean values 'true' and 'false'.</p>
<p>The unary operator 'not' may appear preceding a function call, or a subexpresion enclosed in parentheses. The binary operators 'and' and 'or' may appear between subexpressions. If subexpressions appear adjacent to each other (other than possible whitespace), this is considered an implied 'and' operator.</p>
<p>Operator precedence in order from highest to lowest is: 'not', &lt;implied-and&gt;, 'and', 'or'.</p>
<p>Here are some examples of valid predicate expression syntax:</p>
<ul>
<li><code>foo</code> (call "foo" with no arguments) </li>
<li><code>foo bar</code> (implicit 'and' of "foo" and "bar") </li>
<li><code>foo not bar</code> (implicit 'and' of "foo" and "not bar") </li>
<li><code>color:red (shiny or matte)</code> </li>
<li><code>animal or mineral or vegetable</code> </li>
<li><code>(mammal or bird) and (tame or small)</code> </li>
<li><code>isClose(100, tolerance=3.0) or negative</code> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="predicate_expression_8h_source.html#l00084">84</a> of file <a class="el" href="predicate_expression_8h_source.html">predicateExpression.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a588e6b56097e045c733b60d25c4d45ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588e6b56097e045c733b60d25c4d45ab">&#9670;&nbsp;</a></span>Op</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sdf_predicate_expression.html#a588e6b56097e045c733b60d25c4d45ab">Op</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerant describing a subexpression operation. </p>

<p class="definition">Definition at line <a class="el" href="predicate_expression_8h_source.html#l00179">179</a> of file <a class="el" href="predicate_expression_8h_source.html">predicateExpression.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a00cf42d2c7ad480558ccc421ac51a451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cf42d2c7ad480558ccc421ac51a451">&#9670;&nbsp;</a></span>SdfPredicateExpression() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the empty expression whose bool-operator returns false. </p>

</div>
</div>
<a id="ac7962b67351fea52db46989b5456558d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7962b67351fea52db46989b5456558d">&#9670;&nbsp;</a></span>SdfPredicateExpression() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy construct from another expression. </p>

</div>
</div>
<a id="a76f814ee8352c647393880eea6c04207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f814ee8352c647393880eea6c04207">&#9670;&nbsp;</a></span>SdfPredicateExpression() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move construct from another expression. </p>

</div>
</div>
<a id="afe4a71ff954f56dd027cbf5d386e210e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4a71ff954f56dd027cbf5d386e210e">&#9670;&nbsp;</a></span>SdfPredicateExpression() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>context</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an expression by parsing <code>expr</code>. </p>
<p>If provided, <code>context</code> appears in a parse error, if one is generated. See <a class="el" href="class_sdf_predicate_expression.html#a230b1b2d7246855d5d02d1c6b5a925ee" title="Return parsing errors as a string if this function was constructed from a string and parse errors wer...">GetParseError()</a>. See the class documentation for details on expression syntax. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a230b1b2d7246855d5d02d1c6b5a925ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230b1b2d7246855d5d02d1c6b5a925ee">&#9670;&nbsp;</a></span>GetParseError() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; GetParseError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return parsing errors as a string if this function was constructed from a string and parse errors were encountered. </p>

<p class="definition">Definition at line <a class="el" href="predicate_expression_8h_source.html#l00260">260</a> of file <a class="el" href="predicate_expression_8h_source.html">predicateExpression.h</a>.</p>

</div>
</div>
<a id="a3d5dccd0548d93734790b7f60b36afce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5dccd0548d93734790b7f60b36afce">&#9670;&nbsp;</a></span>GetParseError() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string GetParseError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return parsing errors as a string if this function was constructed from a string and parse errors were encountered. </p>

<p class="definition">Definition at line <a class="el" href="predicate_expression_8h_source.html#l00266">266</a> of file <a class="el" href="predicate_expression_8h_source.html">predicateExpression.h</a>.</p>

</div>
</div>
<a id="a454ec81c69a61bdf6b51db0a10d51b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454ec81c69a61bdf6b51db0a10d51b80">&#9670;&nbsp;</a></span>GetText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API std::string GetText </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a text representation of this expression that parses to the same expression. </p>

</div>
</div>
<a id="a8e12342fc420701fbffd97025421575a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e12342fc420701fbffd97025421575a">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is the empty expression; i.e. </p>
<p>default-constructed or constructed from a string with invalid syntax. </p>

<p class="definition">Definition at line <a class="el" href="predicate_expression_8h_source.html#l00249">249</a> of file <a class="el" href="predicate_expression_8h_source.html">predicateExpression.h</a>.</p>

</div>
</div>
<a id="ab61972aa01b493d3130d2570273389b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61972aa01b493d3130d2570273389b9">&#9670;&nbsp;</a></span>MakeCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API <a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> MakeCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sdf_predicate_expression_1_1_fn_call.html">FnCall</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>call</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce a new expression containing just a the function call <code>call</code>. </p>

</div>
</div>
<a id="a7055191a022f285a076bb5b7c31f3bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7055191a022f285a076bb5b7c31f3bef">&#9670;&nbsp;</a></span>MakeNot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API <a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> MakeNot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce a new expression by prepending the 'not' operator onto <code>right</code>. </p>

</div>
</div>
<a id="a6b1b067ecc4aec8a436d4c39e2e1460e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1b067ecc4aec8a436d4c39e2e1460e">&#9670;&nbsp;</a></span>MakeOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API <a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> MakeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sdf_predicate_expression.html#a588e6b56097e045c733b60d25c4d45ab">Op</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce a new expression by combining <code>left</code> and <code>right</code> with the operator <code>op</code>. </p>
<p>The <code>op</code> must be one of ImpliedAnd, And, or Or. </p>

</div>
</div>
<a id="a67b76affb3b5d35fa419ac234144038b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b76affb3b5d35fa419ac234144038b">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this expression contains any operations, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="predicate_expression_8h_source.html#l00254">254</a> of file <a class="el" href="predicate_expression_8h_source.html">predicateExpression.h</a>.</p>

</div>
</div>
<a id="a854a3c69600d8f30d5ed4a1e738e87af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854a3c69600d8f30d5ed4a1e738e87af">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assign from another expression. </p>

</div>
</div>
<a id="aa9bcd0d7b3a057711f298ffa7e13d34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9bcd0d7b3a057711f298ffa7e13d34f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assign from another expression. </p>

</div>
</div>
<a id="a5ddbd0abb5a2d4688671d1e5f3e091bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddbd0abb5a2d4688671d1e5f3e091bb">&#9670;&nbsp;</a></span>Walk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API void Walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_function_ref.html">TfFunctionRef</a>&lt; void(<a class="el" href="class_sdf_predicate_expression.html#a588e6b56097e045c733b60d25c4d45ab">Op</a>, int)&gt;&#160;</td>
          <td class="paramname"><em>logic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tf_function_ref.html">TfFunctionRef</a>&lt; void(<a class="el" href="struct_sdf_predicate_expression_1_1_fn_call.html">FnCall</a> const &amp;)&gt;&#160;</td>
          <td class="paramname"><em>call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk this expression's syntax tree in depth-first order, calling <code>call</code> with the current function call when a function call is encountered, and calling <code>logic</code> multiple times for each logical operation encountered. </p>
<p>When calling <code>logic</code>, the logical operation is passed as the <code>Op</code> parameter, and an integer indicating "where" we are in the set of operands is passed as the int parameter. For a 'not', call <code>logic</code>(Op=Not, int=0) to start, then after the subexpression that the 'not' applies to is walked, call <code>logic</code>(Op=Not, int=1). For the binary operators like 'and' and 'or', call <code>logic(Op, 0)</code> before the first argument, then <code>logic(Op, 1)</code> after the first subexpression, then <code>logic(Op, 2)</code> after the second subexpression. For a concrete example, consider the following expression: </p><pre class="fragment">(foo or bar) and not baz
</pre><p>The sequence of calls from <a class="el" href="class_sdf_predicate_expression.html#a5ddbd0abb5a2d4688671d1e5f3e091bb" title="Walk this expression&#39;s syntax tree in depth-first order, calling call with the current function call ...">Walk()</a> will be: </p><pre class="fragment">logic(And, 0)
logic(Or, 0)
call("foo")
logic(Or, 1)
call("bar")
logic(Or, 2)
logic(And, 1)
logic(Not, 0)
call("baz")
logic(Not, 1)
logic(And, 2)
</pre> 
</div>
</div>
<a id="aeb61b3ba6cc1977f089a2018bc1e6def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb61b3ba6cc1977f089a2018bc1e6def">&#9670;&nbsp;</a></span>WalkWithOpStack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API void WalkWithOpStack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="class_sdf_predicate_expression.html#a5ddbd0abb5a2d4688671d1e5f3e091bb" title="Walk this expression&#39;s syntax tree in depth-first order, calling call with the current function call ...">Walk()</a>, except that the <code>logic</code> function is called with a const reference to the current Op stack instead of just the top of it. </p>
<p>The top of the Op stack is the vector's back. This is useful in case the processing code needs to understand the context in which an Op appears. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pxr/usd/sdf/<a class="el" href="predicate_expression_8h_source.html">predicateExpression.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_sdf_predicate_expression.html">SdfPredicateExpression</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:04 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>