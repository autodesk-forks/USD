<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: HdMeshUtil Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_hd_mesh_util.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_hd_mesh_util-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HdMeshUtil Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of utility algorithms for generating triangulation and quadrangulation of an input topology.  
 <a href="class_hd_mesh_util.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae30ed555b5e5194e45dd8a0f1686b06"><td class="memItemLeft" align="right" valign="top"><a id="aae30ed555b5e5194e45dd8a0f1686b06"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HdMeshUtil</b> (<a class="el" href="class_hd_mesh_topology.html">HdMeshTopology</a> const *topology, <a class="el" href="class_sdf_path.html">SdfPath</a> const &amp;id)</td></tr>
<tr class="separator:aae30ed555b5e5194e45dd8a0f1686b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aea3e2d25e33795bcd17fc0f5808637"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_mesh_util.html#a3aea3e2d25e33795bcd17fc0f5808637">EnumerateEdges</a> (std::vector&lt; <a class="el" href="class_gf_vec2i.html">GfVec2i</a> &gt; *edgeVerticesOut) const</td></tr>
<tr class="memdesc:a3aea3e2d25e33795bcd17fc0f5808637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a buffer filled with face vertex index pairs corresponding to the sequence in which edges are visited when iterating through the mesh topology.  <a href="#a3aea3e2d25e33795bcd17fc0f5808637">More...</a><br /></td></tr>
<tr class="separator:a3aea3e2d25e33795bcd17fc0f5808637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Triangulation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Produces a mesh where each non-triangle face in the base mesh topology is fan-triangulated such that the resulting mesh consists entirely of triangles.</p>
<p>In order to access per-face signals (face color, face selection etc) we need a mapping from primitiveID to authored face index domain. This is encoded in primitiveParams, and computed along with indices. See <a class="el" href="class_hd_mesh_util.html#PrimitiveParamEncoding">PrimitiveParamEncoding</a>. </p>
</div></td></tr>
<tr class="memitem:a595af20f506e78d0a5c5b432474fadc9"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_mesh_util.html#a595af20f506e78d0a5c5b432474fadc9">ComputeTriangleIndices</a> (VtVec3iArray *indices, VtIntArray *primitiveParams, VtIntArray *edgeIndices=nullptr) const</td></tr>
<tr class="memdesc:a595af20f506e78d0a5c5b432474fadc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a triangulation of the input topology.  <a href="#a595af20f506e78d0a5c5b432474fadc9">More...</a><br /></td></tr>
<tr class="separator:a595af20f506e78d0a5c5b432474fadc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba0e34d324feae18022a3a4120324a6"><td class="memItemLeft" align="right" valign="top">HD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_mesh_util.html#a3ba0e34d324feae18022a3a4120324a6">ComputeTriangulatedFaceVaryingPrimvar</a> (void const *source, int numElements, HdType dataType, <a class="el" href="class_vt_value.html">VtValue</a> *triangulated) const</td></tr>
<tr class="memdesc:a3ba0e34d324feae18022a3a4120324a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a triangulation of a face-varying primvar.  <a href="#a3ba0e34d324feae18022a3a4120324a6">More...</a><br /></td></tr>
<tr class="separator:a3ba0e34d324feae18022a3a4120324a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Quadrangulation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Produces a mesh where each non-quad face in the base mesh topology is quadrangulated such that the resulting mesh consists entirely of quads.</p>
<p>Additionally, supports splitting each resulting quad face into a pair of triangles. This is different than simply triangulating the base mesh topology and can be useful for maintaining consistency with quad-based subdivision schemes.</p>
<p>In order to access per-face signals (face color, face selection etc) we need a mapping from primitiveID to authored face index domain. This is encoded in primitiveParams, and computed along with indices. See <a class="el" href="class_hd_mesh_util.html#PrimitiveParamEncoding">PrimitiveParamEncoding</a>. </p>
</div></td></tr>
<tr class="memitem:ab9ba80142c89ef75a4a232bf59aabf48"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_mesh_util.html#ab9ba80142c89ef75a4a232bf59aabf48">ComputeQuadInfo</a> (<a class="el" href="struct_hd_quad_info.html">HdQuadInfo</a> *quadInfo) const</td></tr>
<tr class="memdesc:ab9ba80142c89ef75a4a232bf59aabf48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a quadInfo struct for the input topology.  <a href="#ab9ba80142c89ef75a4a232bf59aabf48">More...</a><br /></td></tr>
<tr class="separator:ab9ba80142c89ef75a4a232bf59aabf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9f51acd1b38103984439f84caf40e8"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_mesh_util.html#a8d9f51acd1b38103984439f84caf40e8">ComputeQuadIndices</a> (VtIntArray *indices, VtIntArray *primitiveParams, VtVec2iArray *edgeIndices=nullptr) const</td></tr>
<tr class="memdesc:a8d9f51acd1b38103984439f84caf40e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return quadrangulated indices of the input topology.  <a href="#a8d9f51acd1b38103984439f84caf40e8">More...</a><br /></td></tr>
<tr class="separator:a8d9f51acd1b38103984439f84caf40e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22d1d3ff837c0b1692059addf85e6e5"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_mesh_util.html#aa22d1d3ff837c0b1692059addf85e6e5">ComputeTriQuadIndices</a> (VtIntArray *indices, VtIntArray *primitiveParams, VtVec2iArray *edgeIndices=nullptr) const</td></tr>
<tr class="memdesc:aa22d1d3ff837c0b1692059addf85e6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return triquad indices (triangulated after quadrangulation) of the input topology.  <a href="#aa22d1d3ff837c0b1692059addf85e6e5">More...</a><br /></td></tr>
<tr class="separator:aa22d1d3ff837c0b1692059addf85e6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3efb9f97d577c3450156808825a182e"><td class="memItemLeft" align="right" valign="top">HD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_mesh_util.html#ac3efb9f97d577c3450156808825a182e">ComputeQuadrangulatedPrimvar</a> (<a class="el" href="struct_hd_quad_info.html">HdQuadInfo</a> const *qi, void const *source, int numElements, HdType dataType, <a class="el" href="class_vt_value.html">VtValue</a> *quadrangulated) const</td></tr>
<tr class="memdesc:ac3efb9f97d577c3450156808825a182e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a quadrangulation of a per-vertex primvar.  <a href="#ac3efb9f97d577c3450156808825a182e">More...</a><br /></td></tr>
<tr class="separator:ac3efb9f97d577c3450156808825a182e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8332741c3d52a027191ff58c2438d165"><td class="memItemLeft" align="right" valign="top">HD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_mesh_util.html#a8332741c3d52a027191ff58c2438d165">ComputeQuadrangulatedFaceVaryingPrimvar</a> (void const *source, int numElements, HdType dataType, <a class="el" href="class_vt_value.html">VtValue</a> *quadrangulated) const</td></tr>
<tr class="memdesc:a8332741c3d52a027191ff58c2438d165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a quadrangulation of a face-varying primvar.  <a href="#a8332741c3d52a027191ff58c2438d165">More...</a><br /></td></tr>
<tr class="separator:a8332741c3d52a027191ff58c2438d165"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Primitive Param bit encoding</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp30233abfe81c77ef1861cf256a86033f"></a><a class="anchor" id="PrimitiveParamEncoding"></a></p>
<p>This encoding provides information about each sub-face resulting from the triangulation or quadrangulation of a base topology face.</p>
<p>The encoded faceIndex is the index of the base topology face corresponding to a triangulated or quadrangulated sub-face.</p>
<p>The encoded edge flag identifies where a sub-face occurs in the sequence of sub-faces produced for each base topology face. This edge flag can be used to determine which edges of a sub-face correspond to edges of a base topology face and which are internal edges that were introduced by triangulation or quadrangulation:</p><ul>
<li>0 unaffected triangle or quad base topology face</li>
<li>1 first sub-face produced by triangulation or quadrangulation</li>
<li>2 last sub-face produced by triangulation or quadrangulation</li>
<li>3 intermediate sub-face produced by triangulation or quadrangulation </li>
</ul>
</td></tr>
<tr class="memitem:a202aaf296ec1055f880d7e2ce2d8af9f"><td class="memItemLeft" align="right" valign="top"><a id="a202aaf296ec1055f880d7e2ce2d8af9f"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>EncodeCoarseFaceParam</b> (int faceIndex, int edgeFlag)</td></tr>
<tr class="separator:a202aaf296ec1055f880d7e2ce2d8af9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9736da5f434af0eab8d2d3c002b18463"><td class="memItemLeft" align="right" valign="top"><a id="a9736da5f434af0eab8d2d3c002b18463"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>DecodeFaceIndexFromCoarseFaceParam</b> (int coarseFaceParam)</td></tr>
<tr class="separator:a9736da5f434af0eab8d2d3c002b18463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c6d3f990f7f51b9f0983d2499c1065"><td class="memItemLeft" align="right" valign="top"><a id="aa0c6d3f990f7f51b9f0983d2499c1065"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>DecodeEdgeFlagFromCoarseFaceParam</b> (int coarseFaceParam)</td></tr>
<tr class="separator:aa0c6d3f990f7f51b9f0983d2499c1065"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A collection of utility algorithms for generating triangulation and quadrangulation of an input topology. </p>

<p class="definition">Definition at line <a class="el" href="mesh_util_8h_source.html#l00082">82</a> of file <a class="el" href="mesh_util_8h_source.html">meshUtil.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8d9f51acd1b38103984439f84caf40e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9f51acd1b38103984439f84caf40e8">&#9670;&nbsp;</a></span>ComputeQuadIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API void ComputeQuadIndices </td>
          <td>(</td>
          <td class="paramtype">VtIntArray *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VtIntArray *&#160;</td>
          <td class="paramname"><em>primitiveParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VtVec2iArray *&#160;</td>
          <td class="paramname"><em>edgeIndices</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return quadrangulated indices of the input topology. </p>
<p>indices and primitiveParams are output parameters. </p>

</div>
</div>
<a id="ab9ba80142c89ef75a4a232bf59aabf48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ba80142c89ef75a4a232bf59aabf48">&#9670;&nbsp;</a></span>ComputeQuadInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API void ComputeQuadInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_hd_quad_info.html">HdQuadInfo</a> *&#160;</td>
          <td class="paramname"><em>quadInfo</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a quadInfo struct for the input topology. </p>

</div>
</div>
<a id="a8332741c3d52a027191ff58c2438d165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8332741c3d52a027191ff58c2438d165">&#9670;&nbsp;</a></span>ComputeQuadrangulatedFaceVaryingPrimvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API bool ComputeQuadrangulatedFaceVaryingPrimvar </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HdType&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> *&#160;</td>
          <td class="paramname"><em>quadrangulated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a quadrangulation of a face-varying primvar. </p>
<p>source is a buffer of size numElements and type corresponding to dataType (e.g. HdTypeFloatVec3); the result is a VtArray&lt;T&gt; of the correct type written to the variable "quadrangulated". This function returns false if it can't resolve dataType. </p>

</div>
</div>
<a id="ac3efb9f97d577c3450156808825a182e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3efb9f97d577c3450156808825a182e">&#9670;&nbsp;</a></span>ComputeQuadrangulatedPrimvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API bool ComputeQuadrangulatedPrimvar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_hd_quad_info.html">HdQuadInfo</a> const *&#160;</td>
          <td class="paramname"><em>qi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HdType&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> *&#160;</td>
          <td class="paramname"><em>quadrangulated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a quadrangulation of a per-vertex primvar. </p>
<p>source is a buffer of size numElements and type corresponding to dataType (e.g. HdTypeFloatVec3); the result is a VtArray&lt;T&gt; of the correct type written to the variable "quadrangulated". This function returns false if it can't resolve dataType. </p>

</div>
</div>
<a id="a595af20f506e78d0a5c5b432474fadc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595af20f506e78d0a5c5b432474fadc9">&#9670;&nbsp;</a></span>ComputeTriangleIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API void ComputeTriangleIndices </td>
          <td>(</td>
          <td class="paramtype">VtVec3iArray *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VtIntArray *&#160;</td>
          <td class="paramname"><em>primitiveParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VtIntArray *&#160;</td>
          <td class="paramname"><em>edgeIndices</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a triangulation of the input topology. </p>
<p>indices and primitiveParams are output parameters. </p>

</div>
</div>
<a id="a3ba0e34d324feae18022a3a4120324a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba0e34d324feae18022a3a4120324a6">&#9670;&nbsp;</a></span>ComputeTriangulatedFaceVaryingPrimvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API bool ComputeTriangulatedFaceVaryingPrimvar </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HdType&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> *&#160;</td>
          <td class="paramname"><em>triangulated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a triangulation of a face-varying primvar. </p>
<p>source is a buffer of size numElements and type corresponding to dataType (e.g. HdTypeFloatVec3); the result is a VtArray&lt;T&gt; of the correct type written to the variable "triangulated". This function returns false if it can't resolve dataType. </p>

</div>
</div>
<a id="aa22d1d3ff837c0b1692059addf85e6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22d1d3ff837c0b1692059addf85e6e5">&#9670;&nbsp;</a></span>ComputeTriQuadIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API void ComputeTriQuadIndices </td>
          <td>(</td>
          <td class="paramtype">VtIntArray *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VtIntArray *&#160;</td>
          <td class="paramname"><em>primitiveParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VtVec2iArray *&#160;</td>
          <td class="paramname"><em>edgeIndices</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return triquad indices (triangulated after quadrangulation) of the input topology. </p>
<p>indices and primitiveParams are output parameters. </p>

</div>
</div>
<a id="a3aea3e2d25e33795bcd17fc0f5808637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aea3e2d25e33795bcd17fc0f5808637">&#9670;&nbsp;</a></span>EnumerateEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API void EnumerateEdges </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_gf_vec2i.html">GfVec2i</a> &gt; *&#160;</td>
          <td class="paramname"><em>edgeVerticesOut</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a buffer filled with face vertex index pairs corresponding to the sequence in which edges are visited when iterating through the mesh topology. </p>
<p>The edges of degenerate and hole faces are included so that this sequence will correspond with either base face triangulation or quadrangulation (which typically skips over hole faces) as well as for refined surfaces which take into account faces tagged as holes as well as other non-manifold faces. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pxr/imaging/hd/<a class="el" href="mesh_util_8h_source.html">meshUtil.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_hd_mesh_util.html">HdMeshUtil</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:00 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>