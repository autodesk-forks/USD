<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: HdRenderThread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_hd_render_thread.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="class_hd_render_thread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HdRenderThread Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_hd_render_thread.html" title="HdRenderThread is a utility that specific render delegates can choose to use depending on their needs...">HdRenderThread</a> is a utility that specific render delegates can choose to use depending on their needs.  
 <a href="class_hd_render_thread.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">API for thread management</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="Management"></a></p>
<p>Methods to configure, start, and stop the render thread. These functions are not threadsafe. </p>
</div></td></tr>
<tr class="memitem:ade0915553d48ce695b8f715eb93687be"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_render_thread.html#ade0915553d48ce695b8f715eb93687be">SetRenderCallback</a> (std::function&lt; void()&gt; renderCallback)</td></tr>
<tr class="memdesc:ade0915553d48ce695b8f715eb93687be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rendering callback for the render thread to use.  <a href="#ade0915553d48ce695b8f715eb93687be">More...</a><br /></td></tr>
<tr class="separator:ade0915553d48ce695b8f715eb93687be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbc3e39de4b0d29f623655dda9cf9ac"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_render_thread.html#a8cbc3e39de4b0d29f623655dda9cf9ac">SetShutdownCallback</a> (std::function&lt; void()&gt; shutdownCallback)</td></tr>
<tr class="memdesc:a8cbc3e39de4b0d29f623655dda9cf9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the shutdown callback for the render thread to use.  <a href="#a8cbc3e39de4b0d29f623655dda9cf9ac">More...</a><br /></td></tr>
<tr class="separator:a8cbc3e39de4b0d29f623655dda9cf9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95da12b4b6c328ee411acfae9fe5f246"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_render_thread.html#a95da12b4b6c328ee411acfae9fe5f246">StartThread</a> ()</td></tr>
<tr class="memdesc:a95da12b4b6c328ee411acfae9fe5f246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the rendering background thread.  <a href="#a95da12b4b6c328ee411acfae9fe5f246">More...</a><br /></td></tr>
<tr class="separator:a95da12b4b6c328ee411acfae9fe5f246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055764dfec3b153bd9c849a952ca7a3d"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_render_thread.html#a055764dfec3b153bd9c849a952ca7a3d">StopThread</a> ()</td></tr>
<tr class="memdesc:a055764dfec3b153bd9c849a952ca7a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the rendering background thread.  <a href="#a055764dfec3b153bd9c849a952ca7a3d">More...</a><br /></td></tr>
<tr class="separator:a055764dfec3b153bd9c849a952ca7a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6cd1242afed4f4889c22618cdbcfc7"><td class="memItemLeft" align="right" valign="top">HD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_render_thread.html#a5c6cd1242afed4f4889c22618cdbcfc7">IsThreadRunning</a> ()</td></tr>
<tr class="memdesc:a5c6cd1242afed4f4889c22618cdbcfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the background thread is running (i.e.  <a href="#a5c6cd1242afed4f4889c22618cdbcfc7">More...</a><br /></td></tr>
<tr class="separator:a5c6cd1242afed4f4889c22618cdbcfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API for hydra threads</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="RenderThreadAPI"></a></p>
<p>Methods for the render thread to communicate with hydra. These should only be called from the render thread, from inside the render callback. </p>
</div></td></tr>
<tr class="memitem:a2debd29c921e26925e71ce4b06c1e8c2"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_render_thread.html#a2debd29c921e26925e71ce4b06c1e8c2">StartRender</a> ()</td></tr>
<tr class="memdesc:a2debd29c921e26925e71ce4b06c1e8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the render thread to start rendering.  <a href="#a2debd29c921e26925e71ce4b06c1e8c2">More...</a><br /></td></tr>
<tr class="separator:a2debd29c921e26925e71ce4b06c1e8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5f8c3137eb62de866474ac651affbd"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_render_thread.html#aff5f8c3137eb62de866474ac651affbd">StopRender</a> ()</td></tr>
<tr class="memdesc:aff5f8c3137eb62de866474ac651affbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the render thread to stop rendering, and block until the render thread is idle.  <a href="#aff5f8c3137eb62de866474ac651affbd">More...</a><br /></td></tr>
<tr class="separator:aff5f8c3137eb62de866474ac651affbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e59c32193feb6ed74c01db09c59ad9"><td class="memItemLeft" align="right" valign="top">HD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_render_thread.html#ad1e59c32193feb6ed74c01db09c59ad9">IsRendering</a> ()</td></tr>
<tr class="memdesc:ad1e59c32193feb6ed74c01db09c59ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the render thread is currently rendering.  <a href="#ad1e59c32193feb6ed74c01db09c59ad9">More...</a><br /></td></tr>
<tr class="separator:ad1e59c32193feb6ed74c01db09c59ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9ed1a2edb5894bb6e6901d508ab4c0"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_render_thread.html#abc9ed1a2edb5894bb6e6901d508ab4c0">PauseRender</a> ()</td></tr>
<tr class="memdesc:abc9ed1a2edb5894bb6e6901d508ab4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the render thread to pause rendering.  <a href="#abc9ed1a2edb5894bb6e6901d508ab4c0">More...</a><br /></td></tr>
<tr class="separator:abc9ed1a2edb5894bb6e6901d508ab4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c685826ba4bb6c1cf8bf0f7649e035"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_render_thread.html#af6c685826ba4bb6c1cf8bf0f7649e035">ResumeRender</a> ()</td></tr>
<tr class="memdesc:af6c685826ba4bb6c1cf8bf0f7649e035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the render thread to resume rendering.  <a href="#af6c685826ba4bb6c1cf8bf0f7649e035">More...</a><br /></td></tr>
<tr class="separator:af6c685826ba4bb6c1cf8bf0f7649e035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a4c40ddb6dbb4f4eee255c2ef8a770"><td class="memItemLeft" align="right" valign="top">HD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_render_thread.html#ae0a4c40ddb6dbb4f4eee255c2ef8a770">IsStopRequested</a> ()</td></tr>
<tr class="memdesc:ae0a4c40ddb6dbb4f4eee255c2ef8a770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether hydra has asked to interrupt the current frame since the last time <a class="el" href="class_hd_render_thread.html#a2debd29c921e26925e71ce4b06c1e8c2" title="Ask the render thread to start rendering.">StartRender()</a> was called.  <a href="#ae0a4c40ddb6dbb4f4eee255c2ef8a770">More...</a><br /></td></tr>
<tr class="separator:ae0a4c40ddb6dbb4f4eee255c2ef8a770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35078def7afac6dc6cd155eb6aa37f70"><td class="memItemLeft" align="right" valign="top">HD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_render_thread.html#a35078def7afac6dc6cd155eb6aa37f70">IsPauseRequested</a> ()</td></tr>
<tr class="memdesc:a35078def7afac6dc6cd155eb6aa37f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether hydra has asked to pause rendering.  <a href="#a35078def7afac6dc6cd155eb6aa37f70">More...</a><br /></td></tr>
<tr class="separator:a35078def7afac6dc6cd155eb6aa37f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcb3b9e928a9011d71db68aeb514160"><td class="memItemLeft" align="right" valign="top">HD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_render_thread.html#a2fcb3b9e928a9011d71db68aeb514160">IsPauseDirty</a> ()</td></tr>
<tr class="memdesc:a2fcb3b9e928a9011d71db68aeb514160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the pause/resume state has changed since the last time we called IsPauseDirty.  <a href="#a2fcb3b9e928a9011d71db68aeb514160">More...</a><br /></td></tr>
<tr class="separator:a2fcb3b9e928a9011d71db68aeb514160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API for both hydra and render threads</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="CommonAPI"></a></p>
<p>Methods for both hydra and the render threads to synchronize access to other data. </p>
</div></td></tr>
<tr class="memitem:af5e71b4e7e348591d53b54cb6060e6ce"><td class="memItemLeft" align="right" valign="top">HD_API std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_render_thread.html#af5e71b4e7e348591d53b54cb6060e6ce">LockFramebuffer</a> ()</td></tr>
<tr class="memdesc:af5e71b4e7e348591d53b54cb6060e6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a scoped lock on the render delegate's framebuffer.  <a href="#af5e71b4e7e348591d53b54cb6060e6ce">More...</a><br /></td></tr>
<tr class="separator:af5e71b4e7e348591d53b54cb6060e6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_hd_render_thread.html" title="HdRenderThread is a utility that specific render delegates can choose to use depending on their needs...">HdRenderThread</a> is a utility that specific render delegates can choose to use depending on their needs. </p>
<p>It provides a system for rendering in a background thread, and synchronizing between hydra (either in the main thread, or the sync threadpool) and the rendering thread.</p>
<h1><a class="anchor" id="HdRenderThread_StateMachine"></a>
State Machine</h1>
<p>The render thread is implemented in terms of a state machine, and hydra requests to the render thread are implemented in terms of transitions on that state machine.</p>
<p>States:</p><ul>
<li><em>StateInitial</em> - indicates the render thread hasn't been started.</li>
<li><em>StateIdle</em> - indicates the render thread is running, but not rendering.</li>
<li><em>StateRendering</em> - indicates the render thread is rendering.</li>
<li><em>StateTerminated</em> - indicates the render thread is shutting down.</li>
</ul>
<p>Transitions:</p><ul>
<li><a class="el" href="class_hd_render_thread.html#a95da12b4b6c328ee411acfae9fe5f246" title="Start the rendering background thread.">StartThread()</a>: StateInitial =&gt; StateIdle</li>
<li><a class="el" href="class_hd_render_thread.html#a2debd29c921e26925e71ce4b06c1e8c2" title="Ask the render thread to start rendering.">StartRender()</a>: StateIdle, StateRendering =&gt; StateRendering</li>
<li><a class="el" href="class_hd_render_thread.html#aff5f8c3137eb62de866474ac651affbd" title="Ask the render thread to stop rendering, and block until the render thread is idle.">StopRender()</a>: StateIdle, StateRendering =&gt; StateIdle</li>
<li><a class="el" href="class_hd_render_thread.html#a055764dfec3b153bd9c849a952ca7a3d" title="Stop the rendering background thread.">StopThread()</a>: StateIdle, StateRendering =&gt; StateTerminated</li>
<li><a class="el" href="class_hd_render_thread.html#a055764dfec3b153bd9c849a952ca7a3d" title="Stop the rendering background thread.">StopThread()</a>: StateTerminated =&gt; StateInitial</li>
</ul>
<h1><a class="anchor" id="HdRenderThread_Usage"></a>
Example Usage</h1>
<div class="fragment"><div class="line"><span class="keyword">class </span>ExampleRenderDelegate : HdRenderDelegate {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ExampleRenderDelegate() {</div><div class="line">      _renderThread.SetRenderCallback(</div><div class="line">        std::bind(&amp;ExampleRenderDelegate::_RenderCallback, <span class="keyword">this</span>));</div><div class="line">      _renderThread.StartThread();</div><div class="line">    }</div><div class="line">    ~ExampleRenderDelegate() {</div><div class="line">      _renderThread.StopThread();</div><div class="line">    }</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> _RenderCallback() {</div><div class="line">      <span class="keywordtype">bool</span> renderComplete = <span class="keyword">false</span>;</div><div class="line">      <span class="keywordflow">while</span>(!renderComplete) {</div><div class="line">        <span class="comment">// Check if we have been asked to pause.</span></div><div class="line">        <span class="keywordflow">while</span>(_renderThread.IsPauseRequested()) {</div><div class="line">            <span class="keywordflow">if</span>(_renderThread.IsStopRequested()) {</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(10));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span>(_renderThread.IsStopRequested()) {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// generate N pixels.</span></div><div class="line">        <span class="keyword">auto</span> lock = _renderThread.LockFramebuffer();</div><div class="line">        <span class="comment">// resolve pixels to shared buffer.</span></div><div class="line">        <span class="comment">// Set renderComplete = true when finished rendering.</span></div><div class="line">      }</div><div class="line">    }</div><div class="line">    <a class="code" href="class_hd_render_thread.html">HdRenderThread</a> _renderThread;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ExampleRenderParam : <a class="code" href="class_hd_render_param.html">HdRenderParam</a> {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ExampleRenderParam(<a class="code" href="class_hd_render_thread.html">HdRenderThread</a>* renderThread, SceneData *scene);</div><div class="line">    SceneData* AcquireSceneForEdit() {</div><div class="line">      _renderThread-&gt;StopRender();</div><div class="line">      <span class="keywordflow">return</span> _scene;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ExamplePrim : <a class="code" href="class_hd_mesh.html">HdMesh</a> {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> Sync(...) {</div><div class="line">      SceneData *scene = renderParam-&gt;AcquireSceneForEdit();</div><div class="line">      ...</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ExampleRenderPass : <a class="code" href="class_hd_render_pass.html">HdRenderPass</a> {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ExampleRenderPass(<a class="code" href="class_hd_render_thread.html">HdRenderThread</a> *renderThread);</div><div class="line">  <span class="keyword">protected</span>:</div><div class="line">    <span class="keywordtype">void</span> _Execute(...) {</div><div class="line">      _renderThread-&gt;StartRendering();</div><div class="line">      <span class="keyword">auto</span> lock = _renderThread-&gt;LockFramebuffer();</div><div class="line">      <span class="comment">// blit pixels from shared to application buffer.</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Having a locked and shared framebuffer is important if you want to avoid tearing, or if the rendering API disallows multithreaded access to buffers (for example, if your framebuffers are on a GPU). It might be unnecessary for some renderers.</p>
<p>Stopping the render only when you're about to make a scene edit means that long-running renders aren't interrupted if the scene is static. Hiding the renderer's scene data handle behind AcquireSceneForEdit helps callers use the synchronization mechanisms correctly.</p>
<p>The render is restarted at the last possible second, in the render pass, after we know scene edits are done.</p>
<p>The render callback should use <a class="el" href="class_hd_render_thread.html#ae0a4c40ddb6dbb4f4eee255c2ef8a770" title="Query whether hydra has asked to interrupt the current frame since the last time StartRender() was ca...">IsStopRequested()</a> as a cancellation mechanism. </p>

<p class="definition">Definition at line <a class="el" href="render_thread_8h_source.html#l00146">146</a> of file <a class="el" href="render_thread_8h_source.html">renderThread.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2fcb3b9e928a9011d71db68aeb514160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fcb3b9e928a9011d71db68aeb514160">&#9670;&nbsp;</a></span>IsPauseDirty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API bool IsPauseDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the pause/resume state has changed since the last time we called IsPauseDirty. </p>

</div>
</div>
<a id="a35078def7afac6dc6cd155eb6aa37f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35078def7afac6dc6cd155eb6aa37f70">&#9670;&nbsp;</a></span>IsPauseRequested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API bool IsPauseRequested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether hydra has asked to pause rendering. </p>
<p>This will continue to return true until a request has been made for rendering to resume. Remember to check for a stop request while paused. </p>

</div>
</div>
<a id="ad1e59c32193feb6ed74c01db09c59ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e59c32193feb6ed74c01db09c59ad9">&#9670;&nbsp;</a></span>IsRendering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API bool IsRendering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the render thread is currently rendering. </p>
<p>This is set by <a class="el" href="class_hd_render_thread.html#a2debd29c921e26925e71ce4b06c1e8c2" title="Ask the render thread to start rendering.">StartRender()</a> and reset after the render callback exits, or reset by <a class="el" href="class_hd_render_thread.html#aff5f8c3137eb62de866474ac651affbd" title="Ask the render thread to stop rendering, and block until the render thread is idle.">StopRender()</a> if the render callback never runs. This does not block, and is fully threadsafe. </p>

</div>
</div>
<a id="ae0a4c40ddb6dbb4f4eee255c2ef8a770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a4c40ddb6dbb4f4eee255c2ef8a770">&#9670;&nbsp;</a></span>IsStopRequested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API bool IsStopRequested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether hydra has asked to interrupt the current frame since the last time <a class="el" href="class_hd_render_thread.html#a2debd29c921e26925e71ce4b06c1e8c2" title="Ask the render thread to start rendering.">StartRender()</a> was called. </p>
<p>The render callback can check this to determine whether to cancel rendering. </p>

</div>
</div>
<a id="a5c6cd1242afed4f4889c22618cdbcfc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6cd1242afed4f4889c22618cdbcfc7">&#9670;&nbsp;</a></span>IsThreadRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API bool IsThreadRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the background thread is running (i.e. </p>
<p>StartThread was called successfully, but StopThread has not been). </p>

</div>
</div>
<a id="af5e71b4e7e348591d53b54cb6060e6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e71b4e7e348591d53b54cb6060e6ce">&#9670;&nbsp;</a></span>LockFramebuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API std::unique_lock&lt;std::mutex&gt; LockFramebuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a scoped lock on the render delegate's framebuffer. </p>
<p>Hydra and the render thread can use this to synchronize blits between render-thread owned resources, and application-owned resources. </p>

</div>
</div>
<a id="abc9ed1a2edb5894bb6e6901d508ab4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9ed1a2edb5894bb6e6901d508ab4c0">&#9670;&nbsp;</a></span>PauseRender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API void PauseRender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the render thread to pause rendering. </p>
<p>The speed at which the renderer actually enters the pause state depends on the delegate. </p>

</div>
</div>
<a id="af6c685826ba4bb6c1cf8bf0f7649e035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c685826ba4bb6c1cf8bf0f7649e035">&#9670;&nbsp;</a></span>ResumeRender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API void ResumeRender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the render thread to resume rendering. </p>
<p>Pause and Resume calls do not need to be paired. The last call (to Pause or Resume) decides the current state. </p>

</div>
</div>
<a id="ade0915553d48ce695b8f715eb93687be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0915553d48ce695b8f715eb93687be">&#9670;&nbsp;</a></span>SetRenderCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API void SetRenderCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>renderCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the rendering callback for the render thread to use. </p>

</div>
</div>
<a id="a8cbc3e39de4b0d29f623655dda9cf9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbc3e39de4b0d29f623655dda9cf9ac">&#9670;&nbsp;</a></span>SetShutdownCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API void SetShutdownCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>shutdownCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the shutdown callback for the render thread to use. </p>
<p>This will be called once, right before the render thread exits, regardless of whether the render callback has been called. This can be used to clean up thread-specific rendering resources. </p>

</div>
</div>
<a id="a2debd29c921e26925e71ce4b06c1e8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2debd29c921e26925e71ce4b06c1e8c2">&#9670;&nbsp;</a></span>StartRender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API void StartRender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the render thread to start rendering. </p>
<p>This call is a no-op if the render thread is already rendering. Otherwise, it may block briefly. This is threadsafe against the render thread, but it shouldn't be called at the same time as <a class="el" href="class_hd_render_thread.html#aff5f8c3137eb62de866474ac651affbd" title="Ask the render thread to stop rendering, and block until the render thread is idle.">StopRender()</a>, and it shouldn't be called from multiple hydra threads at once. </p>

</div>
</div>
<a id="a95da12b4b6c328ee411acfae9fe5f246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95da12b4b6c328ee411acfae9fe5f246">&#9670;&nbsp;</a></span>StartThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API void StartThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the rendering background thread. </p>
<p>Note: it's an error to call this function when the render thread is already running, but it's acceptable to stop the render thread and then start it again. </p>

</div>
</div>
<a id="aff5f8c3137eb62de866474ac651affbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5f8c3137eb62de866474ac651affbd">&#9670;&nbsp;</a></span>StopRender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API void StopRender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the render thread to stop rendering, and block until the render thread is idle. </p>
<p>This is fully threadsafe, and can be called from multiple hydra threads at once. </p>

</div>
</div>
<a id="a055764dfec3b153bd9c849a952ca7a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055764dfec3b153bd9c849a952ca7a3d">&#9670;&nbsp;</a></span>StopThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HD_API void StopThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the rendering background thread. </p>
<p>This function will ask the render thread to transition to StateTerminated, and then join on the thread, so it will block. After this function returns, the rendering state machine will be back in its initial state, and the render thread can be started again. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pxr/imaging/hd/<a class="el" href="render_thread_8h_source.html">renderThread.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_hd_render_thread.html">HdRenderThread</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:00 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>