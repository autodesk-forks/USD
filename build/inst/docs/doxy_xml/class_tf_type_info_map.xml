<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="class_tf_type_info_map" kind="class" language="C++" prot="public">
    <compoundname>TfTypeInfoMap</compoundname>
    <includes refid="type_info_map_8h" local="no">typeInfoMap.h</includes>
    <innerclass refid="struct_tf_type_info_map_1_1___entry" prot="private">TfTypeInfoMap::_Entry</innerclass>
    <templateparamlist>
      <param>
        <type>class VALUE</type>
      </param>
    </templateparamlist>
      <sectiondef kind="private-type">
      <memberdef kind="typedef" id="class_tf_type_info_map_1a0a958a52df88cf12ce4e98f3cd1382ef" prot="private" static="no">
        <type>std::list&lt; const std::type_info * &gt;</type>
        <definition>typedef std::list&lt;const std::type_info*&gt; _TypeInfoList</definition>
        <argsstring></argsstring>
        <name>_TypeInfoList</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="212" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="212" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="class_tf_type_info_map_1aa55b04764219ec1a62c37fdeff581e3c" prot="private" static="no">
        <type>TfHashMap&lt; std::string, _Entry, <ref refid="class_tf_hash" kindref="compound">TfHash</ref> &gt;</type>
        <definition>typedef TfHashMap&lt;std::string, _Entry, TfHash&gt; _NameMap</definition>
        <argsstring></argsstring>
        <name>_NameMap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="241" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="241" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="class_tf_type_info_map_1a84e9d300c4cfba2e5a650c20e0f79932" prot="private" static="no">
        <type>TfHashMap&lt; const std::type_info *, _Entry *, <ref refid="class_tf_hash" kindref="compound">TfHash</ref> &gt;</type>
        <definition>typedef TfHashMap&lt;const std::type_info*, _Entry*, TfHash&gt; _TypeInfoCache</definition>
        <argsstring></argsstring>
        <name>_TypeInfoCache</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="243" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="243" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="class_tf_type_info_map_1a9fb72637c91c4edc55a6ade6e8276850" prot="private" static="no">
        <type>TfHashMap&lt; std::string, _Entry *, <ref refid="class_tf_hash" kindref="compound">TfHash</ref> &gt;</type>
        <definition>typedef TfHashMap&lt;std::string, _Entry*, TfHash&gt; _StringCache</definition>
        <argsstring></argsstring>
        <name>_StringCache</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="244" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="244" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_tf_type_info_map_1af3be06ef991cf80e9406f648f7c15eff" prot="private" static="no" mutable="no">
        <type>_NameMap</type>
        <definition>_NameMap _nameMap</definition>
        <argsstring></argsstring>
        <name>_nameMap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="246" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="246" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_tf_type_info_map_1ac3e3669add4e5d3f0ba52c47639213e2" prot="private" static="no" mutable="no">
        <type>_TypeInfoCache</type>
        <definition>_TypeInfoCache _typeInfoCache</definition>
        <argsstring></argsstring>
        <name>_typeInfoCache</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="248" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="248" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_tf_type_info_map_1af33687616897aea802a7cfaaa0d9c27f" prot="private" static="no" mutable="no">
        <type>_StringCache</type>
        <definition>_StringCache _stringCache</definition>
        <argsstring></argsstring>
        <name>_stringCache</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="249" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="249" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="class_tf_type_info_map_1a1b9130fffe9715c7181efa1af8c09eba" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>TfTypeInfoMap</definition>
        <argsstring>(const TfTypeInfoMap &amp;)=delete</argsstring>
        <name>TfTypeInfoMap</name>
        <param>
          <type>const <ref refid="class_tf_type_info_map" kindref="compound">TfTypeInfoMap</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="63" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1ae85924d4691125e325ebb7bbbef11a6a" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="class_tf_type_info_map" kindref="compound">TfTypeInfoMap</ref> &amp;</type>
        <definition>TfTypeInfoMap&amp; operator=</definition>
        <argsstring>(const TfTypeInfoMap &amp;)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="class_tf_type_info_map" kindref="compound">TfTypeInfoMap</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="64" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1a658c9aed0b5eff7b87176971baf41f20" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void _CreateAlias</definition>
        <argsstring>(const std::type_info &amp;alias, const std::string &amp;key)</argsstring>
        <name>_CreateAlias</name>
        <param>
          <type>const std::type_info &amp;</type>
          <declname>alias</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="221" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="221" bodyend="225"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1abfd9e0a8d72e8526cd764b33512504f9" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void _CreateAlias</definition>
        <argsstring>(const std::type_info &amp;alias, _Entry *e)</argsstring>
        <name>_CreateAlias</name>
        <param>
          <type>const std::type_info &amp;</type>
          <declname>alias</declname>
        </param>
        <param>
          <type>_Entry *</type>
          <declname>e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="227" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="227" bodyend="232"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1ad2b4ef272076f6ed078026b9271afa0b" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void _CreateAlias</definition>
        <argsstring>(const std::string &amp;alias, _Entry *e)</argsstring>
        <name>_CreateAlias</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>alias</declname>
        </param>
        <param>
          <type>_Entry *</type>
          <declname>e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="234" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="234" bodyend="239"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="class_tf_type_info_map_1a38629c6c5eede79a69d96118391376a5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>TfTypeInfoMap</definition>
        <argsstring>()</argsstring>
        <name>TfTypeInfoMap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="69" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="69" bodyend="69"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1a357beb1ac05af1e33a5642a78067db6b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Exists</definition>
        <argsstring>(const std::type_info &amp;key) const</argsstring>
        <name>Exists</name>
        <param>
          <type>const std::type_info &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>Return true if the given key is present in the map. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="72" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="72" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1aac36c3466066b32cdd876ab68e15a192" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Exists</definition>
        <argsstring>(const std::string &amp;key) const</argsstring>
        <name>Exists</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>Return true if the given key is present in the map. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that lookup by <computeroutput>std::type_info</computeroutput> is preferable for speed reasons. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="79" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="79" bodyend="81"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1acc97d56ae018908100ce883d3efe635e" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>VALUE *</type>
        <definition>VALUE* Find</definition>
        <argsstring>(const std::type_info &amp;key) const</argsstring>
        <name>Find</name>
        <param>
          <type>const std::type_info &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>Return a pointer to the value stored under <computeroutput>key</computeroutput>, and NULL if <computeroutput>key</computeroutput> is not a key in the map. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="85" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="85" bodyend="93"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1a2373405776bf9b829c5c2849e57db4aa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Upgrader</type>
          </param>
        </templateparamlist>
        <type>VALUE *</type>
        <definition>VALUE* Find</definition>
        <argsstring>(const std::type_info &amp;key, Upgrader &amp;upgrader)</argsstring>
        <name>Find</name>
        <param>
          <type>const std::type_info &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>Upgrader &amp;</type>
          <declname>upgrader</declname>
        </param>
        <briefdescription>
<para>Return a pointer to the value stored under <computeroutput>key</computeroutput>, and NULL if <computeroutput>key</computeroutput> is not a key in the map. </para>
        </briefdescription>
        <detaileddescription>
<para>For efficiency of future lookups this will cache the result if it falls back to a string based lookup. In that case before updating the cache it will call the functor <computeroutput>upgrader</computeroutput> to allow the client to upgrade any lock to exclusive access. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="101" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="101" bodyend="111"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1a693fb9ebe05bdce6da414ead5a41f85a" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>VALUE *</type>
        <definition>VALUE* Find</definition>
        <argsstring>(const std::string &amp;key) const</argsstring>
        <name>Find</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>Return a pointer to the value stored under <computeroutput>key</computeroutput>, and NULL if <computeroutput>key</computeroutput> is not a key in the map. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that lookup by <computeroutput>std::type_info</computeroutput> is preferable for speed reasons. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="117" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="117" bodyend="120"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1a13c88afd9b76be69252ebd788bbe57e5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Set</definition>
        <argsstring>(const std::type_info &amp;key, const VALUE &amp;value)</argsstring>
        <name>Set</name>
        <param>
          <type>const std::type_info &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>const VALUE &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Set the value for a given key. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that if <computeroutput>key</computeroutput> is not already in the table, this creates a new entry. Also, <computeroutput>key.name()</computeroutput> is automatically made linked with this entry, so that future queries can be made via <computeroutput>key.name()</computeroutput>, though lookup by <computeroutput>std::type_info</computeroutput> is greatly preferred. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="128" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="128" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1a6cee27b5e386d5639ef026ab54b258b8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Set</definition>
        <argsstring>(const std::string &amp;key, const VALUE &amp;value)</argsstring>
        <name>Set</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>const VALUE &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Set the value for a given key. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that if <computeroutput>key</computeroutput> is not already in the table, this creates a new entry. Also, lookup by <computeroutput>std::type_info</computeroutput> is preferable for speed reasons. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="142" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="142" bodyend="155"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1ad3eb503d8ab3bb759dc43046be36e211" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool CreateAlias</definition>
        <argsstring>(const std::string &amp;alias, const std::string &amp;key)</argsstring>
        <name>CreateAlias</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>alias</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>Create an alias for a key. </para>
        </briefdescription>
        <detaileddescription>
<para>Queries with a key of <computeroutput>alias</computeroutput> will return the same data associated with queries for <computeroutput>key</computeroutput>.</para>
<para>If <computeroutput>key</computeroutput> is not presently a member of the map, this function does nothing and returns <computeroutput>false</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="164" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="164" bodyend="170"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1a9d8042c5f91b6efeccd919b49ceb2d02" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool CreateAlias</definition>
        <argsstring>(const std::string &amp;alias, const std::type_info &amp;key)</argsstring>
        <name>CreateAlias</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>alias</declname>
        </param>
        <param>
          <type>const std::type_info &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="173" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="173" bodyend="179"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1a26b1d5be79838e6760aef79e5fda6735" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Remove</definition>
        <argsstring>(const std::type_info &amp;key)</argsstring>
        <name>Remove</name>
        <param>
          <type>const std::type_info &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>Remove this key (and any aliases associated with it). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="182" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="182" bodyend="184"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_type_info_map_1a3f80a1c1161b1b9d0219d54dfe140d70" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Remove</definition>
        <argsstring>(const std::string &amp;key)</argsstring>
        <name>Remove</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>Remove this key (and any aliases associated with it). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/typeInfoMap.h" line="187" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="187" bodyend="209"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>A map whose key is a const std::type_info&amp;, or a string alias. </para>
    </briefdescription>
    <detaileddescription>
<para>A <computeroutput><ref refid="class_tf_type_info_map" kindref="compound">TfTypeInfoMap</ref></computeroutput> stores values of arbitrary type (template parameter VALUE) under a key that is either a <computeroutput>const</computeroutput> <computeroutput>std::type_info&amp;</computeroutput>, or an <computeroutput>std::string</computeroutput>. Note that the <computeroutput>std::type_info</computeroutput> structure is many-to-one with respect to its name, i.e. two distinct instances of a <computeroutput>std::type_info</computeroutput> can represent the same type. Thus, a naive implementation that does pointer comparison on the address of a <computeroutput>std::type_info</computeroutput> can fail. The <computeroutput><ref refid="class_tf_type_info_map" kindref="compound">TfTypeInfoMap</ref></computeroutput> takes care of this aliasing.</para>
<para>Additionally, the table lets one create additional string aliases for a given entry. </para>
    </detaileddescription>
    <location file="pxr/base/tf/typeInfoMap.h" line="62" column="1" bodyfile="pxr/base/tf/typeInfoMap.h" bodystart="62" bodyend="250"/>
    <listofallmembers>
      <member refid="class_tf_type_info_map_1a658c9aed0b5eff7b87176971baf41f20" prot="private" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>_CreateAlias</name></member>
      <member refid="class_tf_type_info_map_1abfd9e0a8d72e8526cd764b33512504f9" prot="private" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>_CreateAlias</name></member>
      <member refid="class_tf_type_info_map_1ad2b4ef272076f6ed078026b9271afa0b" prot="private" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>_CreateAlias</name></member>
      <member refid="class_tf_type_info_map_1af3be06ef991cf80e9406f648f7c15eff" prot="private" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>_nameMap</name></member>
      <member refid="class_tf_type_info_map_1aa55b04764219ec1a62c37fdeff581e3c" prot="private" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>_NameMap</name></member>
      <member refid="class_tf_type_info_map_1a9fb72637c91c4edc55a6ade6e8276850" prot="private" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>_StringCache</name></member>
      <member refid="class_tf_type_info_map_1af33687616897aea802a7cfaaa0d9c27f" prot="private" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>_stringCache</name></member>
      <member refid="class_tf_type_info_map_1a84e9d300c4cfba2e5a650c20e0f79932" prot="private" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>_TypeInfoCache</name></member>
      <member refid="class_tf_type_info_map_1ac3e3669add4e5d3f0ba52c47639213e2" prot="private" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>_typeInfoCache</name></member>
      <member refid="class_tf_type_info_map_1a0a958a52df88cf12ce4e98f3cd1382ef" prot="private" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>_TypeInfoList</name></member>
      <member refid="class_tf_type_info_map_1ad3eb503d8ab3bb759dc43046be36e211" prot="public" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>CreateAlias</name></member>
      <member refid="class_tf_type_info_map_1a9d8042c5f91b6efeccd919b49ceb2d02" prot="public" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>CreateAlias</name></member>
      <member refid="class_tf_type_info_map_1a357beb1ac05af1e33a5642a78067db6b" prot="public" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>Exists</name></member>
      <member refid="class_tf_type_info_map_1aac36c3466066b32cdd876ab68e15a192" prot="public" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>Exists</name></member>
      <member refid="class_tf_type_info_map_1acc97d56ae018908100ce883d3efe635e" prot="public" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>Find</name></member>
      <member refid="class_tf_type_info_map_1a2373405776bf9b829c5c2849e57db4aa" prot="public" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>Find</name></member>
      <member refid="class_tf_type_info_map_1a693fb9ebe05bdce6da414ead5a41f85a" prot="public" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>Find</name></member>
      <member refid="class_tf_type_info_map_1ae85924d4691125e325ebb7bbbef11a6a" prot="private" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>operator=</name></member>
      <member refid="class_tf_type_info_map_1a26b1d5be79838e6760aef79e5fda6735" prot="public" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>Remove</name></member>
      <member refid="class_tf_type_info_map_1a3f80a1c1161b1b9d0219d54dfe140d70" prot="public" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>Remove</name></member>
      <member refid="class_tf_type_info_map_1a13c88afd9b76be69252ebd788bbe57e5" prot="public" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>Set</name></member>
      <member refid="class_tf_type_info_map_1a6cee27b5e386d5639ef026ab54b258b8" prot="public" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>Set</name></member>
      <member refid="class_tf_type_info_map_1a1b9130fffe9715c7181efa1af8c09eba" prot="private" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>TfTypeInfoMap</name></member>
      <member refid="class_tf_type_info_map_1a38629c6c5eede79a69d96118391376a5" prot="public" virt="non-virtual"><scope>TfTypeInfoMap</scope><name>TfTypeInfoMap</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
