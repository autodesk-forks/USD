<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: PcpCache Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_pcp_cache.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_pcp_cache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PcpCache Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_pcp_cache.html" title="PcpCache is the context required to make requests of the Pcp composition algorithm and cache the resu...">PcpCache</a> is the context required to make requests of the Pcp composition algorithm and cache the results.  
 <a href="class_pcp_cache.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac0fec6b1b4615a3b5b2c9e6d0564d018"><td class="memItemLeft" align="right" valign="top">PCP_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#ac0fec6b1b4615a3b5b2c9e6d0564d018">PcpCache</a> (const <a class="el" href="class_pcp_layer_stack_identifier.html">PcpLayerStackIdentifier</a> &amp;layerStackIdentifier, const std::string &amp;fileFormatTarget=std::string(), bool usd=false)</td></tr>
<tr class="memdesc:ac0fec6b1b4615a3b5b2c9e6d0564d018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_pcp_cache.html" title="PcpCache is the context required to make requests of the Pcp composition algorithm and cache the resu...">PcpCache</a> to compose results for the layer stack identified by <em>layerStackIdentifier</em>.  <a href="#ac0fec6b1b4615a3b5b2c9e6d0564d018">More...</a><br /></td></tr>
<tr class="separator:ac0fec6b1b4615a3b5b2c9e6d0564d018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computations</div></td></tr>
<tr class="memitem:a316a2ebde2a1f18e3ffd14c3c6e662d8"><td class="memItemLeft" align="right" valign="top">PCP_API PcpLayerStackRefPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a316a2ebde2a1f18e3ffd14c3c6e662d8">ComputeLayerStack</a> (const <a class="el" href="class_pcp_layer_stack_identifier.html">PcpLayerStackIdentifier</a> &amp;identifier, PcpErrorVector *allErrors)</td></tr>
<tr class="memdesc:a316a2ebde2a1f18e3ffd14c3c6e662d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the layer stack for <code>identifier</code> if it exists, otherwise creates a new layer stack for <code>identifier</code>.  <a href="#a316a2ebde2a1f18e3ffd14c3c6e662d8">More...</a><br /></td></tr>
<tr class="separator:a316a2ebde2a1f18e3ffd14c3c6e662d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8197bdd39cb465843a59b2299e4c117a"><td class="memItemLeft" align="right" valign="top">PCP_API PcpLayerStackPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a8197bdd39cb465843a59b2299e4c117a">FindLayerStack</a> (const <a class="el" href="class_pcp_layer_stack_identifier.html">PcpLayerStackIdentifier</a> &amp;identifier) const</td></tr>
<tr class="memdesc:a8197bdd39cb465843a59b2299e4c117a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the layer stack for <code>identifier</code> if it has been computed and cached, otherwise returns <code>NULL</code>.  <a href="#a8197bdd39cb465843a59b2299e4c117a">More...</a><br /></td></tr>
<tr class="separator:a8197bdd39cb465843a59b2299e4c117a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91550db50d25ec82dee97cb207c84148"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a91550db50d25ec82dee97cb207c84148">UsesLayerStack</a> (const PcpLayerStackPtr &amp;layerStack) const</td></tr>
<tr class="memdesc:a91550db50d25ec82dee97cb207c84148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>layerStack</code> is used by this cache in its composition, false otherwise.  <a href="#a91550db50d25ec82dee97cb207c84148">More...</a><br /></td></tr>
<tr class="separator:a91550db50d25ec82dee97cb207c84148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e7a19d2c33d5dd2de28423299b85ae"><td class="memItemLeft" align="right" valign="top">PCP_API const <a class="el" href="class_pcp_prim_index.html">PcpPrimIndex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a65e7a19d2c33d5dd2de28423299b85ae">ComputePrimIndex</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;primPath, PcpErrorVector *allErrors)</td></tr>
<tr class="memdesc:a65e7a19d2c33d5dd2de28423299b85ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return a reference to the cached result for the prim index for the given path.  <a href="#a65e7a19d2c33d5dd2de28423299b85ae">More...</a><br /></td></tr>
<tr class="separator:a65e7a19d2c33d5dd2de28423299b85ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8148727da89fcc27c85c846ec2a9875b"><td class="memTemplParams" colspan="2">template&lt;class ChildrenPredicate , class PayloadPredicate &gt; </td></tr>
<tr class="memitem:a8148727da89fcc27c85c846ec2a9875b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a8148727da89fcc27c85c846ec2a9875b">ComputePrimIndexesInParallel</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path, PcpErrorVector *allErrors, const ChildrenPredicate &amp;childrenPred, const PayloadPredicate &amp;payloadPred)</td></tr>
<tr class="memdesc:a8148727da89fcc27c85c846ec2a9875b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute PcpPrimIndexes in the subtree rooted at path in parallel, recursing to children based on the supplied <code>childrenPred</code>.  <a href="#a8148727da89fcc27c85c846ec2a9875b">More...</a><br /></td></tr>
<tr class="separator:a8148727da89fcc27c85c846ec2a9875b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296a95e5c9862da92c87fe619786fe53"><td class="memTemplParams" colspan="2">template&lt;class ChildrenPredicate , class PayloadPredicate &gt; </td></tr>
<tr class="memitem:a296a95e5c9862da92c87fe619786fe53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a296a95e5c9862da92c87fe619786fe53">ComputePrimIndexesInParallel</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path, PcpErrorVector *allErrors, const ChildrenPredicate &amp;childrenPred, const PayloadPredicate &amp;payloadPred, const char *mallocTag1, const char *mallocTag2)</td></tr>
<tr class="memdesc:a296a95e5c9862da92c87fe619786fe53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. XXX Do not add new callers of this method.  <a href="#a296a95e5c9862da92c87fe619786fe53">More...</a><br /></td></tr>
<tr class="separator:a296a95e5c9862da92c87fe619786fe53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70672b1171530466df9955e4dda981c"><td class="memTemplParams" colspan="2">template&lt;class ChildrenPredicate , class PayloadPredicate &gt; </td></tr>
<tr class="memitem:ab70672b1171530466df9955e4dda981c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#ab70672b1171530466df9955e4dda981c">ComputePrimIndexesInParallel</a> (const SdfPathVector &amp;paths, PcpErrorVector *allErrors, const ChildrenPredicate &amp;childrenPred, const PayloadPredicate &amp;payloadPred)</td></tr>
<tr class="memdesc:ab70672b1171530466df9955e4dda981c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized form of <a class="el" href="class_pcp_cache.html#a8148727da89fcc27c85c846ec2a9875b" title="Compute PcpPrimIndexes in the subtree rooted at path in parallel, recursing to children based on the ...">ComputePrimIndexesInParallel()</a>.  <a href="#ab70672b1171530466df9955e4dda981c">More...</a><br /></td></tr>
<tr class="separator:ab70672b1171530466df9955e4dda981c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011be08e5df427e14cfb54c2cb634a4d"><td class="memTemplParams" colspan="2">template&lt;class ChildrenPredicate , class PayloadPredicate &gt; </td></tr>
<tr class="memitem:a011be08e5df427e14cfb54c2cb634a4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a011be08e5df427e14cfb54c2cb634a4d">ComputePrimIndexesInParallel</a> (const SdfPathVector &amp;paths, PcpErrorVector *allErrors, const ChildrenPredicate &amp;childrenPred, const PayloadPredicate &amp;payloadPred, const char *mallocTag1, const char *mallocTag2)</td></tr>
<tr class="memdesc:a011be08e5df427e14cfb54c2cb634a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. XXX Do not add new callers of this method.  <a href="#a011be08e5df427e14cfb54c2cb634a4d">More...</a><br /></td></tr>
<tr class="separator:a011be08e5df427e14cfb54c2cb634a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fbf4df256f960ff2a5fed8ffc716b5"><td class="memItemLeft" align="right" valign="top">PCP_API const <a class="el" href="class_pcp_prim_index.html">PcpPrimIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a96fbf4df256f960ff2a5fed8ffc716b5">FindPrimIndex</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;primPath) const</td></tr>
<tr class="memdesc:a96fbf4df256f960ff2a5fed8ffc716b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the cached computed prim index for the given path, or NULL if it has not been computed.  <a href="#a96fbf4df256f960ff2a5fed8ffc716b5">More...</a><br /></td></tr>
<tr class="separator:a96fbf4df256f960ff2a5fed8ffc716b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a63babf1e8baf998a48fc06c60cb3c"><td class="memTemplParams" colspan="2">template&lt;class Callback &gt; </td></tr>
<tr class="memitem:a12a63babf1e8baf998a48fc06c60cb3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a12a63babf1e8baf998a48fc06c60cb3c">ForEachPrimIndex</a> (const Callback &amp;callback) const</td></tr>
<tr class="memdesc:a12a63babf1e8baf998a48fc06c60cb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the given <code>callback</code> on every prim index in the cache.  <a href="#a12a63babf1e8baf998a48fc06c60cb3c">More...</a><br /></td></tr>
<tr class="separator:a12a63babf1e8baf998a48fc06c60cb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede3a9aa1f6efd932a87f13ba002a19b"><td class="memItemLeft" align="right" valign="top">PCP_API const <a class="el" href="class_pcp_property_index.html">PcpPropertyIndex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#aede3a9aa1f6efd932a87f13ba002a19b">ComputePropertyIndex</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;propPath, PcpErrorVector *allErrors)</td></tr>
<tr class="memdesc:aede3a9aa1f6efd932a87f13ba002a19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return a reference to the cached result for the property index for the given path.  <a href="#aede3a9aa1f6efd932a87f13ba002a19b">More...</a><br /></td></tr>
<tr class="separator:aede3a9aa1f6efd932a87f13ba002a19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f5417de104b822cdc331b1298dd374"><td class="memItemLeft" align="right" valign="top">PCP_API const <a class="el" href="class_pcp_property_index.html">PcpPropertyIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a22f5417de104b822cdc331b1298dd374">FindPropertyIndex</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;propPath) const</td></tr>
<tr class="memdesc:a22f5417de104b822cdc331b1298dd374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the cached computed property index for the given path, or NULL if it has not been computed.  <a href="#a22f5417de104b822cdc331b1298dd374">More...</a><br /></td></tr>
<tr class="separator:a22f5417de104b822cdc331b1298dd374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac905bf0ec5b616f0f7bc92b6f2228b2"><td class="memItemLeft" align="right" valign="top">PCP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#aac905bf0ec5b616f0f7bc92b6f2228b2">ComputeRelationshipTargetPaths</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;relationshipPath, SdfPathVector *paths, bool localOnly, const SdfSpecHandle &amp;stopProperty, bool includeStopProperty, SdfPathVector *deletedPaths, PcpErrorVector *allErrors)</td></tr>
<tr class="memdesc:aac905bf0ec5b616f0f7bc92b6f2228b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the relationship target paths for the relationship at <code>relationshipPath</code> into <code>paths</code>.  <a href="#aac905bf0ec5b616f0f7bc92b6f2228b2">More...</a><br /></td></tr>
<tr class="separator:aac905bf0ec5b616f0f7bc92b6f2228b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2868ca7cc8823357cb05367de61340c7"><td class="memItemLeft" align="right" valign="top">PCP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a2868ca7cc8823357cb05367de61340c7">ComputeAttributeConnectionPaths</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;attributePath, SdfPathVector *paths, bool localOnly, const SdfSpecHandle &amp;stopProperty, bool includeStopProperty, SdfPathVector *deletedPaths, PcpErrorVector *allErrors)</td></tr>
<tr class="memdesc:a2868ca7cc8823357cb05367de61340c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the attribute connection paths for the attribute at <code>attributePath</code> into <code>paths</code>.  <a href="#a2868ca7cc8823357cb05367de61340c7">More...</a><br /></td></tr>
<tr class="separator:a2868ca7cc8823357cb05367de61340c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dependencies</div></td></tr>
<tr class="memitem:accc21b563933a964a6f565e600788c75"><td class="memItemLeft" align="right" valign="top">PCP_API SdfLayerHandleSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#accc21b563933a964a6f565e600788c75">GetUsedLayers</a> () const</td></tr>
<tr class="memdesc:accc21b563933a964a6f565e600788c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set of all layers used by this cache.  <a href="#accc21b563933a964a6f565e600788c75">More...</a><br /></td></tr>
<tr class="separator:accc21b563933a964a6f565e600788c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ceff6bdebf15987eb68207b9b68a401"><td class="memItemLeft" align="right" valign="top">PCP_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a9ceff6bdebf15987eb68207b9b68a401">GetUsedLayersRevision</a> () const</td></tr>
<tr class="memdesc:a9ceff6bdebf15987eb68207b9b68a401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a number that can be used to determine whether or not the set of layers used by this cache may have changed or not.  <a href="#a9ceff6bdebf15987eb68207b9b68a401">More...</a><br /></td></tr>
<tr class="separator:a9ceff6bdebf15987eb68207b9b68a401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2f976871ba19918b1e44cf88eaf16b"><td class="memItemLeft" align="right" valign="top">PCP_API SdfLayerHandleSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a2e2f976871ba19918b1e44cf88eaf16b">GetUsedRootLayers</a> () const</td></tr>
<tr class="memdesc:a2e2f976871ba19918b1e44cf88eaf16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set of all root layers used by this cache.  <a href="#a2e2f976871ba19918b1e44cf88eaf16b">More...</a><br /></td></tr>
<tr class="separator:a2e2f976871ba19918b1e44cf88eaf16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b942fed51a649c73c6e56e4bdf16d4e"><td class="memItemLeft" align="right" valign="top">PCP_API const PcpLayerStackPtrVector &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a9b942fed51a649c73c6e56e4bdf16d4e">FindAllLayerStacksUsingLayer</a> (const SdfLayerHandle &amp;layer) const</td></tr>
<tr class="memdesc:a9b942fed51a649c73c6e56e4bdf16d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns every computed &amp; cached layer stack that includes <code>layer</code>.  <a href="#a9b942fed51a649c73c6e56e4bdf16d4e">More...</a><br /></td></tr>
<tr class="separator:a9b942fed51a649c73c6e56e4bdf16d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04adf403cfa215f80492e97cee20075"><td class="memTemplParams" colspan="2">template&lt;class Callback &gt; </td></tr>
<tr class="memitem:af04adf403cfa215f80492e97cee20075"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#af04adf403cfa215f80492e97cee20075">ForEachLayerStack</a> (const Callback &amp;callback) const</td></tr>
<tr class="memdesc:af04adf403cfa215f80492e97cee20075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the given <code>callbcack</code> on every layer stack used by prim indexes in the cache.  <a href="#af04adf403cfa215f80492e97cee20075">More...</a><br /></td></tr>
<tr class="separator:af04adf403cfa215f80492e97cee20075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37222ecf13dfa784cb634410ae9ba2f"><td class="memItemLeft" align="right" valign="top">PCP_API PcpDependencyVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#af37222ecf13dfa784cb634410ae9ba2f">FindSiteDependencies</a> (const PcpLayerStackPtr &amp;siteLayerStack, const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;sitePath, PcpDependencyFlags depMask, bool recurseOnSite, bool recurseOnIndex, bool filterForExistingCachesOnly) const</td></tr>
<tr class="memdesc:af37222ecf13dfa784cb634410ae9ba2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns dependencies on the given site of scene description, as discovered by the cached index computations.  <a href="#af37222ecf13dfa784cb634410ae9ba2f">More...</a><br /></td></tr>
<tr class="separator:af37222ecf13dfa784cb634410ae9ba2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93db0f1b103daf63093b072f1bbd411"><td class="memItemLeft" align="right" valign="top">PCP_API PcpDependencyVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#ab93db0f1b103daf63093b072f1bbd411">FindSiteDependencies</a> (const SdfLayerHandle &amp;siteLayer, const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;sitePath, PcpDependencyFlags depMask, bool recurseOnSite, bool recurseOnIndex, bool filterForExistingCachesOnly) const</td></tr>
<tr class="memdesc:ab93db0f1b103daf63093b072f1bbd411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns dependencies on the given site of scene description, as discovered by the cached index computations.  <a href="#ab93db0f1b103daf63093b072f1bbd411">More...</a><br /></td></tr>
<tr class="separator:ab93db0f1b103daf63093b072f1bbd411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa080b6bdd403af24152b007df589ac88"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#aa080b6bdd403af24152b007df589ac88">CanHaveOpinionForSite</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;localPcpSitePath, const SdfLayerHandle &amp;layer, <a class="el" href="class_sdf_path.html">SdfPath</a> *allowedPathInLayer) const</td></tr>
<tr class="memdesc:aa080b6bdd403af24152b007df589ac88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if an opinion for the site at <code>localPcpSitePath</code> in the cache's layer stack can be provided by an opinion in <code>layer</code>, <code>false</code> otherwise.  <a href="#aa080b6bdd403af24152b007df589ac88">More...</a><br /></td></tr>
<tr class="separator:aa080b6bdd403af24152b007df589ac88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee59af48a4eea375ac80d95446a5a549"><td class="memItemLeft" align="right" valign="top">PCP_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#aee59af48a4eea375ac80d95446a5a549">GetInvalidSublayerIdentifiers</a> () const</td></tr>
<tr class="memdesc:aee59af48a4eea375ac80d95446a5a549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of sublayer asset paths used in the layer stack that didn't resolve to valid assets.  <a href="#aee59af48a4eea375ac80d95446a5a549">More...</a><br /></td></tr>
<tr class="separator:aee59af48a4eea375ac80d95446a5a549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeceb677d3e011e2ccc251b9151c9c4fa"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#aeceb677d3e011e2ccc251b9151c9c4fa">IsInvalidSublayerIdentifier</a> (const std::string &amp;identifier) const</td></tr>
<tr class="memdesc:aeceb677d3e011e2ccc251b9151c9c4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>identifier</code> was used as a sublayer path in a layer stack but did not identify a valid layer.  <a href="#aeceb677d3e011e2ccc251b9151c9c4fa">More...</a><br /></td></tr>
<tr class="separator:aeceb677d3e011e2ccc251b9151c9c4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93dd2e793974c329e8d0b7a60b930ae5"><td class="memItemLeft" align="right" valign="top">PCP_API std::map&lt; <a class="el" href="class_sdf_path.html">SdfPath</a>, std::vector&lt; std::string &gt;, SdfPath::FastLessThan &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a93dd2e793974c329e8d0b7a60b930ae5">GetInvalidAssetPaths</a> () const</td></tr>
<tr class="memdesc:a93dd2e793974c329e8d0b7a60b930ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map of prim paths to asset paths used by that prim (e.g.  <a href="#a93dd2e793974c329e8d0b7a60b930ae5">More...</a><br /></td></tr>
<tr class="separator:a93dd2e793974c329e8d0b7a60b930ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d2dc9a6dd6595032e6e8a3f554f542"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a99d2dc9a6dd6595032e6e8a3f554f542">IsInvalidAssetPath</a> (const std::string &amp;resolvedAssetPath) const</td></tr>
<tr class="memdesc:a99d2dc9a6dd6595032e6e8a3f554f542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>resolvedAssetPath</code> was used by a prim (e.g.  <a href="#a99d2dc9a6dd6595032e6e8a3f554f542">More...</a><br /></td></tr>
<tr class="separator:a99d2dc9a6dd6595032e6e8a3f554f542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98da62ae892a59ea214ee919dfd50e0"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#aa98da62ae892a59ea214ee919dfd50e0">HasAnyDynamicFileFormatArgumentFieldDependencies</a> () const</td></tr>
<tr class="memdesc:aa98da62ae892a59ea214ee919dfd50e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any prim index in this cache has a dependency on a dynamic file format argument field.  <a href="#aa98da62ae892a59ea214ee919dfd50e0">More...</a><br /></td></tr>
<tr class="separator:aa98da62ae892a59ea214ee919dfd50e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc36e5f5edc0c3b3b22b2c219483c7a7"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#afc36e5f5edc0c3b3b22b2c219483c7a7">HasAnyDynamicFileFormatArgumentAttributeDependencies</a> () const</td></tr>
<tr class="memdesc:afc36e5f5edc0c3b3b22b2c219483c7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any prim index in this cache has a dependency on a dynamic file format argument attribute's default value field.  <a href="#afc36e5f5edc0c3b3b22b2c219483c7a7">More...</a><br /></td></tr>
<tr class="separator:afc36e5f5edc0c3b3b22b2c219483c7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3981dba89620eaa70d6db10ea2440b"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a4a3981dba89620eaa70d6db10ea2440b">IsPossibleDynamicFileFormatArgumentField</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;field) const</td></tr>
<tr class="memdesc:a4a3981dba89620eaa70d6db10ea2440b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <code>field</code> is the name of a field that was composed while generating dynamic file format arguments for any prim index in this cache.  <a href="#a4a3981dba89620eaa70d6db10ea2440b">More...</a><br /></td></tr>
<tr class="separator:a4a3981dba89620eaa70d6db10ea2440b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6051ad9de95519043c10d4356c001a"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a5a6051ad9de95519043c10d4356c001a">IsPossibleDynamicFileFormatArgumentAttribute</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;attributeName) const</td></tr>
<tr class="memdesc:a5a6051ad9de95519043c10d4356c001a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <code>attributeName</code> is the name of an attribute whose default value field was composed while generating dynamic file format arguments for any prim index in this cache.  <a href="#a5a6051ad9de95519043c10d4356c001a">More...</a><br /></td></tr>
<tr class="separator:a5a6051ad9de95519043c10d4356c001a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccca22f81de09c334eabcdd198bbddc"><td class="memItemLeft" align="right" valign="top">PCP_API const <a class="el" href="class_pcp_dynamic_file_format_dependency_data.html">PcpDynamicFileFormatDependencyData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a7ccca22f81de09c334eabcdd198bbddc">GetDynamicFileFormatArgumentDependencyData</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;primIndexPath) const</td></tr>
<tr class="memdesc:a7ccca22f81de09c334eabcdd198bbddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dynamic file format dependency data object for the prim index with the given <code>primIndexPath</code>.  <a href="#a7ccca22f81de09c334eabcdd198bbddc">More...</a><br /></td></tr>
<tr class="separator:a7ccca22f81de09c334eabcdd198bbddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40ad447da0d475d2c45462e786e0104"><td class="memItemLeft" align="right" valign="top">PCP_API const SdfPathVector &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#af40ad447da0d475d2c45462e786e0104">GetPrimsUsingExpressionVariablesFromLayerStack</a> (const PcpLayerStackPtr &amp;layerStack) const</td></tr>
<tr class="memdesc:af40ad447da0d475d2c45462e786e0104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of prim index paths that depend on one or more expression variables from <code>layerStack</code>.  <a href="#af40ad447da0d475d2c45462e786e0104">More...</a><br /></td></tr>
<tr class="separator:af40ad447da0d475d2c45462e786e0104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f1de4ca6ea3751f94426ed83b0741f"><td class="memItemLeft" align="right" valign="top">PCP_API const std::unordered_set&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a66f1de4ca6ea3751f94426ed83b0741f">GetExpressionVariablesFromLayerStackUsedByPrim</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;primIndexPath, const PcpLayerStackPtr &amp;layerStack) const</td></tr>
<tr class="memdesc:a66f1de4ca6ea3751f94426ed83b0741f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of expression variables in <code>layerStack</code> that are used by the prim index at <code>primIndexPath</code>.  <a href="#a66f1de4ca6ea3751f94426ed83b0741f">More...</a><br /></td></tr>
<tr class="separator:a66f1de4ca6ea3751f94426ed83b0741f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Change handling</div></td></tr>
<tr class="memitem:a3f9b0f07cd0b437a480fbc1fb7c77d9e"><td class="memItemLeft" align="right" valign="top">PCP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a3f9b0f07cd0b437a480fbc1fb7c77d9e">Apply</a> (const <a class="el" href="class_pcp_cache_changes.html">PcpCacheChanges</a> &amp;changes, <a class="el" href="class_pcp_lifeboat.html">PcpLifeboat</a> *lifeboat)</td></tr>
<tr class="memdesc:a3f9b0f07cd0b437a480fbc1fb7c77d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the changes in <code>changes</code>.  <a href="#a3f9b0f07cd0b437a480fbc1fb7c77d9e">More...</a><br /></td></tr>
<tr class="separator:a3f9b0f07cd0b437a480fbc1fb7c77d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d8b91fd17eb86b918242922c4b826c"><td class="memItemLeft" align="right" valign="top">PCP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a13d8b91fd17eb86b918242922c4b826c">Reload</a> (<a class="el" href="class_pcp_changes.html">PcpChanges</a> *changes)</td></tr>
<tr class="memdesc:a13d8b91fd17eb86b918242922c4b826c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reload the layers of the layer stack, except session layers and sublayers of session layers.  <a href="#a13d8b91fd17eb86b918242922c4b826c">More...</a><br /></td></tr>
<tr class="separator:a13d8b91fd17eb86b918242922c4b826c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1dcab7b9144ebd8266c37314b46377"><td class="memItemLeft" align="right" valign="top">PCP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a0d1dcab7b9144ebd8266c37314b46377">ReloadReferences</a> (<a class="el" href="class_pcp_changes.html">PcpChanges</a> *changes, const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;primPath)</td></tr>
<tr class="memdesc:a0d1dcab7b9144ebd8266c37314b46377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reload every layer used by the prim at <code>primPath</code> that's across a reference or payload.  <a href="#a0d1dcab7b9144ebd8266c37314b46377">More...</a><br /></td></tr>
<tr class="separator:a0d1dcab7b9144ebd8266c37314b46377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Diagnostics</div></td></tr>
<tr class="memitem:ae930cda55ec639abd1e9e723553b9a0d"><td class="memItemLeft" align="right" valign="top">PCP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#ae930cda55ec639abd1e9e723553b9a0d">PrintStatistics</a> () const</td></tr>
<tr class="memdesc:ae930cda55ec639abd1e9e723553b9a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints various statistics about the data stored in this cache.  <a href="#ae930cda55ec639abd1e9e723553b9a0d">More...</a><br /></td></tr>
<tr class="separator:ae930cda55ec639abd1e9e723553b9a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1a61fe3fdaa9cda325ddfcb5179d8433"><td class="memItemLeft" align="right" valign="top"><a id="a1a61fe3fdaa9cda325ddfcb5179d8433"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PcpChanges</b></td></tr>
<tr class="separator:a1a61fe3fdaa9cda325ddfcb5179d8433"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Parameters</h2></td></tr>
<tr class="memitem:a006884c57fc666f8f69292cd68497d66"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a006884c57fc666f8f69292cd68497d66">PayloadSet</a> = std::unordered_set&lt; <a class="el" href="class_sdf_path.html">SdfPath</a>, SdfPath::Hash &gt;</td></tr>
<tr class="memdesc:a006884c57fc666f8f69292cd68497d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the payloads requested for inclusion.  <a href="#a006884c57fc666f8f69292cd68497d66">More...</a><br /></td></tr>
<tr class="separator:a006884c57fc666f8f69292cd68497d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d830779e268f6bda770ef7450ba92b"><td class="memItemLeft" align="right" valign="top">PCP_API const <a class="el" href="class_pcp_layer_stack_identifier.html">PcpLayerStackIdentifier</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a08d830779e268f6bda770ef7450ba92b">GetLayerStackIdentifier</a> () const</td></tr>
<tr class="memdesc:a08d830779e268f6bda770ef7450ba92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the identifier of the layerStack used for composition.  <a href="#a08d830779e268f6bda770ef7450ba92b">More...</a><br /></td></tr>
<tr class="separator:a08d830779e268f6bda770ef7450ba92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3032310279fc40362a567bf4452abfb7"><td class="memItemLeft" align="right" valign="top">PCP_API PcpLayerStackPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a3032310279fc40362a567bf4452abfb7">GetLayerStack</a> () const</td></tr>
<tr class="memdesc:a3032310279fc40362a567bf4452abfb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the layer stack for <a class="el" href="class_pcp_cache.html#a08d830779e268f6bda770ef7450ba92b" title="Get the identifier of the layerStack used for composition.">GetLayerStackIdentifier()</a>.  <a href="#a3032310279fc40362a567bf4452abfb7">More...</a><br /></td></tr>
<tr class="separator:a3032310279fc40362a567bf4452abfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5c9e0242c37d231967611d2f5eccd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a6d5c9e0242c37d231967611d2f5eccd1">HasRootLayerStack</a> (PcpLayerStackRefPtr const &amp;layerStack) const</td></tr>
<tr class="memdesc:a6d5c9e0242c37d231967611d2f5eccd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this cache's root layer stack is <code>layerStack</code>, false otherwise.  <a href="#a6d5c9e0242c37d231967611d2f5eccd1">More...</a><br /></td></tr>
<tr class="separator:a6d5c9e0242c37d231967611d2f5eccd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98719777d6ad28a536fa42ec3edfc597"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a98719777d6ad28a536fa42ec3edfc597">HasRootLayerStack</a> (PcpLayerStackPtr const &amp;layerStack) const</td></tr>
<tr class="separator:a98719777d6ad28a536fa42ec3edfc597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959d34686e5ba4df5f776be6e5efd86f"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a959d34686e5ba4df5f776be6e5efd86f">IsUsd</a> () const</td></tr>
<tr class="memdesc:a959d34686e5ba4df5f776be6e5efd86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the cache is configured in Usd mode.  <a href="#a959d34686e5ba4df5f776be6e5efd86f">More...</a><br /></td></tr>
<tr class="separator:a959d34686e5ba4df5f776be6e5efd86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d27ff049e15338bffe1ac25b99d6d2"><td class="memItemLeft" align="right" valign="top">PCP_API const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a51d27ff049e15338bffe1ac25b99d6d2">GetFileFormatTarget</a> () const</td></tr>
<tr class="memdesc:a51d27ff049e15338bffe1ac25b99d6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the file format target this cache is configured for.  <a href="#a51d27ff049e15338bffe1ac25b99d6d2">More...</a><br /></td></tr>
<tr class="separator:a51d27ff049e15338bffe1ac25b99d6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e115abd7466c935edd9d47cb0936032"><td class="memItemLeft" align="right" valign="top">PCP_API <a class="el" href="usd_2pcp_2types_8h.html#a72ae489ff9c2601b5f289baf87cece28">PcpVariantFallbackMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a2e115abd7466c935edd9d47cb0936032">GetVariantFallbacks</a> () const</td></tr>
<tr class="memdesc:a2e115abd7466c935edd9d47cb0936032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of fallbacks to attempt to use when evaluating variant sets that lack an authored selection.  <a href="#a2e115abd7466c935edd9d47cb0936032">More...</a><br /></td></tr>
<tr class="separator:a2e115abd7466c935edd9d47cb0936032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4146ac269e86cb8b033b8c71d55581"><td class="memItemLeft" align="right" valign="top">PCP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a7e4146ac269e86cb8b033b8c71d55581">SetVariantFallbacks</a> (const <a class="el" href="usd_2pcp_2types_8h.html#a72ae489ff9c2601b5f289baf87cece28">PcpVariantFallbackMap</a> &amp;map, <a class="el" href="class_pcp_changes.html">PcpChanges</a> *changes=NULL)</td></tr>
<tr class="memdesc:a7e4146ac269e86cb8b033b8c71d55581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the list of fallbacks to attempt to use when evaluating variant sets that lack an authored selection.  <a href="#a7e4146ac269e86cb8b033b8c71d55581">More...</a><br /></td></tr>
<tr class="separator:a7e4146ac269e86cb8b033b8c71d55581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0432ea3758714e3576bbafb94655793"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#ad0432ea3758714e3576bbafb94655793">IsPayloadIncluded</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path) const</td></tr>
<tr class="memdesc:ad0432ea3758714e3576bbafb94655793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the payload is included for the given path.  <a href="#ad0432ea3758714e3576bbafb94655793">More...</a><br /></td></tr>
<tr class="separator:ad0432ea3758714e3576bbafb94655793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbfc63965ab24efbb0bed1c59d76295"><td class="memItemLeft" align="right" valign="top"><a id="acfbfc63965ab24efbb0bed1c59d76295"></a>
PCP_API <a class="el" href="class_pcp_cache.html#a006884c57fc666f8f69292cd68497d66">PayloadSet</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetIncludedPayloads</b> () const</td></tr>
<tr class="separator:acfbfc63965ab24efbb0bed1c59d76295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e66b152b678df77bf4ca463d759df76"><td class="memItemLeft" align="right" valign="top">PCP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a1e66b152b678df77bf4ca463d759df76">RequestPayloads</a> (const SdfPathSet &amp;pathsToInclude, const SdfPathSet &amp;pathsToExclude, <a class="el" href="class_pcp_changes.html">PcpChanges</a> *changes=NULL)</td></tr>
<tr class="memdesc:a1e66b152b678df77bf4ca463d759df76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request payloads to be included or excluded from composition.  <a href="#a1e66b152b678df77bf4ca463d759df76">More...</a><br /></td></tr>
<tr class="separator:a1e66b152b678df77bf4ca463d759df76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442f27205bfe2232696c6069e7fd8a63"><td class="memItemLeft" align="right" valign="top">PCP_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a442f27205bfe2232696c6069e7fd8a63">RequestLayerMuting</a> (const std::vector&lt; std::string &gt; &amp;layersToMute, const std::vector&lt; std::string &gt; &amp;layersToUnmute, <a class="el" href="class_pcp_changes.html">PcpChanges</a> *changes=nullptr, std::vector&lt; std::string &gt; *newLayersMuted=nullptr, std::vector&lt; std::string &gt; *newLayersUnmuted=nullptr)</td></tr>
<tr class="memdesc:a442f27205bfe2232696c6069e7fd8a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request layers to be muted or unmuted in this cache.  <a href="#a442f27205bfe2232696c6069e7fd8a63">More...</a><br /></td></tr>
<tr class="separator:a442f27205bfe2232696c6069e7fd8a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b7829b41a29610a08b120ad49dbc0b"><td class="memItemLeft" align="right" valign="top">PCP_API const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a45b7829b41a29610a08b120ad49dbc0b">GetMutedLayers</a> () const</td></tr>
<tr class="memdesc:a45b7829b41a29610a08b120ad49dbc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of canonical identifiers for muted layers in this cache.  <a href="#a45b7829b41a29610a08b120ad49dbc0b">More...</a><br /></td></tr>
<tr class="separator:a45b7829b41a29610a08b120ad49dbc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642079b52ee90d678c471180283a83a2"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a642079b52ee90d678c471180283a83a2">IsLayerMuted</a> (const std::string &amp;layerIdentifier) const</td></tr>
<tr class="memdesc:a642079b52ee90d678c471180283a83a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the layer specified by <code>layerIdentifier</code> is muted in this cache, false otherwise.  <a href="#a642079b52ee90d678c471180283a83a2">More...</a><br /></td></tr>
<tr class="separator:a642079b52ee90d678c471180283a83a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0379049d8a5361522fee5e1bef8f2ee"><td class="memItemLeft" align="right" valign="top">PCP_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#af0379049d8a5361522fee5e1bef8f2ee">IsLayerMuted</a> (const SdfLayerHandle &amp;anchorLayer, const std::string &amp;layerIdentifier, std::string *canonicalMutedLayerIdentifier=nullptr) const</td></tr>
<tr class="memdesc:af0379049d8a5361522fee5e1bef8f2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the layer specified by <code>layerIdentifier</code> is muted in this cache, false otherwise.  <a href="#af0379049d8a5361522fee5e1bef8f2ee">More...</a><br /></td></tr>
<tr class="separator:af0379049d8a5361522fee5e1bef8f2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846225e4dd5b1de08c4d5bd344321d88"><td class="memItemLeft" align="right" valign="top">PCP_API <a class="el" href="class_pcp_prim_index_inputs.html">PcpPrimIndexInputs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pcp_cache.html#a846225e4dd5b1de08c4d5bd344321d88">GetPrimIndexInputs</a> ()</td></tr>
<tr class="memdesc:a846225e4dd5b1de08c4d5bd344321d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns parameter object containing all inputs for the prim index computation used by this cache.  <a href="#a846225e4dd5b1de08c4d5bd344321d88">More...</a><br /></td></tr>
<tr class="separator:a846225e4dd5b1de08c4d5bd344321d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_pcp_cache.html" title="PcpCache is the context required to make requests of the Pcp composition algorithm and cache the resu...">PcpCache</a> is the context required to make requests of the Pcp composition algorithm and cache the results. </p>
<p>Because the algorithms are recursive &ndash; making a request typically makes other internal requests to solve subproblems &ndash; caching subproblem results is required for reasonable performance, and so this cache is the only entrypoint to the algorithms.</p>
<p>There is a set of parameters that affect the composition results:</p>
<ul>
<li>variant fallbacks: per named variant set, an ordered list of fallback values to use when composing a prim that defines a variant set but does not specify a selection </li>
<li>payload inclusion set: an <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> set used to identify which prims should have their payloads included during composition; this is the basis for explicit control over the "working set" of composition </li>
<li>file format target: the file format target that Pcp will request when opening scene description layers </li>
<li>"USD mode" configures the Pcp composition algorithm to provide only a custom, lighter subset of the full feature set, as needed by the Universal Scene Description system</li>
</ul>
<p>There are a number of different computations that can be requested. These include computing a layer stack from a <a class="el" href="class_pcp_layer_stack_identifier.html" title="Arguments used to identify a layer stack.">PcpLayerStackIdentifier</a>, computing a prim index or prim stack, and computing a property index. </p>

<p class="definition">Definition at line <a class="el" href="pcp_2cache_8h_source.html#l00093">93</a> of file <a class="el" href="pcp_2cache_8h_source.html">cache.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a006884c57fc666f8f69292cd68497d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006884c57fc666f8f69292cd68497d66">&#9670;&nbsp;</a></span>PayloadSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_pcp_cache.html#a006884c57fc666f8f69292cd68497d66">PayloadSet</a> =  std::unordered_set&lt;<a class="el" href="class_sdf_path.html">SdfPath</a>, SdfPath::Hash&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the payloads requested for inclusion. </p>

<p class="definition">Definition at line <a class="el" href="pcp_2cache_8h_source.html#l00170">170</a> of file <a class="el" href="pcp_2cache_8h_source.html">cache.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac0fec6b1b4615a3b5b2c9e6d0564d018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0fec6b1b4615a3b5b2c9e6d0564d018">&#9670;&nbsp;</a></span>PcpCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API <a class="el" href="class_pcp_cache.html">PcpCache</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pcp_layer_stack_identifier.html">PcpLayerStackIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>layerStackIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileFormatTarget</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>usd</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_pcp_cache.html" title="PcpCache is the context required to make requests of the Pcp composition algorithm and cache the resu...">PcpCache</a> to compose results for the layer stack identified by <em>layerStackIdentifier</em>. </p>
<p>If <code>fileFormatTarget</code> is given, Pcp will specify <code>fileFormatTarget</code> as the file format target when searching for or opening a layer.</p>
<p>If <code>usd</code> is true, computation of prim indices and composition of prim child names are performed without relocates, inherits, permissions, symmetry, or payloads, and without populating the prim stack and gathering its dependencies. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3f9b0f07cd0b437a480fbc1fb7c77d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9b0f07cd0b437a480fbc1fb7c77d9e">&#9670;&nbsp;</a></span>Apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API void Apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pcp_cache_changes.html">PcpCacheChanges</a> &amp;&#160;</td>
          <td class="paramname"><em>changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pcp_lifeboat.html">PcpLifeboat</a> *&#160;</td>
          <td class="paramname"><em>lifeboat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the changes in <code>changes</code>. </p>
<p>This blows caches. It's up to the client to pull on those caches again as needed.</p>
<p>Objects that are no longer needed and would be destroyed are retained in <code>lifeboat</code> and won't be destroyed until <code>lifeboat</code> is itself destroyed. This gives the client control over the timing of the destruction of those objects. Clients may choose to pull on the caches before destroying <code>lifeboat</code>. That may cause the caches to again retain the objects, meaning they won't be destroyed when <code>lifeboat</code> is destroyed.</p>
<p>For example, if blowing a cache means an <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> is no longer needed then <code>lifeboat</code> will hold an SdfLayerRefPtr to that layer. The client can then pull on that cache, which could cause the cache to hold an SdfLayerRefPtr to the layer again. If so then destroying <code>changes</code> will not destroy the layer. In any case, we don't destroy the layer and then read it again. However, if the client destroys <code>lifeboat</code> before pulling on the cache then we would destroy the layer then read it again. </p>

</div>
</div>
<a id="aa080b6bdd403af24152b007df589ac88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa080b6bdd403af24152b007df589ac88">&#9670;&nbsp;</a></span>CanHaveOpinionForSite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool CanHaveOpinionForSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>localPcpSitePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sdf_path.html">SdfPath</a> *&#160;</td>
          <td class="paramname"><em>allowedPathInLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if an opinion for the site at <code>localPcpSitePath</code> in the cache's layer stack can be provided by an opinion in <code>layer</code>, <code>false</code> otherwise. </p>
<p>If <code>true</code> and <code>allowedPathInLayer</code> is not <code>NULL</code> then it's set to a path in <code>layer</code> that would provide an opinion.</p>
<p>This returns <code>false</code> if no prim index has yet been computed for <code>localPcpSitePath</code>. </p>

</div>
</div>
<a id="a2868ca7cc8823357cb05367de61340c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2868ca7cc8823357cb05367de61340c7">&#9670;&nbsp;</a></span>ComputeAttributeConnectionPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API void ComputeAttributeConnectionPaths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>attributePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SdfPathVector *&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>localOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SdfSpecHandle &amp;&#160;</td>
          <td class="paramname"><em>stopProperty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeStopProperty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SdfPathVector *&#160;</td>
          <td class="paramname"><em>deletedPaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PcpErrorVector *&#160;</td>
          <td class="paramname"><em>allErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the attribute connection paths for the attribute at <code>attributePath</code> into <code>paths</code>. </p>
<p>If <code>localOnly</code> is <code>true</code> then this will compose attribute connections from local nodes only. If <code>stopProperty</code> is not <code>NULL</code> then this will stop composing attribute connections at <code>stopProperty</code>, including <code>stopProperty</code> iff <code>includeStopProperty</code> is <code>true</code>. If not <code>NULL</code>, <code>deletedPaths</code> will be populated with connection paths whose deletion contributed to the computed result. <code>allErrors</code> will contain any errors encountered while performing this operation. </p>

</div>
</div>
<a id="a316a2ebde2a1f18e3ffd14c3c6e662d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316a2ebde2a1f18e3ffd14c3c6e662d8">&#9670;&nbsp;</a></span>ComputeLayerStack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API PcpLayerStackRefPtr ComputeLayerStack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pcp_layer_stack_identifier.html">PcpLayerStackIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PcpErrorVector *&#160;</td>
          <td class="paramname"><em>allErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the layer stack for <code>identifier</code> if it exists, otherwise creates a new layer stack for <code>identifier</code>. </p>
<p>This returns <code>NULL</code> if <code>identifier</code> is invalid (i.e. its root layer is <code>NULL</code>). <code>allErrors</code> will contain any errors encountered while creating a new layer stack. It'll be unchanged if the layer stack already existed. </p>

</div>
</div>
<a id="a65e7a19d2c33d5dd2de28423299b85ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e7a19d2c33d5dd2de28423299b85ae">&#9670;&nbsp;</a></span>ComputePrimIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API const <a class="el" href="class_pcp_prim_index.html">PcpPrimIndex</a>&amp; ComputePrimIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>primPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PcpErrorVector *&#160;</td>
          <td class="paramname"><em>allErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute and return a reference to the cached result for the prim index for the given path. </p>
<p><code>allErrors</code> will contain any errors encountered while performing this operation. </p>

</div>
</div>
<a id="a8148727da89fcc27c85c846ec2a9875b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8148727da89fcc27c85c846ec2a9875b">&#9670;&nbsp;</a></span>ComputePrimIndexesInParallel() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ComputePrimIndexesInParallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PcpErrorVector *&#160;</td>
          <td class="paramname"><em>allErrors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChildrenPredicate &amp;&#160;</td>
          <td class="paramname"><em>childrenPred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PayloadPredicate &amp;&#160;</td>
          <td class="paramname"><em>payloadPred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute PcpPrimIndexes in the subtree rooted at path in parallel, recursing to children based on the supplied <code>childrenPred</code>. </p>
<p>Also include payloads not already in this cache's included payloads (see GetIncludedPayloads()) according to <code>payloadPred</code>.</p>
<p>This is similar to <a class="el" href="class_pcp_cache.html#a65e7a19d2c33d5dd2de28423299b85ae" title="Compute and return a reference to the cached result for the prim index for the given path.">ComputePrimIndex()</a>, except it computes an entire subtree of indexes in parallel so it can be much more efficient. This function invokes both <code>childrenPred</code> and <code>payloadPred</code> concurrently, so it must be safe to do so.</p>
<p>When a <a class="el" href="class_pcp_prim_index.html" title="PcpPrimIndex is an index of the all sites of scene description that contribute opinions to a specific...">PcpPrimIndex</a> computation completes invoke <code>childrenPred</code>, passing it the <a class="el" href="class_pcp_prim_index.html" title="PcpPrimIndex is an index of the all sites of scene description that contribute opinions to a specific...">PcpPrimIndex</a>. If <code>childrenPred</code> returns true, continue indexing children prim indexes. In this case, <code>childrenPred</code> may provide a list of names of the children prim indexes to compute. If it does not, all children prim indexes will be computed. If <code>childrenPred</code> returns false, stop indexing in that subtree.</p>
<p>If payloads discovered during indexing do not already appear in this cache's set of included payloads, invoke <code>payloadPred</code>, passing it the path for the prim with the payload. If <code>payloadPred</code> returns true, include its payload and add it to the cache's set of included payloads upon completion. </p>

<p class="definition">Definition at line <a class="el" href="pcp_2cache_8h_source.html#l00314">314</a> of file <a class="el" href="pcp_2cache_8h_source.html">cache.h</a>.</p>

</div>
</div>
<a id="a296a95e5c9862da92c87fe619786fe53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296a95e5c9862da92c87fe619786fe53">&#9670;&nbsp;</a></span>ComputePrimIndexesInParallel() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ComputePrimIndexesInParallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PcpErrorVector *&#160;</td>
          <td class="paramname"><em>allErrors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChildrenPredicate &amp;&#160;</td>
          <td class="paramname"><em>childrenPred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PayloadPredicate &amp;&#160;</td>
          <td class="paramname"><em>payloadPred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mallocTag1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mallocTag2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. XXX Do not add new callers of this method. </p>
<p>It is needed as a workaround for bug #132031, which we hope to tackle soon (as of 6/2016) </p>

<p class="definition">Definition at line <a class="el" href="pcp_2cache_8h_source.html#l00327">327</a> of file <a class="el" href="pcp_2cache_8h_source.html">cache.h</a>.</p>

</div>
</div>
<a id="ab70672b1171530466df9955e4dda981c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70672b1171530466df9955e4dda981c">&#9670;&nbsp;</a></span>ComputePrimIndexesInParallel() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ComputePrimIndexesInParallel </td>
          <td>(</td>
          <td class="paramtype">const SdfPathVector &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PcpErrorVector *&#160;</td>
          <td class="paramname"><em>allErrors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChildrenPredicate &amp;&#160;</td>
          <td class="paramname"><em>childrenPred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PayloadPredicate &amp;&#160;</td>
          <td class="paramname"><em>payloadPred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vectorized form of <a class="el" href="class_pcp_cache.html#a8148727da89fcc27c85c846ec2a9875b" title="Compute PcpPrimIndexes in the subtree rooted at path in parallel, recursing to children based on the ...">ComputePrimIndexesInParallel()</a>. </p>
<p>Equivalent to invoking that method for each path in <code>paths</code>, but more efficient. </p>

<p class="definition">Definition at line <a class="el" href="pcp_2cache_8h_source.html#l00341">341</a> of file <a class="el" href="pcp_2cache_8h_source.html">cache.h</a>.</p>

</div>
</div>
<a id="a011be08e5df427e14cfb54c2cb634a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011be08e5df427e14cfb54c2cb634a4d">&#9670;&nbsp;</a></span>ComputePrimIndexesInParallel() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ComputePrimIndexesInParallel </td>
          <td>(</td>
          <td class="paramtype">const SdfPathVector &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PcpErrorVector *&#160;</td>
          <td class="paramname"><em>allErrors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChildrenPredicate &amp;&#160;</td>
          <td class="paramname"><em>childrenPred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PayloadPredicate &amp;&#160;</td>
          <td class="paramname"><em>payloadPred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mallocTag1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mallocTag2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. XXX Do not add new callers of this method. </p>
<p>It is needed as a workaround for bug #132031, which we hope to tackle soon (as of 6/2016) </p>

<p class="definition">Definition at line <a class="el" href="pcp_2cache_8h_source.html#l00355">355</a> of file <a class="el" href="pcp_2cache_8h_source.html">cache.h</a>.</p>

</div>
</div>
<a id="aede3a9aa1f6efd932a87f13ba002a19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede3a9aa1f6efd932a87f13ba002a19b">&#9670;&nbsp;</a></span>ComputePropertyIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API const <a class="el" href="class_pcp_property_index.html">PcpPropertyIndex</a>&amp; ComputePropertyIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>propPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PcpErrorVector *&#160;</td>
          <td class="paramname"><em>allErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute and return a reference to the cached result for the property index for the given path. </p>
<p><code>allErrors</code> will contain any errors encountered while performing this operation. </p>

</div>
</div>
<a id="aac905bf0ec5b616f0f7bc92b6f2228b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac905bf0ec5b616f0f7bc92b6f2228b2">&#9670;&nbsp;</a></span>ComputeRelationshipTargetPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API void ComputeRelationshipTargetPaths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>relationshipPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SdfPathVector *&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>localOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SdfSpecHandle &amp;&#160;</td>
          <td class="paramname"><em>stopProperty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeStopProperty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SdfPathVector *&#160;</td>
          <td class="paramname"><em>deletedPaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PcpErrorVector *&#160;</td>
          <td class="paramname"><em>allErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the relationship target paths for the relationship at <code>relationshipPath</code> into <code>paths</code>. </p>
<p>If <code>localOnly</code> is <code>true</code> then this will compose relationship targets from local nodes only. If <code>stopProperty</code> is not <code>NULL</code> then this will stop composing relationship targets at <code>stopProperty</code>, including <code>stopProperty</code> iff <code>includeStopProperty</code> is <code>true</code>. If not <code>NULL</code>, <code>deletedPaths</code> will be populated with target paths whose deletion contributed to the computed result. <code>allErrors</code> will contain any errors encountered while performing this operation. </p>

</div>
</div>
<a id="a9b942fed51a649c73c6e56e4bdf16d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b942fed51a649c73c6e56e4bdf16d4e">&#9670;&nbsp;</a></span>FindAllLayerStacksUsingLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API const PcpLayerStackPtrVector&amp; FindAllLayerStacksUsingLayer </td>
          <td>(</td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns every computed &amp; cached layer stack that includes <code>layer</code>. </p>

</div>
</div>
<a id="a8197bdd39cb465843a59b2299e4c117a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8197bdd39cb465843a59b2299e4c117a">&#9670;&nbsp;</a></span>FindLayerStack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API PcpLayerStackPtr FindLayerStack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pcp_layer_stack_identifier.html">PcpLayerStackIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>identifier</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the layer stack for <code>identifier</code> if it has been computed and cached, otherwise returns <code>NULL</code>. </p>

</div>
</div>
<a id="a96fbf4df256f960ff2a5fed8ffc716b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fbf4df256f960ff2a5fed8ffc716b5">&#9670;&nbsp;</a></span>FindPrimIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API const <a class="el" href="class_pcp_prim_index.html">PcpPrimIndex</a>* FindPrimIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>primPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the cached computed prim index for the given path, or NULL if it has not been computed. </p>

</div>
</div>
<a id="a22f5417de104b822cdc331b1298dd374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f5417de104b822cdc331b1298dd374">&#9670;&nbsp;</a></span>FindPropertyIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API const <a class="el" href="class_pcp_property_index.html">PcpPropertyIndex</a>* FindPropertyIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>propPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the cached computed property index for the given path, or NULL if it has not been computed. </p>

</div>
</div>
<a id="af37222ecf13dfa784cb634410ae9ba2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37222ecf13dfa784cb634410ae9ba2f">&#9670;&nbsp;</a></span>FindSiteDependencies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API PcpDependencyVector FindSiteDependencies </td>
          <td>(</td>
          <td class="paramtype">const PcpLayerStackPtr &amp;&#160;</td>
          <td class="paramname"><em>siteLayerStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>sitePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PcpDependencyFlags&#160;</td>
          <td class="paramname"><em>depMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recurseOnSite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recurseOnIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>filterForExistingCachesOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns dependencies on the given site of scene description, as discovered by the cached index computations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depMask</td><td>specifies what classes of dependency to include; see PcpDependencyFlags for details </td></tr>
    <tr><td class="paramname">recurseOnSite</td><td>includes incoming dependencies on children of sitePath </td></tr>
    <tr><td class="paramname">recurseOnIndex</td><td>extends the result to include all <a class="el" href="class_pcp_cache.html" title="PcpCache is the context required to make requests of the Pcp composition algorithm and cache the resu...">PcpCache</a> child indexes below discovered results </td></tr>
    <tr><td class="paramname">filterForExistingCachesOnly</td><td>filters the results to only paths representing computed prim and property index caches; otherwise a recursively-expanded result can include un-computed paths that are expected to depend on the site </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab93db0f1b103daf63093b072f1bbd411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93db0f1b103daf63093b072f1bbd411">&#9670;&nbsp;</a></span>FindSiteDependencies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API PcpDependencyVector FindSiteDependencies </td>
          <td>(</td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>siteLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>sitePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PcpDependencyFlags&#160;</td>
          <td class="paramname"><em>depMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recurseOnSite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recurseOnIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>filterForExistingCachesOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns dependencies on the given site of scene description, as discovered by the cached index computations. </p>
<p>This method overload takes a site layer rather than a layer stack. It will check every layer stack using that layer, and apply any relevant sublayer offsets to the map functions in the returned PcpDependencyVector.</p>
<p>See the other method for parameter details. </p>

</div>
</div>
<a id="af04adf403cfa215f80492e97cee20075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04adf403cfa215f80492e97cee20075">&#9670;&nbsp;</a></span>ForEachLayerStack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ForEachLayerStack </td>
          <td>(</td>
          <td class="paramtype">const Callback &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the given <code>callbcack</code> on every layer stack used by prim indexes in the cache. </p>
<p>The callback must have the signature: void(const PcpLayerStackPtr&amp;). </p>

<p class="definition">Definition at line <a class="el" href="pcp_2cache_8h_source.html#l00464">464</a> of file <a class="el" href="pcp_2cache_8h_source.html">cache.h</a>.</p>

</div>
</div>
<a id="a12a63babf1e8baf998a48fc06c60cb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a63babf1e8baf998a48fc06c60cb3c">&#9670;&nbsp;</a></span>ForEachPrimIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ForEachPrimIndex </td>
          <td>(</td>
          <td class="paramtype">const Callback &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the given <code>callback</code> on every prim index in the cache. </p>
<p>The callback must have the signature: void(const PcpPrimIndex&amp;). </p>

<p class="definition">Definition at line <a class="el" href="pcp_2cache_8h_source.html#l00377">377</a> of file <a class="el" href="pcp_2cache_8h_source.html">cache.h</a>.</p>

</div>
</div>
<a id="a7ccca22f81de09c334eabcdd198bbddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccca22f81de09c334eabcdd198bbddc">&#9670;&nbsp;</a></span>GetDynamicFileFormatArgumentDependencyData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API const <a class="el" href="class_pcp_dynamic_file_format_dependency_data.html">PcpDynamicFileFormatDependencyData</a>&amp; GetDynamicFileFormatArgumentDependencyData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>primIndexPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dynamic file format dependency data object for the prim index with the given <code>primIndexPath</code>. </p>
<p>This will return an empty dependency data if either there is no cache prim index for the path or if the prim index has no dynamic file formats that it depends on. </p>

</div>
</div>
<a id="a66f1de4ca6ea3751f94426ed83b0741f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f1de4ca6ea3751f94426ed83b0741f">&#9670;&nbsp;</a></span>GetExpressionVariablesFromLayerStackUsedByPrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API const std::unordered_set&lt;std::string&gt;&amp; GetExpressionVariablesFromLayerStackUsedByPrim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>primIndexPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PcpLayerStackPtr &amp;&#160;</td>
          <td class="paramname"><em>layerStack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of expression variables in <code>layerStack</code> that are used by the prim index at <code>primIndexPath</code>. </p>

</div>
</div>
<a id="a51d27ff049e15338bffe1ac25b99d6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d27ff049e15338bffe1ac25b99d6d2">&#9670;&nbsp;</a></span>GetFileFormatTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API const std::string&amp; GetFileFormatTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the file format target this cache is configured for. </p>

</div>
</div>
<a id="a93dd2e793974c329e8d0b7a60b930ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93dd2e793974c329e8d0b7a60b930ae5">&#9670;&nbsp;</a></span>GetInvalidAssetPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API std::map&lt;<a class="el" href="class_sdf_path.html">SdfPath</a>, std::vector&lt;std::string&gt;, SdfPath::FastLessThan&gt; GetInvalidAssetPaths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map of prim paths to asset paths used by that prim (e.g. </p>
<p>in a reference) that didn't resolve to valid assets. </p>

</div>
</div>
<a id="aee59af48a4eea375ac80d95446a5a549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee59af48a4eea375ac80d95446a5a549">&#9670;&nbsp;</a></span>GetInvalidSublayerIdentifiers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API std::vector&lt;std::string&gt; GetInvalidSublayerIdentifiers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of sublayer asset paths used in the layer stack that didn't resolve to valid assets. </p>

</div>
</div>
<a id="a3032310279fc40362a567bf4452abfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3032310279fc40362a567bf4452abfb7">&#9670;&nbsp;</a></span>GetLayerStack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API PcpLayerStackPtr GetLayerStack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the layer stack for <a class="el" href="class_pcp_cache.html#a08d830779e268f6bda770ef7450ba92b" title="Get the identifier of the layerStack used for composition.">GetLayerStackIdentifier()</a>. </p>
<p>Note that this will neither compute the layer stack nor report errors. So if the layer stack has not been computed yet this will return <code>NULL</code>. Use <a class="el" href="class_pcp_cache.html#a316a2ebde2a1f18e3ffd14c3c6e662d8" title="Returns the layer stack for identifier if it exists, otherwise creates a new layer stack for identifi...">ComputeLayerStack()</a> if you need to compute the layer stack if it hasn't been computed already and/or get errors caused by computing the layer stack. </p>

</div>
</div>
<a id="a08d830779e268f6bda770ef7450ba92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d830779e268f6bda770ef7450ba92b">&#9670;&nbsp;</a></span>GetLayerStackIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API const <a class="el" href="class_pcp_layer_stack_identifier.html">PcpLayerStackIdentifier</a>&amp; GetLayerStackIdentifier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the identifier of the layerStack used for composition. </p>

</div>
</div>
<a id="a45b7829b41a29610a08b120ad49dbc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b7829b41a29610a08b120ad49dbc0b">&#9670;&nbsp;</a></span>GetMutedLayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API const std::vector&lt;std::string&gt;&amp; GetMutedLayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of canonical identifiers for muted layers in this cache. </p>
<p>See documentation on RequestLayerMuting for more details. </p>

</div>
</div>
<a id="a846225e4dd5b1de08c4d5bd344321d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846225e4dd5b1de08c4d5bd344321d88">&#9670;&nbsp;</a></span>GetPrimIndexInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API <a class="el" href="class_pcp_prim_index_inputs.html">PcpPrimIndexInputs</a> GetPrimIndexInputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns parameter object containing all inputs for the prim index computation used by this cache. </p>

</div>
</div>
<a id="af40ad447da0d475d2c45462e786e0104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40ad447da0d475d2c45462e786e0104">&#9670;&nbsp;</a></span>GetPrimsUsingExpressionVariablesFromLayerStack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API const SdfPathVector&amp; GetPrimsUsingExpressionVariablesFromLayerStack </td>
          <td>(</td>
          <td class="paramtype">const PcpLayerStackPtr &amp;&#160;</td>
          <td class="paramname"><em>layerStack</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of prim index paths that depend on one or more expression variables from <code>layerStack</code>. </p>

</div>
</div>
<a id="accc21b563933a964a6f565e600788c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc21b563933a964a6f565e600788c75">&#9670;&nbsp;</a></span>GetUsedLayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API SdfLayerHandleSet GetUsedLayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set of all layers used by this cache. </p>

</div>
</div>
<a id="a9ceff6bdebf15987eb68207b9b68a401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ceff6bdebf15987eb68207b9b68a401">&#9670;&nbsp;</a></span>GetUsedLayersRevision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API size_t GetUsedLayersRevision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a number that can be used to determine whether or not the set of layers used by this cache may have changed or not. </p>
<p>For example, if one calls <a class="el" href="class_pcp_cache.html#accc21b563933a964a6f565e600788c75" title="Returns set of all layers used by this cache.">GetUsedLayers()</a> and saves the <a class="el" href="class_pcp_cache.html#a9ceff6bdebf15987eb68207b9b68a401" title="Return a number that can be used to determine whether or not the set of layers used by this cache may...">GetUsedLayersRevision()</a>, and then later calls <a class="el" href="class_pcp_cache.html#a9ceff6bdebf15987eb68207b9b68a401" title="Return a number that can be used to determine whether or not the set of layers used by this cache may...">GetUsedLayersRevision()</a> again, if the number is unchanged, then <a class="el" href="class_pcp_cache.html#accc21b563933a964a6f565e600788c75" title="Returns set of all layers used by this cache.">GetUsedLayers()</a> is guaranteed to be unchanged as well. </p>

</div>
</div>
<a id="a2e2f976871ba19918b1e44cf88eaf16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2f976871ba19918b1e44cf88eaf16b">&#9670;&nbsp;</a></span>GetUsedRootLayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API SdfLayerHandleSet GetUsedRootLayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set of all root layers used by this cache. </p>

</div>
</div>
<a id="a2e115abd7466c935edd9d47cb0936032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e115abd7466c935edd9d47cb0936032">&#9670;&nbsp;</a></span>GetVariantFallbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API <a class="el" href="usd_2pcp_2types_8h.html#a72ae489ff9c2601b5f289baf87cece28">PcpVariantFallbackMap</a> GetVariantFallbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of fallbacks to attempt to use when evaluating variant sets that lack an authored selection. </p>

</div>
</div>
<a id="afc36e5f5edc0c3b3b22b2c219483c7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc36e5f5edc0c3b3b22b2c219483c7a7">&#9670;&nbsp;</a></span>HasAnyDynamicFileFormatArgumentAttributeDependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool HasAnyDynamicFileFormatArgumentAttributeDependencies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if any prim index in this cache has a dependency on a dynamic file format argument attribute's default value field. </p>

</div>
</div>
<a id="aa98da62ae892a59ea214ee919dfd50e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98da62ae892a59ea214ee919dfd50e0">&#9670;&nbsp;</a></span>HasAnyDynamicFileFormatArgumentFieldDependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool HasAnyDynamicFileFormatArgumentFieldDependencies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if any prim index in this cache has a dependency on a dynamic file format argument field. </p>

</div>
</div>
<a id="a6d5c9e0242c37d231967611d2f5eccd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5c9e0242c37d231967611d2f5eccd1">&#9670;&nbsp;</a></span>HasRootLayerStack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HasRootLayerStack </td>
          <td>(</td>
          <td class="paramtype">PcpLayerStackRefPtr const &amp;&#160;</td>
          <td class="paramname"><em>layerStack</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this cache's root layer stack is <code>layerStack</code>, false otherwise. </p>
<p>This is functionally equivalent to comparing against the result of <a class="el" href="class_pcp_cache.html#a3032310279fc40362a567bf4452abfb7" title="Get the layer stack for GetLayerStackIdentifier().">GetLayerStack()</a>, but does not require constructing a <a class="el" href="class_tf_weak_ptr.html" title="Pointer storage with deletion detection.">TfWeakPtr</a> or any refcount operations. </p>

<p class="definition">Definition at line <a class="el" href="pcp_2cache_8h_source.html#l00134">134</a> of file <a class="el" href="pcp_2cache_8h_source.html">cache.h</a>.</p>

</div>
</div>
<a id="a98719777d6ad28a536fa42ec3edfc597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98719777d6ad28a536fa42ec3edfc597">&#9670;&nbsp;</a></span>HasRootLayerStack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool HasRootLayerStack </td>
          <td>(</td>
          <td class="paramtype">PcpLayerStackPtr const &amp;&#160;</td>
          <td class="paramname"><em>layerStack</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a99d2dc9a6dd6595032e6e8a3f554f542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d2dc9a6dd6595032e6e8a3f554f542">&#9670;&nbsp;</a></span>IsInvalidAssetPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool IsInvalidAssetPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>resolvedAssetPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>resolvedAssetPath</code> was used by a prim (e.g. </p>
<p>in a reference) but did not resolve to a valid asset. This is functionally equivalent to examining the values in the map returned by GetInvalidAssetPaths, but more efficient. </p>

</div>
</div>
<a id="aeceb677d3e011e2ccc251b9151c9c4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeceb677d3e011e2ccc251b9151c9c4fa">&#9670;&nbsp;</a></span>IsInvalidSublayerIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool IsInvalidSublayerIdentifier </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>identifier</code> was used as a sublayer path in a layer stack but did not identify a valid layer. </p>
<p>This is functionally equivalent to examining the values in the vector returned by GetInvalidSublayerIdentifiers, but more efficient. </p>

</div>
</div>
<a id="a642079b52ee90d678c471180283a83a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642079b52ee90d678c471180283a83a2">&#9670;&nbsp;</a></span>IsLayerMuted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool IsLayerMuted </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layerIdentifier</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the layer specified by <code>layerIdentifier</code> is muted in this cache, false otherwise. </p>
<p>If <code>layerIdentifier</code> is relative, it is assumed to be relative to this cache's root layer. See documentation on RequestLayerMuting for more details. </p>

</div>
</div>
<a id="af0379049d8a5361522fee5e1bef8f2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0379049d8a5361522fee5e1bef8f2ee">&#9670;&nbsp;</a></span>IsLayerMuted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool IsLayerMuted </td>
          <td>(</td>
          <td class="paramtype">const SdfLayerHandle &amp;&#160;</td>
          <td class="paramname"><em>anchorLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layerIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>canonicalMutedLayerIdentifier</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the layer specified by <code>layerIdentifier</code> is muted in this cache, false otherwise. </p>
<p>If <code>layerIdentifier</code> is relative, it is assumed to be relative to <code>anchorLayer</code>. If <code>canonicalMutedLayerIdentifier</code> is supplied, it will be populated with the canonical identifier of the muted layer if this function returns true. See documentation on RequestLayerMuting for more details. </p>

</div>
</div>
<a id="ad0432ea3758714e3576bbafb94655793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0432ea3758714e3576bbafb94655793">&#9670;&nbsp;</a></span>IsPayloadIncluded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool IsPayloadIncluded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the payload is included for the given path. </p>

</div>
</div>
<a id="a5a6051ad9de95519043c10d4356c001a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6051ad9de95519043c10d4356c001a">&#9670;&nbsp;</a></span>IsPossibleDynamicFileFormatArgumentAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool IsPossibleDynamicFileFormatArgumentAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>attributeName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <code>attributeName</code> is the name of an attribute whose default value field was composed while generating dynamic file format arguments for any prim index in this cache. </p>

</div>
</div>
<a id="a4a3981dba89620eaa70d6db10ea2440b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3981dba89620eaa70d6db10ea2440b">&#9670;&nbsp;</a></span>IsPossibleDynamicFileFormatArgumentField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool IsPossibleDynamicFileFormatArgumentField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <code>field</code> is the name of a field that was composed while generating dynamic file format arguments for any prim index in this cache. </p>

</div>
</div>
<a id="a959d34686e5ba4df5f776be6e5efd86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959d34686e5ba4df5f776be6e5efd86f">&#9670;&nbsp;</a></span>IsUsd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool IsUsd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the cache is configured in Usd mode. </p>

</div>
</div>
<a id="ae930cda55ec639abd1e9e723553b9a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae930cda55ec639abd1e9e723553b9a0d">&#9670;&nbsp;</a></span>PrintStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API void PrintStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints various statistics about the data stored in this cache. </p>

</div>
</div>
<a id="a13d8b91fd17eb86b918242922c4b826c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d8b91fd17eb86b918242922c4b826c">&#9670;&nbsp;</a></span>Reload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API void Reload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pcp_changes.html">PcpChanges</a> *&#160;</td>
          <td class="paramname"><em>changes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reload the layers of the layer stack, except session layers and sublayers of session layers. </p>
<p>This will also try to load sublayers in this cache's layer stack that could not be loaded previously. It will also try to load any referenced or payloaded layer that could not be loaded previously. Clients should subsequently <code><a class="el" href="class_pcp_cache.html#a3f9b0f07cd0b437a480fbc1fb7c77d9e" title="Apply the changes in changes.">Apply()</a></code> <code>changes</code> to use any now-valid layers. </p>

</div>
</div>
<a id="a0d1dcab7b9144ebd8266c37314b46377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1dcab7b9144ebd8266c37314b46377">&#9670;&nbsp;</a></span>ReloadReferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API void ReloadReferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pcp_changes.html">PcpChanges</a> *&#160;</td>
          <td class="paramname"><em>changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>primPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reload every layer used by the prim at <code>primPath</code> that's across a reference or payload. </p>
<p>Clients should subsequently apply the changes to use any now valid layers.</p>
<p>Note: If a reference or payload was to an invalid asset and this asset is valid upon reloading then this call will not necessarily reload every layer accessible across the reference or payload. For example, say prim R has an invalid reference and prim Q has a valid reference to layer X with sublayer Y. If on reload R now has a valid reference to layer Z with sublayer Y, we will load Z but we will not reload Y. </p>

</div>
</div>
<a id="a442f27205bfe2232696c6069e7fd8a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442f27205bfe2232696c6069e7fd8a63">&#9670;&nbsp;</a></span>RequestLayerMuting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API void RequestLayerMuting </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>layersToMute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>layersToUnmute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pcp_changes.html">PcpChanges</a> *&#160;</td>
          <td class="paramname"><em>changes</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>newLayersMuted</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>newLayersUnmuted</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request layers to be muted or unmuted in this cache. </p>
<p>Muted layers are ignored during composition and do not appear in any layer stacks. The root layer of this stage may not be muted; attempting to do so will generate a coding error. If the root layer of a reference or payload layer stack is muted, the behavior is as if the muted layer did not exist, which means a composition error will be generated.</p>
<p>A canonical identifier for each layer in <code>layersToMute</code> will be computed using <a class="el" href="class_ar_resolver.html#a68e5ae6385d1733b79f734c59682ff61" title="Returns an identifier for the asset specified by assetPath.">ArResolver::CreateIdentifier</a> using the cache's root layer as the anchoring asset. Any layer encountered during composition with the same identifier will be considered muted and ignored.</p>
<p>Note that muting a layer will cause this cache to release all references to that layer. If no other client is holding on to references to that layer, it will be unloaded. In this case, if there are unsaved edits to the muted layer, those edits are lost.</p>
<p>Since anonymous layers are not serialized, muting an anonymous layer will cause that layer and its contents to be lost in this case.</p>
<p>If <code>changes</code> is not <code>nullptr</code>, it is adjusted to reflect the changes necessary to see the change in muted layers. Otherwise, those changes are applied immediately.</p>
<p><code>newLayersMuted</code> and <code>newLayersUnmuted</code> contains the pruned vector of layers which are muted or unmuted by this call to RequestLayerMuting. </p>

</div>
</div>
<a id="a1e66b152b678df77bf4ca463d759df76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e66b152b678df77bf4ca463d759df76">&#9670;&nbsp;</a></span>RequestPayloads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API void RequestPayloads </td>
          <td>(</td>
          <td class="paramtype">const SdfPathSet &amp;&#160;</td>
          <td class="paramname"><em>pathsToInclude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SdfPathSet &amp;&#160;</td>
          <td class="paramname"><em>pathsToExclude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pcp_changes.html">PcpChanges</a> *&#160;</td>
          <td class="paramname"><em>changes</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request payloads to be included or excluded from composition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathsToInclude</td><td>is a set of paths to add to the set for payload inclusion. </td></tr>
    <tr><td class="paramname">pathsToExclude</td><td>is a set of paths to remove from the set for payload inclusion. </td></tr>
    <tr><td class="paramname">changes</td><td>if not <code>NULL</code>, is adjusted to reflect the changes necessary to see the change in payloads; otherwise those changes are applied immediately. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a path is listed in both pathsToInclude and pathsToExclude, it will be treated as an inclusion only. </dd></dl>

</div>
</div>
<a id="a7e4146ac269e86cb8b033b8c71d55581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4146ac269e86cb8b033b8c71d55581">&#9670;&nbsp;</a></span>SetVariantFallbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API void SetVariantFallbacks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="usd_2pcp_2types_8h.html#a72ae489ff9c2601b5f289baf87cece28">PcpVariantFallbackMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pcp_changes.html">PcpChanges</a> *&#160;</td>
          <td class="paramname"><em>changes</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the list of fallbacks to attempt to use when evaluating variant sets that lack an authored selection. </p>
<p>If <code>changes</code> is not <code>NULL</code> then it's adjusted to reflect the changes necessary to see the change in standin preferences, otherwise those changes are applied immediately. </p>

</div>
</div>
<a id="a91550db50d25ec82dee97cb207c84148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91550db50d25ec82dee97cb207c84148">&#9670;&nbsp;</a></span>UsesLayerStack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCP_API bool UsesLayerStack </td>
          <td>(</td>
          <td class="paramtype">const PcpLayerStackPtr &amp;&#160;</td>
          <td class="paramname"><em>layerStack</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <code>layerStack</code> is used by this cache in its composition, false otherwise. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pxr/usd/pcp/<a class="el" href="pcp_2cache_8h_source.html">cache.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_pcp_cache.html">PcpCache</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:03 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>