<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="group__group__tf___debugging_output" kind="group">
    <compoundname>group_tf_DebuggingOutput</compoundname>
    <title>Output for Debugging Purposes</title>
    <innerfile refid="debug_8h">debug.h</innerfile>
    <innerfile refid="ostream_methods_8h">ostreamMethods.h</innerfile>
    <innerclass refid="class_tf_debug" prot="public">TfDebug</innerclass>
    <innerclass refid="struct_tf_debug_1_1_timed_scope_helper_3_01false_01_4" prot="public">TfDebug::TimedScopeHelper&lt; false &gt;</innerclass>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__group__tf___debugging_output_1gaecd0c562216e157474364beae58bfcbf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API std::ostream &amp;</type>
        <definition>TF_API std::ostream&amp; operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const TfEnum &amp;e)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="class_tf_enum" kindref="compound">TfEnum</ref> &amp;</type>
          <declname>e</declname>
        </param>
        <briefdescription>
<para>Output a <ref refid="class_tf_enum" kindref="compound">TfEnum</ref> value. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/enum.h" line="443" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__group__tf___debugging_output_1ga7df159850b084a9451818b9094967a5b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>uint32_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; 1::Tf_IsOstreamable&lt; T &gt;), std::ostream &amp; &gt;::type</type>
        <definition>std::enable_if&lt;1::Tf_IsOstreamable&lt;T&gt;), std::ostream &amp;&gt;::type operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const TfSmallVector&lt; T, N &gt; &amp;v)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="class_tf_small_vector" kindref="compound">TfSmallVector</ref>&lt; T, N &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Output a <ref refid="class_tf_small_vector" kindref="compound">TfSmallVector</ref> using [ ] as delimiters. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/ostreamMethods.h" line="75" column="1" bodyfile="pxr/base/tf/ostreamMethods.h" bodystart="76" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="group__group__tf___debugging_output_1ga8635953e3fdf59540d85c2f766a6afdf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; 1::Tf_IsOstreamable&lt; T &gt;), std::ostream &amp; &gt;::type</type>
        <definition>std::enable_if&lt;1::Tf_IsOstreamable&lt;T&gt;), std::ostream &amp;&gt;::type std::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const std::vector&lt; T &gt; &amp;v)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Output an STL vector using [ ] as delimiters. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/ostreamMethods.h" line="95" column="1" bodyfile="pxr/base/tf/ostreamMethods.h" bodystart="96" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="group__group__tf___debugging_output_1ga9f287e3b6a6532a4b1325d4c5d6bed14" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; 1::Tf_IsOstreamable&lt; T &gt;), std::ostream &amp; &gt;::type</type>
        <definition>std::enable_if&lt;1::Tf_IsOstreamable&lt;T&gt;), std::ostream &amp;&gt;::type std::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const std::set&lt; T &gt; &amp;v)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const std::set&lt; T &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Output an STL set using ( ) as delimiters. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/ostreamMethods.h" line="109" column="1" bodyfile="pxr/base/tf/ostreamMethods.h" bodystart="110" bodyend="118"/>
      </memberdef>
      <memberdef kind="function" id="group__group__tf___debugging_output_1gab8c029e19bd3baf06c2921bed4c3843c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; 1::Tf_IsOstreamable&lt; T &gt;), std::ostream &amp; &gt;::type</type>
        <definition>std::enable_if&lt;1::Tf_IsOstreamable&lt;T&gt;), std::ostream &amp;&gt;::type std::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const std::list&lt; T &gt; &amp;l)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const std::list&lt; T &gt; &amp;</type>
          <declname>l</declname>
        </param>
        <briefdescription>
<para>Output an STL list using { } as delimiters. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/ostreamMethods.h" line="123" column="1" bodyfile="pxr/base/tf/ostreamMethods.h" bodystart="124" bodyend="132"/>
      </memberdef>
      <memberdef kind="function" id="group__group__tf___debugging_output_1ga8b825695ad26ffacfa7030e74d6f451c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class M</type>
          </param>
          <param>
            <type>class H</type>
          </param>
          <param>
            <type>class C</type>
          </param>
          <param>
            <type>class A</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; 1::Tf_IsOstreamable&lt; K &gt;) &amp;&amp;1::Tf_IsOstreamable&lt; M &gt;), std::ostream &amp; &gt;::type</type>
        <definition>std::enable_if&lt; 1::Tf_IsOstreamable&lt;K&gt;) &amp;&amp; 1::Tf_IsOstreamable&lt;M&gt;), std::ostream &amp;&gt;::type std::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const 1::TfHashMap&lt; K, M, H, C, A &gt; &amp;h)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const 1::TfHashMap&lt; K, M, H, C, A &gt; &amp;</type>
          <declname>h</declname>
        </param>
        <briefdescription>
<para>Output an TfHashMap using &lt; &gt; as delimiters. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/ostreamMethods.h" line="138" column="1" bodyfile="pxr/base/tf/ostreamMethods.h" bodystart="139" bodyend="146"/>
      </memberdef>
      <memberdef kind="function" id="group__group__tf___debugging_output_1gae2420183990ed203c8a17378582cce41" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class K</type>
          </param>
          <param>
            <type>class M</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; 1::Tf_IsOstreamable&lt; K &gt;) &amp;&amp;1::Tf_IsOstreamable&lt; M &gt;), std::ostream &amp; &gt;::type</type>
        <definition>std::enable_if&lt; 1::Tf_IsOstreamable&lt;K&gt;) &amp;&amp; 1::Tf_IsOstreamable&lt;M&gt;), std::ostream &amp;&gt;::type std::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const std::map&lt; K, M &gt; &amp;h)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const std::map&lt; K, M &gt; &amp;</type>
          <declname>h</declname>
        </param>
        <briefdescription>
<para>Output an STL map using &lt; &gt; as delimiters. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/ostreamMethods.h" line="152" column="1" bodyfile="pxr/base/tf/ostreamMethods.h" bodystart="153" bodyend="160"/>
      </memberdef>
      <memberdef kind="function" id="group__group__tf___debugging_output_1gae0c6e95e8025cc303ddc93c8d1949767" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API std::ostream &amp;</type>
        <definition>TF_API std::ostream&amp; operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const TfStopwatch &amp;s)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="class_tf_stopwatch" kindref="compound">TfStopwatch</ref> &amp;</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>Output a <ref refid="class_tf_stopwatch" kindref="compound">TfStopwatch</ref>, using the format seconds. </para>
        </briefdescription>
        <detaileddescription>
<para>The elapsed time in the stopwatch is output in seconds. Note that the timer need not be stopped. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/stopwatch.h" line="150" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__group__tf___debugging_output_1ga69abc534ad81fd3843710a1f2db0e5e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API std::ostream &amp;</type>
        <definition>TF_API std::ostream&amp; operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const TfType &amp;t)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="class_tf_type" kindref="compound">TfType</ref> &amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Output a <ref refid="class_tf_type" kindref="compound">TfType</ref>, using the machine-independent type name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/type.h" line="733" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="define">
      <memberdef kind="define" id="group__group__tf___debugging_output_1ga798d0b335c62eb79f5cd3ca35361932f" prot="public" static="no">
        <name>TF_DEBUG_CODES</name>
        <param><defname>...</defname></param>
        <briefdescription>
<para>Define debugging symbols. </para>
        </briefdescription>
        <detaileddescription>
<para>This is a simple macro that takes care of declaring debug codes. Use it as follows: <programlisting><codeline><highlight class="normal">TF_DEBUG_CODES(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MY_E1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MY_E2</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/debug.h" line="393" column="9" bodyfile="pxr/base/tf/debug.h" bodystart="393" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__group__tf___debugging_output_1ga90f9903d097f7c5b41fcc90db639765c" prot="public" static="no">
        <name>TF_CONDITIONALLY_COMPILE_TIME_ENABLED_DEBUG_CODES</name>
        <param><defname>condition</defname></param>
        <param><defname>...</defname></param>
        <briefdescription>
<para>Define debugging symbols. </para>
        </briefdescription>
        <detaileddescription>
<para>This is a simple macro that takes care of declaring debug codes, subject to a compile-time condition that enables or disables them completely. Use it as follows: <programlisting><codeline><highlight class="normal">TF_CONDITIONALLY_COMPILE_TIME_ENABLED_DEBUG_CODES(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;Enabled<sp/>State:<sp/>a<sp/>compile-time<sp/>value<sp/>convertible<sp/>to<sp/>bool&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MY_E1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MY_E2</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
</programlisting></para>
<para>If the Enabled State is true, this is equivalent to the <ref refid="group__group__tf___debugging_output_1ga798d0b335c62eb79f5cd3ca35361932f" kindref="member">TF_DEBUG_CODES()</ref> macro. If it is false, then these debug codes are disabled at compile time and generated code pays no cost for them. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/debug.h" line="414" column="9" bodyfile="pxr/base/tf/debug.h" bodystart="414" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__group__tf___debugging_output_1ga72a43c1f42e054359695bf66bd7a80d1" prot="public" static="no">
        <name>_TF_DEBUG_MAKE_STRING</name>
        <param><defname>x</defname></param>
        <initializer>#x,</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/debug.h" line="434" column="9" bodyfile="pxr/base/tf/debug.h" bodystart="434" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__group__tf___debugging_output_1ga6fc99443889fc5cee4f89ea1c4b01205" prot="public" static="no">
        <name>_TF_DEBUG_ENUM_NAME</name>
        <param><defname>...</defname></param>
        <initializer>TF_PP_CAT(_TF_DEBUG_FIRST_CODE(__VA_ARGS__, dummy), __DebugCodes)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/debug.h" line="439" column="9" bodyfile="pxr/base/tf/debug.h" bodystart="439" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__group__tf___debugging_output_1gacdd1bec67a095afca2911858a9280e94" prot="public" static="no">
        <name>_TF_DEBUG_FIRST_CODE</name>
        <param><defname>first</defname></param>
        <param><defname>...</defname></param>
        <initializer>first</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/debug.h" line="442" column="9" bodyfile="pxr/base/tf/debug.h" bodystart="442" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__group__tf___debugging_output_1ga065857ce30ea9e97d83c8c03cf85b3a3" prot="public" static="no">
        <name>TF_DEBUG_MSG</name>
        <param><defname>enumVal</defname></param>
        <param><defname>...</defname></param>
        <briefdescription>
<para>Evaluate and print debugging message <computeroutput>msg</computeroutput> if <computeroutput>enumVal</computeroutput> is enabled for debugging. </para>
        </briefdescription>
        <detaileddescription>
<para>This macro is a newer, more convenient form of the <computeroutput><ref refid="group__group__tf___debugging_output_1ga6db9ff23ef8a070034390745b54e1bf6" kindref="member">TF_DEBUG()</ref></computeroutput> macro. Writing <programlisting><codeline><highlight class="normal">TF_DEBUG_MSG(enumVal,<sp/>msg,<sp/>...);</highlight></codeline>
</programlisting> is equivalent to <programlisting><codeline><highlight class="normal">TF_DEBUG(enumVal).Msg(msg,<sp/>...);</highlight></codeline>
</programlisting></para>
<para>The <ref refid="group__group__tf___debugging_output_1ga065857ce30ea9e97d83c8c03cf85b3a3" kindref="member">TF_DEBUG_MSG()</ref> macro allows either an std::string argument or a printf-like format string followed by a variable number of arguments: <programlisting><codeline><highlight class="normal">TF_DEBUG_MSG(enumVal,<sp/>&quot;opening<sp/>file<sp/>%s\n&quot;,<sp/>file.c_str());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TF_DEBUG_MSG(enumVal,<sp/>&quot;opening<sp/>file<sp/>&quot;<sp/>+<sp/>file);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/debug.h" line="466" column="9" bodyfile="pxr/base/tf/debug.h" bodystart="466" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__group__tf___debugging_output_1ga6db9ff23ef8a070034390745b54e1bf6" prot="public" static="no">
        <name>TF_DEBUG</name>
        <param><defname>enumVal</defname></param>
        <briefdescription>
<para>Evaluate and print debugging message <computeroutput>msg</computeroutput> if <computeroutput>enumVal</computeroutput> is enabled for debugging. </para>
        </briefdescription>
        <detaileddescription>
<para>The <computeroutput><ref refid="group__group__tf___debugging_output_1ga6db9ff23ef8a070034390745b54e1bf6" kindref="member">TF_DEBUG()</ref></computeroutput> macro is used as follows: <programlisting><codeline><highlight class="normal">TF_DEBUG(enumVal).Msg(&quot;opening<sp/>file<sp/>%s,<sp/>count<sp/>=<sp/>%d\n&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>file.c_str(),<sp/>count);</highlight></codeline>
</programlisting></para>
<para>If <computeroutput>enumVal</computeroutput> is of enumerated type <computeroutput>enumType</computeroutput>, and <computeroutput>enumType</computeroutput> has been enabled for debugging (see <computeroutput><ref refid="group__group__tf___debugging_output_1ga798d0b335c62eb79f5cd3ca35361932f" kindref="member">TF_DEBUG_CODES()</ref></computeroutput>), and the specific value <computeroutput>enumVal</computeroutput> has been enabled for debugging by a call to <computeroutput><ref refid="class_tf_debug_1a25af33b09bfa847b850d56016c098894" kindref="member">TfDebug::Enable()</ref></computeroutput>, then the arguments in the <computeroutput>Msg()</computeroutput> call are evaluated and printed. The argument to <computeroutput>Msg()</computeroutput> may either be a <computeroutput>const</computeroutput> <computeroutput>char*</computeroutput> and a variable number of arguments, using standard printf-formatting rules, or a <computeroutput>std::string</computeroutput> variable: <programlisting><codeline><highlight class="normal">TF_DEBUG(enumVal).Msg(&quot;opening<sp/>file<sp/>&quot;<sp/>+<sp/>file<sp/>+<sp/>&quot;\n&quot;);</highlight></codeline>
</programlisting></para>
<para>Note that the arguments to <computeroutput>Msg()</computeroutput> are unevaluated when the value <computeroutput>enumVal</computeroutput> is not enabled for debugging, so <computeroutput>Msg()</computeroutput> must be free of side-effects; however, when <computeroutput>enumVal</computeroutput> is not enabled, there is no expense incurred in computing the arguments to <computeroutput>Msg()</computeroutput>. Note that if the entire enum type corresponding to <computeroutput>enumVal</computeroutput> is disabled (a compile-time determination) then the code for the <emphasis>entire</emphasis> <computeroutput><ref refid="group__group__tf___debugging_output_1ga6db9ff23ef8a070034390745b54e1bf6" kindref="member">TF_DEBUG()</ref></computeroutput>.Msg() statement will typically not even be generated!</para>
<para><simplesect kind="see"><para><ref refid="group__group__tf___debugging_output_1ga065857ce30ea9e97d83c8c03cf85b3a3" kindref="member">TF_DEBUG_MSG()</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/debug.h" line="501" column="9" bodyfile="pxr/base/tf/debug.h" bodystart="501" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__group__tf___debugging_output_1ga26e5c98b1b539a57edc15b47896a9eaf" prot="public" static="no">
        <name>TF_INFO</name>
        <param><defname>x</defname></param>
        <briefdescription>
<para>Evaluate and print diagnostic messages intended for end-users. </para>
        </briefdescription>
        <detaileddescription>
<para>The <ref refid="group__group__tf___debugging_output_1ga26e5c98b1b539a57edc15b47896a9eaf" kindref="member">TF_INFO(x)</ref> macro is cosmetic; it actually just calls the TF_DEBUG macro (see above). This macro should be used if its output is intended to be seen by end-users. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/debug.h" line="511" column="9" bodyfile="pxr/base/tf/debug.h" bodystart="511" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__group__tf___debugging_output_1gaa64c32ba1023e34bde00183c90904431" prot="public" static="no">
        <name>TF_DEBUG_TIMED_SCOPE</name>
        <param><defname>enumVal</defname></param>
        <param><defname>...</defname></param>
        <briefdescription>
<para>Print description and time spent in scope upon beginning and exiting it if <computeroutput>enumVal</computeroutput> is enabled for debugging. </para>
        </briefdescription>
        <detaileddescription>
<para>The <computeroutput><ref refid="group__group__tf___debugging_output_1gaa64c32ba1023e34bde00183c90904431" kindref="member">TF_DEBUG_TIMED_SCOPE()</ref></computeroutput> macro is used as follows: <programlisting><codeline><highlight class="normal">void<sp/>Attribute::Compute()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TF_DEBUG_TIMED_SCOPE(ATTR_COMPUTE,<sp/>&quot;Computing<sp/>%s&quot;,<sp/>name.c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>When the <computeroutput>TF_DEBUG_TIMED_SCOPE</computeroutput> macro is invoked, a timer is started and the supplied description is printed. When the enclosing scope is exited (in the example, when Attribute::Compute() finishes) the timer is stopped and the scope description and measured time are printed. This allows for very fine-grained timing of operations.</para>
<para>Note that if the entire enum type corresponding to <computeroutput>enumVal</computeroutput> is disabled (a compile-time determination) then the presence of a <computeroutput><ref refid="group__group__tf___debugging_output_1gaa64c32ba1023e34bde00183c90904431" kindref="member">TF_DEBUG_TIMED_SCOPE()</ref></computeroutput> macro should not produce any extra generated code (in an optimized build). If the enum type is enabled, but the particular value <computeroutput>enumVal</computeroutput> is disabled, the cost of the macro should be quite minimal; still, it would be best not to embed the macro in functions that are called in very tight loops, in final released code. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/debug.h" line="540" column="9" bodyfile="pxr/base/tf/debug.h" bodystart="540" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__group__tf___debugging_output_1ga3ea29ad0eb18051afa6956fa5407fab9" prot="public" static="no">
        <name>TF_DEBUG_ENVIRONMENT_SYMBOL</name>
        <param><defname>VAL</defname></param>
        <param><defname>descrip</defname></param>
        <briefdescription>
<para>Register description strings with enum symbols for debugging. </para>
        </briefdescription>
        <detaileddescription>
<para>This call should be used in source files, not header files, and should This macro should usually appear within a <computeroutput><ref refid="registry_manager_8h_1ab1604c7efa4277ed6ee17fddaf70075f" kindref="member">TF_REGISTRY_FUNCTION(TfDebug,...)</ref></computeroutput> call. The first argument should be the literal name of the enum symbol, while the second argument should be a (short) description of what debugging will be enabled if the symbol is activated. The enum being registered must be one which is contained in some <ref refid="group__group__tf___debugging_output_1ga798d0b335c62eb79f5cd3ca35361932f" kindref="member">TF_DEBUG_CODES()</ref> call. For example: <programlisting><codeline><highlight class="normal">TF_REGISTRY_FUNCTION(TfDebug)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TF_DEBUG_ENVIRONMENT_SYMBOL(MY_E1,<sp/>&quot;loading<sp/>of<sp/>blah-blah<sp/>files&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>TF_DEBUG_ENVIRONMENT_SYMBOL(MY_E2,<sp/>&quot;parsing<sp/>of<sp/>mdl<sp/>code&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>etc.</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/debug.h" line="565" column="9" bodyfile="pxr/base/tf/debug.h" bodystart="565" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="group__group__tf___debugging_output_1gad9943ff687b10ed03025517ec445b30d" prot="public" static="yes" mutable="no">
        <type>_Node</type>
        <definition>TfDebug::_Node nodes</definition>
        <argsstring>[_Traits&lt; T &gt;::NumCodes]</argsstring>
        <name>nodes</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/debug.h" line="348" column="1" bodyfile="pxr/base/tf/debug.h" bodystart="348" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Functions/classes that generate output solely as a debugging aid. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
