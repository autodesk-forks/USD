<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: TfType Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_tf_type.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_tf_type-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TfType Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> represents a dynamic runtime type.  
 <a href="class_tf_type.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:struct_tf_type_1_1_bases"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#struct_tf_type_1_1_bases">Bases</a></td></tr>
<tr class="memdesc:struct_tf_type_1_1_bases"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-list of C++ base types.  <a href="class_tf_type.html#struct_tf_type_1_1_bases">More...</a><br /></td></tr>
<tr class="separator:struct_tf_type_1_1_bases"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type_1_1_factory_base.html">FactoryBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all factory types.  <a href="class_tf_type_1_1_factory_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3de4639f976acbf3cf416d5997939bff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a3de4639f976acbf3cf416d5997939bff">LegacyFlags</a> { <a class="el" href="class_tf_type.html#a3de4639f976acbf3cf416d5997939bffa7b62cfe03ccf259e4f0a1be2bf90491f">ABSTRACT</a> = 0x01, 
<a class="el" href="class_tf_type.html#a3de4639f976acbf3cf416d5997939bffa4579924b160e725f1bcb8945e133bd57">CONCRETE</a> = 0x02, 
<a class="el" href="class_tf_type.html#a3de4639f976acbf3cf416d5997939bffa76598f1dc08ed2d9f1901b24f0bfeb28">MANUFACTURABLE</a> = 0x08
 }</td></tr>
<tr class="separator:a3de4639f976acbf3cf416d5997939bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2f72e93cad36d6653d4ff08b1fc44a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#aad2f72e93cad36d6653d4ff08b1fc44a">DefinitionCallback</a> = void(*)(<a class="el" href="class_tf_type.html">TfType</a>)</td></tr>
<tr class="memdesc:aad2f72e93cad36d6653d4ff08b1fc44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback invoked when a declared type needs to be defined.  <a href="#aad2f72e93cad36d6653d4ff08b1fc44a">More...</a><br /></td></tr>
<tr class="separator:aad2f72e93cad36d6653d4ff08b1fc44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae6e3ad1e2feda01500c56388e68bd61f"><td class="memItemLeft" align="right" valign="top">TF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#ae6e3ad1e2feda01500c56388e68bd61f">TfType</a> ()</td></tr>
<tr class="memdesc:ae6e3ad1e2feda01500c56388e68bd61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> representing an unknown type.  <a href="#ae6e3ad1e2feda01500c56388e68bd61f">More...</a><br /></td></tr>
<tr class="separator:ae6e3ad1e2feda01500c56388e68bd61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338bf504cf9c50f054bb402df356fb92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a338bf504cf9c50f054bb402df356fb92">operator==</a> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;t) const</td></tr>
<tr class="memdesc:a338bf504cf9c50f054bb402df356fb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#a338bf504cf9c50f054bb402df356fb92">More...</a><br /></td></tr>
<tr class="separator:a338bf504cf9c50f054bb402df356fb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746b66bb6dd145168b529fcde1b93c0d"><td class="memItemLeft" align="right" valign="top"><a id="a746b66bb6dd145168b529fcde1b93c0d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator !=</b> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;t) const</td></tr>
<tr class="separator:a746b66bb6dd145168b529fcde1b93c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f19f39d38d18d5d4171e3962632ef6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a53f19f39d38d18d5d4171e3962632ef6">operator&lt;</a> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;t) const</td></tr>
<tr class="memdesc:a53f19f39d38d18d5d4171e3962632ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="#a53f19f39d38d18d5d4171e3962632ef6">More...</a><br /></td></tr>
<tr class="separator:a53f19f39d38d18d5d4171e3962632ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e405cbbd3e7b348435fb3df5f39aa44"><td class="memItemLeft" align="right" valign="top"><a id="a5e405cbbd3e7b348435fb3df5f39aa44"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator &gt;</b> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;t) const</td></tr>
<tr class="separator:a5e405cbbd3e7b348435fb3df5f39aa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb646ade111969946f2f21c4ea995307"><td class="memItemLeft" align="right" valign="top"><a id="adb646ade111969946f2f21c4ea995307"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;t) const</td></tr>
<tr class="separator:adb646ade111969946f2f21c4ea995307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec602b5b156df33a99829537ee4a731"><td class="memItemLeft" align="right" valign="top"><a id="a5ec602b5b156df33a99829537ee4a731"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator &gt;=</b> (const <a class="el" href="class_tf_type.html">TfType</a> &amp;t) const</td></tr>
<tr class="separator:a5ec602b5b156df33a99829537ee4a731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Pointer casts</div></td></tr>
<tr class="memitem:aab94403439cd7a644b2ed1cf1961e697"><td class="memItemLeft" align="right" valign="top">TF_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#aab94403439cd7a644b2ed1cf1961e697">CastToAncestor</a> (<a class="el" href="class_tf_type.html">TfType</a> ancestor, void *addr) const</td></tr>
<tr class="memdesc:aab94403439cd7a644b2ed1cf1961e697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <code>addr</code> to the address corresponding to the type <code>ancestor</code>.  <a href="#aab94403439cd7a644b2ed1cf1961e697">More...</a><br /></td></tr>
<tr class="separator:aab94403439cd7a644b2ed1cf1961e697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a4d747261cc4260c65482c8b2d6f15"><td class="memItemLeft" align="right" valign="top"><a id="aa3a4d747261cc4260c65482c8b2d6f15"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>CastToAncestor</b> (<a class="el" href="class_tf_type.html">TfType</a> ancestor, const void *addr) const</td></tr>
<tr class="separator:aa3a4d747261cc4260c65482c8b2d6f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6caba8ce25c352c43bb23e062a5b9467"><td class="memItemLeft" align="right" valign="top">TF_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a6caba8ce25c352c43bb23e062a5b9467">CastFromAncestor</a> (<a class="el" href="class_tf_type.html">TfType</a> ancestor, void *addr) const</td></tr>
<tr class="memdesc:a6caba8ce25c352c43bb23e062a5b9467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <code>addr</code>, which pointed to the ancestor type <code>ancestor</code>, to the type of <code>*this</code>.  <a href="#a6caba8ce25c352c43bb23e062a5b9467">More...</a><br /></td></tr>
<tr class="separator:a6caba8ce25c352c43bb23e062a5b9467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772da3665f08bd3247fac16779c8cdc6"><td class="memItemLeft" align="right" valign="top"><a id="a772da3665f08bd3247fac16779c8cdc6"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>CastFromAncestor</b> (<a class="el" href="class_tf_type.html">TfType</a> ancestor, const void *addr) const</td></tr>
<tr class="separator:a772da3665f08bd3247fac16779c8cdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Instantiation / Manufacturing</div></td></tr>
<tr class="memitem:a6d120688765f2587c837f76b16642ad3"><td class="memItemLeft" align="right" valign="top">TF_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a6d120688765f2587c837f76b16642ad3">SetFactory</a> (std::unique_ptr&lt; <a class="el" href="class_tf_type_1_1_factory_base.html">FactoryBase</a> &gt; factory) const</td></tr>
<tr class="memdesc:a6d120688765f2587c837f76b16642ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the factory object for this type.  <a href="#a6d120688765f2587c837f76b16642ad3">More...</a><br /></td></tr>
<tr class="separator:a6d120688765f2587c837f76b16642ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53c7cdd4e9444851870fdccd9bbc32f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae53c7cdd4e9444851870fdccd9bbc32f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_type.html#ae53c7cdd4e9444851870fdccd9bbc32f">SetFactory</a> (std::unique_ptr&lt; T &gt; &amp;factory) const</td></tr>
<tr class="memdesc:ae53c7cdd4e9444851870fdccd9bbc32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the factory object for this type.  <a href="#ae53c7cdd4e9444851870fdccd9bbc32f">More...</a><br /></td></tr>
<tr class="separator:ae53c7cdd4e9444851870fdccd9bbc32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6977e081e73fc9160f2ad76d5cbd6ef"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa6977e081e73fc9160f2ad76d5cbd6ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_type.html#aa6977e081e73fc9160f2ad76d5cbd6ef">SetFactory</a> () const</td></tr>
<tr class="memdesc:aa6977e081e73fc9160f2ad76d5cbd6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the factory object for this type to be a <code>T</code>.  <a href="#aa6977e081e73fc9160f2ad76d5cbd6ef">More...</a><br /></td></tr>
<tr class="separator:aa6977e081e73fc9160f2ad76d5cbd6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae458d57fc5e7715cf7c24fb20ba77674"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#ae458d57fc5e7715cf7c24fb20ba77674">Factory</a> (std::unique_ptr&lt; <a class="el" href="class_tf_type_1_1_factory_base.html">FactoryBase</a> &gt; factory) const</td></tr>
<tr class="memdesc:ae458d57fc5e7715cf7c24fb20ba77674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the factory object for this type.  <a href="#ae458d57fc5e7715cf7c24fb20ba77674">More...</a><br /></td></tr>
<tr class="separator:ae458d57fc5e7715cf7c24fb20ba77674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498eaf7e8830aabd7bf0dcdffa3c3f70"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a498eaf7e8830aabd7bf0dcdffa3c3f70"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a498eaf7e8830aabd7bf0dcdffa3c3f70">Factory</a> (std::unique_ptr&lt; T &gt; &amp;factory) const</td></tr>
<tr class="memdesc:a498eaf7e8830aabd7bf0dcdffa3c3f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the factory object for this type.  <a href="#a498eaf7e8830aabd7bf0dcdffa3c3f70">More...</a><br /></td></tr>
<tr class="separator:a498eaf7e8830aabd7bf0dcdffa3c3f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a573d676ff6fcad58e369e66df0cbcb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1a573d676ff6fcad58e369e66df0cbcb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a1a573d676ff6fcad58e369e66df0cbcb">Factory</a> () const</td></tr>
<tr class="memdesc:a1a573d676ff6fcad58e369e66df0cbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the factory object for this type to be a <code>T</code>.  <a href="#a1a573d676ff6fcad58e369e66df0cbcb">More...</a><br /></td></tr>
<tr class="separator:a1a573d676ff6fcad58e369e66df0cbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f5ea108b10ee71f163a847bc494d33"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a11f5ea108b10ee71f163a847bc494d33"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a11f5ea108b10ee71f163a847bc494d33">GetFactory</a> () const</td></tr>
<tr class="memdesc:a11f5ea108b10ee71f163a847bc494d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the factory object for this type as a <code>T*</code>, or <code>NULL</code> if there is no factory or the factory is not or is not derived from <code>T</code>.  <a href="#a11f5ea108b10ee71f163a847bc494d33">More...</a><br /></td></tr>
<tr class="separator:a11f5ea108b10ee71f163a847bc494d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afd7fcde80651e2882b54e8e94977f721"><td class="memItemLeft" align="right" valign="top">static TF_API <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#afd7fcde80651e2882b54e8e94977f721">GetUnknownType</a> ()</td></tr>
<tr class="memdesc:afd7fcde80651e2882b54e8e94977f721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an empty <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a>, representing the unknown type.  <a href="#afd7fcde80651e2882b54e8e94977f721">More...</a><br /></td></tr>
<tr class="separator:afd7fcde80651e2882b54e8e94977f721"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6b78fbe9357c548ed6412401f11a7a5f"><td class="memItemLeft" align="right" valign="top"><a id="a6b78fbe9357c548ed6412401f11a7a5f"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>_TypeInfo</b></td></tr>
<tr class="separator:a6b78fbe9357c548ed6412401f11a7a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5297e64bab3e7c7bd3201b71fa35b3e7"><td class="memTemplParams" colspan="2"><a id="a5297e64bab3e7c7bd3201b71fa35b3e7"></a>
template&lt;class HashState &gt; </td></tr>
<tr class="memitem:a5297e64bab3e7c7bd3201b71fa35b3e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TfHashAppend</b> (HashState &amp;h, <a class="el" href="class_tf_type.html">TfType</a> const &amp;type)</td></tr>
<tr class="separator:a5297e64bab3e7c7bd3201b71fa35b3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Finding types</h2></td></tr>
<tr class="memitem:ac2acc8a814d948d5444aba8852db5bcf"><td class="memItemLeft" align="right" valign="top">TF_API <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#ac2acc8a814d948d5444aba8852db5bcf">FindDerivedByName</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ac2acc8a814d948d5444aba8852db5bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> that derives from this type and has the given alias or typename.  <a href="#ac2acc8a814d948d5444aba8852db5bcf">More...</a><br /></td></tr>
<tr class="separator:ac2acc8a814d948d5444aba8852db5bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1c650c0fd030a4822d3548654c594e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc1c650c0fd030a4822d3548654c594e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_type.html#abc1c650c0fd030a4822d3548654c594e">Find</a> ()</td></tr>
<tr class="memdesc:abc1c650c0fd030a4822d3548654c594e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to type <code>T</code>.  <a href="#abc1c650c0fd030a4822d3548654c594e">More...</a><br /></td></tr>
<tr class="separator:abc1c650c0fd030a4822d3548654c594e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa648bc184361cdb6da077bb364e55217"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa648bc184361cdb6da077bb364e55217"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_type.html#aa648bc184361cdb6da077bb364e55217">Find</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:aa648bc184361cdb6da077bb364e55217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to <code>obj</code>.  <a href="#aa648bc184361cdb6da077bb364e55217">More...</a><br /></td></tr>
<tr class="separator:aa648bc184361cdb6da077bb364e55217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359bb2e5b2a54e9f4dd6889bf37a0484"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a359bb2e5b2a54e9f4dd6889bf37a0484">Find</a> (const std::type_info &amp;t)</td></tr>
<tr class="memdesc:a359bb2e5b2a54e9f4dd6889bf37a0484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to an obj with the given <code>type_info</code>.  <a href="#a359bb2e5b2a54e9f4dd6889bf37a0484">More...</a><br /></td></tr>
<tr class="separator:a359bb2e5b2a54e9f4dd6889bf37a0484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad710c9bbc6c158c6eda96a91b580b368"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#ad710c9bbc6c158c6eda96a91b580b368">FindByTypeid</a> (const std::type_info &amp;t)</td></tr>
<tr class="memdesc:ad710c9bbc6c158c6eda96a91b580b368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to an obj with the given <code>type_info</code>.  <a href="#ad710c9bbc6c158c6eda96a91b580b368">More...</a><br /></td></tr>
<tr class="separator:ad710c9bbc6c158c6eda96a91b580b368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73035766205949ad12cc23ebf622e07e"><td class="memItemLeft" align="right" valign="top">static TF_API <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a73035766205949ad12cc23ebf622e07e">FindByName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a73035766205949ad12cc23ebf622e07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to the given <code>name</code>.  <a href="#a73035766205949ad12cc23ebf622e07e">More...</a><br /></td></tr>
<tr class="separator:a73035766205949ad12cc23ebf622e07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20546b560a5304be95a16db23d04178c"><td class="memTemplParams" colspan="2">template&lt;typename BASE &gt; </td></tr>
<tr class="memitem:a20546b560a5304be95a16db23d04178c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a20546b560a5304be95a16db23d04178c">FindDerivedByName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a20546b560a5304be95a16db23d04178c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> that derives from BASE and has the given alias or typename.  <a href="#a20546b560a5304be95a16db23d04178c">More...</a><br /></td></tr>
<tr class="separator:a20546b560a5304be95a16db23d04178c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7600b470c5b3f487a9fe6ec7c4d300de"><td class="memItemLeft" align="right" valign="top">static TF_API <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a7600b470c5b3f487a9fe6ec7c4d300de">FindByPythonClass</a> (const <a class="el" href="class_tf_py_obj_wrapper.html">TfPyObjWrapper</a> &amp;classObj)</td></tr>
<tr class="memdesc:a7600b470c5b3f487a9fe6ec7c4d300de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to an obj with the given Python class <code>classObj</code>.  <a href="#a7600b470c5b3f487a9fe6ec7c4d300de">More...</a><br /></td></tr>
<tr class="separator:a7600b470c5b3f487a9fe6ec7c4d300de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Type queries</h2></td></tr>
<tr class="memitem:a85d263270c1b947fb5f65a61c79a8c91"><td class="memItemLeft" align="right" valign="top"><a id="a85d263270c1b947fb5f65a61c79a8c91"></a>
typedef TfType::_TypeInfo *TfType::*&#160;</td><td class="memItemRight" valign="bottom"><b>UnspecifiedBoolType</b></td></tr>
<tr class="separator:a85d263270c1b947fb5f65a61c79a8c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47e7403c714d094efe32a4b788b0194"><td class="memItemLeft" align="right" valign="top">TF_API const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#af47e7403c714d094efe32a4b788b0194">GetTypeName</a> () const</td></tr>
<tr class="memdesc:af47e7403c714d094efe32a4b788b0194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the machine-independent name for this type.  <a href="#af47e7403c714d094efe32a4b788b0194">More...</a><br /></td></tr>
<tr class="separator:af47e7403c714d094efe32a4b788b0194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74e202a4c93274c08acba663999d6b2"><td class="memItemLeft" align="right" valign="top">TF_API const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#aa74e202a4c93274c08acba663999d6b2">GetTypeid</a> () const</td></tr>
<tr class="memdesc:aa74e202a4c93274c08acba663999d6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a C++ RTTI type_info for this type.  <a href="#aa74e202a4c93274c08acba663999d6b2">More...</a><br /></td></tr>
<tr class="separator:aa74e202a4c93274c08acba663999d6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be6067b46f1e5fb8feb7a409dbc5fb5"><td class="memItemLeft" align="right" valign="top">TF_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a4be6067b46f1e5fb8feb7a409dbc5fb5">GetAliases</a> (<a class="el" href="class_tf_type.html">TfType</a> derivedType) const</td></tr>
<tr class="memdesc:a4be6067b46f1e5fb8feb7a409dbc5fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of the aliases registered for the derivedType under this, the base type.  <a href="#a4be6067b46f1e5fb8feb7a409dbc5fb5">More...</a><br /></td></tr>
<tr class="separator:a4be6067b46f1e5fb8feb7a409dbc5fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8e2e20954e222625dd0e282e6dd572"><td class="memItemLeft" align="right" valign="top">TF_API <a class="el" href="class_tf_py_obj_wrapper.html">TfPyObjWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#abe8e2e20954e222625dd0e282e6dd572">GetPythonClass</a> () const</td></tr>
<tr class="memdesc:abe8e2e20954e222625dd0e282e6dd572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Python class object for this type.  <a href="#abe8e2e20954e222625dd0e282e6dd572">More...</a><br /></td></tr>
<tr class="separator:abe8e2e20954e222625dd0e282e6dd572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7935af24ffec851e74f0b29b8b70eb17"><td class="memItemLeft" align="right" valign="top">TF_API std::vector&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a7935af24ffec851e74f0b29b8b70eb17">GetBaseTypes</a> () const</td></tr>
<tr class="memdesc:a7935af24ffec851e74f0b29b8b70eb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of types from which this type was derived.  <a href="#a7935af24ffec851e74f0b29b8b70eb17">More...</a><br /></td></tr>
<tr class="separator:a7935af24ffec851e74f0b29b8b70eb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb7f3726a7b628a4d8b777ace37dadb"><td class="memItemLeft" align="right" valign="top">TF_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#adfb7f3726a7b628a4d8b777ace37dadb">GetNBaseTypes</a> (<a class="el" href="class_tf_type.html">TfType</a> *out, size_t maxBases) const</td></tr>
<tr class="memdesc:adfb7f3726a7b628a4d8b777ace37dadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first <code>maxBases</code> base types of <code>this</code> type to <code>out</code>, or all the base types if this type has <code>maxBases</code> or fewer base types.  <a href="#adfb7f3726a7b628a4d8b777ace37dadb">More...</a><br /></td></tr>
<tr class="separator:adfb7f3726a7b628a4d8b777ace37dadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37b02659aa00a6f6f098acd1bff3a41"><td class="memItemLeft" align="right" valign="top">TF_API std::vector&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#aa37b02659aa00a6f6f098acd1bff3a41">GetDirectlyDerivedTypes</a> () const</td></tr>
<tr class="memdesc:aa37b02659aa00a6f6f098acd1bff3a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of types derived directly from this type.  <a href="#aa37b02659aa00a6f6f098acd1bff3a41">More...</a><br /></td></tr>
<tr class="separator:aa37b02659aa00a6f6f098acd1bff3a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d87322e1c71bb36860c9ce532e6ee9f"><td class="memItemLeft" align="right" valign="top">TF_API <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a7d87322e1c71bb36860c9ce532e6ee9f">GetCanonicalType</a> () const</td></tr>
<tr class="memdesc:a7d87322e1c71bb36860c9ce532e6ee9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the canonical type for this type.  <a href="#a7d87322e1c71bb36860c9ce532e6ee9f">More...</a><br /></td></tr>
<tr class="separator:a7d87322e1c71bb36860c9ce532e6ee9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa596041c67273d15501bef32540094fd"><td class="memItemLeft" align="right" valign="top">TF_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#aa596041c67273d15501bef32540094fd">GetAllDerivedTypes</a> (std::set&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt; *result) const</td></tr>
<tr class="memdesc:aa596041c67273d15501bef32540094fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the set of all types derived (directly or indirectly) from this type.  <a href="#aa596041c67273d15501bef32540094fd">More...</a><br /></td></tr>
<tr class="separator:aa596041c67273d15501bef32540094fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d52ed62dd2dfedcdddb3fbae99f50f"><td class="memItemLeft" align="right" valign="top">TF_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#ab2d52ed62dd2dfedcdddb3fbae99f50f">GetAllAncestorTypes</a> (std::vector&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt; *result) const</td></tr>
<tr class="memdesc:ab2d52ed62dd2dfedcdddb3fbae99f50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a vector of all ancestor types inherited by this type.  <a href="#ab2d52ed62dd2dfedcdddb3fbae99f50f">More...</a><br /></td></tr>
<tr class="separator:ab2d52ed62dd2dfedcdddb3fbae99f50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af87da6dea85ee71026bd61edff67f3"><td class="memItemLeft" align="right" valign="top">TF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a4af87da6dea85ee71026bd61edff67f3">IsA</a> (<a class="el" href="class_tf_type.html">TfType</a> queryType) const</td></tr>
<tr class="memdesc:a4af87da6dea85ee71026bd61edff67f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this type is the same as or derived from <code>queryType</code>.  <a href="#a4af87da6dea85ee71026bd61edff67f3">More...</a><br /></td></tr>
<tr class="separator:a4af87da6dea85ee71026bd61edff67f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc1b146723c266ae69fb873bcb2df67"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cc1b146723c266ae69fb873bcb2df67"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a6cc1b146723c266ae69fb873bcb2df67">IsA</a> () const</td></tr>
<tr class="memdesc:a6cc1b146723c266ae69fb873bcb2df67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this type is the same as or derived from T.  <a href="#a6cc1b146723c266ae69fb873bcb2df67">More...</a><br /></td></tr>
<tr class="separator:a6cc1b146723c266ae69fb873bcb2df67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcd9e3cee35fcfc8dcdba7429af0b00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#abdcd9e3cee35fcfc8dcdba7429af0b00">IsUnknown</a> () const</td></tr>
<tr class="memdesc:abdcd9e3cee35fcfc8dcdba7429af0b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is the unknown type, representing a type unknown to the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> system.  <a href="#abdcd9e3cee35fcfc8dcdba7429af0b00">More...</a><br /></td></tr>
<tr class="separator:abdcd9e3cee35fcfc8dcdba7429af0b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c79bb09aeb8efbd9b01ee1fbde0061"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a10c79bb09aeb8efbd9b01ee1fbde0061">operator UnspecifiedBoolType</a> () const</td></tr>
<tr class="memdesc:a10c79bb09aeb8efbd9b01ee1fbde0061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to bool &ndash; return true if this type is not unknown, false otherwise.  <a href="#a10c79bb09aeb8efbd9b01ee1fbde0061">More...</a><br /></td></tr>
<tr class="separator:a10c79bb09aeb8efbd9b01ee1fbde0061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a49470b17aeb71f23c5a2ca7bff5fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a45a49470b17aeb71f23c5a2ca7bff5fa">operator !</a> () const</td></tr>
<tr class="memdesc:a45a49470b17aeb71f23c5a2ca7bff5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean not operator &ndash; return true if this type is unknown, false otherwise.  <a href="#a45a49470b17aeb71f23c5a2ca7bff5fa">More...</a><br /></td></tr>
<tr class="separator:a45a49470b17aeb71f23c5a2ca7bff5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7b57b6ef7cbf118d492df6b7e2f6b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#adf7b57b6ef7cbf118d492df6b7e2f6b7">IsRoot</a> () const</td></tr>
<tr class="memdesc:adf7b57b6ef7cbf118d492df6b7e2f6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is the root type.  <a href="#adf7b57b6ef7cbf118d492df6b7e2f6b7">More...</a><br /></td></tr>
<tr class="separator:adf7b57b6ef7cbf118d492df6b7e2f6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54072cd078d021310c47f1ce3d9c5d1c"><td class="memItemLeft" align="right" valign="top">TF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a54072cd078d021310c47f1ce3d9c5d1c">IsEnumType</a> () const</td></tr>
<tr class="memdesc:a54072cd078d021310c47f1ce3d9c5d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an enum type.  <a href="#a54072cd078d021310c47f1ce3d9c5d1c">More...</a><br /></td></tr>
<tr class="separator:a54072cd078d021310c47f1ce3d9c5d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbdc4606290c71b789bc3f0ff0db613"><td class="memItemLeft" align="right" valign="top">TF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#afbbdc4606290c71b789bc3f0ff0db613">IsPlainOldDataType</a> () const</td></tr>
<tr class="memdesc:afbbdc4606290c71b789bc3f0ff0db613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a plain old data type, as defined by C++.  <a href="#afbbdc4606290c71b789bc3f0ff0db613">More...</a><br /></td></tr>
<tr class="separator:afbbdc4606290c71b789bc3f0ff0db613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727195e7e724066712f29fc213c92b2d"><td class="memItemLeft" align="right" valign="top">TF_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a727195e7e724066712f29fc213c92b2d">GetSizeof</a> () const</td></tr>
<tr class="memdesc:a727195e7e724066712f29fc213c92b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size required to hold an instance of this type on the stack (does not include any heap allocated memory the instance uses).  <a href="#a727195e7e724066712f29fc213c92b2d">More...</a><br /></td></tr>
<tr class="separator:a727195e7e724066712f29fc213c92b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad6fbbe1ff47153d19b9239b50908a4"><td class="memItemLeft" align="right" valign="top">static TF_API <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#afad6fbbe1ff47153d19b9239b50908a4">GetRoot</a> ()</td></tr>
<tr class="memdesc:afad6fbbe1ff47153d19b9239b50908a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the root type of the type hierarchy.  <a href="#afad6fbbe1ff47153d19b9239b50908a4">More...</a><br /></td></tr>
<tr class="separator:afad6fbbe1ff47153d19b9239b50908a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47e0ba4a284fabdbbd03a6ee33a61bd"><td class="memItemLeft" align="right" valign="top">static TF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#ae47e0ba4a284fabdbbd03a6ee33a61bd">GetCanonicalTypeName</a> (const std::type_info &amp;)</td></tr>
<tr class="memdesc:ae47e0ba4a284fabdbbd03a6ee33a61bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the canonical typeName used for a given std::type_info.  <a href="#ae47e0ba4a284fabdbbd03a6ee33a61bd">More...</a><br /></td></tr>
<tr class="separator:ae47e0ba4a284fabdbbd03a6ee33a61bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Registering new types</h2></td></tr>
<tr class="memitem:a35f5c369ebaaa8b07ec2e03cf9dff0ab"><td class="memItemLeft" align="right" valign="top">TF_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a35f5c369ebaaa8b07ec2e03cf9dff0ab">DefinePythonClass</a> (const <a class="el" href="class_tf_py_obj_wrapper.html">TfPyObjWrapper</a> &amp;classObj) const</td></tr>
<tr class="memdesc:a35f5c369ebaaa8b07ec2e03cf9dff0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the Python class object corresponding to this <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a>.  <a href="#a35f5c369ebaaa8b07ec2e03cf9dff0ab">More...</a><br /></td></tr>
<tr class="separator:a35f5c369ebaaa8b07ec2e03cf9dff0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28744a3b459987b9ddc07131fcef7a43"><td class="memItemLeft" align="right" valign="top">TF_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a28744a3b459987b9ddc07131fcef7a43">AddAlias</a> (<a class="el" href="class_tf_type.html">TfType</a> base, const std::string &amp;name) const</td></tr>
<tr class="memdesc:a28744a3b459987b9ddc07131fcef7a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an alias name for this type under the given base type.  <a href="#a28744a3b459987b9ddc07131fcef7a43">More...</a><br /></td></tr>
<tr class="separator:a28744a3b459987b9ddc07131fcef7a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67ef635ebcb6748375db0d87e4a37a3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#af67ef635ebcb6748375db0d87e4a37a3">Alias</a> (<a class="el" href="class_tf_type.html">TfType</a> base, const std::string &amp;name) const</td></tr>
<tr class="memdesc:af67ef635ebcb6748375db0d87e4a37a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to add an alias and return *this.  <a href="#af67ef635ebcb6748375db0d87e4a37a3">More...</a><br /></td></tr>
<tr class="separator:af67ef635ebcb6748375db0d87e4a37a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9baa83cae0c2ba6ef594a2c8d5f1ad"><td class="memItemLeft" align="right" valign="top">static TF_API <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a7b9baa83cae0c2ba6ef594a2c8d5f1ad">Declare</a> (const std::string &amp;typeName)</td></tr>
<tr class="memdesc:a7b9baa83cae0c2ba6ef594a2c8d5f1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> with the given <code>typeName</code>, but no base type information.  <a href="#a7b9baa83cae0c2ba6ef594a2c8d5f1ad">More...</a><br /></td></tr>
<tr class="separator:a7b9baa83cae0c2ba6ef594a2c8d5f1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2111a01b759c946eff600211ef5765"><td class="memItemLeft" align="right" valign="top">static TF_API <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a6b2111a01b759c946eff600211ef5765">Declare</a> (const std::string &amp;typeName, const std::vector&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt; &amp;bases, <a class="el" href="class_tf_type.html#aad2f72e93cad36d6653d4ff08b1fc44a">DefinitionCallback</a> definitionCallback=nullptr)</td></tr>
<tr class="memdesc:a6b2111a01b759c946eff600211ef5765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> with the given <code>typeName</code> and <code>bases</code>.  <a href="#a6b2111a01b759c946eff600211ef5765">More...</a><br /></td></tr>
<tr class="separator:a6b2111a01b759c946eff600211ef5765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032cf1f970470d87c2ca320a6c9be24f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename BaseTypes  = TfType::Bases&lt;&gt;&gt; </td></tr>
<tr class="memitem:a032cf1f970470d87c2ca320a6c9be24f"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a032cf1f970470d87c2ca320a6c9be24f">Declare</a> ()</td></tr>
<tr class="memdesc:a032cf1f970470d87c2ca320a6c9be24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> with the given C++ type T and C++ base types <a class="el" href="class_tf_type.html#struct_tf_type_1_1_bases" title="A type-list of C++ base types.">Bases</a>.  <a href="#a032cf1f970470d87c2ca320a6c9be24f">More...</a><br /></td></tr>
<tr class="separator:a032cf1f970470d87c2ca320a6c9be24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2812a06d6d2dbafc53b4f297d2aed030"><td class="memTemplParams" colspan="2">template&lt;typename T , typename B &gt; </td></tr>
<tr class="memitem:a2812a06d6d2dbafc53b4f297d2aed030"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a2812a06d6d2dbafc53b4f297d2aed030">Define</a> ()</td></tr>
<tr class="memdesc:a2812a06d6d2dbafc53b4f297d2aed030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> with the given C++ type T and C++ base types B.  <a href="#a2812a06d6d2dbafc53b4f297d2aed030">More...</a><br /></td></tr>
<tr class="separator:a2812a06d6d2dbafc53b4f297d2aed030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfdbc4b1dbd978b4f20fa76293a582b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3cfdbc4b1dbd978b4f20fa76293a582b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_tf_type.html">TfType</a> const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a3cfdbc4b1dbd978b4f20fa76293a582b">Define</a> ()</td></tr>
<tr class="memdesc:a3cfdbc4b1dbd978b4f20fa76293a582b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> with the given C++ type T and no bases.  <a href="#a3cfdbc4b1dbd978b4f20fa76293a582b">More...</a><br /></td></tr>
<tr class="separator:a3cfdbc4b1dbd978b4f20fa76293a582b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5dc94f0775e8d845514466e3620c97"><td class="memTemplParams" colspan="2">template&lt;typename Base , typename Derived &gt; </td></tr>
<tr class="memitem:a4a5dc94f0775e8d845514466e3620c97"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_type.html#a4a5dc94f0775e8d845514466e3620c97">AddAlias</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a4a5dc94f0775e8d845514466e3620c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an alias for DERIVED beneath BASE.  <a href="#a4a5dc94f0775e8d845514466e3620c97">More...</a><br /></td></tr>
<tr class="separator:a4a5dc94f0775e8d845514466e3620c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> represents a dynamic runtime type. </p>
<p>TfTypes are created and discovered at runtime, rather than compile time.</p>
<p>Features:</p>
<ul>
<li>unique typename</li>
<li>safe across DSO boundaries</li>
<li>can represent C++ types, pure Python types, or Python subclasses of wrapped C++ types</li>
<li>lightweight value semantics &ndash; you can copy and default construct <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a>, unlike <code>std::type_info</code>.</li>
<li>totally ordered &ndash; can use as a <code>std::map</code> key </li>
</ul>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00064">64</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="struct_tf_type_1_1_bases" id="struct_tf_type_1_1_bases"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_tf_type_1_1_bases">&#9670;&nbsp;</a></span>TfType::Bases</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct TfType::Bases</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class ... Args&gt;<br />
struct TfType::Bases&lt; Args &gt;</h3>

<p>A type-list of C++ base types. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_tf_type.html#a2812a06d6d2dbafc53b4f297d2aed030" title="Define a TfType with the given C++ type T and C++ base types B.">TfType::Define()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00100">100</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>
</div>
</div>
</div>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aad2f72e93cad36d6653d4ff08b1fc44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2f72e93cad36d6653d4ff08b1fc44a">&#9670;&nbsp;</a></span>DefinitionCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_tf_type.html#aad2f72e93cad36d6653d4ff08b1fc44a">DefinitionCallback</a> =  void (*)(<a class="el" href="class_tf_type.html">TfType</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback invoked when a declared type needs to be defined. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00070">70</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a3de4639f976acbf3cf416d5997939bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de4639f976acbf3cf416d5997939bff">&#9670;&nbsp;</a></span>LegacyFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_tf_type.html#a3de4639f976acbf3cf416d5997939bff">LegacyFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3de4639f976acbf3cf416d5997939bffa7b62cfe03ccf259e4f0a1be2bf90491f"></a>ABSTRACT&#160;</td><td class="fielddoc"><p>Abstract (unmanufacturable and unclonable) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3de4639f976acbf3cf416d5997939bffa4579924b160e725f1bcb8945e133bd57"></a>CONCRETE&#160;</td><td class="fielddoc"><p>Not abstract. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3de4639f976acbf3cf416d5997939bffa76598f1dc08ed2d9f1901b24f0bfeb28"></a>MANUFACTURABLE&#160;</td><td class="fielddoc"><p>Manufacturable type (implies concrete) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00080">80</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae6e3ad1e2feda01500c56388e68bd61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e3ad1e2feda01500c56388e68bd61f">&#9670;&nbsp;</a></span>TfType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API <a class="el" href="class_tf_type.html">TfType</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> representing an unknown type. </p>
<p>To actually register a new type with the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> system, see <a class="el" href="class_tf_type.html#a032cf1f970470d87c2ca320a6c9be24f" title="Declares a TfType with the given C++ type T and C++ base types Bases.">TfType::Declare()</a>.</p>
<p>Note that this always holds true: </p><div class="fragment"><div class="line"><a class="code" href="class_tf_type.html#ae6e3ad1e2feda01500c56388e68bd61f">TfType</a>().IsUnknown() == <span class="keyword">true</span></div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4a5dc94f0775e8d845514466e3620c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5dc94f0775e8d845514466e3620c97">&#9670;&nbsp;</a></span>AddAlias() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void AddAlias </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an alias for DERIVED beneath BASE. </p>
<p>This is a convenience method, that declares both DERIVED and BASE as TfTypes before adding the alias. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00505">505</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="a28744a3b459987b9ddc07131fcef7a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28744a3b459987b9ddc07131fcef7a43">&#9670;&nbsp;</a></span>AddAlias() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API void AddAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_type.html">TfType</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an alias name for this type under the given base type. </p>
<p>Aliases are similar to typedefs in C++: they provide an alternate name for a type. The alias is defined with respect to the given <code>base</code> type. Aliases must be unique with respect to both other aliases beneath that base type and names of derived types of that base. </p>

</div>
</div>
<a id="af67ef635ebcb6748375db0d87e4a37a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67ef635ebcb6748375db0d87e4a37a3">&#9670;&nbsp;</a></span>Alias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_tf_type.html">TfType</a>&amp; Alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_type.html">TfType</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method to add an alias and return *this. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_tf_type.html#a4a5dc94f0775e8d845514466e3620c97" title="Add an alias for DERIVED beneath BASE.">AddAlias()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00524">524</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="a6caba8ce25c352c43bb23e062a5b9467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6caba8ce25c352c43bb23e062a5b9467">&#9670;&nbsp;</a></span>CastFromAncestor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API void* CastFromAncestor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_type.html">TfType</a>&#160;</td>
          <td class="paramname"><em>ancestor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast <code>addr</code>, which pointed to the ancestor type <code>ancestor</code>, to the type of <code>*this</code>. </p>
<p>This function is the opposite of <code><a class="el" href="class_tf_type.html#aab94403439cd7a644b2ed1cf1961e697" title="Cast addr to the address corresponding to the type ancestor.">CastToAncestor()</a></code>; the assumption is that <code>addr</code> was a pointer to the type corresponding to <code>ancestor</code>, and was then reinterpret-cast to <code>void*</code>, but now you wish to turn cast the pointer to the type corresponding to <code>*this</code>. While the fact that <code>addr</code> was a pointer of type <code>ancestor</code> is taken on faith, a runtime check is performed to verify that the underlying object pointed to by <code>addr</code> is of type <code>*this</code> (or derived from <code>*this</code>).</p>
<dl class="section warning"><dt>Warning</dt><dd>Again, this is dangerous territory, and there's probably something much better than using this function. </dd></dl>

</div>
</div>
<a id="aab94403439cd7a644b2ed1cf1961e697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab94403439cd7a644b2ed1cf1961e697">&#9670;&nbsp;</a></span>CastToAncestor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API void* CastToAncestor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_type.html">TfType</a>&#160;</td>
          <td class="paramname"><em>ancestor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast <code>addr</code> to the address corresponding to the type <code>ancestor</code>. </p>
<p>(This is a dangerous function; there's probably a much better way to do whatever it is you're trying to do.)</p>
<p>With multiple inheritance, you can't do a reinterpret_cast back to an ancestor type; this function figures out how to cast addr to the address corresponding to the type ancestor if in fact ancestor is really an ancestor of the type corresponding to <code>*this</code>.</p>
<p>In order for this function to work correctly, <code>addr</code> must have been a pointer of type corresponding to <code>*this</code>, which was cast to void; and of course the type of <code>ancestor</code> must be an ancestor of the type of <code>*this</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>You are warned: this is deadly dangerous stuff, and you shouldn't be doing it! </dd></dl>

</div>
</div>
<a id="a7b9baa83cae0c2ba6ef594a2c8d5f1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9baa83cae0c2ba6ef594a2c8d5f1ad">&#9670;&nbsp;</a></span>Declare() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TF_API <a class="el" href="class_tf_type.html">TfType</a> const&amp; Declare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare a <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> with the given <code>typeName</code>, but no base type information. </p>
<p>This just establishes the minimal stub for the type to exist, prior to it being fleshed out with more declarations (specifying base types) or a definition. </p>

</div>
</div>
<a id="a6b2111a01b759c946eff600211ef5765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2111a01b759c946eff600211ef5765">&#9670;&nbsp;</a></span>Declare() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TF_API <a class="el" href="class_tf_type.html">TfType</a> const&amp; Declare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>typeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tf_type.html#aad2f72e93cad36d6653d4ff08b1fc44a">DefinitionCallback</a>&#160;</td>
          <td class="paramname"><em>definitionCallback</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare a <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> with the given <code>typeName</code> and <code>bases</code>. </p>
<p>If the bases vector is empty, the type will be marked as deriving from the root <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> (see TfType::GetRootType()). The <code>definitionCallback</code>, if given, will be invoked later to define the type when needed.</p>
<p>It is ok to redeclare a type that has already been declared. The given bases will supplement any existing bases. An example use of this is the Plugin system, where only a single base may be known in the plugin metadata, but when the code is loaded later, a full set of bases is specified.</p>
<p>It is an error to redeclare a type's definitionCallback. </p>

</div>
</div>
<a id="a032cf1f970470d87c2ca320a6c9be24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032cf1f970470d87c2ca320a6c9be24f">&#9670;&nbsp;</a></span>Declare() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_type.html">TfType</a> const  &amp; Declare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares a <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> with the given C++ type T and C++ base types <a class="el" href="class_tf_type.html#struct_tf_type_1_1_bases" title="A type-list of C++ base types.">Bases</a>. </p>
<p>Each of the base types will be declared (but not defined) as TfTypes if they have not already been. See the other <a class="el" href="class_tf_type.html#a032cf1f970470d87c2ca320a6c9be24f" title="Declares a TfType with the given C++ type T and C++ base types Bases.">Declare()</a> methods for more details. </p>

<p class="definition">Definition at line <a class="el" href="type___impl_8h_source.html#l00065">65</a> of file <a class="el" href="type___impl_8h_source.html">type_Impl.h</a>.</p>

</div>
</div>
<a id="a2812a06d6d2dbafc53b4f297d2aed030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2812a06d6d2dbafc53b4f297d2aed030">&#9670;&nbsp;</a></span>Define() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_type.html">TfType</a> const  &amp; Define </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define a <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> with the given C++ type T and C++ base types B. </p>
<p>Each of the base types will be declared (but not defined) as TfTypes if they have not already been.</p>
<p>The typeName of the created <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> will be the canonical demangled RTTI type name, as defined by <a class="el" href="class_tf_type.html#ae47e0ba4a284fabdbbd03a6ee33a61bd" title="Return the canonical typeName used for a given std::type_info.">GetCanonicalTypeName()</a>.</p>
<p>It is an error to attempt to define a type that has already been defined. </p>

<p class="definition">Definition at line <a class="el" href="type___impl_8h_source.html#l00077">77</a> of file <a class="el" href="type___impl_8h_source.html">type_Impl.h</a>.</p>

</div>
</div>
<a id="a3cfdbc4b1dbd978b4f20fa76293a582b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfdbc4b1dbd978b4f20fa76293a582b">&#9670;&nbsp;</a></span>Define() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_type.html">TfType</a> const  &amp; Define </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define a <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> with the given C++ type T and no bases. </p>
<p>See the other <a class="el" href="class_tf_type.html#a2812a06d6d2dbafc53b4f297d2aed030" title="Define a TfType with the given C++ type T and C++ base types B.">Define()</a> template for more details.</p>
<dl class="section note"><dt>Note</dt><dd>C++ does not allow default template arguments for function templates, so we provide this separate definition for the case of no bases. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type___impl_8h_source.html#l00102">102</a> of file <a class="el" href="type___impl_8h_source.html">type_Impl.h</a>.</p>

</div>
</div>
<a id="a35f5c369ebaaa8b07ec2e03cf9dff0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f5c369ebaaa8b07ec2e03cf9dff0ab">&#9670;&nbsp;</a></span>DefinePythonClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API void DefinePythonClass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_py_obj_wrapper.html">TfPyObjWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>classObj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the Python class object corresponding to this <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_tf_type_python_class.html" title="A boost.python visitor that associates the Python class object created by the wrapping with the TfTyp...">TfTypePythonClass</a> </dd></dl>

</div>
</div>
<a id="ae458d57fc5e7715cf7c24fb20ba77674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae458d57fc5e7715cf7c24fb20ba77674">&#9670;&nbsp;</a></span>Factory() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_tf_type.html">TfType</a>&amp; Factory </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_tf_type_1_1_factory_base.html">FactoryBase</a> &gt;&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the factory object for this type. </p>
<p>A type's factory typically has methods to instantiate the type given various arguments and must inherit from <code><a class="el" href="class_tf_type_1_1_factory_base.html" title="Base class of all factory types.">FactoryBase</a></code>. The factory cannot be changed once set. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00609">609</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="a498eaf7e8830aabd7bf0dcdffa3c3f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498eaf7e8830aabd7bf0dcdffa3c3f70">&#9670;&nbsp;</a></span>Factory() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_tf_type.html">TfType</a>&amp; Factory </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the factory object for this type. </p>
<p>A type's factory typically has methods to instantiate the type given various arguments and must inherit from <code><a class="el" href="class_tf_type_1_1_factory_base.html" title="Base class of all factory types.">FactoryBase</a></code>. The factory cannot be changed once set. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00618">618</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="a1a573d676ff6fcad58e369e66df0cbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a573d676ff6fcad58e369e66df0cbcb">&#9670;&nbsp;</a></span>Factory() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_tf_type.html">TfType</a>&amp; Factory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the factory object for this type to be a <code>T</code>. </p>
<p>The factory cannot be changed once set. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00627">627</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="abc1c650c0fd030a4822d3548654c594e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1c650c0fd030a4822d3548654c594e">&#9670;&nbsp;</a></span>Find() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_tf_type.html">TfType</a> const&amp; Find </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to type <code>T</code>. </p>
<p>The type <code>T</code> must have been declared or defined in the type system or the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to an unknown type is returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_tf_type.html#abdcd9e3cee35fcfc8dcdba7429af0b00" title="Return true if this is the unknown type, representing a type unknown to the TfType system.">IsUnknown()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00153">153</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="aa648bc184361cdb6da077bb364e55217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa648bc184361cdb6da077bb364e55217">&#9670;&nbsp;</a></span>Find() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_tf_type.html">TfType</a> const&amp; Find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to <code>obj</code>. </p>
<p>The <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to the actual object represented by <code>obj</code> is returned; this may not be the object returned by <code><a class="el" href="class_tf_type.html#abc1c650c0fd030a4822d3548654c594e" title="Retrieve the TfType corresponding to type T.">TfType::Find&lt;T&gt;()</a></code> if <code>T</code> is a polymorphic type.</p>
<p>This works for Python subclasses of the C++ type <code>T</code> as well, as long as <code>T</code> has been wrapped using TfPyPolymorphic.</p>
<p>Of course, the object's type must have been declared or defined in the type system or the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to an unknown type is returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_tf_type.html#abdcd9e3cee35fcfc8dcdba7429af0b00" title="Return true if this is the unknown type, representing a type unknown to the TfType system.">IsUnknown()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00173">173</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="a359bb2e5b2a54e9f4dd6889bf37a0484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359bb2e5b2a54e9f4dd6889bf37a0484">&#9670;&nbsp;</a></span>Find() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_tf_type.html">TfType</a> const&amp; Find </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to an obj with the given <code>type_info</code>. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00186">186</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="a73035766205949ad12cc23ebf622e07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73035766205949ad12cc23ebf622e07e">&#9670;&nbsp;</a></span>FindByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TF_API <a class="el" href="class_tf_type.html">TfType</a> const&amp; FindByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to the given <code>name</code>. </p>
<p>Every type defined in the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> system has a unique, implementation independent name. In addition, aliases can be added to identify a type underneath a specific base type; see <a class="el" href="class_tf_type.html#a4a5dc94f0775e8d845514466e3620c97" title="Add an alias for DERIVED beneath BASE.">TfType::AddAlias()</a>. The given name will first be tried as an alias under the root type, and subsequently as a typename.</p>
<p>This method is equivalent to: </p><div class="fragment"><div class="line"><a class="code" href="class_tf_type.html#afad6fbbe1ff47153d19b9239b50908a4">TfType::GetRoot</a>().<a class="code" href="class_tf_type.html#ac2acc8a814d948d5444aba8852db5bcf">FindDerivedByName</a>(name)</div></div><!-- fragment --><p>For any object <code>obj</code>, </p><div class="fragment"><div class="line"><a class="code" href="class_tf_type.html#abc1c650c0fd030a4822d3548654c594e">Find</a>(obj) == <a class="code" href="class_tf_type.html#a73035766205949ad12cc23ebf622e07e">FindByName</a>( <a class="code" href="class_tf_type.html#abc1c650c0fd030a4822d3548654c594e">Find</a>(obj).<a class="code" href="class_tf_type.html#af47e7403c714d094efe32a4b788b0194">GetTypeName</a>() )</div></div><!-- fragment --> 
</div>
</div>
<a id="a7600b470c5b3f487a9fe6ec7c4d300de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7600b470c5b3f487a9fe6ec7c4d300de">&#9670;&nbsp;</a></span>FindByPythonClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TF_API <a class="el" href="class_tf_type.html">TfType</a> const&amp; FindByPythonClass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_py_obj_wrapper.html">TfPyObjWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>classObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to an obj with the given Python class <code>classObj</code>. </p>

</div>
</div>
<a id="ad710c9bbc6c158c6eda96a91b580b368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad710c9bbc6c158c6eda96a91b580b368">&#9670;&nbsp;</a></span>FindByTypeid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_tf_type.html">TfType</a> const&amp; FindByTypeid </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> corresponding to an obj with the given <code>type_info</code>. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00193">193</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="ac2acc8a814d948d5444aba8852db5bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2acc8a814d948d5444aba8852db5bcf">&#9670;&nbsp;</a></span>FindDerivedByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API <a class="el" href="class_tf_type.html">TfType</a> const&amp; FindDerivedByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> that derives from this type and has the given alias or typename. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_tf_type.html#a4a5dc94f0775e8d845514466e3620c97" title="Add an alias for DERIVED beneath BASE.">AddAlias</a> </dd></dl>

</div>
</div>
<a id="a20546b560a5304be95a16db23d04178c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20546b560a5304be95a16db23d04178c">&#9670;&nbsp;</a></span>FindDerivedByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_tf_type.html">TfType</a> const&amp; FindDerivedByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the <code><a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a></code> that derives from BASE and has the given alias or typename. </p>
<p>This is a convenience method, and is equivalent to: </p><div class="fragment"><div class="line">TfType::Find&lt;BASE&gt;().FindDerivedByName(name)</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00235">235</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="a4be6067b46f1e5fb8feb7a409dbc5fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be6067b46f1e5fb8feb7a409dbc5fb5">&#9670;&nbsp;</a></span>GetAliases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::vector&lt;std::string&gt; GetAliases </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_type.html">TfType</a>&#160;</td>
          <td class="paramname"><em>derivedType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of the aliases registered for the derivedType under this, the base type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_tf_type.html#a4a5dc94f0775e8d845514466e3620c97" title="Add an alias for DERIVED beneath BASE.">AddAlias()</a> </dd></dl>

</div>
</div>
<a id="ab2d52ed62dd2dfedcdddb3fbae99f50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d52ed62dd2dfedcdddb3fbae99f50f">&#9670;&nbsp;</a></span>GetAllAncestorTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API void GetAllAncestorTypes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt; *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a vector of all ancestor types inherited by this type. </p>
<p>The starting type is itself included, as the first element of the results vector.</p>
<p>Types are given in "C3" resolution order, as used for new-style classes starting in Python 2.3. This algorithm is more complicated than a simple depth-first traversal of base classes, in order to prevent some subtle errors with multiple-inheritance. See the references below for more background.</p>
<dl class="section note"><dt>Note</dt><dd>This can be expensive; consider caching the results. <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> does not cache this itself since it is not needed internally.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Guido van Rossum. "Unifying types and classes in Python 2.2: Method resolution order." <a href="http://www.python.org/download/releases/2.2.2/descrintro/#mro">http://www.python.org/download/releases/2.2.2/descrintro/#mro</a></dd>
<dd>
Barrett, Cassels, Haahr, Moon, Playford, Withington. "A Monotonic Superclass Linearization for Dylan." OOPSLA 96. <a href="http://www.webcom.com/haahr/dylan/linearization-oopsla96.html">http://www.webcom.com/haahr/dylan/linearization-oopsla96.html</a> </dd></dl>

</div>
</div>
<a id="aa596041c67273d15501bef32540094fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa596041c67273d15501bef32540094fd">&#9670;&nbsp;</a></span>GetAllDerivedTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API void GetAllDerivedTypes </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt; *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the set of all types derived (directly or indirectly) from this type. </p>

</div>
</div>
<a id="a7935af24ffec851e74f0b29b8b70eb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7935af24ffec851e74f0b29b8b70eb17">&#9670;&nbsp;</a></span>GetBaseTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::vector&lt;<a class="el" href="class_tf_type.html">TfType</a>&gt; GetBaseTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector of types from which this type was derived. </p>

</div>
</div>
<a id="a7d87322e1c71bb36860c9ce532e6ee9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d87322e1c71bb36860c9ce532e6ee9f">&#9670;&nbsp;</a></span>GetCanonicalType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API <a class="el" href="class_tf_type.html">TfType</a> const&amp; GetCanonicalType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the canonical type for this type. </p>

</div>
</div>
<a id="ae47e0ba4a284fabdbbd03a6ee33a61bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47e0ba4a284fabdbbd03a6ee33a61bd">&#9670;&nbsp;</a></span>GetCanonicalTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TF_API std::string GetCanonicalTypeName </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the canonical typeName used for a given std::type_info. </p>
<p>Exactly how the canonical name is generated is left undefined, but in practice it is likely to be the demangled RTTI name of the type_info, stripped of namespaces. The real answer is implemented by this method. </p>

</div>
</div>
<a id="aa37b02659aa00a6f6f098acd1bff3a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37b02659aa00a6f6f098acd1bff3a41">&#9670;&nbsp;</a></span>GetDirectlyDerivedTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API std::vector&lt;<a class="el" href="class_tf_type.html">TfType</a>&gt; GetDirectlyDerivedTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector of types derived directly from this type. </p>

</div>
</div>
<a id="a11f5ea108b10ee71f163a847bc494d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f5ea108b10ee71f163a847bc494d33">&#9670;&nbsp;</a></span>GetFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* GetFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the factory object for this type as a <code>T*</code>, or <code>NULL</code> if there is no factory or the factory is not or is not derived from <code>T</code>. </p>
<p>Clients can check if a factory is set using <code><a class="el" href="class_tf_type.html#a11f5ea108b10ee71f163a847bc494d33" title="Returns the factory object for this type as a T*, or NULL if there is no factory or the factory is no...">GetFactory&lt;TfType::FactoryBase&gt;()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00637">637</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="adfb7f3726a7b628a4d8b777ace37dadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb7f3726a7b628a4d8b777ace37dadb">&#9670;&nbsp;</a></span>GetNBaseTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API size_t GetNBaseTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_type.html">TfType</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxBases</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the first <code>maxBases</code> base types of <code>this</code> type to <code>out</code>, or all the base types if this type has <code>maxBases</code> or fewer base types. </p>
<p>Return <code>this</code> type's number of base types.</p>
<p>Note that it is supported to change a <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> to its first base type by calling this function. For example: </p><div class="fragment"><div class="line"><a class="code" href="class_tf_type.html">TfType</a> t = ...;</div><div class="line">t.<a class="code" href="class_tf_type.html#adfb7f3726a7b628a4d8b777ace37dadb">GetNBaseTypes</a>(&amp;t, 1);</div></div><!-- fragment --> 
</div>
</div>
<a id="abe8e2e20954e222625dd0e282e6dd572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8e2e20954e222625dd0e282e6dd572">&#9670;&nbsp;</a></span>GetPythonClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API <a class="el" href="class_tf_py_obj_wrapper.html">TfPyObjWrapper</a> GetPythonClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Python class object for this type. </p>
<p>If this type is unknown or has not yet had a Python class defined, this will return <code>None</code>, as an empty <code><a class="el" href="class_tf_py_obj_wrapper.html" title="Boost Python object wrapper.">TfPyObjWrapper</a></code> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_tf_type.html#a35f5c369ebaaa8b07ec2e03cf9dff0ab" title="Define the Python class object corresponding to this TfType.">DefinePythonClass()</a> </dd></dl>

</div>
</div>
<a id="afad6fbbe1ff47153d19b9239b50908a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad6fbbe1ff47153d19b9239b50908a4">&#9670;&nbsp;</a></span>GetRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TF_API <a class="el" href="class_tf_type.html">TfType</a> const&amp; GetRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the root type of the type hierarchy. </p>
<p>All known types derive (directly or indirectly) from the root. If a type is specified with no bases, it is implicitly considered to derive from the root type. </p>

</div>
</div>
<a id="a727195e7e724066712f29fc213c92b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727195e7e724066712f29fc213c92b2d">&#9670;&nbsp;</a></span>GetSizeof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API size_t GetSizeof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size required to hold an instance of this type on the stack (does not include any heap allocated memory the instance uses). </p>
<p>This is what the C++ sizeof operator returns for the type, so this value is not very useful for Python types (it will always be sizeof(boost::python::object)). </p>

</div>
</div>
<a id="aa74e202a4c93274c08acba663999d6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74e202a4c93274c08acba663999d6b2">&#9670;&nbsp;</a></span>GetTypeid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API const std::type_info&amp; GetTypeid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a C++ RTTI type_info for this type. </p>
<p>If this type is unknown or has not yet had a C++ type defined, <code>typeid(void)</code> will be returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_tf_type.html#a2812a06d6d2dbafc53b4f297d2aed030" title="Define a TfType with the given C++ type T and C++ base types B.">Define()</a> </dd></dl>

</div>
</div>
<a id="af47e7403c714d094efe32a4b788b0194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47e7403c714d094efe32a4b788b0194">&#9670;&nbsp;</a></span>GetTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API const std::string&amp; GetTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the machine-independent name for this type. </p>
<p>This name is specified when the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> is declared. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_tf_type.html#a032cf1f970470d87c2ca320a6c9be24f" title="Declares a TfType with the given C++ type T and C++ base types Bases.">Declare()</a> </dd></dl>

</div>
</div>
<a id="afd7fcde80651e2882b54e8e94977f721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7fcde80651e2882b54e8e94977f721">&#9670;&nbsp;</a></span>GetUnknownType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TF_API <a class="el" href="class_tf_type.html">TfType</a> const&amp; GetUnknownType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an empty <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a>, representing the unknown type. </p>
<p>This is equivalento the default constructor, <a class="el" href="class_tf_type.html#ae6e3ad1e2feda01500c56388e68bd61f" title="Construct an TfType representing an unknown type.">TfType()</a>. This form exists as a clearer way to express intent in code explicitly dealing with unknown types.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_tf_type.html#abdcd9e3cee35fcfc8dcdba7429af0b00" title="Return true if this is the unknown type, representing a type unknown to the TfType system.">IsUnknown()</a> </dd></dl>

</div>
</div>
<a id="a4af87da6dea85ee71026bd61edff67f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af87da6dea85ee71026bd61edff67f3">&#9670;&nbsp;</a></span>IsA() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API bool IsA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_type.html">TfType</a>&#160;</td>
          <td class="paramname"><em>queryType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this type is the same as or derived from <code>queryType</code>. </p>
<p>If <code>queryType</code> is unknown, this always returns <code>false</code>. </p>

</div>
</div>
<a id="a6cc1b146723c266ae69fb873bcb2df67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc1b146723c266ae69fb873bcb2df67">&#9670;&nbsp;</a></span>IsA() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this type is the same as or derived from T. </p>
<p>This is equivalent to: </p><div class="fragment"><div class="line"><a class="code" href="class_tf_type.html#a6cc1b146723c266ae69fb873bcb2df67">IsA</a>(Find&lt;T&gt;())</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00380">380</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="a54072cd078d021310c47f1ce3d9c5d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54072cd078d021310c47f1ce3d9c5d1c">&#9670;&nbsp;</a></span>IsEnumType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API bool IsEnumType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an enum type. </p>

</div>
</div>
<a id="afbbdc4606290c71b789bc3f0ff0db613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbdc4606290c71b789bc3f0ff0db613">&#9670;&nbsp;</a></span>IsPlainOldDataType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API bool IsPlainOldDataType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a plain old data type, as defined by C++. </p>

</div>
</div>
<a id="adf7b57b6ef7cbf118d492df6b7e2f6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7b57b6ef7cbf118d492df6b7e2f6b7">&#9670;&nbsp;</a></span>IsRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is the root type. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00404">404</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="abdcd9e3cee35fcfc8dcdba7429af0b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcd9e3cee35fcfc8dcdba7429af0b00">&#9670;&nbsp;</a></span>IsUnknown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsUnknown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is the unknown type, representing a type unknown to the <a class="el" href="class_tf_type.html" title="TfType represents a dynamic runtime type.">TfType</a> system. </p>
<p>The unknown type does not derive from the root type, or any other type. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00388">388</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="a45a49470b17aeb71f23c5a2ca7bff5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a49470b17aeb71f23c5a2ca7bff5fa">&#9670;&nbsp;</a></span>operator !()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator ! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boolean not operator &ndash; return true if this type is unknown, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00400">400</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="a10c79bb09aeb8efbd9b01ee1fbde0061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c79bb09aeb8efbd9b01ee1fbde0061">&#9670;&nbsp;</a></span>operator UnspecifiedBoolType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operator UnspecifiedBoolType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to bool &ndash; return true if this type is not unknown, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00394">394</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="a53f19f39d38d18d5d4171e3962632ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f19f39d38d18d5d4171e3962632ef6">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00136">136</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="a338bf504cf9c50f054bb402df356fb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338bf504cf9c50f054bb402df356fb92">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<dl class="section note"><dt>Note</dt><dd>All unknown types (see <a class="el" href="class_tf_type.html#abdcd9e3cee35fcfc8dcdba7429af0b00" title="Return true if this is the unknown type, representing a type unknown to the TfType system.">IsUnknown()</a>) are considered equal. This is so all unknown types will only occupy one key when used in an associative map. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00132">132</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="a6d120688765f2587c837f76b16642ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d120688765f2587c837f76b16642ad3">&#9670;&nbsp;</a></span>SetFactory() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TF_API void SetFactory </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_tf_type_1_1_factory_base.html">FactoryBase</a> &gt;&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the factory object for this type. </p>
<p>A type's factory typically has methods to instantiate the type given various arguments and must inherit from <code><a class="el" href="class_tf_type_1_1_factory_base.html" title="Base class of all factory types.">FactoryBase</a></code>. The factory cannot be changed once set. </p>

</div>
</div>
<a id="ae53c7cdd4e9444851870fdccd9bbc32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53c7cdd4e9444851870fdccd9bbc32f">&#9670;&nbsp;</a></span>SetFactory() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetFactory </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the factory object for this type. </p>
<p>A type's factory typically has methods to instantiate the type given various arguments and must inherit from <code><a class="el" href="class_tf_type_1_1_factory_base.html" title="Base class of all factory types.">FactoryBase</a></code>. The factory cannot be changed once set. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00597">597</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<a id="aa6977e081e73fc9160f2ad76d5cbd6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6977e081e73fc9160f2ad76d5cbd6ef">&#9670;&nbsp;</a></span>SetFactory() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the factory object for this type to be a <code>T</code>. </p>
<p>The factory cannot be changed once set. </p>

<p class="definition">Definition at line <a class="el" href="type_8h_source.html#l00604">604</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>pxr/base/tf/<a class="el" href="type_8h_source.html">type.h</a></li>
<li>pxr/base/tf/<a class="el" href="type___impl_8h_source.html">type_Impl.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_tf_type.html">TfType</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:05 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>