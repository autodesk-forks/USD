<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: SdfPath Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_sdf_path.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_sdf_path-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SdfPath Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A path value used to locate objects in layers or scenegraphs.  
 <a href="class_sdf_path.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:aea68ecfef116a2cc08bc50210662def7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#aea68ecfef116a2cc08bc50210662def7">SdfPath</a> () noexcept=default</td></tr>
<tr class="memdesc:aea68ecfef116a2cc08bc50210662def7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the default, empty path.  <a href="#aea68ecfef116a2cc08bc50210662def7">More...</a><br /></td></tr>
<tr class="separator:aea68ecfef116a2cc08bc50210662def7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a5631e3571b1383af85713efb38f35"><td class="memItemLeft" align="right" valign="top">SDF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a02a5631e3571b1383af85713efb38f35">SdfPath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a02a5631e3571b1383af85713efb38f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path from the given string.  <a href="#a02a5631e3571b1383af85713efb38f35">More...</a><br /></td></tr>
<tr class="separator:a02a5631e3571b1383af85713efb38f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Querying paths</div></td></tr>
<tr class="memitem:a7838272dc514490d9f71c595b82137bb"><td class="memItemLeft" align="right" valign="top">SDF_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a7838272dc514490d9f71c595b82137bb">GetPathElementCount</a> () const</td></tr>
<tr class="memdesc:a7838272dc514490d9f71c595b82137bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of path elements in this path.  <a href="#a7838272dc514490d9f71c595b82137bb">More...</a><br /></td></tr>
<tr class="separator:a7838272dc514490d9f71c595b82137bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458ea9a47c7b224c0d496e4a12e0e659"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a458ea9a47c7b224c0d496e4a12e0e659">IsAbsolutePath</a> () const</td></tr>
<tr class="memdesc:a458ea9a47c7b224c0d496e4a12e0e659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the path is absolute.  <a href="#a458ea9a47c7b224c0d496e4a12e0e659">More...</a><br /></td></tr>
<tr class="separator:a458ea9a47c7b224c0d496e4a12e0e659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad158c53ee477c4f2d7acba3cd12452d2"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#ad158c53ee477c4f2d7acba3cd12452d2">IsAbsoluteRootPath</a> () const</td></tr>
<tr class="memdesc:ad158c53ee477c4f2d7acba3cd12452d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this path is the <a class="el" href="class_sdf_path.html#a9e77b565c10268c2b55f92559f621606" title="The absolute path representing the top of the namespace hierarchy.">AbsoluteRootPath()</a>.  <a href="#ad158c53ee477c4f2d7acba3cd12452d2">More...</a><br /></td></tr>
<tr class="separator:ad158c53ee477c4f2d7acba3cd12452d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93299f20b4d90532349b5105ea5bbbcb"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a93299f20b4d90532349b5105ea5bbbcb">IsPrimPath</a> () const</td></tr>
<tr class="memdesc:a93299f20b4d90532349b5105ea5bbbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the path identifies a prim.  <a href="#a93299f20b4d90532349b5105ea5bbbcb">More...</a><br /></td></tr>
<tr class="separator:a93299f20b4d90532349b5105ea5bbbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277dfdde9ab5121eb82dab94353d6667"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a277dfdde9ab5121eb82dab94353d6667">IsAbsoluteRootOrPrimPath</a> () const</td></tr>
<tr class="memdesc:a277dfdde9ab5121eb82dab94353d6667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the path identifies a prim or the absolute root.  <a href="#a277dfdde9ab5121eb82dab94353d6667">More...</a><br /></td></tr>
<tr class="separator:a277dfdde9ab5121eb82dab94353d6667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcc5731c01942e64dcf6fa235bcf9ed"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a8bcc5731c01942e64dcf6fa235bcf9ed">IsRootPrimPath</a> () const</td></tr>
<tr class="memdesc:a8bcc5731c01942e64dcf6fa235bcf9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the path identifies a root prim.  <a href="#a8bcc5731c01942e64dcf6fa235bcf9ed">More...</a><br /></td></tr>
<tr class="separator:a8bcc5731c01942e64dcf6fa235bcf9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ed1464cbdb872743a6b9a86de74907"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a69ed1464cbdb872743a6b9a86de74907">IsPropertyPath</a> () const</td></tr>
<tr class="memdesc:a69ed1464cbdb872743a6b9a86de74907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the path identifies a property.  <a href="#a69ed1464cbdb872743a6b9a86de74907">More...</a><br /></td></tr>
<tr class="separator:a69ed1464cbdb872743a6b9a86de74907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3bbcc350fc138c737f8c18d99e8456"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#adb3bbcc350fc138c737f8c18d99e8456">IsPrimPropertyPath</a> () const</td></tr>
<tr class="memdesc:adb3bbcc350fc138c737f8c18d99e8456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the path identifies a prim's property.  <a href="#adb3bbcc350fc138c737f8c18d99e8456">More...</a><br /></td></tr>
<tr class="separator:adb3bbcc350fc138c737f8c18d99e8456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bafb2c3e04cd0ff6d2ca2a64e2d4d42"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a9bafb2c3e04cd0ff6d2ca2a64e2d4d42">IsNamespacedPropertyPath</a> () const</td></tr>
<tr class="memdesc:a9bafb2c3e04cd0ff6d2ca2a64e2d4d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the path identifies a namespaced property.  <a href="#a9bafb2c3e04cd0ff6d2ca2a64e2d4d42">More...</a><br /></td></tr>
<tr class="separator:a9bafb2c3e04cd0ff6d2ca2a64e2d4d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ba3395e4c97b5ea922bdb03ec2e686"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a10ba3395e4c97b5ea922bdb03ec2e686">IsPrimVariantSelectionPath</a> () const</td></tr>
<tr class="memdesc:a10ba3395e4c97b5ea922bdb03ec2e686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the path identifies a variant selection for a prim.  <a href="#a10ba3395e4c97b5ea922bdb03ec2e686">More...</a><br /></td></tr>
<tr class="separator:a10ba3395e4c97b5ea922bdb03ec2e686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49fb335633cf47d279894f9646440d5"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#ae49fb335633cf47d279894f9646440d5">IsPrimOrPrimVariantSelectionPath</a> () const</td></tr>
<tr class="memdesc:ae49fb335633cf47d279894f9646440d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this path is a prim path or is a prim variant selection path.  <a href="#ae49fb335633cf47d279894f9646440d5">More...</a><br /></td></tr>
<tr class="separator:ae49fb335633cf47d279894f9646440d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e5ef524da1ebed1294084a659a543a"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#ad6e5ef524da1ebed1294084a659a543a">ContainsPrimVariantSelection</a> () const</td></tr>
<tr class="memdesc:ad6e5ef524da1ebed1294084a659a543a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the path or any of its parent paths identifies a variant selection for a prim.  <a href="#ad6e5ef524da1ebed1294084a659a543a">More...</a><br /></td></tr>
<tr class="separator:ad6e5ef524da1ebed1294084a659a543a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5c34d8ec6196f02608177e353f756d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#abd5c34d8ec6196f02608177e353f756d">ContainsPropertyElements</a> () const</td></tr>
<tr class="memdesc:abd5c34d8ec6196f02608177e353f756d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this path contains any property elements, false otherwise.  <a href="#abd5c34d8ec6196f02608177e353f756d">More...</a><br /></td></tr>
<tr class="separator:abd5c34d8ec6196f02608177e353f756d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc16aa92a79440e6030bd9210d2e376"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#addc16aa92a79440e6030bd9210d2e376">ContainsTargetPath</a> () const</td></tr>
<tr class="memdesc:addc16aa92a79440e6030bd9210d2e376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this path is or has a prefix that's a target path or a mapper path.  <a href="#addc16aa92a79440e6030bd9210d2e376">More...</a><br /></td></tr>
<tr class="separator:addc16aa92a79440e6030bd9210d2e376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215275ea9c7e897be090b5328359cfb5"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a215275ea9c7e897be090b5328359cfb5">IsRelationalAttributePath</a> () const</td></tr>
<tr class="memdesc:a215275ea9c7e897be090b5328359cfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the path identifies a relational attribute.  <a href="#a215275ea9c7e897be090b5328359cfb5">More...</a><br /></td></tr>
<tr class="separator:a215275ea9c7e897be090b5328359cfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d804883fcdf1198ea831515e39232e"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a73d804883fcdf1198ea831515e39232e">IsTargetPath</a> () const</td></tr>
<tr class="memdesc:a73d804883fcdf1198ea831515e39232e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the path identifies a relationship or connection target.  <a href="#a73d804883fcdf1198ea831515e39232e">More...</a><br /></td></tr>
<tr class="separator:a73d804883fcdf1198ea831515e39232e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb96290e258748826ef4d4f32910dbb"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#abdb96290e258748826ef4d4f32910dbb">IsMapperPath</a> () const</td></tr>
<tr class="memdesc:abdb96290e258748826ef4d4f32910dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the path identifies a connection mapper.  <a href="#abdb96290e258748826ef4d4f32910dbb">More...</a><br /></td></tr>
<tr class="separator:abdb96290e258748826ef4d4f32910dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ad6f88fd54e3b4f273d78fd67fa2d3"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a20ad6f88fd54e3b4f273d78fd67fa2d3">IsMapperArgPath</a> () const</td></tr>
<tr class="memdesc:a20ad6f88fd54e3b4f273d78fd67fa2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the path identifies a connection mapper arg.  <a href="#a20ad6f88fd54e3b4f273d78fd67fa2d3">More...</a><br /></td></tr>
<tr class="separator:a20ad6f88fd54e3b4f273d78fd67fa2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970e60a5288c37534d15f2ededffcc18"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a970e60a5288c37534d15f2ededffcc18">IsExpressionPath</a> () const</td></tr>
<tr class="memdesc:a970e60a5288c37534d15f2ededffcc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the path identifies a connection expression.  <a href="#a970e60a5288c37534d15f2ededffcc18">More...</a><br /></td></tr>
<tr class="separator:a970e60a5288c37534d15f2ededffcc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a51a0b54bb8a19b68ff5f09d861b3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a43a51a0b54bb8a19b68ff5f09d861b3d">IsEmpty</a> () const noexcept</td></tr>
<tr class="memdesc:a43a51a0b54bb8a19b68ff5f09d861b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is the empty path (<a class="el" href="class_sdf_path.html#aa3aa772925347d882bf8d68219e086c9" title="The empty path value, equivalent to SdfPath().">SdfPath::EmptyPath()</a>).  <a href="#a43a51a0b54bb8a19b68ff5f09d861b3d">More...</a><br /></td></tr>
<tr class="separator:a43a51a0b54bb8a19b68ff5f09d861b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1e5284da36a816af8fb44cd4e178a0"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a7f1e5284da36a816af8fb44cd4e178a0">GetAsToken</a> () const</td></tr>
<tr class="memdesc:a7f1e5284da36a816af8fb44cd4e178a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the string representation of this path as a <a class="el" href="class_tf_token.html" title="Token for efficient comparison, assignment, and hashing of known strings.">TfToken</a>.  <a href="#a7f1e5284da36a816af8fb44cd4e178a0">More...</a><br /></td></tr>
<tr class="separator:a7f1e5284da36a816af8fb44cd4e178a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bf22c483e7f514107851f9c8faaceb"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_tf_token.html">TfToken</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a36bf22c483e7f514107851f9c8faaceb">GetToken</a> () const</td></tr>
<tr class="memdesc:a36bf22c483e7f514107851f9c8faaceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the string representation of this path as a <a class="el" href="class_tf_token.html" title="Token for efficient comparison, assignment, and hashing of known strings.">TfToken</a> lvalue.  <a href="#a36bf22c483e7f514107851f9c8faaceb">More...</a><br /></td></tr>
<tr class="separator:a36bf22c483e7f514107851f9c8faaceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe23cf9d5aeee3f03004e968c545753"><td class="memItemLeft" align="right" valign="top">SDF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#afbe23cf9d5aeee3f03004e968c545753">GetAsString</a> () const</td></tr>
<tr class="memdesc:afbe23cf9d5aeee3f03004e968c545753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the string representation of this path as a std::string.  <a href="#afbe23cf9d5aeee3f03004e968c545753">More...</a><br /></td></tr>
<tr class="separator:afbe23cf9d5aeee3f03004e968c545753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d60b0568603a696ac239b362d25417"><td class="memItemLeft" align="right" valign="top">SDF_API const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#af4d60b0568603a696ac239b362d25417">GetString</a> () const</td></tr>
<tr class="memdesc:af4d60b0568603a696ac239b362d25417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the string representation of this path as a std::string.  <a href="#af4d60b0568603a696ac239b362d25417">More...</a><br /></td></tr>
<tr class="separator:af4d60b0568603a696ac239b362d25417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31225e07892b847e3e98473f7f04dbf4"><td class="memItemLeft" align="right" valign="top">SDF_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a31225e07892b847e3e98473f7f04dbf4">GetText</a> () const</td></tr>
<tr class="memdesc:a31225e07892b847e3e98473f7f04dbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of this path as a c string.  <a href="#a31225e07892b847e3e98473f7f04dbf4">More...</a><br /></td></tr>
<tr class="separator:a31225e07892b847e3e98473f7f04dbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82108b55a93456fb23d2775d98991d2a"><td class="memItemLeft" align="right" valign="top">SDF_API SdfPathVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a82108b55a93456fb23d2775d98991d2a">GetPrefixes</a> () const</td></tr>
<tr class="memdesc:a82108b55a93456fb23d2775d98991d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the prefix paths of this path.  <a href="#a82108b55a93456fb23d2775d98991d2a">More...</a><br /></td></tr>
<tr class="separator:a82108b55a93456fb23d2775d98991d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea81e3a0674c44ee439e8133e97827d8"><td class="memItemLeft" align="right" valign="top">SDF_API SdfPathVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#aea81e3a0674c44ee439e8133e97827d8">GetPrefixes</a> (size_t numPrefixes) const</td></tr>
<tr class="memdesc:aea81e3a0674c44ee439e8133e97827d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return up to <code>numPrefixes</code> prefix paths of this path.  <a href="#aea81e3a0674c44ee439e8133e97827d8">More...</a><br /></td></tr>
<tr class="separator:aea81e3a0674c44ee439e8133e97827d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e29e31b8d905d2882cd2d321e55ab1"><td class="memItemLeft" align="right" valign="top">SDF_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#ae2e29e31b8d905d2882cd2d321e55ab1">GetPrefixes</a> (SdfPathVector *prefixes) const</td></tr>
<tr class="memdesc:ae2e29e31b8d905d2882cd2d321e55ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills prefixes with prefixes of this path.  <a href="#ae2e29e31b8d905d2882cd2d321e55ab1">More...</a><br /></td></tr>
<tr class="separator:ae2e29e31b8d905d2882cd2d321e55ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fb0d2e17cc1c09f8551f0015f9a917"><td class="memItemLeft" align="right" valign="top">SDF_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a85fb0d2e17cc1c09f8551f0015f9a917">GetPrefixes</a> (SdfPathVector *prefixes, size_t numPrefixes) const</td></tr>
<tr class="memdesc:a85fb0d2e17cc1c09f8551f0015f9a917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <code>prefixes</code> with up to <code>numPrefixes</code> prefixes of this path.  <a href="#a85fb0d2e17cc1c09f8551f0015f9a917">More...</a><br /></td></tr>
<tr class="separator:a85fb0d2e17cc1c09f8551f0015f9a917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4478d499efea8bb68e8cb884dd54f86"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path_ancestors_range.html">SdfPathAncestorsRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#ad4478d499efea8bb68e8cb884dd54f86">GetAncestorsRange</a> () const</td></tr>
<tr class="memdesc:ad4478d499efea8bb68e8cb884dd54f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range for iterating over the ancestors of this path.  <a href="#ad4478d499efea8bb68e8cb884dd54f86">More...</a><br /></td></tr>
<tr class="separator:ad4478d499efea8bb68e8cb884dd54f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204344d110d2bb74928f43d2c1fe0047"><td class="memItemLeft" align="right" valign="top">SDF_API const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a204344d110d2bb74928f43d2c1fe0047">GetName</a> () const</td></tr>
<tr class="memdesc:a204344d110d2bb74928f43d2c1fe0047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the prim, property or relational attribute identified by the path.  <a href="#a204344d110d2bb74928f43d2c1fe0047">More...</a><br /></td></tr>
<tr class="separator:a204344d110d2bb74928f43d2c1fe0047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88a596e6ffdba5f0841e3eba451753e"><td class="memItemLeft" align="right" valign="top">SDF_API const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#ab88a596e6ffdba5f0841e3eba451753e">GetNameToken</a> () const</td></tr>
<tr class="memdesc:ab88a596e6ffdba5f0841e3eba451753e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the prim, property or relational attribute identified by the path, as a token.  <a href="#ab88a596e6ffdba5f0841e3eba451753e">More...</a><br /></td></tr>
<tr class="separator:ab88a596e6ffdba5f0841e3eba451753e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c38dfddbe1085125aec26c846354bb1"><td class="memItemLeft" align="right" valign="top">SDF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a3c38dfddbe1085125aec26c846354bb1">GetElementString</a> () const</td></tr>
<tr class="memdesc:a3c38dfddbe1085125aec26c846354bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an ascii representation of the "terminal" element of this path, which can be used to reconstruct the path using <code><a class="el" href="class_sdf_path.html#a1f2786a8b276f2ddd906168312f71891" title="Creates a path by extracting and appending an element from the given ascii element encoding.">AppendElementString()</a></code> on its parent.  <a href="#a3c38dfddbe1085125aec26c846354bb1">More...</a><br /></td></tr>
<tr class="separator:a3c38dfddbe1085125aec26c846354bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2f4362056e115b7c17b1a904aecf2b"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a7b2f4362056e115b7c17b1a904aecf2b">GetElementToken</a> () const</td></tr>
<tr class="memdesc:a7b2f4362056e115b7c17b1a904aecf2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="class_sdf_path.html#a3c38dfddbe1085125aec26c846354bb1" title="Returns an ascii representation of the &quot;terminal&quot; element of this path, which can be used to reconstr...">GetElementString()</a> but return the value as a <a class="el" href="class_tf_token.html" title="Token for efficient comparison, assignment, and hashing of known strings.">TfToken</a>.  <a href="#a7b2f4362056e115b7c17b1a904aecf2b">More...</a><br /></td></tr>
<tr class="separator:a7b2f4362056e115b7c17b1a904aecf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01eff387b47bcf63459826038b3f833"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#ae01eff387b47bcf63459826038b3f833">ReplaceName</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;newName) const</td></tr>
<tr class="memdesc:ae01eff387b47bcf63459826038b3f833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of this path with its final component changed to <em>newName</em>.  <a href="#ae01eff387b47bcf63459826038b3f833">More...</a><br /></td></tr>
<tr class="separator:ae01eff387b47bcf63459826038b3f833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad00f48495e2e6bbfb3485920696e71"><td class="memItemLeft" align="right" valign="top">SDF_API const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a8ad00f48495e2e6bbfb3485920696e71">GetTargetPath</a> () const</td></tr>
<tr class="memdesc:a8ad00f48495e2e6bbfb3485920696e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relational attribute or mapper target path for this path.  <a href="#a8ad00f48495e2e6bbfb3485920696e71">More...</a><br /></td></tr>
<tr class="separator:a8ad00f48495e2e6bbfb3485920696e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165a43440075ea161dc4b3bd9fbbad1c"><td class="memItemLeft" align="right" valign="top">SDF_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a165a43440075ea161dc4b3bd9fbbad1c">GetAllTargetPathsRecursively</a> (SdfPathVector *result) const</td></tr>
<tr class="memdesc:a165a43440075ea161dc4b3bd9fbbad1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all the relationship target or connection target paths contained in this path, and recursively all the target paths contained in those target paths in reverse depth-first order.  <a href="#a165a43440075ea161dc4b3bd9fbbad1c">More...</a><br /></td></tr>
<tr class="separator:a165a43440075ea161dc4b3bd9fbbad1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0604a5a83af57bbda444963431c8c5"><td class="memItemLeft" align="right" valign="top">SDF_API std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#ace0604a5a83af57bbda444963431c8c5">GetVariantSelection</a> () const</td></tr>
<tr class="memdesc:ace0604a5a83af57bbda444963431c8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variant selection for this path, if this is a variant selection path.  <a href="#ace0604a5a83af57bbda444963431c8c5">More...</a><br /></td></tr>
<tr class="separator:ace0604a5a83af57bbda444963431c8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec718687c3ab1ca71f459fd6af46c8b"><td class="memItemLeft" align="right" valign="top">SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a6ec718687c3ab1ca71f459fd6af46c8b">HasPrefix</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;prefix) const</td></tr>
<tr class="memdesc:a6ec718687c3ab1ca71f459fd6af46c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if both this path and <em>prefix</em> are not the empty path and this path has <em>prefix</em> as a prefix.  <a href="#a6ec718687c3ab1ca71f459fd6af46c8b">More...</a><br /></td></tr>
<tr class="separator:a6ec718687c3ab1ca71f459fd6af46c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Creating new paths by modifying existing paths</div></td></tr>
<tr class="memitem:a0da79e196526d8f2e9bfd075e36e505f"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a0da79e196526d8f2e9bfd075e36e505f">GetParentPath</a> () const</td></tr>
<tr class="memdesc:a0da79e196526d8f2e9bfd075e36e505f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the path that identifies this path's namespace parent.  <a href="#a0da79e196526d8f2e9bfd075e36e505f">More...</a><br /></td></tr>
<tr class="separator:a0da79e196526d8f2e9bfd075e36e505f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af113e66c25e4e2b1bffdf93b492e96d5"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#af113e66c25e4e2b1bffdf93b492e96d5">GetPrimPath</a> () const</td></tr>
<tr class="memdesc:af113e66c25e4e2b1bffdf93b492e96d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path by stripping all relational attributes, targets, properties, and variant selections from the leafmost prim path, leaving the nearest path for which <em><a class="el" href="class_sdf_path.html#a93299f20b4d90532349b5105ea5bbbcb" title="Returns whether the path identifies a prim.">IsPrimPath()</a></em> returns true.  <a href="#af113e66c25e4e2b1bffdf93b492e96d5">More...</a><br /></td></tr>
<tr class="separator:af113e66c25e4e2b1bffdf93b492e96d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a26a7060fc6b4125f11e9afda7b468"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a16a26a7060fc6b4125f11e9afda7b468">GetPrimOrPrimVariantSelectionPath</a> () const</td></tr>
<tr class="memdesc:a16a26a7060fc6b4125f11e9afda7b468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path by stripping all relational attributes, targets, and properties, leaving the nearest path for which <em><a class="el" href="class_sdf_path.html#ae49fb335633cf47d279894f9646440d5" title="Return true if this path is a prim path or is a prim variant selection path.">IsPrimOrPrimVariantSelectionPath()</a></em> returns true.  <a href="#a16a26a7060fc6b4125f11e9afda7b468">More...</a><br /></td></tr>
<tr class="separator:a16a26a7060fc6b4125f11e9afda7b468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494bde09b2265e393c5152744a1acaa9"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a494bde09b2265e393c5152744a1acaa9">GetAbsoluteRootOrPrimPath</a> () const</td></tr>
<tr class="memdesc:a494bde09b2265e393c5152744a1acaa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path by stripping all properties and relational attributes from this path, leaving the path to the containing prim.  <a href="#a494bde09b2265e393c5152744a1acaa9">More...</a><br /></td></tr>
<tr class="separator:a494bde09b2265e393c5152744a1acaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc29d6c107a54135f0609c723c1f7bdc"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#adc29d6c107a54135f0609c723c1f7bdc">StripAllVariantSelections</a> () const</td></tr>
<tr class="memdesc:adc29d6c107a54135f0609c723c1f7bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a path by stripping all variant selections from all components of this path, leaving a path with no embedded variant selections.  <a href="#adc29d6c107a54135f0609c723c1f7bdc">More...</a><br /></td></tr>
<tr class="separator:adc29d6c107a54135f0609c723c1f7bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49af4bd996cf81ad9f92ca51d943a39c"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a49af4bd996cf81ad9f92ca51d943a39c">AppendPath</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;newSuffix) const</td></tr>
<tr class="memdesc:a49af4bd996cf81ad9f92ca51d943a39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path by appending a given relative path to this path.  <a href="#a49af4bd996cf81ad9f92ca51d943a39c">More...</a><br /></td></tr>
<tr class="separator:a49af4bd996cf81ad9f92ca51d943a39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38c801f846f5eda9934f7306a0ba229"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#ab38c801f846f5eda9934f7306a0ba229">AppendChild</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;childName) const</td></tr>
<tr class="memdesc:ab38c801f846f5eda9934f7306a0ba229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path by appending an element for <code>childName</code> to this path.  <a href="#ab38c801f846f5eda9934f7306a0ba229">More...</a><br /></td></tr>
<tr class="separator:ab38c801f846f5eda9934f7306a0ba229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b67bfea8a8295271a32014b563d913"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a94b67bfea8a8295271a32014b563d913">AppendProperty</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;propName) const</td></tr>
<tr class="memdesc:a94b67bfea8a8295271a32014b563d913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path by appending an element for <code>propName</code> to this path.  <a href="#a94b67bfea8a8295271a32014b563d913">More...</a><br /></td></tr>
<tr class="separator:a94b67bfea8a8295271a32014b563d913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946ab463ef19352e33a5f67f73994d23"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a946ab463ef19352e33a5f67f73994d23">AppendVariantSelection</a> (const std::string &amp;variantSet, const std::string &amp;variant) const</td></tr>
<tr class="memdesc:a946ab463ef19352e33a5f67f73994d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path by appending an element for <code>variantSet</code> and <code>variant</code> to this path.  <a href="#a946ab463ef19352e33a5f67f73994d23">More...</a><br /></td></tr>
<tr class="separator:a946ab463ef19352e33a5f67f73994d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae531cda2703b759b24484b87469178f3"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#ae531cda2703b759b24484b87469178f3">AppendTarget</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;targetPath) const</td></tr>
<tr class="memdesc:ae531cda2703b759b24484b87469178f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path by appending an element for <code>targetPath</code>.  <a href="#ae531cda2703b759b24484b87469178f3">More...</a><br /></td></tr>
<tr class="separator:ae531cda2703b759b24484b87469178f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a27f9b82c613c58569cc25d7736781c"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a3a27f9b82c613c58569cc25d7736781c">AppendRelationalAttribute</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;attrName) const</td></tr>
<tr class="memdesc:a3a27f9b82c613c58569cc25d7736781c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path by appending an element for <code>attrName</code> to this path.  <a href="#a3a27f9b82c613c58569cc25d7736781c">More...</a><br /></td></tr>
<tr class="separator:a3a27f9b82c613c58569cc25d7736781c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1592d4f22c0608188059400d91c56113"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a1592d4f22c0608188059400d91c56113">ReplaceTargetPath</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;newTargetPath) const</td></tr>
<tr class="memdesc:a1592d4f22c0608188059400d91c56113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the relational attribute's target path.  <a href="#a1592d4f22c0608188059400d91c56113">More...</a><br /></td></tr>
<tr class="separator:a1592d4f22c0608188059400d91c56113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbead869ac7fbff2e37ec96709cc080"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a6dbead869ac7fbff2e37ec96709cc080">AppendMapper</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;targetPath) const</td></tr>
<tr class="memdesc:a6dbead869ac7fbff2e37ec96709cc080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path by appending a mapper element for <code>targetPath</code>.  <a href="#a6dbead869ac7fbff2e37ec96709cc080">More...</a><br /></td></tr>
<tr class="separator:a6dbead869ac7fbff2e37ec96709cc080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8e8bef1132cab5b6c751d004e1a467"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a9e8e8bef1132cab5b6c751d004e1a467">AppendMapperArg</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;argName) const</td></tr>
<tr class="memdesc:a9e8e8bef1132cab5b6c751d004e1a467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path by appending an element for <code>argName</code>.  <a href="#a9e8e8bef1132cab5b6c751d004e1a467">More...</a><br /></td></tr>
<tr class="separator:a9e8e8bef1132cab5b6c751d004e1a467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340d08137235ab2ffffafd104ec71c96"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a340d08137235ab2ffffafd104ec71c96">AppendExpression</a> () const</td></tr>
<tr class="memdesc:a340d08137235ab2ffffafd104ec71c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path by appending an expression element.  <a href="#a340d08137235ab2ffffafd104ec71c96">More...</a><br /></td></tr>
<tr class="separator:a340d08137235ab2ffffafd104ec71c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2786a8b276f2ddd906168312f71891"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a1f2786a8b276f2ddd906168312f71891">AppendElementString</a> (const std::string &amp;element) const</td></tr>
<tr class="memdesc:a1f2786a8b276f2ddd906168312f71891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a path by extracting and appending an element from the given ascii element encoding.  <a href="#a1f2786a8b276f2ddd906168312f71891">More...</a><br /></td></tr>
<tr class="separator:a1f2786a8b276f2ddd906168312f71891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e44103fa23dd4bb484221bb8b9f5c66"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a6e44103fa23dd4bb484221bb8b9f5c66">AppendElementToken</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;elementTok) const</td></tr>
<tr class="memdesc:a6e44103fa23dd4bb484221bb8b9f5c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="class_sdf_path.html#a1f2786a8b276f2ddd906168312f71891" title="Creates a path by extracting and appending an element from the given ascii element encoding.">AppendElementString()</a> but take the element as a <a class="el" href="class_tf_token.html" title="Token for efficient comparison, assignment, and hashing of known strings.">TfToken</a>.  <a href="#a6e44103fa23dd4bb484221bb8b9f5c66">More...</a><br /></td></tr>
<tr class="separator:a6e44103fa23dd4bb484221bb8b9f5c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecb0aa28f9acd0f113c6c52d0ea3b82"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#acecb0aa28f9acd0f113c6c52d0ea3b82">ReplacePrefix</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;oldPrefix, const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;newPrefix, bool fixTargetPaths=true) const</td></tr>
<tr class="memdesc:acecb0aa28f9acd0f113c6c52d0ea3b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a path with all occurrences of the prefix path <code>oldPrefix</code> replaced with the prefix path <code>newPrefix</code>.  <a href="#acecb0aa28f9acd0f113c6c52d0ea3b82">More...</a><br /></td></tr>
<tr class="separator:acecb0aa28f9acd0f113c6c52d0ea3b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e7fab9ea5b2fd517ad7f1c91bb420b"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#ac6e7fab9ea5b2fd517ad7f1c91bb420b">GetCommonPrefix</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path) const</td></tr>
<tr class="memdesc:ac6e7fab9ea5b2fd517ad7f1c91bb420b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a path with maximal length that is a prefix path of both this path and <code>path</code>.  <a href="#ac6e7fab9ea5b2fd517ad7f1c91bb420b">More...</a><br /></td></tr>
<tr class="separator:ac6e7fab9ea5b2fd517ad7f1c91bb420b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5188047700bc4b8a6786960b7788abd7"><td class="memItemLeft" align="right" valign="top">SDF_API std::pair&lt; <a class="el" href="class_sdf_path.html">SdfPath</a>, <a class="el" href="class_sdf_path.html">SdfPath</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a5188047700bc4b8a6786960b7788abd7">RemoveCommonSuffix</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;otherPath, bool stopAtRootPrim=false) const</td></tr>
<tr class="memdesc:a5188047700bc4b8a6786960b7788abd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and remove the longest common suffix from two paths.  <a href="#a5188047700bc4b8a6786960b7788abd7">More...</a><br /></td></tr>
<tr class="separator:a5188047700bc4b8a6786960b7788abd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057a39843c10795ce68c27d86639db55"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a057a39843c10795ce68c27d86639db55">MakeAbsolutePath</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;anchor) const</td></tr>
<tr class="memdesc:a057a39843c10795ce68c27d86639db55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute form of this path using <code>anchor</code> as the relative basis.  <a href="#a057a39843c10795ce68c27d86639db55">More...</a><br /></td></tr>
<tr class="separator:a057a39843c10795ce68c27d86639db55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9d4d7cc1c40ae2b35a69e32d6f0abb"><td class="memItemLeft" align="right" valign="top">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a4e9d4d7cc1c40ae2b35a69e32d6f0abb">MakeRelativePath</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;anchor) const</td></tr>
<tr class="memdesc:a4e9d4d7cc1c40ae2b35a69e32d6f0abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relative form of this path using <code>anchor</code> as the relative basis.  <a href="#a4e9d4d7cc1c40ae2b35a69e32d6f0abb">More...</a><br /></td></tr>
<tr class="separator:a4e9d4d7cc1c40ae2b35a69e32d6f0abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa3aa772925347d882bf8d68219e086c9"><td class="memItemLeft" align="right" valign="top">static SDF_API const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#aa3aa772925347d882bf8d68219e086c9">EmptyPath</a> ()</td></tr>
<tr class="memdesc:aa3aa772925347d882bf8d68219e086c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The empty path value, equivalent to <a class="el" href="class_sdf_path.html#aea68ecfef116a2cc08bc50210662def7" title="Constructs the default, empty path.">SdfPath()</a>.  <a href="#aa3aa772925347d882bf8d68219e086c9">More...</a><br /></td></tr>
<tr class="separator:aa3aa772925347d882bf8d68219e086c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e77b565c10268c2b55f92559f621606"><td class="memItemLeft" align="right" valign="top">static SDF_API const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a9e77b565c10268c2b55f92559f621606">AbsoluteRootPath</a> ()</td></tr>
<tr class="memdesc:a9e77b565c10268c2b55f92559f621606"><td class="mdescLeft">&#160;</td><td class="mdescRight">The absolute path representing the top of the namespace hierarchy.  <a href="#a9e77b565c10268c2b55f92559f621606">More...</a><br /></td></tr>
<tr class="separator:a9e77b565c10268c2b55f92559f621606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aff400613a556af9b180b056afde195"><td class="memItemLeft" align="right" valign="top">static SDF_API const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a4aff400613a556af9b180b056afde195">ReflexiveRelativePath</a> ()</td></tr>
<tr class="memdesc:a4aff400613a556af9b180b056afde195"><td class="mdescLeft">&#160;</td><td class="mdescRight">The relative path representing "self".  <a href="#a4aff400613a556af9b180b056afde195">More...</a><br /></td></tr>
<tr class="separator:a4aff400613a556af9b180b056afde195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Valid path strings, prim and property names</div></td></tr>
<tr class="memitem:a1499271167c20dd276d87693b18f5226"><td class="memItemLeft" align="right" valign="top">static SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a1499271167c20dd276d87693b18f5226">IsValidIdentifier</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a1499271167c20dd276d87693b18f5226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <code>name</code> is a legal identifier for any path component.  <a href="#a1499271167c20dd276d87693b18f5226">More...</a><br /></td></tr>
<tr class="separator:a1499271167c20dd276d87693b18f5226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c66a8d5eadec9b49cd9a5f32747834e"><td class="memItemLeft" align="right" valign="top">static SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a8c66a8d5eadec9b49cd9a5f32747834e">IsValidNamespacedIdentifier</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a8c66a8d5eadec9b49cd9a5f32747834e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <code>name</code> is a legal namespaced identifier.  <a href="#a8c66a8d5eadec9b49cd9a5f32747834e">More...</a><br /></td></tr>
<tr class="separator:a8c66a8d5eadec9b49cd9a5f32747834e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace29b426c1003c910ee565250e4519a6"><td class="memItemLeft" align="right" valign="top">static SDF_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#ace29b426c1003c910ee565250e4519a6">TokenizeIdentifier</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ace29b426c1003c910ee565250e4519a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokenizes <code>name</code> by the namespace delimiter.  <a href="#ace29b426c1003c910ee565250e4519a6">More...</a><br /></td></tr>
<tr class="separator:ace29b426c1003c910ee565250e4519a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885403f9808560bb1e3611130d9e61e8"><td class="memItemLeft" align="right" valign="top">static SDF_API <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a885403f9808560bb1e3611130d9e61e8">TokenizeIdentifierAsTokens</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a885403f9808560bb1e3611130d9e61e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokenizes <code>name</code> by the namespace delimiter.  <a href="#a885403f9808560bb1e3611130d9e61e8">More...</a><br /></td></tr>
<tr class="separator:a885403f9808560bb1e3611130d9e61e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ebddbfd0d0d176f98abd7e666689d5"><td class="memItemLeft" align="right" valign="top">static SDF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a71ebddbfd0d0d176f98abd7e666689d5">JoinIdentifier</a> (const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="memdesc:a71ebddbfd0d0d176f98abd7e666689d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join <code>names</code> into a single identifier using the namespace delimiter.  <a href="#a71ebddbfd0d0d176f98abd7e666689d5">More...</a><br /></td></tr>
<tr class="separator:a71ebddbfd0d0d176f98abd7e666689d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c0fac9fc1ee9719e692d1ab9df5805"><td class="memItemLeft" align="right" valign="top">static SDF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a13c0fac9fc1ee9719e692d1ab9df5805">JoinIdentifier</a> (const <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a> &amp;names)</td></tr>
<tr class="memdesc:a13c0fac9fc1ee9719e692d1ab9df5805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join <code>names</code> into a single identifier using the namespace delimiter.  <a href="#a13c0fac9fc1ee9719e692d1ab9df5805">More...</a><br /></td></tr>
<tr class="separator:a13c0fac9fc1ee9719e692d1ab9df5805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8b3131c82ff6f09c7a265258830e59"><td class="memItemLeft" align="right" valign="top">static SDF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a5d8b3131c82ff6f09c7a265258830e59">JoinIdentifier</a> (const std::string &amp;lhs, const std::string &amp;rhs)</td></tr>
<tr class="memdesc:a5d8b3131c82ff6f09c7a265258830e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join <code>lhs</code> and <code>rhs</code> into a single identifier using the namespace delimiter.  <a href="#a5d8b3131c82ff6f09c7a265258830e59">More...</a><br /></td></tr>
<tr class="separator:a5d8b3131c82ff6f09c7a265258830e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb024f403d4b8c49c7a5e66d221c524e"><td class="memItemLeft" align="right" valign="top">static SDF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#acb024f403d4b8c49c7a5e66d221c524e">JoinIdentifier</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;lhs, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;rhs)</td></tr>
<tr class="memdesc:acb024f403d4b8c49c7a5e66d221c524e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join <code>lhs</code> and <code>rhs</code> into a single identifier using the namespace delimiter.  <a href="#acb024f403d4b8c49c7a5e66d221c524e">More...</a><br /></td></tr>
<tr class="separator:acb024f403d4b8c49c7a5e66d221c524e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8230082d270b014bf412407fe9a526d0"><td class="memItemLeft" align="right" valign="top">static SDF_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a8230082d270b014bf412407fe9a526d0">StripNamespace</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a8230082d270b014bf412407fe9a526d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>name</code> stripped of any namespaces.  <a href="#a8230082d270b014bf412407fe9a526d0">More...</a><br /></td></tr>
<tr class="separator:a8230082d270b014bf412407fe9a526d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221902d3b503ca633b9f2ebf550afb62"><td class="memItemLeft" align="right" valign="top">static SDF_API <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a221902d3b503ca633b9f2ebf550afb62">StripNamespace</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;name)</td></tr>
<tr class="memdesc:a221902d3b503ca633b9f2ebf550afb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>name</code> stripped of any namespaces.  <a href="#a221902d3b503ca633b9f2ebf550afb62">More...</a><br /></td></tr>
<tr class="separator:a221902d3b503ca633b9f2ebf550afb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841e3e96d81ff509d8f45259d8cd7ae1"><td class="memItemLeft" align="right" valign="top">static SDF_API std::pair&lt; std::string, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a841e3e96d81ff509d8f45259d8cd7ae1">StripPrefixNamespace</a> (const std::string &amp;name, const std::string &amp;matchNamespace)</td></tr>
<tr class="memdesc:a841e3e96d81ff509d8f45259d8cd7ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns (<code>name</code>, <code>true</code>) where <code>name</code> is stripped of the prefix specified by <code>matchNamespace</code> if <code>name</code> indeed starts with <code>matchNamespace</code>.  <a href="#a841e3e96d81ff509d8f45259d8cd7ae1">More...</a><br /></td></tr>
<tr class="separator:a841e3e96d81ff509d8f45259d8cd7ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec9f4ce12ac98cb7d365646bb0bf35b"><td class="memItemLeft" align="right" valign="top">static SDF_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#acec9f4ce12ac98cb7d365646bb0bf35b">IsValidPathString</a> (const std::string &amp;pathString, std::string *errMsg=0)</td></tr>
<tr class="memdesc:acec9f4ce12ac98cb7d365646bb0bf35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>pathString</code> is a valid path string, meaning that passing the string to the <em><a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a></em> constructor will result in a valid, non-empty <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a>.  <a href="#acec9f4ce12ac98cb7d365646bb0bf35b">More...</a><br /></td></tr>
<tr class="separator:acec9f4ce12ac98cb7d365646bb0bf35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utilities</div></td></tr>
<tr class="memitem:a2c0552b700469ef7060a9aa8df3eee69"><td class="memItemLeft" align="right" valign="top">static SDF_API SdfPathVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a2c0552b700469ef7060a9aa8df3eee69">GetConciseRelativePaths</a> (const SdfPathVector &amp;paths)</td></tr>
<tr class="memdesc:a2c0552b700469ef7060a9aa8df3eee69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given some vector of paths, get a vector of concise unambiguous relative paths.  <a href="#a2c0552b700469ef7060a9aa8df3eee69">More...</a><br /></td></tr>
<tr class="separator:a2c0552b700469ef7060a9aa8df3eee69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fcc9c525284def3fc2315b343e3b91"><td class="memItemLeft" align="right" valign="top">static SDF_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#ac1fcc9c525284def3fc2315b343e3b91">RemoveDescendentPaths</a> (SdfPathVector *paths)</td></tr>
<tr class="memdesc:ac1fcc9c525284def3fc2315b343e3b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements of <em>paths</em> that are prefixed by other elements in <em>paths</em>.  <a href="#ac1fcc9c525284def3fc2315b343e3b91">More...</a><br /></td></tr>
<tr class="separator:ac1fcc9c525284def3fc2315b343e3b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31641f36475586915e1317aa87818f6"><td class="memItemLeft" align="right" valign="top">static SDF_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#af31641f36475586915e1317aa87818f6">RemoveAncestorPaths</a> (SdfPathVector *paths)</td></tr>
<tr class="memdesc:af31641f36475586915e1317aa87818f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements of <em>paths</em> that prefix other elements in <em>paths</em>.  <a href="#af31641f36475586915e1317aa87818f6">More...</a><br /></td></tr>
<tr class="separator:af31641f36475586915e1317aa87818f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7d74a06aa1bae37fe766467bfceebfd1"><td class="memItemLeft" align="right" valign="top"><a id="a7d74a06aa1bae37fe766467bfceebfd1"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Sdfext_PathAccess</b></td></tr>
<tr class="separator:a7d74a06aa1bae37fe766467bfceebfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9218299b345c74891827813872ed37ec"><td class="memItemLeft" align="right" valign="top"><a id="a9218299b345c74891827813872ed37ec"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SdfPathAncestorsRange</b></td></tr>
<tr class="separator:a9218299b345c74891827813872ed37ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909ff6c959355afb4b5a5a28ad490622"><td class="memItemLeft" align="right" valign="top"><a id="a909ff6c959355afb4b5a5a28ad490622"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="class_sdf_path.html">SdfPath</a> &amp;lhs, <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;rhs)</td></tr>
<tr class="separator:a909ff6c959355afb4b5a5a28ad490622"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Operators</h2></td></tr>
<tr class="memitem:a9ee6a9aa0a486f4092335b7f1cf8b3f1"><td class="memTemplParams" colspan="2"><a id="a9ee6a9aa0a486f4092335b7f1cf8b3f1"></a>
template&lt;class HashState &gt; </td></tr>
<tr class="memitem:a9ee6a9aa0a486f4092335b7f1cf8b3f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TfHashAppend</b> (HashState &amp;h, <a class="el" href="class_sdf_path.html">SdfPath</a> const &amp;path)</td></tr>
<tr class="separator:a9ee6a9aa0a486f4092335b7f1cf8b3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad405c341013019fb6b9aaa90aa2598a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#ad405c341013019fb6b9aaa90aa2598a1">operator==</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ad405c341013019fb6b9aaa90aa2598a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#ad405c341013019fb6b9aaa90aa2598a1">More...</a><br /></td></tr>
<tr class="separator:ad405c341013019fb6b9aaa90aa2598a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7f17c2d6a7a53528c62158ce9ad335"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#afb7f17c2d6a7a53528c62158ce9ad335">operator!=</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;rhs) const</td></tr>
<tr class="memdesc:afb7f17c2d6a7a53528c62158ce9ad335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#afb7f17c2d6a7a53528c62158ce9ad335">More...</a><br /></td></tr>
<tr class="separator:afb7f17c2d6a7a53528c62158ce9ad335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad310c9d17d03812d810bf4e4edf3fb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#aad310c9d17d03812d810bf4e4edf3fb9">operator&lt;</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;rhs) const</td></tr>
<tr class="memdesc:aad310c9d17d03812d810bf4e4edf3fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="#aad310c9d17d03812d810bf4e4edf3fb9">More...</a><br /></td></tr>
<tr class="separator:aad310c9d17d03812d810bf4e4edf3fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57aa0abebf5481d6ffa80b2483b2bb8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a57aa0abebf5481d6ffa80b2483b2bb8a">operator&gt;</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a57aa0abebf5481d6ffa80b2483b2bb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than operator.  <a href="#a57aa0abebf5481d6ffa80b2483b2bb8a">More...</a><br /></td></tr>
<tr class="separator:a57aa0abebf5481d6ffa80b2483b2bb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3016b02123ca74bab194219ec9227bf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#a3016b02123ca74bab194219ec9227bf2">operator&lt;=</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a3016b02123ca74bab194219ec9227bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal operator.  <a href="#a3016b02123ca74bab194219ec9227bf2">More...</a><br /></td></tr>
<tr class="separator:a3016b02123ca74bab194219ec9227bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae48d25dda744ff6efaf3c363588bb8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sdf_path.html#aae48d25dda744ff6efaf3c363588bb8d">operator&gt;=</a> (const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;rhs) const</td></tr>
<tr class="memdesc:aae48d25dda744ff6efaf3c363588bb8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal operator.  <a href="#aae48d25dda744ff6efaf3c363588bb8d">More...</a><br /></td></tr>
<tr class="separator:aae48d25dda744ff6efaf3c363588bb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99b522cc14f7d4a22d78368b476e12a"><td class="memItemLeft" align="right" valign="top"><a id="aa99b522cc14f7d4a22d78368b476e12a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetHash</b> () const</td></tr>
<tr class="separator:aa99b522cc14f7d4a22d78368b476e12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A path value used to locate objects in layers or scenegraphs. </p>
<h1><a class="anchor" id="sec_SdfPath_Overview"></a>
Overview</h1>
<p><a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> is used in several ways: </p><ul>
<li>As a storage key for addressing and accessing values held in a <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> </li>
<li>As a namespace identity for scenegraph objects </li>
<li>As a way to refer to other scenegraph objects through relative paths</li>
</ul>
<p>The paths represented by an <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> class may be either relative or absolute. Relative paths are relative to the prim object that contains them (that is, if an <a class="el" href="class_sdf_relationship_spec.html" title="A property that contains a reference to one or more SdfPrimSpec instances.">SdfRelationshipSpec</a> target is relative, it is relative to the <a class="el" href="class_sdf_prim_spec.html" title="Represents a prim description in an SdfLayer object.">SdfPrimSpec</a> object that owns the <a class="el" href="class_sdf_relationship_spec.html" title="A property that contains a reference to one or more SdfPrimSpec instances.">SdfRelationshipSpec</a> object).</p>
<p><a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> objects can be readily created from and converted back to strings, but as <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> objects, they have behaviors that make it easy and efficient to work with them. The <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> class provides a full range of methods for manipulating scene paths by appending a namespace child, appending a relationship target, getting the parent path, and so on. Since the <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> class uses a node-based representation internally, you should use the editing functions rather than converting to and from strings if possible.</p>
<h1><a class="anchor" id="sec_SdfPath_Syntax"></a>
Path Syntax</h1>
<p>Like a filesystem path, an <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> is conceptually just a sequence of path components. Unlike a filesystem path, each component has a type, and the type is indicated by the syntax.</p>
<p>Two separators are used between parts of a path. A slash ("/") following an identifier is used to introduce a namespace child. A period (".") following an identifier is used to introduce a property. A property may also have several non-sequential colons (':') in its name to provide a rudimentary namespace within properties but may not end or begin with a colon.</p>
<p>A leading slash in the string representation of an <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> object indicates an absolute path. Two adjacent periods indicate the parent namespace.</p>
<p>Brackets ("[" and "]") are used to indicate relationship target paths for relational attributes.</p>
<p>The first part in a path is assumed to be a namespace child unless it is preceded by a period. That means: </p><ul>
<li><code>/Foo</code> is an absolute path specifying the root prim Foo. </li>
<li><code>/Foo/Bar</code> is an absolute path specifying namespace child Bar of root prim Foo. </li>
<li><code>/Foo/Bar.baz</code> is an absolute path specifying property <code>baz</code> of namespace child Bar of root prim Foo. </li>
<li><code>Foo</code> is a relative path specifying namespace child Foo of the current prim. </li>
<li><code>Foo/Bar</code> is a relative path specifying namespace child Bar of namespace child Foo of the current prim. </li>
<li><code>Foo/Bar.baz</code> is a relative path specifying property <code>baz</code> of namespace child Bar of namespace child Foo of the current prim. </li>
<li><code>.foo</code> is a relative path specifying the property <code>foo</code> of the current prim. </li>
<li><code>/Foo.bar[/Foo.baz].attrib</code> is a relational attribute path. The relationship <code>/Foo.bar</code> has a target <code>/Foo.baz</code>. There is a relational attribute <code>attrib</code> on that relationship-&gt;target pair.</li>
</ul>
<h1><a class="anchor" id="sec_SdfPath_ThreadSafety"></a>
A Note on Thread-Safety</h1>
<p><a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> is strongly thread-safe, in the sense that zero additional synchronization is required between threads creating or using <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> values. Just like <a class="el" href="class_tf_token.html" title="Token for efficient comparison, assignment, and hashing of known strings.">TfToken</a>, <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> values are immutable. Internally, <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> uses a global prefix tree to efficiently share representations of paths, and provide fast equality/hashing operations, but modifications to this table are internally synchronized. Consequently, as with <a class="el" href="class_tf_token.html" title="Token for efficient comparison, assignment, and hashing of known strings.">TfToken</a>, for best performance it is important to minimize the number of values created (since it requires synchronized access to this table) or copied (since it requires atomic ref-counting operations). </p>

<p class="definition">Definition at line <a class="el" href="path_8h_source.html#l00290">290</a> of file <a class="el" href="path_8h_source.html">path.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea68ecfef116a2cc08bc50210662def7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea68ecfef116a2cc08bc50210662def7">&#9670;&nbsp;</a></span>SdfPath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sdf_path.html">SdfPath</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the default, empty path. </p>

</div>
</div>
<a id="a02a5631e3571b1383af85713efb38f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a5631e3571b1383af85713efb38f35">&#9670;&nbsp;</a></span>SdfPath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a path from the given string. </p>
<p>If the given string is not a well-formed path, this will raise a Tf error. Note that passing an empty std::string() will also raise an error; the correct way to get the empty path is <a class="el" href="class_sdf_path.html#aea68ecfef116a2cc08bc50210662def7" title="Constructs the default, empty path.">SdfPath()</a>.</p>
<p>Internal dot-dots will be resolved by removing the first dot-dot, the element preceding it, and repeating until no internal dot-dots remain.</p>
<p>Note that most often new paths are expected to be created by asking existing paths to return modified versions of themselves. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9e77b565c10268c2b55f92559f621606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e77b565c10268c2b55f92559f621606">&#9670;&nbsp;</a></span>AbsoluteRootPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API const <a class="el" href="class_sdf_path.html">SdfPath</a>&amp; AbsoluteRootPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The absolute path representing the top of the namespace hierarchy. </p>

</div>
</div>
<a id="ab38c801f846f5eda9934f7306a0ba229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38c801f846f5eda9934f7306a0ba229">&#9670;&nbsp;</a></span>AppendChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> AppendChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_token.html">TfToken</a> const &amp;&#160;</td>
          <td class="paramname"><em>childName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a path by appending an element for <code>childName</code> to this path. </p>
<p>This path must be a prim path, the AbsoluteRootPath or the ReflexiveRelativePath. </p>

</div>
</div>
<a id="a1f2786a8b276f2ddd906168312f71891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2786a8b276f2ddd906168312f71891">&#9670;&nbsp;</a></span>AppendElementString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> AppendElementString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a path by extracting and appending an element from the given ascii element encoding. </p>
<p>Attempting to append a root or empty path (or malformed path) or attempting to append <em>to</em> the EmptyPath will raise an error and return the EmptyPath.</p>
<p>May also fail and return EmptyPath if this path's type cannot possess a child of the type encoded in <code>element</code>. </p>

</div>
</div>
<a id="a6e44103fa23dd4bb484221bb8b9f5c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e44103fa23dd4bb484221bb8b9f5c66">&#9670;&nbsp;</a></span>AppendElementToken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> AppendElementToken </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>elementTok</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="class_sdf_path.html#a1f2786a8b276f2ddd906168312f71891" title="Creates a path by extracting and appending an element from the given ascii element encoding.">AppendElementString()</a> but take the element as a <a class="el" href="class_tf_token.html" title="Token for efficient comparison, assignment, and hashing of known strings.">TfToken</a>. </p>

</div>
</div>
<a id="a340d08137235ab2ffffafd104ec71c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340d08137235ab2ffffafd104ec71c96">&#9670;&nbsp;</a></span>AppendExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> AppendExpression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a path by appending an expression element. </p>
<p>This path must be a prim property or relational attribute path. </p>

</div>
</div>
<a id="a6dbead869ac7fbff2e37ec96709cc080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dbead869ac7fbff2e37ec96709cc080">&#9670;&nbsp;</a></span>AppendMapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> AppendMapper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>targetPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a path by appending a mapper element for <code>targetPath</code>. </p>
<p>This path must be a prim property or relational attribute path. </p>

</div>
</div>
<a id="a9e8e8bef1132cab5b6c751d004e1a467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8e8bef1132cab5b6c751d004e1a467">&#9670;&nbsp;</a></span>AppendMapperArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> AppendMapperArg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_token.html">TfToken</a> const &amp;&#160;</td>
          <td class="paramname"><em>argName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a path by appending an element for <code>argName</code>. </p>
<p>This path must be a mapper path. </p>

</div>
</div>
<a id="a49af4bd996cf81ad9f92ca51d943a39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49af4bd996cf81ad9f92ca51d943a39c">&#9670;&nbsp;</a></span>AppendPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> AppendPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>newSuffix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a path by appending a given relative path to this path. </p>
<p>If the newSuffix is a prim path, then this path must be a prim path or a root path.</p>
<p>If the newSuffix is a prim property path, then this path must be a prim path or the ReflexiveRelativePath. </p>

</div>
</div>
<a id="a94b67bfea8a8295271a32014b563d913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b67bfea8a8295271a32014b563d913">&#9670;&nbsp;</a></span>AppendProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> AppendProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_token.html">TfToken</a> const &amp;&#160;</td>
          <td class="paramname"><em>propName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a path by appending an element for <code>propName</code> to this path. </p>
<p>This path must be a prim path or the ReflexiveRelativePath. </p>

</div>
</div>
<a id="a3a27f9b82c613c58569cc25d7736781c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a27f9b82c613c58569cc25d7736781c">&#9670;&nbsp;</a></span>AppendRelationalAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> AppendRelationalAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_token.html">TfToken</a> const &amp;&#160;</td>
          <td class="paramname"><em>attrName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a path by appending an element for <code>attrName</code> to this path. </p>
<p>This path must be a target path. </p>

</div>
</div>
<a id="ae531cda2703b759b24484b87469178f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae531cda2703b759b24484b87469178f3">&#9670;&nbsp;</a></span>AppendTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> AppendTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>targetPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a path by appending an element for <code>targetPath</code>. </p>
<p>This path must be a prim property or relational attribute path. </p>

</div>
</div>
<a id="a946ab463ef19352e33a5f67f73994d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946ab463ef19352e33a5f67f73994d23">&#9670;&nbsp;</a></span>AppendVariantSelection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> AppendVariantSelection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variantSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a path by appending an element for <code>variantSet</code> and <code>variant</code> to this path. </p>
<p>This path must be a prim path. </p>

</div>
</div>
<a id="ad6e5ef524da1ebed1294084a659a543a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e5ef524da1ebed1294084a659a543a">&#9670;&nbsp;</a></span>ContainsPrimVariantSelection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool ContainsPrimVariantSelection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the path or any of its parent paths identifies a variant selection for a prim. </p>

</div>
</div>
<a id="abd5c34d8ec6196f02608177e353f756d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5c34d8ec6196f02608177e353f756d">&#9670;&nbsp;</a></span>ContainsPropertyElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ContainsPropertyElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this path contains any property elements, false otherwise. </p>
<p>A false return indicates a prim-like path, specifically a root path, a prim path, or a prim variant selection path. A true return indicates a property-like path: a prim property path, a target path, a relational attribute path, etc. </p>

<p class="definition">Definition at line <a class="el" href="path_8h_source.html#l00396">396</a> of file <a class="el" href="path_8h_source.html">path.h</a>.</p>

</div>
</div>
<a id="addc16aa92a79440e6030bd9210d2e376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc16aa92a79440e6030bd9210d2e376">&#9670;&nbsp;</a></span>ContainsTargetPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool ContainsTargetPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this path is or has a prefix that's a target path or a mapper path. </p>

</div>
</div>
<a id="aa3aa772925347d882bf8d68219e086c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3aa772925347d882bf8d68219e086c9">&#9670;&nbsp;</a></span>EmptyPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API const <a class="el" href="class_sdf_path.html">SdfPath</a>&amp; EmptyPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The empty path value, equivalent to <a class="el" href="class_sdf_path.html#aea68ecfef116a2cc08bc50210662def7" title="Constructs the default, empty path.">SdfPath()</a>. </p>

</div>
</div>
<a id="a494bde09b2265e393c5152744a1acaa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494bde09b2265e393c5152744a1acaa9">&#9670;&nbsp;</a></span>GetAbsoluteRootOrPrimPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> GetAbsoluteRootOrPrimPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a path by stripping all properties and relational attributes from this path, leaving the path to the containing prim. </p>
<p>If the path is already a prim or absolute root path, the same path is returned. </p>

</div>
</div>
<a id="a165a43440075ea161dc4b3bd9fbbad1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165a43440075ea161dc4b3bd9fbbad1c">&#9670;&nbsp;</a></span>GetAllTargetPathsRecursively()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API void GetAllTargetPathsRecursively </td>
          <td>(</td>
          <td class="paramtype">SdfPathVector *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all the relationship target or connection target paths contained in this path, and recursively all the target paths contained in those target paths in reverse depth-first order. </p>
<p>For example, given the path: '/A/B.a[/C/D.a[/E/F.a]].a[/A/B.a[/C/D.a]]' this method produces: '/A/B.a[/C/D.a]', '/C/D.a', '/C/D.a[/E/F.a]', '/E/F.a' </p>

</div>
</div>
<a id="ad4478d499efea8bb68e8cb884dd54f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4478d499efea8bb68e8cb884dd54f86">&#9670;&nbsp;</a></span>GetAncestorsRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path_ancestors_range.html">SdfPathAncestorsRange</a> GetAncestorsRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a range for iterating over the ancestors of this path. </p>
<p>The range provides iteration over the prefixes of a path, ordered from longest to shortest (the opposite of the order of the prefixes returned by GetPrefixes). </p>

</div>
</div>
<a id="afbe23cf9d5aeee3f03004e968c545753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe23cf9d5aeee3f03004e968c545753">&#9670;&nbsp;</a></span>GetAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API std::string GetAsString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the string representation of this path as a std::string. </p>
<p>This function is recommended only for human-readable or diagnostic output. Use the <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> API to manipulate paths. It is less error-prone and has better performance. </p>

</div>
</div>
<a id="a7f1e5284da36a816af8fb44cd4e178a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1e5284da36a816af8fb44cd4e178a0">&#9670;&nbsp;</a></span>GetAsToken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_tf_token.html">TfToken</a> GetAsToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the string representation of this path as a <a class="el" href="class_tf_token.html" title="Token for efficient comparison, assignment, and hashing of known strings.">TfToken</a>. </p>
<p>This function is recommended only for human-readable or diagnostic output. Use the <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> API to manipulate paths. It is less error-prone and has better performance. </p>

</div>
</div>
<a id="ac6e7fab9ea5b2fd517ad7f1c91bb420b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e7fab9ea5b2fd517ad7f1c91bb420b">&#9670;&nbsp;</a></span>GetCommonPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> GetCommonPrefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a path with maximal length that is a prefix path of both this path and <code>path</code>. </p>

</div>
</div>
<a id="a2c0552b700469ef7060a9aa8df3eee69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0552b700469ef7060a9aa8df3eee69">&#9670;&nbsp;</a></span>GetConciseRelativePaths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API SdfPathVector GetConciseRelativePaths </td>
          <td>(</td>
          <td class="paramtype">const SdfPathVector &amp;&#160;</td>
          <td class="paramname"><em>paths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given some vector of paths, get a vector of concise unambiguous relative paths. </p>
<p>GetConciseRelativePaths requires a vector of absolute paths. It finds a set of relative paths such that each relative path is unique. </p>

</div>
</div>
<a id="a3c38dfddbe1085125aec26c846354bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c38dfddbe1085125aec26c846354bb1">&#9670;&nbsp;</a></span>GetElementString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API std::string GetElementString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an ascii representation of the "terminal" element of this path, which can be used to reconstruct the path using <code><a class="el" href="class_sdf_path.html#a1f2786a8b276f2ddd906168312f71891" title="Creates a path by extracting and appending an element from the given ascii element encoding.">AppendElementString()</a></code> on its parent. </p>
<p><a class="el" href="class_sdf_path.html#aa3aa772925347d882bf8d68219e086c9" title="The empty path value, equivalent to SdfPath().">EmptyPath()</a>, <a class="el" href="class_sdf_path.html#a9e77b565c10268c2b55f92559f621606" title="The absolute path representing the top of the namespace hierarchy.">AbsoluteRootPath()</a>, and <a class="el" href="class_sdf_path.html#a4aff400613a556af9b180b056afde195" title="The relative path representing &quot;self&quot;.">ReflexiveRelativePath()</a> are <em>not</em> considered elements (one of the defining properties of elements is that they have a parent), so <code><a class="el" href="class_sdf_path.html#a3c38dfddbe1085125aec26c846354bb1" title="Returns an ascii representation of the &quot;terminal&quot; element of this path, which can be used to reconstr...">GetElementString()</a></code> will return the empty string for these paths.</p>
<p>Unlike <code><a class="el" href="class_sdf_path.html#a204344d110d2bb74928f43d2c1fe0047" title="Returns the name of the prim, property or relational attribute identified by the path.">GetName()</a></code> and <code><a class="el" href="class_sdf_path.html#a8ad00f48495e2e6bbfb3485920696e71" title="Returns the relational attribute or mapper target path for this path.">GetTargetPath()</a></code>, which provide you "some" information about the terminal element, this provides a complete representation of the element, for all element types.</p>
<p>Also note that whereas <code><a class="el" href="class_sdf_path.html#a204344d110d2bb74928f43d2c1fe0047" title="Returns the name of the prim, property or relational attribute identified by the path.">GetName()</a></code>, <code><a class="el" href="class_sdf_path.html#ab88a596e6ffdba5f0841e3eba451753e" title="Returns the name of the prim, property or relational attribute identified by the path,...">GetNameToken()</a></code>, <code><a class="el" href="class_sdf_path.html#a31225e07892b847e3e98473f7f04dbf4" title="Returns the string representation of this path as a c string.">GetText()</a></code>, <code><a class="el" href="class_sdf_path.html#af4d60b0568603a696ac239b362d25417" title="Return the string representation of this path as a std::string.">GetString()</a></code>, and <code><a class="el" href="class_sdf_path.html#a8ad00f48495e2e6bbfb3485920696e71" title="Returns the relational attribute or mapper target path for this path.">GetTargetPath()</a></code> return cached results, <code><a class="el" href="class_sdf_path.html#a3c38dfddbe1085125aec26c846354bb1" title="Returns an ascii representation of the &quot;terminal&quot; element of this path, which can be used to reconstr...">GetElementString()</a></code> always performs some amount of string manipulation, which you should keep in mind if performance is a concern. </p>

</div>
</div>
<a id="a7b2f4362056e115b7c17b1a904aecf2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2f4362056e115b7c17b1a904aecf2b">&#9670;&nbsp;</a></span>GetElementToken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_tf_token.html">TfToken</a> GetElementToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="class_sdf_path.html#a3c38dfddbe1085125aec26c846354bb1" title="Returns an ascii representation of the &quot;terminal&quot; element of this path, which can be used to reconstr...">GetElementString()</a> but return the value as a <a class="el" href="class_tf_token.html" title="Token for efficient comparison, assignment, and hashing of known strings.">TfToken</a>. </p>

</div>
</div>
<a id="a204344d110d2bb74928f43d2c1fe0047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204344d110d2bb74928f43d2c1fe0047">&#9670;&nbsp;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API const std::string&amp; GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the prim, property or relational attribute identified by the path. </p>
<p>Returns EmptyPath if this path is a target or mapper path.</p>
<ul>
<li>
Returns "" for EmptyPath. </li>
<li>
Returns "." for ReflexiveRelativePath. </li>
<li>
Returns ".." for a path ending in ParentPathElement. </li>
</ul>

</div>
</div>
<a id="ab88a596e6ffdba5f0841e3eba451753e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88a596e6ffdba5f0841e3eba451753e">&#9670;&nbsp;</a></span>GetNameToken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API const <a class="el" href="class_tf_token.html">TfToken</a>&amp; GetNameToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the prim, property or relational attribute identified by the path, as a token. </p>

</div>
</div>
<a id="a0da79e196526d8f2e9bfd075e36e505f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da79e196526d8f2e9bfd075e36e505f">&#9670;&nbsp;</a></span>GetParentPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> GetParentPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the path that identifies this path's namespace parent. </p>
<p>For a prim path (like '/foo/bar'), return the prim's parent's path ('/foo'). For a prim property path (like '/foo/bar.property'), return the prim's path ('/foo/bar'). For a target path (like '/foo/bar.property[/target]') return the property path ('/foo/bar.property'). For a mapper path (like '/foo/bar.property.mapper[/target]') return the property path ('/foo/bar.property). For a relational attribute path (like '/foo/bar.property[/target].relAttr') return the relationship target's path ('/foo/bar.property[/target]'). For a prim variant selection path (like '/foo/bar{var=sel}') return the prim path ('/foo/bar'). For a root prim path (like '/rootPrim'), return <a class="el" href="class_sdf_path.html#a9e77b565c10268c2b55f92559f621606" title="The absolute path representing the top of the namespace hierarchy.">AbsoluteRootPath()</a> ('/'). For a single element relative prim path (like 'relativePrim'), return <a class="el" href="class_sdf_path.html#a4aff400613a556af9b180b056afde195" title="The relative path representing &quot;self&quot;.">ReflexiveRelativePath()</a> ('.'). For <a class="el" href="class_sdf_path.html#a4aff400613a556af9b180b056afde195" title="The relative path representing &quot;self&quot;.">ReflexiveRelativePath()</a>, return the relative parent path ('..').</p>
<p>Note that the parent path of a relative parent path ('..') is a relative grandparent path ('../..'). Use caution writing loops that walk to parent paths since relative paths have infinitely many ancestors. To more safely traverse ancestor paths, consider iterating over an <a class="el" href="class_sdf_path_ancestors_range.html" title="Range representing a path and ancestors, and providing methods for iterating over them.">SdfPathAncestorsRange</a> instead, as returned by <a class="el" href="class_sdf_path.html#ad4478d499efea8bb68e8cb884dd54f86" title="Return a range for iterating over the ancestors of this path.">GetAncestorsRange()</a>. </p>

</div>
</div>
<a id="a7838272dc514490d9f71c595b82137bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7838272dc514490d9f71c595b82137bb">&#9670;&nbsp;</a></span>GetPathElementCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API size_t GetPathElementCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of path elements in this path. </p>

</div>
</div>
<a id="a82108b55a93456fb23d2775d98991d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82108b55a93456fb23d2775d98991d2a">&#9670;&nbsp;</a></span>GetPrefixes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API SdfPathVector GetPrefixes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the prefix paths of this path. </p>
<p>Prefixes are returned in order of shortest to longest. The path itself is returned as the last prefix. Note that if the prefix order does not need to be from shortest to longest, it is more efficient to use GetAncestorsRange, which produces an equivalent set of paths, ordered from longest to shortest. </p>

</div>
</div>
<a id="aea81e3a0674c44ee439e8133e97827d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea81e3a0674c44ee439e8133e97827d8">&#9670;&nbsp;</a></span>GetPrefixes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API SdfPathVector GetPrefixes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numPrefixes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return up to <code>numPrefixes</code> prefix paths of this path. </p>
<p>Prefixes are returned in order of shortest to longest. The path itself is returned as the last prefix. Note that if the prefix order does not need to be from shortest to longest, it is more efficient to use GetAncestorsRange, which produces an equivalent set of paths, ordered from longest to shortest. If <code>numPrefixes</code> is 0 or greater than the number of this path's prefixes, fill all prefixes. </p>

</div>
</div>
<a id="ae2e29e31b8d905d2882cd2d321e55ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e29e31b8d905d2882cd2d321e55ab1">&#9670;&nbsp;</a></span>GetPrefixes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API void GetPrefixes </td>
          <td>(</td>
          <td class="paramtype">SdfPathVector *&#160;</td>
          <td class="paramname"><em>prefixes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills prefixes with prefixes of this path. </p>
<p>This avoids copy constructing the return value.</p>
<p>Prefixes are returned in order of shortest to longest. The path itself is returned as the last prefix. Note that if the prefix order does not need to be from shortest to longest, it is more efficient to use <a class="el" href="class_sdf_path.html#ad4478d499efea8bb68e8cb884dd54f86" title="Return a range for iterating over the ancestors of this path.">GetAncestorsRange()</a>, which produces an equivalent set of paths, ordered from longest to shortest. </p>

</div>
</div>
<a id="a85fb0d2e17cc1c09f8551f0015f9a917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fb0d2e17cc1c09f8551f0015f9a917">&#9670;&nbsp;</a></span>GetPrefixes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API void GetPrefixes </td>
          <td>(</td>
          <td class="paramtype">SdfPathVector *&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numPrefixes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill <code>prefixes</code> with up to <code>numPrefixes</code> prefixes of this path. </p>
<p>Prefixes are filled in order of shortest to longest. The path itself is included as the last prefix. Note that if the prefix order does not need to be from shortest to longest, it can be more efficient to use <a class="el" href="class_sdf_path.html#ad4478d499efea8bb68e8cb884dd54f86" title="Return a range for iterating over the ancestors of this path.">GetAncestorsRange()</a>, which produces an equivalent set of paths, ordered from longest to shortest. If <code>numPrefixes</code> is 0 or greater than the number of this path's prefixes, fill all prefixes. </p>

</div>
</div>
<a id="a16a26a7060fc6b4125f11e9afda7b468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a26a7060fc6b4125f11e9afda7b468">&#9670;&nbsp;</a></span>GetPrimOrPrimVariantSelectionPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> GetPrimOrPrimVariantSelectionPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a path by stripping all relational attributes, targets, and properties, leaving the nearest path for which <em><a class="el" href="class_sdf_path.html#ae49fb335633cf47d279894f9646440d5" title="Return true if this path is a prim path or is a prim variant selection path.">IsPrimOrPrimVariantSelectionPath()</a></em> returns true. </p>
<p>See <em>GetPrimPath</em> also.</p>
<p>If the path is already a prim or a prim variant selection path, the same path is returned. </p>

</div>
</div>
<a id="af113e66c25e4e2b1bffdf93b492e96d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af113e66c25e4e2b1bffdf93b492e96d5">&#9670;&nbsp;</a></span>GetPrimPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> GetPrimPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a path by stripping all relational attributes, targets, properties, and variant selections from the leafmost prim path, leaving the nearest path for which <em><a class="el" href="class_sdf_path.html#a93299f20b4d90532349b5105ea5bbbcb" title="Returns whether the path identifies a prim.">IsPrimPath()</a></em> returns true. </p>
<p>See <em>GetPrimOrPrimVariantSelectionPath</em> also.</p>
<p>If the path is already a prim path, the same path is returned. </p>

</div>
</div>
<a id="af4d60b0568603a696ac239b362d25417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d60b0568603a696ac239b362d25417">&#9670;&nbsp;</a></span>GetString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API const std::string&amp; GetString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the string representation of this path as a std::string. </p>
<p>This function returns a persistent lvalue. If an rvalue will suffice, call <a class="el" href="class_sdf_path.html#afbe23cf9d5aeee3f03004e968c545753" title="Return the string representation of this path as a std::string.">GetAsString()</a> instead. That avoids populating internal data structures to hold the persistent string.</p>
<p>This function is recommended only for human-readable or diagnostic output. Use the <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> API to manipulate paths. It is less error-prone and has better performance. </p>

</div>
</div>
<a id="a8ad00f48495e2e6bbfb3485920696e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad00f48495e2e6bbfb3485920696e71">&#9670;&nbsp;</a></span>GetTargetPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API const <a class="el" href="class_sdf_path.html">SdfPath</a>&amp; GetTargetPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the relational attribute or mapper target path for this path. </p>
<p>Returns EmptyPath if this is not a target, relational attribute or mapper path.</p>
<p>Note that it is possible for a path to have multiple "target" paths. For example a path that identifies a connection target for a relational attribute includes the target of the connection as well as the target of the relational attribute. In these cases, the "deepest" or right-most target path will be returned (the connection target in this example). </p>

</div>
</div>
<a id="a31225e07892b847e3e98473f7f04dbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31225e07892b847e3e98473f7f04dbf4">&#9670;&nbsp;</a></span>GetText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API const char* GetText </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the string representation of this path as a c string. </p>
<p>This function returns a pointer to a persistent c string. If a temporary c string will suffice, call <a class="el" href="class_sdf_path.html#afbe23cf9d5aeee3f03004e968c545753" title="Return the string representation of this path as a std::string.">GetAsString()</a>.c_str() instead. That avoids populating internal data structures to hold the persistent string.</p>
<p>This function is recommended only for human-readable or diagnostic output. Use the <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> API to manipulate paths. It is less error-prone and has better performance. </p>

</div>
</div>
<a id="a36bf22c483e7f514107851f9c8faaceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bf22c483e7f514107851f9c8faaceb">&#9670;&nbsp;</a></span>GetToken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_tf_token.html">TfToken</a> const&amp; GetToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the string representation of this path as a <a class="el" href="class_tf_token.html" title="Token for efficient comparison, assignment, and hashing of known strings.">TfToken</a> lvalue. </p>
<p>This function returns a persistent lvalue. If an rvalue will suffice, call <a class="el" href="class_sdf_path.html#a7f1e5284da36a816af8fb44cd4e178a0" title="Return the string representation of this path as a TfToken.">GetAsToken()</a> instead. That avoids populating internal data structures to hold the persistent token.</p>
<p>This function is recommended only for human-readable or diagnostic output. Use the <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> API to manipulate paths. It is less error-prone and has better performance. </p>

</div>
</div>
<a id="ace0604a5a83af57bbda444963431c8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0604a5a83af57bbda444963431c8c5">&#9670;&nbsp;</a></span>GetVariantSelection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API std::pair&lt;std::string, std::string&gt; GetVariantSelection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the variant selection for this path, if this is a variant selection path. </p>
<p>Returns a pair of empty strings if this path is not a variant selection path. </p>

</div>
</div>
<a id="a6ec718687c3ab1ca71f459fd6af46c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec718687c3ab1ca71f459fd6af46c8b">&#9670;&nbsp;</a></span>HasPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool HasPrefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if both this path and <em>prefix</em> are not the empty path and this path has <em>prefix</em> as a prefix. </p>
<p>Return false otherwise. </p>

</div>
</div>
<a id="a458ea9a47c7b224c0d496e4a12e0e659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458ea9a47c7b224c0d496e4a12e0e659">&#9670;&nbsp;</a></span>IsAbsolutePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsAbsolutePath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the path is absolute. </p>

</div>
</div>
<a id="a277dfdde9ab5121eb82dab94353d6667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277dfdde9ab5121eb82dab94353d6667">&#9670;&nbsp;</a></span>IsAbsoluteRootOrPrimPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsAbsoluteRootOrPrimPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the path identifies a prim or the absolute root. </p>

</div>
</div>
<a id="ad158c53ee477c4f2d7acba3cd12452d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad158c53ee477c4f2d7acba3cd12452d2">&#9670;&nbsp;</a></span>IsAbsoluteRootPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsAbsoluteRootPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this path is the <a class="el" href="class_sdf_path.html#a9e77b565c10268c2b55f92559f621606" title="The absolute path representing the top of the namespace hierarchy.">AbsoluteRootPath()</a>. </p>

</div>
</div>
<a id="a43a51a0b54bb8a19b68ff5f09d861b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a51a0b54bb8a19b68ff5f09d861b3d">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this is the empty path (<a class="el" href="class_sdf_path.html#aa3aa772925347d882bf8d68219e086c9" title="The empty path value, equivalent to SdfPath().">SdfPath::EmptyPath()</a>). </p>

<p class="definition">Definition at line <a class="el" href="path_8h_source.html#l00423">423</a> of file <a class="el" href="path_8h_source.html">path.h</a>.</p>

</div>
</div>
<a id="a970e60a5288c37534d15f2ededffcc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970e60a5288c37534d15f2ededffcc18">&#9670;&nbsp;</a></span>IsExpressionPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsExpressionPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the path identifies a connection expression. </p>

</div>
</div>
<a id="a20ad6f88fd54e3b4f273d78fd67fa2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ad6f88fd54e3b4f273d78fd67fa2d3">&#9670;&nbsp;</a></span>IsMapperArgPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsMapperArgPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the path identifies a connection mapper arg. </p>

</div>
</div>
<a id="abdb96290e258748826ef4d4f32910dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb96290e258748826ef4d4f32910dbb">&#9670;&nbsp;</a></span>IsMapperPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsMapperPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the path identifies a connection mapper. </p>

</div>
</div>
<a id="a9bafb2c3e04cd0ff6d2ca2a64e2d4d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bafb2c3e04cd0ff6d2ca2a64e2d4d42">&#9670;&nbsp;</a></span>IsNamespacedPropertyPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsNamespacedPropertyPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the path identifies a namespaced property. </p>
<p>A namespaced property has colon embedded in its name. </p>

</div>
</div>
<a id="ae49fb335633cf47d279894f9646440d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49fb335633cf47d279894f9646440d5">&#9670;&nbsp;</a></span>IsPrimOrPrimVariantSelectionPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsPrimOrPrimVariantSelectionPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this path is a prim path or is a prim variant selection path. </p>

</div>
</div>
<a id="a93299f20b4d90532349b5105ea5bbbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93299f20b4d90532349b5105ea5bbbcb">&#9670;&nbsp;</a></span>IsPrimPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsPrimPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the path identifies a prim. </p>

</div>
</div>
<a id="adb3bbcc350fc138c737f8c18d99e8456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3bbcc350fc138c737f8c18d99e8456">&#9670;&nbsp;</a></span>IsPrimPropertyPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsPrimPropertyPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the path identifies a prim's property. </p>
<p>A relational attribute is not a prim property. </p>

</div>
</div>
<a id="a10ba3395e4c97b5ea922bdb03ec2e686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ba3395e4c97b5ea922bdb03ec2e686">&#9670;&nbsp;</a></span>IsPrimVariantSelectionPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsPrimVariantSelectionPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the path identifies a variant selection for a prim. </p>

</div>
</div>
<a id="a69ed1464cbdb872743a6b9a86de74907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ed1464cbdb872743a6b9a86de74907">&#9670;&nbsp;</a></span>IsPropertyPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsPropertyPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the path identifies a property. </p>
<p>A relational attribute is considered to be a property, so this method will return true for relational attributes as well as properties of prims. </p>

</div>
</div>
<a id="a215275ea9c7e897be090b5328359cfb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215275ea9c7e897be090b5328359cfb5">&#9670;&nbsp;</a></span>IsRelationalAttributePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsRelationalAttributePath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the path identifies a relational attribute. </p>
<p>If this is true, <a class="el" href="class_sdf_path.html#a69ed1464cbdb872743a6b9a86de74907" title="Returns whether the path identifies a property.">IsPropertyPath()</a> will also be true. </p>

</div>
</div>
<a id="a8bcc5731c01942e64dcf6fa235bcf9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcc5731c01942e64dcf6fa235bcf9ed">&#9670;&nbsp;</a></span>IsRootPrimPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsRootPrimPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the path identifies a root prim. </p>
<p>the path must be absolute and have a single element (for example <code>/foo</code>). </p>

</div>
</div>
<a id="a73d804883fcdf1198ea831515e39232e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d804883fcdf1198ea831515e39232e">&#9670;&nbsp;</a></span>IsTargetPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API bool IsTargetPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the path identifies a relationship or connection target. </p>

</div>
</div>
<a id="a1499271167c20dd276d87693b18f5226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1499271167c20dd276d87693b18f5226">&#9670;&nbsp;</a></span>IsValidIdentifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API bool IsValidIdentifier </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether <code>name</code> is a legal identifier for any path component. </p>

</div>
</div>
<a id="a8c66a8d5eadec9b49cd9a5f32747834e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c66a8d5eadec9b49cd9a5f32747834e">&#9670;&nbsp;</a></span>IsValidNamespacedIdentifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API bool IsValidNamespacedIdentifier </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether <code>name</code> is a legal namespaced identifier. </p>
<p>This returns <code>true</code> if <a class="el" href="class_sdf_path.html#a1499271167c20dd276d87693b18f5226" title="Returns whether name is a legal identifier for any path component.">IsValidIdentifier()</a> does. </p>

</div>
</div>
<a id="acec9f4ce12ac98cb7d365646bb0bf35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec9f4ce12ac98cb7d365646bb0bf35b">&#9670;&nbsp;</a></span>IsValidPathString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API bool IsValidPathString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errMsg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <code>pathString</code> is a valid path string, meaning that passing the string to the <em><a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a></em> constructor will result in a valid, non-empty <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a>. </p>
<p>Otherwise, return false and if <code>errMsg</code> is not NULL, set the pointed-to string to the parse error. </p>

</div>
</div>
<a id="a71ebddbfd0d0d176f98abd7e666689d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ebddbfd0d0d176f98abd7e666689d5">&#9670;&nbsp;</a></span>JoinIdentifier() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API std::string JoinIdentifier </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join <code>names</code> into a single identifier using the namespace delimiter. </p>
<p>Any empty strings present in <code>names</code> are ignored when joining. </p>

</div>
</div>
<a id="a13c0fac9fc1ee9719e692d1ab9df5805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c0fac9fc1ee9719e692d1ab9df5805">&#9670;&nbsp;</a></span>JoinIdentifier() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API std::string JoinIdentifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a> &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join <code>names</code> into a single identifier using the namespace delimiter. </p>
<p>Any empty strings present in <code>names</code> are ignored when joining. </p>

</div>
</div>
<a id="a5d8b3131c82ff6f09c7a265258830e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8b3131c82ff6f09c7a265258830e59">&#9670;&nbsp;</a></span>JoinIdentifier() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API std::string JoinIdentifier </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join <code>lhs</code> and <code>rhs</code> into a single identifier using the namespace delimiter. </p>
<p>Returns <code>lhs</code> if <code>rhs</code> is empty and vice verse. Returns an empty string if both <code>lhs</code> and <code>rhs</code> are empty. </p>

</div>
</div>
<a id="acb024f403d4b8c49c7a5e66d221c524e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb024f403d4b8c49c7a5e66d221c524e">&#9670;&nbsp;</a></span>JoinIdentifier() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API std::string JoinIdentifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join <code>lhs</code> and <code>rhs</code> into a single identifier using the namespace delimiter. </p>
<p>Returns <code>lhs</code> if <code>rhs</code> is empty and vice verse. Returns an empty string if both <code>lhs</code> and <code>rhs</code> are empty. </p>

</div>
</div>
<a id="a057a39843c10795ce68c27d86639db55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057a39843c10795ce68c27d86639db55">&#9670;&nbsp;</a></span>MakeAbsolutePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> MakeAbsolutePath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>anchor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the absolute form of this path using <code>anchor</code> as the relative basis. </p>
<p><code>anchor</code> must be an absolute prim path.</p>
<p>If this path is a relative path, resolve it using <code>anchor</code> as the relative basis.</p>
<p>If this path is already an absolute path, just return a copy. </p>

</div>
</div>
<a id="a4e9d4d7cc1c40ae2b35a69e32d6f0abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9d4d7cc1c40ae2b35a69e32d6f0abb">&#9670;&nbsp;</a></span>MakeRelativePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> MakeRelativePath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>anchor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the relative form of this path using <code>anchor</code> as the relative basis. </p>
<p><code>anchor</code> must be an absolute prim path.</p>
<p>If this path is an absolute path, return the corresponding relative path that is relative to the absolute path given by <code>anchor</code>.</p>
<p>If this path is a relative path, return the optimal relative path to the absolute path given by <code>anchor</code>. (The optimal relative path from a given prim path is the relative path with the least leading dot-dots. </p>

</div>
</div>
<a id="afb7f17c2d6a7a53528c62158ce9ad335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7f17c2d6a7a53528c62158ce9ad335">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>

<p class="definition">Definition at line <a class="el" href="path_8h_source.html#l00913">913</a> of file <a class="el" href="path_8h_source.html">path.h</a>.</p>

</div>
</div>
<a id="aad310c9d17d03812d810bf4e4edf3fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad310c9d17d03812d810bf4e4edf3fb9">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>This orders paths lexicographically, aka dictionary-style. </p>

<p class="definition">Definition at line <a class="el" href="path_8h_source.html#l00921">921</a> of file <a class="el" href="path_8h_source.html">path.h</a>.</p>

</div>
</div>
<a id="a3016b02123ca74bab194219ec9227bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3016b02123ca74bab194219ec9227bf2">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than or equal operator. </p>
<dl class="section see"><dt>See also</dt><dd>SdfPath::operator&lt;(const SdfPath&amp;) </dd></dl>

<p class="definition">Definition at line <a class="el" href="path_8h_source.html#l00940">940</a> of file <a class="el" href="path_8h_source.html">path.h</a>.</p>

</div>
</div>
<a id="ad405c341013019fb6b9aaa90aa2598a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad405c341013019fb6b9aaa90aa2598a1">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>

<p class="definition">Definition at line <a class="el" href="path_8h_source.html#l00908">908</a> of file <a class="el" href="path_8h_source.html">path.h</a>.</p>

</div>
</div>
<a id="a57aa0abebf5481d6ffa80b2483b2bb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57aa0abebf5481d6ffa80b2483b2bb8a">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than operator. </p>
<dl class="section see"><dt>See also</dt><dd>SdfPath::operator&lt;(const SdfPath&amp;) </dd></dl>

<p class="definition">Definition at line <a class="el" href="path_8h_source.html#l00934">934</a> of file <a class="el" href="path_8h_source.html">path.h</a>.</p>

</div>
</div>
<a id="aae48d25dda744ff6efaf3c363588bb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae48d25dda744ff6efaf3c363588bb8d">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than or equal operator. </p>
<dl class="section see"><dt>See also</dt><dd>SdfPath::operator&lt;(const SdfPath&amp;) </dd></dl>

<p class="definition">Definition at line <a class="el" href="path_8h_source.html#l00946">946</a> of file <a class="el" href="path_8h_source.html">path.h</a>.</p>

</div>
</div>
<a id="a4aff400613a556af9b180b056afde195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aff400613a556af9b180b056afde195">&#9670;&nbsp;</a></span>ReflexiveRelativePath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API const <a class="el" href="class_sdf_path.html">SdfPath</a>&amp; ReflexiveRelativePath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The relative path representing "self". </p>

</div>
</div>
<a id="af31641f36475586915e1317aa87818f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31641f36475586915e1317aa87818f6">&#9670;&nbsp;</a></span>RemoveAncestorPaths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API void RemoveAncestorPaths </td>
          <td>(</td>
          <td class="paramtype">SdfPathVector *&#160;</td>
          <td class="paramname"><em>paths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all elements of <em>paths</em> that prefix other elements in <em>paths</em>. </p>
<p>As a side-effect, the result is left in sorted order. </p>

</div>
</div>
<a id="a5188047700bc4b8a6786960b7788abd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5188047700bc4b8a6786960b7788abd7">&#9670;&nbsp;</a></span>RemoveCommonSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API std::pair&lt;<a class="el" href="class_sdf_path.html">SdfPath</a>, <a class="el" href="class_sdf_path.html">SdfPath</a>&gt; RemoveCommonSuffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>otherPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtRootPrim</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find and remove the longest common suffix from two paths. </p>
<p>Returns this path and <code>otherPath</code> with the longest common suffix removed (first and second, respectively). If the two paths have no common suffix then the paths are returned as-is. If the paths are equal then this returns empty paths for relative paths and absolute roots for absolute paths. The paths need not be the same length.</p>
<p>If <code>stopAtRootPrim</code> is <code>true</code> then neither returned path will be the root path. That, in turn, means that some common suffixes will not be removed. For example, if <code>stopAtRootPrim</code> is <code>true</code> then the paths /A/B and /B will be returned as is. Were it <code>false</code> then the result would be /A and /. Similarly paths /A/B/C and /B/C would return /A/B and /B if <code>stopAtRootPrim</code> is <code>true</code> but /A and / if it's <code>false</code>. </p>

</div>
</div>
<a id="ac1fcc9c525284def3fc2315b343e3b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fcc9c525284def3fc2315b343e3b91">&#9670;&nbsp;</a></span>RemoveDescendentPaths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API void RemoveDescendentPaths </td>
          <td>(</td>
          <td class="paramtype">SdfPathVector *&#160;</td>
          <td class="paramname"><em>paths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all elements of <em>paths</em> that are prefixed by other elements in <em>paths</em>. </p>
<p>As a side-effect, the result is left in sorted order. </p>

</div>
</div>
<a id="ae01eff387b47bcf63459826038b3f833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01eff387b47bcf63459826038b3f833">&#9670;&nbsp;</a></span>ReplaceName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> ReplaceName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_token.html">TfToken</a> const &amp;&#160;</td>
          <td class="paramname"><em>newName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of this path with its final component changed to <em>newName</em>. </p>
<p>This path must be a prim or property path.</p>
<p>This method is shorthand for path.GetParentPath().AppendChild(newName) for prim paths, path.GetParentPath().AppendProperty(newName) for prim property paths, and path.GetParentPath().AppendRelationalAttribute(newName) for relational attribute paths.</p>
<p>Note that only the final path component is ever changed. If the name of the final path component appears elsewhere in the path, it will not be modified.</p>
<p>Some examples:</p>
<p>ReplaceName('/chars/MeridaGroup', 'AngusGroup') -&gt; '/chars/AngusGroup' ReplaceName('/Merida.tx', 'ty') -&gt; '/Merida.ty' ReplaceName('/Merida.tx[targ].tx', 'ty') -&gt; '/Merida.tx[targ].ty' </p>

</div>
</div>
<a id="acecb0aa28f9acd0f113c6c52d0ea3b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecb0aa28f9acd0f113c6c52d0ea3b82">&#9670;&nbsp;</a></span>ReplacePrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> ReplacePrefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>oldPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>newPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fixTargetPaths</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a path with all occurrences of the prefix path <code>oldPrefix</code> replaced with the prefix path <code>newPrefix</code>. </p>
<p>If fixTargetPaths is true, any embedded target paths will also have their paths replaced. This is the default.</p>
<p>If this is not a target, relational attribute or mapper path this will do zero or one path prefix replacements, if not the number of replacements can be greater than one. </p>

</div>
</div>
<a id="a1592d4f22c0608188059400d91c56113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1592d4f22c0608188059400d91c56113">&#9670;&nbsp;</a></span>ReplaceTargetPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> ReplaceTargetPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>newTargetPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the relational attribute's target path. </p>
<p>The path must be a relational attribute path. </p>

</div>
</div>
<a id="adc29d6c107a54135f0609c723c1f7bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc29d6c107a54135f0609c723c1f7bdc">&#9670;&nbsp;</a></span>StripAllVariantSelections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDF_API <a class="el" href="class_sdf_path.html">SdfPath</a> StripAllVariantSelections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a path by stripping all variant selections from all components of this path, leaving a path with no embedded variant selections. </p>

</div>
</div>
<a id="a8230082d270b014bf412407fe9a526d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8230082d270b014bf412407fe9a526d0">&#9670;&nbsp;</a></span>StripNamespace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API std::string StripNamespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>name</code> stripped of any namespaces. </p>
<p>This does not check the validity of the name; it just attempts to remove anything that looks like a namespace. </p>

</div>
</div>
<a id="a221902d3b503ca633b9f2ebf550afb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221902d3b503ca633b9f2ebf550afb62">&#9670;&nbsp;</a></span>StripNamespace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API <a class="el" href="class_tf_token.html">TfToken</a> StripNamespace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>name</code> stripped of any namespaces. </p>
<p>This does not check the validity of the name; it just attempts to remove anything that looks like a namespace. </p>

</div>
</div>
<a id="a841e3e96d81ff509d8f45259d8cd7ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841e3e96d81ff509d8f45259d8cd7ae1">&#9670;&nbsp;</a></span>StripPrefixNamespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API std::pair&lt;std::string, bool&gt; StripPrefixNamespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>matchNamespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns (<code>name</code>, <code>true</code>) where <code>name</code> is stripped of the prefix specified by <code>matchNamespace</code> if <code>name</code> indeed starts with <code>matchNamespace</code>. </p>
<p>Returns (<code>name</code>, <code>false</code>) otherwise, with <code>name</code> unmodified.</p>
<p>This function deals with both the case where <code>matchNamespace</code> contains the trailing namespace delimiter ':' or not. </p>

</div>
</div>
<a id="ace29b426c1003c910ee565250e4519a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace29b426c1003c910ee565250e4519a6">&#9670;&nbsp;</a></span>TokenizeIdentifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API std::vector&lt;std::string&gt; TokenizeIdentifier </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tokenizes <code>name</code> by the namespace delimiter. </p>
<p>Returns the empty vector if <code>name</code> is not a valid namespaced identifier. </p>

</div>
</div>
<a id="a885403f9808560bb1e3611130d9e61e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885403f9808560bb1e3611130d9e61e8">&#9670;&nbsp;</a></span>TokenizeIdentifierAsTokens()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SDF_API <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a> TokenizeIdentifierAsTokens </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tokenizes <code>name</code> by the namespace delimiter. </p>
<p>Returns the empty vector if <code>name</code> is not a valid namespaced identifier. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pxr/usd/sdf/<a class="el" href="path_8h_source.html">path.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_sdf_path.html">SdfPath</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:04 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>