<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: Dynamic File Formats</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_usd__page__dynamic_file_format.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Dynamic File Formats </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Usd_DynamicFileFormat_Overview"></a>
Overview</h1>
<p>A dynamic file format is an <a class="el" href="class_sdf_file_format.html" title="Base class for file format implementations.">SdfFileFormat</a> that allows the contents of its layers to be generated dynamically, when <a class="el" href="_usd__page__dynamic_file_format.html#Usd_DynamicFileFormat_DynamicPayloads">included as a payload</a>, within the context of the prim in which it is included. This feature relies on the fact that all layer file paths can optionally have file format arguments that are appended to the layer asset path and are passed to the file format when the layer is opened and read (see <a class="el" href="class_sdf_layer.html#a0193260dcb2b4dec6be9d39e4daefea7" title="Returns the file format-specific arguments used during the construction of this layer.">SdfLayer::GetFileFormatArguments</a>, <a class="el" href="class_sdf_layer.html#a945800f72e30b5b425b26a4ee6f46ffc" title="Joins the given layer path and arguments into an identifier.">SdfLayer::CreateIdentifier</a>, <a class="el" href="class_sdf_layer.html#a3d1926f596211786a3f0b2b2a234257c" title="Splits the given layer identifier into its constituent layer path and arguments.">SdfLayer::SplitIdentifier</a>). Any file format can use these arguments to guide how it will translate the contents of the referenced data file into a valid USD layer. What makes a <em>dynamic</em> file format unique is that it is able to <b>compose values of prim fields or attribute defaults</b> to generate the file format arguments within the context where the layer will be included. When the values of any of the composed fields or attribute defaults change, the prim automatically regenerates the file format arguments and creates new layer contents.</p>
<h1><a class="anchor" id="Usd_DynamicFileFormat_Creation"></a>
Creating a Dynamic File Format</h1>
<p>To create a dynamic file format, we first create a plugin library that implements a new derived subclass of <a class="el" href="class_sdf_file_format.html" title="Base class for file format implementations.">SdfFileFormat</a>, just like we would for any other custom file format, and add the type to the library's pluginInfo.json.</p>
<p>For an example in this document, we'll start with a new file format, MyDynamicFileFormat:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyDynamicFileFormat : <span class="keyword">public</span> <a class="code" href="class_sdf_file_format.html">SdfFileFormat</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Required SdfFileFormat overrides.</span></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="class_sdf_file_format.html#afa76b34e13314ffaf726f4799d4161ae">CanRead</a>(<span class="keyword">const</span> std::string &amp;file) <span class="keyword">const override</span>;</div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="class_sdf_file_format.html#a8621e64c229386ea8e743faaf3f34d68">Read</a>(<a class="code" href="class_sdf_layer.html">SdfLayer</a> *layer,</div><div class="line">              <span class="keyword">const</span> std::string&amp; resolvedPath,</div><div class="line">              <span class="keywordtype">bool</span> metadataOnly) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <a class="code" href="file_format_8h.html#ab7556e2290d5075582c4aa84ad9d5ee5">SDF_FILE_FORMAT_FACTORY_ACCESS</a>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> ~MyDynamicFileFormat();</div><div class="line">    MyDynamicFileFormat() : </div><div class="line">        <a class="code" href="class_sdf_file_format.html">SdfFileFormat</a>(</div><div class="line">            <a class="code" href="class_tf_token.html">TfToken</a>(<span class="stringliteral">&quot;MyDynamicFileFormat&quot;</span>), <span class="comment">// formatId</span></div><div class="line">            <a class="code" href="class_tf_token.html">TfToken</a>(<span class="stringliteral">&quot;1.0&quot;</span>), <span class="comment">// versionString</span></div><div class="line">            <a class="code" href="class_tf_token.html">TfToken</a>(<span class="stringliteral">&quot;usd&quot;</span>), <span class="comment">// target</span></div><div class="line">            <span class="stringliteral">&quot;mydynamicfile&quot;</span>) <span class="comment">// extension</span></div><div class="line">    {}</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">### plugInfo.json</span></div><div class="line"></div><div class="line">{</div><div class="line">    <span class="stringliteral">&quot;Plugins&quot;</span>: [</div><div class="line">        {</div><div class="line">            <span class="stringliteral">&quot;Info&quot;</span>: {</div><div class="line">                <span class="stringliteral">&quot;Types&quot;</span>: {</div><div class="line">                    <span class="stringliteral">&quot;MyDynamicFileFormat&quot;</span>: {</div><div class="line">                        <span class="stringliteral">&quot;bases&quot;</span>: [</div><div class="line">                            <span class="stringliteral">&quot;SdfFileFormat&quot;</span></div><div class="line">                        ],</div><div class="line">                        <span class="stringliteral">&quot;displayName&quot;</span>: <span class="stringliteral">&quot;Dynamic File Format&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;extensions&quot;</span>: [</div><div class="line">                            <span class="stringliteral">&quot;mydynamicfile&quot;</span></div><div class="line">                        ],</div><div class="line">                        <span class="stringliteral">&quot;formatId&quot;</span>: <span class="stringliteral">&quot;MyDynamicFileFormat&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;primary&quot;</span>: <span class="keyword">true</span>,</div><div class="line">                        <span class="stringliteral">&quot;target&quot;</span>: <span class="stringliteral">&quot;usd&quot;</span></div><div class="line">                    }</div><div class="line">                }</div><div class="line">            },</div><div class="line">            <span class="stringliteral">&quot;LibraryPath&quot;</span>: <span class="stringliteral">&quot;@PLUG_INFO_LIBRARY_PATH@&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;Name&quot;</span>: <span class="stringliteral">&quot;myDynamicFileFormat&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;ResourcePath&quot;</span>: <span class="stringliteral">&quot;@PLUG_INFO_RESOURCE_PATH@&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;Root&quot;</span>: <span class="stringliteral">&quot;@PLUG_INFO_ROOT@&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;Type&quot;</span>: <span class="stringliteral">&quot;library&quot;</span></div><div class="line">        }</div><div class="line">    ]</div><div class="line">}</div></div><!-- fragment --><p>An essential piece of implementing a dynamic file format, that will not be covered in depth here, is using file format arguments that can be appended to the layer's file path to generate or alter some portion of the contents of the layer when the file is read. This can be done by using the file format arguments in the implementation of the Read function or, in the case of a fully procedural layer, creating a custom subclass of <a class="el" href="class_sdf_abstract_data.html" title="Interface for scene description data storage.">SdfAbstractData</a> that utilizes the arguments. The file format arguments are also part of the identity of the layer, meaning layers opened with the same asset path but different arguments are opened as separate layers. Refer to the included <a class="el" href="_usd__page__dynamic_file_format.html#Usd_DynamicFileFormat_Examples">examples</a> for detailed methods of creating dynamic content.</p>
<p>Assume that for this example we wrote the implementation of MyDynamicFileFormat::Read to use <a class="el" href="class_sdf_layer.html#a0193260dcb2b4dec6be9d39e4daefea7" title="Returns the file format-specific arguments used during the construction of this layer.">SdfLayer::GetFileFormatArguments</a> to get the file format arguments from the asset path of the <code>layer</code> it is reading (these would be the same <code>args</code> that are passed to <a class="el" href="class_sdf_layer.html#aa01062bf4dde3f28c1fc617a1acaf35e" title="Return an existing layer with the given identifier and args, or else load it.">SdfLayer::FindOrOpen</a> when the layer is opened). Also assume our Read function uses the values of the arguments <em>dynamicName</em> and <em>isPositive</em> to alter the contents of the <code>layer</code>.</p>
<p>Now to make this file format dynamic, we must also have this class derive from <a class="el" href="class_pcp_dynamic_file_format_interface.html" title="Interface mixin that can be included by SdfFileFormat subclasses to enable dynamic file format argume...">PcpDynamicFileFormatInterface</a> and implement ComposeFieldsForFileFormatArguments, and optionally implement CanFieldChangeAffectFileFormatArguments and/or CanAttributeDefaultValueChangeAffectFileFormatArguments.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyDynamicFileFormat : </div><div class="line">    <span class="keyword">public</span> <a class="code" href="class_sdf_file_format.html">SdfFileFormat</a>, <span class="keyword">public</span> <a class="code" href="class_pcp_dynamic_file_format_interface.html">PcpDynamicFileFormatInterface</a></div><div class="line">{</div><div class="line">    ...</div><div class="line"></div><div class="line">public:</div><div class="line">    <span class="comment">// Required PcpDynamicFileFormatInterface overrides</span></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="class_pcp_dynamic_file_format_interface.html#a4af0bb04b1f5f6e5f708ee07892fb090">ComposeFieldsForFileFormatArguments</a>(</div><div class="line">        <span class="keyword">const</span> std::string&amp; assetPath, </div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_pcp_dynamic_file_format_context.html">PcpDynamicFileFormatContext</a>&amp; context,</div><div class="line">        FileFormatArguments* args,</div><div class="line">        <a class="code" href="class_vt_value.html">VtValue</a> *dependencyContextData) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Optional overrides</span></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="class_pcp_dynamic_file_format_interface.html#a1a8d904695c0922ff74507d0afd1df8f">CanFieldChangeAffectFileFormatArguments</a>(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_tf_token.html">TfToken</a>&amp; field,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_vt_value.html">VtValue</a>&amp; oldValue,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_vt_value.html">VtValue</a>&amp; newValue,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_vt_value.html">VtValue</a> &amp;dependencyContextData) <span class="keyword">const override</span>;</div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="class_pcp_dynamic_file_format_interface.html#aa3776801ea8378314a2e94a238bbd6f5">CanAttributeDefaultValueChangeAffectFileFormatArguments</a>(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_tf_token.html">TfToken</a> &amp;attributeName,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_vt_value.html">VtValue</a> &amp;oldValue,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_vt_value.html">VtValue</a> &amp;newValue,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_vt_value.html">VtValue</a> &amp;dependencyContextData) <span class="keyword">const override</span>;        </div><div class="line"></div><div class="line">   ...</div><div class="line">}</div></div><!-- fragment --><p>The default implementation of CanFieldChangeAffectFileFormatArguments returns true, indicating that any value change for a passed in field will require file format arguments to be recomputed. Derived classes should override this function if there are scenarios where field value changes do not need to recompute arguments. This will reduce the number of unnecessary recompositions of dynamic payloads. See <a class="el" href="_usd__page__dynamic_file_format.html#Usd_DynamicFileFormat_ChangeManagement">Dependencies and Change Management</a> for an explanation of how this function is used and implemented.</p>
<p>The default implementation of CanAttributeDefaultValueChangeAffectFileFormatArguments also returns true. This method is similar in concept to CanFieldChangeAffectFileFormatArguments, but used for situations where changes to an attribute's default value will require recomputing file format arguments. Derived classes should override this function if there are scenarios where attribute default changes do not need to recompute arguments.</p>
<p>Now, because this file format implements <a class="el" href="class_pcp_dynamic_file_format_interface.html" title="Interface mixin that can be included by SdfFileFormat subclasses to enable dynamic file format argume...">PcpDynamicFileFormatInterface</a>, <a class="el" href="class_pcp_dynamic_file_format_interface.html#a4af0bb04b1f5f6e5f708ee07892fb090">ComposeFieldsForFileFormatArguments</a> will be called while composing the prim whenever a prim spec includes a payload to a file with the extension ".mydynamicfile". This is called before the file is opened to generate additional file format arguments that will be added to the file asset path. The function can use the given <a class="el" href="class_pcp_dynamic_file_format_context.html" title="Context object for the current state of a prim index that is being built that allows implementations ...">PcpDynamicFileFormatContext</a> to compose the value of the strongest opinion of a field or attribute default on the prim being indexed at the point in which the payload is being included. Currently the only metadata fields that are allowed to be evaluated by the context are</p>
<p>defined plugin metadata fields, so we'll have to define the fields we plan to use in our plugInfo.json. This restriction may be lifted in the future to include builtin fields like <em>variantSelection</em> but for now those fields cannot be used. The context can also be used to evaluate attribute defaults, as described in <a class="el" href="_usd__page__dynamic_file_format.html#Usd_DynamicFileFormat_Attributes">Using Attributes To Compute Arguments</a>.</p>
<p>So, in our example plugInfo.json, we'll also define some new SdfMetadata fields, <em>dynamicName</em> and <em>dynamicNumber</em> that we can use to compute file format arguments:</p>
<div class="fragment"><div class="line"><span class="preprocessor">### plugInfo.json</span></div><div class="line"></div><div class="line">{</div><div class="line">    <span class="stringliteral">&quot;Plugins&quot;</span>: [</div><div class="line">        {</div><div class="line">            <span class="stringliteral">&quot;Info&quot;</span>: {</div><div class="line">                <span class="stringliteral">&quot;SdfMetadata&quot;</span>: {</div><div class="line">                    <span class="stringliteral">&quot;dynamicName&quot;</span>: {</div><div class="line">                        <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;string&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;default&quot;</span>: <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;displayGroup&quot;</span>: <span class="stringliteral">&quot;Core&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;appliesTo&quot;</span>: [<span class="stringliteral">&quot;prims&quot;</span>],</div><div class="line">                        <span class="stringliteral">&quot;documentation:&quot;</span>: <span class="stringliteral">&quot;Example custom string metadata.&quot;</span></div><div class="line">                    },</div><div class="line">                    <span class="stringliteral">&quot;dynamicNumber&quot;</span>: {</div><div class="line">                        <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;int&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;default&quot;</span>: 1,</div><div class="line">                        <span class="stringliteral">&quot;displayGroup&quot;</span>: <span class="stringliteral">&quot;Core&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;appliesTo&quot;</span>: [<span class="stringliteral">&quot;prims&quot;</span>],</div><div class="line">                        <span class="stringliteral">&quot;documentation:&quot;</span>: <span class="stringliteral">&quot;Example custom number metadata&quot;</span></div><div class="line">                    }</div><div class="line">                },</div><div class="line"></div><div class="line">                ...</div><div class="line">            },</div><div class="line"></div><div class="line">            ...</div><div class="line">        }</div><div class="line">    ]</div><div class="line">}</div></div><!-- fragment --><p>In our <a class="el" href="class_pcp_dynamic_file_format_interface.html#a4af0bb04b1f5f6e5f708ee07892fb090">ComposeFieldsForFileFormatArguments</a> implementation we'll use the <code>context</code> to compose the strongest value of the <em>dynamicName</em> and <em>dynamicNumber</em> metadata fields to generate file format arguments to add to <code>args:</code> </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyDynamicFileFormat::ComposeFieldsForFileFormatArguments(</div><div class="line">    <span class="keyword">const</span> std::string&amp; assetPath, </div><div class="line">    <span class="keyword">const</span> <a class="code" href="class_pcp_dynamic_file_format_context.html">PcpDynamicFileFormatContext</a>&amp; context,</div><div class="line">    FileFormatArguments* args,</div><div class="line">    <a class="code" href="class_vt_value.html">VtValue</a> *dependencyContextData)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="class_tf_token.html">TfToken</a> dynamicNameToken(<span class="stringliteral">&quot;dynamicName&quot;</span>);</div><div class="line">    <a class="code" href="class_vt_value.html">VtValue</a> dynamicNameValue;</div><div class="line">    <span class="keywordflow">if</span> (context.<a class="code" href="class_pcp_dynamic_file_format_context.html#a7c6232095b5a3cc0761f1ae751d12254">ComposeValue</a>(dynamicNameToken, &amp;dynamicNameValue)) {</div><div class="line">        (*args)[dynamicNameToken] = <a class="code" href="group__group__tf___string.html#ga7554a67d6bbf6eae3f12131757f13d36">TfStringify</a>(dynamicNameValue);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="class_tf_token.html">TfToken</a> dynamicNumberToken(<span class="stringliteral">&quot;dynamicNumber&quot;</span>);</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="class_tf_token.html">TfToken</a> isPositiveToken(<span class="stringliteral">&quot;isPositive&quot;</span>);</div><div class="line">    <a class="code" href="class_vt_value.html">VtValue</a> dynamicNumberValue;</div><div class="line">    <span class="keywordflow">if</span> (context.<a class="code" href="class_pcp_dynamic_file_format_context.html#a7c6232095b5a3cc0761f1ae751d12254">ComposeValue</a>(dynamicNumberToken, &amp;dynamicNumberValue)) {</div><div class="line">        <span class="keywordflow">if</span> (dynamicNumberValue.<a class="code" href="class_vt_value.html#ae5d3187e0408744ac959d6146de2f2bf">IsHolding</a>&lt;<span class="keywordtype">int</span>&gt;() &amp;&amp;</div><div class="line">            dynamicNumberValue.<a class="code" href="class_vt_value.html#a60c1f31cc358d0d74f2dcbe9b686bc80">UncheckedGet</a>&lt;<span class="keywordtype">int</span>&gt;() &gt; 0) {</div><div class="line">            (*args)[isPositiveToken] = <span class="stringliteral">&quot;true&quot;</span>;</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            (*args)[isPositiveToken] = <span class="stringliteral">&quot;false&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>For <em>dynamicName</em>, we add its computed string value into the <code>args</code> with the key <em>dynamicName</em>. However it's not necessary to always directly transpose field values into <code>args</code> using the field or attribute name as the key. For <em>dynamicNumber</em> we compute its composed value to check if it is a positive integer and write either "true" or "false" into <code>args</code> with the key <em>isPositive</em> instead.</p>
<p>For an example implementation of ComposeFieldsForFileFormatArguments that composes attribute defaults for <em>dynamicName</em> and <em>dynamicNumber</em>, see <a class="el" href="_usd__page__dynamic_file_format.html#Usd_DynamicFileFormat_Attributes">Using Attributes To Compute Arguments</a>. Note that you should avoid composing both field values and attribute defaults for computing the same file format argument in your ComposeFieldsForFileFormatArguments implementation.</p>
<p>With the plugin complete, here's how the dynamic file format would work in practice. Let's say we have the following usd file:</p>
<div class="fragment"><div class="line"><span class="preprocessor">### root.usd</span></div><div class="line"></div><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Root&quot;</span> (</div><div class="line">    references = &lt;/Params&gt;</div><div class="line">    payload = @./dynamic.mydynamicfile@</div><div class="line">)</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Params&quot;</span> (</div><div class="line">    dynamicName = <span class="stringliteral">&quot;Foo&quot;</span></div><div class="line">    dynamicNumber = 8</div><div class="line">)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p>The prim <em>Root</em> has a reference to the <em>Params</em> prim which has value opinions for the plugin fields <em>dynamicName</em> and <em>dynamicNumber</em>. <em>Root</em> also has a payload to a file with the ".mydynamicfile" extension. When the prim index is computed for <em>Root</em>, and the indexer gets to composing the payload, it will see that file format is <em>MyDynamicFileFormat</em> and it will call the format's ComposeFieldsForFileFormatArguments function to produce the file format arguments. At this point in composition, the <code>context</code> includes the reference to <em>Params</em> and will get its values for <em>dynamicName</em> and <em>dynamicNumber</em> as those fields' strongest opinions to produce the fileformat arguments: </p><ul>
<li><em>dynamicName</em> = "Foo" </li>
<li><em>isPositive</em> = "true"</li>
</ul>
<p>These args are added to the asset path of the payload layer that will be read giving the resolved layer path: <br />
<b>dynamic.mydynamicfile:SDF_FORMAT_ARGS:dynamicName=Foo:isPositive=true</b> </p>
<p>As mentioned above MyDynamicFileFormat's Read function uses these arguments to generate the identity and contents of the layer. Now say we update root.usd and add the <em>dynamicName</em> field to <em>Root</em> with the value "Bar":</p>
<div class="fragment"><div class="line"><span class="preprocessor">### root.usd</span></div><div class="line"></div><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Root&quot;</span> (</div><div class="line">    dynamicName = <span class="stringliteral">&quot;Bar&quot;</span></div><div class="line">    references = &lt;/Params&gt;</div><div class="line">    payload = @./dynamic.mydynamicfile@</div><div class="line">)</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Params&quot;</span> (</div><div class="line">    dynamicName = <span class="stringliteral">&quot;Foo&quot;</span></div><div class="line">    dynamicNumber = 8</div><div class="line">)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p>When <em>Root</em> is prim composed again, the stongest opinion for <em>dynamicName</em>, in the <code>context</code> where payload is composed, will come from <em>Root</em> giving us the file format arguments:</p>
<ul>
<li><em>dynamicName</em> = "Bar" </li>
<li><em>isPositive</em> = "true"</li>
</ul>
<p>Note that the strongest opinion for <em>dynamicNumber</em> still comes from <em>Params</em>. The resolved payload layer path is now: <br />
<b>dynamic.mydynamicfile:SDF_FORMAT_ARGS:dynamicName=Bar:isPositive=true</b> </p>
<p>We have new layer with a different identity and contents from the same payload field without changing the payload declaration itself.</p>
<h2><a class="anchor" id="Usd_DynamicFileFormat_Attributes"></a>
Using Attributes To Compute Arguments</h2>
<p>Your dynamic file format plugin can also use uniform attribute defaults instead of metadata fields to compute file format arguments. Unlike metadata fields, these attributes do not need to be registered in your plugInfo.json. Only the default value of an attribute can be used and the attribute should be declared uniform in the USD data.</p>
<p>If you wanted to modify the MyDynamicFileFormat plugin example described earlier to use attribute defaults instead of fields, you would change the implementation of <a class="el" href="class_pcp_dynamic_file_format_interface.html#a4af0bb04b1f5f6e5f708ee07892fb090">ComposeFieldsForFileFormatArguments</a> to use ComposeAttributeDefaultValue to compose the strongest <em>dynamicName</em> and <em>dynamicNumber</em> attribute defaults.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyDynamicFileFormat::ComposeFieldsForFileFormatArguments(</div><div class="line">    <span class="keyword">const</span> std::string&amp; assetPath, </div><div class="line">    <span class="keyword">const</span> <a class="code" href="class_pcp_dynamic_file_format_context.html">PcpDynamicFileFormatContext</a>&amp; context,</div><div class="line">    FileFormatArguments* args,</div><div class="line">    <a class="code" href="class_vt_value.html">VtValue</a> *dependencyContextData)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="class_tf_token.html">TfToken</a> dynamicNameToken(<span class="stringliteral">&quot;dynamicName&quot;</span>);</div><div class="line">    <a class="code" href="class_vt_value.html">VtValue</a> dynamicNameValue;</div><div class="line">    <span class="keywordflow">if</span> (context.<a class="code" href="class_pcp_dynamic_file_format_context.html#abaf3b506c81e8e00e1f4c2018283bebb">ComposeAttributeDefaultValue</a>(dynamicNameToken, &amp;dynamicNameValue)) {</div><div class="line">        (*args)[dynamicNameToken] = <a class="code" href="group__group__tf___string.html#ga7554a67d6bbf6eae3f12131757f13d36">TfStringify</a>(dynamicNameValue);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="class_tf_token.html">TfToken</a> dynamicNumberToken(<span class="stringliteral">&quot;dynamicNumber&quot;</span>);</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="class_tf_token.html">TfToken</a> isPositiveToken(<span class="stringliteral">&quot;isPositive&quot;</span>);</div><div class="line">    <a class="code" href="class_vt_value.html">VtValue</a> dynamicNumberValue;</div><div class="line">    <span class="keywordflow">if</span> (context.<a class="code" href="class_pcp_dynamic_file_format_context.html#abaf3b506c81e8e00e1f4c2018283bebb">ComposeAttributeDefaultValue</a>(dynamicNumberToken, &amp;dynamicNumberValue)) {</div><div class="line">        <span class="keywordflow">if</span> (dynamicNumberValue.<a class="code" href="class_vt_value.html#ae5d3187e0408744ac959d6146de2f2bf">IsHolding</a>&lt;<span class="keywordtype">int</span>&gt;() &amp;&amp;</div><div class="line">            dynamicNumberValue.<a class="code" href="class_vt_value.html#a60c1f31cc358d0d74f2dcbe9b686bc80">UncheckedGet</a>&lt;<span class="keywordtype">int</span>&gt;() &gt; 0) {</div><div class="line">            (*args)[isPositiveToken] = <span class="stringliteral">&quot;true&quot;</span>;</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            (*args)[isPositiveToken] = <span class="stringliteral">&quot;false&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In general, while USD supports composing both field values and attribute defaults in your ComposeFieldsForFileFormatArguments implementation, you should avoid using both field and attribute defaults in your plugin if possible.</p>
<p>If you want to filter out attribute default changes that would not require recomputing the file format arguments, you can implement CanAttributeDefaultValueChangeAffectFileFormatArguments and add your logic for determining which default value changes require recomputing the appropriate argument.</p>
<p>USD data that would use the uniform attribute defaults for this plugin would look like:</p>
<div class="fragment"><div class="line"><span class="preprocessor">### root.usd</span></div><div class="line"></div><div class="line"><span class="preprocessor">#usda 1.0</span></div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Root&quot;</span> (</div><div class="line">    references = &lt;/Params&gt;</div><div class="line">    payload = @./dynamic.mydynamicfile@</div><div class="line">)</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line">def <span class="stringliteral">&quot;Params&quot;</span> (</div><div class="line">)</div><div class="line">{</div><div class="line">    uniform <span class="keywordtype">string</span> dynamicName = <span class="stringliteral">&quot;Foo&quot;</span></div><div class="line">    uniform <span class="keywordtype">int</span> dynamicNumber = 8</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Usd_DynamicFileFormat_Examples"></a>
Advanced Examples</h1>
<p>We include two examples of dynamic file format plugins in pxr/extras/usd/examples. One ot the major differences between these examples that's worth highlighting is how the scene description is represented. <a class="el" href="class_sdf_abstract_data.html" title="Interface for scene description data storage.">SdfAbstractData</a> is the base class for all scene description represented by a layer and we have a choice when writing a file format as to whether we want use the default <a class="el" href="class_sdf_data.html" title="SdfData provides concrete scene description data storage.">SdfData</a> class for our scene description or if we want to write our own custom data representation. </p><ul>
<li><b>usdRecursivePayloadsExample</b> - This example uses file format arguments to recursively generate prims with payloads targeting the same file but with a different set of arguments. It uses the default <a class="el" href="class_sdf_data.html" title="SdfData provides concrete scene description data storage.">SdfData</a> representation provided by <a class="el" href="class_sdf_file_format.html#a7e6fe1b90e69c2f271c631b2e0597b23" title="This method allows the file format to bind to whatever data container is appropriate.">SdfFileFormat::InitData</a>, just like the text based sdf and usda file formats, and creates prim specs in its Read function through the standard <a class="el" href="class_sdf_prim_spec.html" title="Represents a prim description in an SdfLayer object.">SdfPrimSpec</a> API. The generated scene description is pretty simple and minimal so it doesn't warrant the complexity of a custom <a class="el" href="class_sdf_abstract_data.html" title="Interface for scene description data storage.">SdfAbstractData</a> type. </li>
<li><b>usdDancingCubesExample</b> - This example generates a cube made up of animated cubes backed by a completely procedural scene description representation. It implements its own <a class="el" href="class_sdf_abstract_data.html" title="Interface for scene description data storage.">SdfAbstractData</a> subclass that is returned by overriding <a class="el" href="class_sdf_file_format.html#a7e6fe1b90e69c2f271c631b2e0597b23" title="This method allows the file format to bind to whatever data container is appropriate.">SdfFileFormat::InitData</a>. The file format generates a small set of parameters from the file format arguments and provides them to the data implementation of the layer. The <a class="el" href="class_sdf_abstract_data.html" title="Interface for scene description data storage.">SdfAbstractData</a> subclass uses these parameters to cache some information about the scene and provides the API that generates spec data on the fly when requested. This example greatly benefits from a customized <a class="el" href="class_sdf_abstract_data.html" title="Interface for scene description data storage.">SdfAbstractData</a> implementation as it avoids having to precompute every time sample for every prim when the layer is opened.</li>
</ul>
<h1><a class="anchor" id="Usd_DynamicFileFormat_DynamicPayloads"></a>
Dynamic Payloads</h1>
<p>As mentioned above, the composition of prim fields or attribute defaults into file format arguments only occurs when a dynamic asset is included as a payload. We refer to such a payload as a <em>dynamic payload</em>. This behavior is intentionally exclusive to payloads, as opposed to references, for a couple of reasons: </p><ul>
<li>Payloads are the weakest composition arcs that read in layer files. The effect of this is that when prim indexing encounters a dynamic payload, the context used for composing fields will have access to all local or referenced opinions on those fields, giving the most complete context with which to process the dynamic file's arguments. </li>
<li>Payloads can be loaded and unloaded providing a convenient way to recompute dynamic layers whose contents depend on factors other than just file format arguments alone.</li>
</ul>
<p>A prim index can have multiple payload arcs with any number of them being dynamic. Opinions from stronger payloads are included in the context for weaker dynamic payloads when computing file format arguments.</p>
<h1><a class="anchor" id="Usd_DynamicFileFormat_ChangeManagement"></a>
Dependencies and Change Management</h1>
<p>When the <a class="el" href="class_pcp_dynamic_file_format_context.html" title="Context object for the current state of a prim index that is being built that allows implementations ...">PcpDynamicFileFormatContext</a> is used to compute a field value in <a class="el" href="class_pcp_dynamic_file_format_interface.html#a4af0bb04b1f5f6e5f708ee07892fb090">ComposeFieldsForFileFormatArguments</a> using <a class="el" href="class_pcp_dynamic_file_format_context.html#a7c6232095b5a3cc0761f1ae751d12254">ComposeValue</a> (or <a class="el" href="class_pcp_dynamic_file_format_context.html#ab5c80398ec5a7a298b088d22fc2216d5">ComposeValueStack</a>) during prim indexing, a dependency is automatically registered for that payload arc on that field value. This means that change management in Pcp knows which fields were used to generate file format arguments for the payload's layer and therefore may need to invalidate the prim index that includes the payload if any of those fields change. It is recommended when writing an implementation of <a class="el" href="class_pcp_dynamic_file_format_interface.html#a4af0bb04b1f5f6e5f708ee07892fb090">ComposeFieldsForFileFormatArguments</a> to only call ComposeValue on fields as needed if the use of any fields are conditional as it prevents unnecessary change dependencies on unused fields. The same guidance applies when using <a class="el" href="class_pcp_dynamic_file_format_context.html#abaf3b506c81e8e00e1f4c2018283bebb">ComposeAttributeDefaultValue</a> in your ComposeFieldsForFileFormatArguments to compute attribute defaults.</p>
<p>Since prim indexes that include dynamic payloads automatically have a dependency on changes to the computed fields, the other interface function <a class="el" href="class_pcp_dynamic_file_format_interface.html#a1a8d904695c0922ff74507d0afd1df8f">CanFieldChangeAffectFileFormatArguments</a> exists to filter out field changes that we know will not alter the file format arguments. Looking at <em>MyDynamicFileFormat</em> still, the <em>dynamicNumber</em> field holds an integer value that is used to populate the boolean <em>isPositive</em> argument. There are multiple values of <em>dynamicNumber</em> that produce the same arguments so we can write <a class="el" href="class_pcp_dynamic_file_format_interface.html#a1a8d904695c0922ff74507d0afd1df8f">CanFieldChangeAffectFileFormatArguments</a> to take advantage of this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyDynamicFileFormat::CanFieldChangeAffectFileFormatArguments(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="class_tf_token.html">TfToken</a>&amp; field,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="class_vt_value.html">VtValue</a>&amp; oldValue,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="class_vt_value.html">VtValue</a>&amp; newValue,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="class_vt_value.html">VtValue</a> &amp;dependencyContextData)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="class_tf_token.html">TfToken</a> dynamicNumberToken(<span class="stringliteral">&quot;dynamicNumber&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (field == dynamicNumberToken) {</div><div class="line">        <span class="keywordflow">if</span> (oldValue.<a class="code" href="class_vt_value.html#a8e12342fc420701fbffd97025421575a">IsEmpty</a>() != newValue.<a class="code" href="class_vt_value.html#a8e12342fc420701fbffd97025421575a">IsEmpty</a>()) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> oldIsPositive = (oldValue.<a class="code" href="class_vt_value.html#ae5d3187e0408744ac959d6146de2f2bf">IsHolding</a>&lt;<span class="keywordtype">int</span>&gt;() &amp;&amp; </div><div class="line">                                    oldValue.<a class="code" href="class_vt_value.html#a60c1f31cc358d0d74f2dcbe9b686bc80">UncheckedGet</a>&lt;<span class="keywordtype">int</span>&gt;() &gt; 0);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> newIsPositive = (newValue.<a class="code" href="class_vt_value.html#ae5d3187e0408744ac959d6146de2f2bf">IsHolding</a>&lt;<span class="keywordtype">int</span>&gt;() &amp;&amp; </div><div class="line">                                    newValue.<a class="code" href="class_vt_value.html#a60c1f31cc358d0d74f2dcbe9b686bc80">UncheckedGet</a>&lt;<span class="keywordtype">int</span>&gt;() &gt; 0);</div><div class="line">        <span class="keywordflow">return</span> oldIsPositive != newIsPositive;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p>Here if the field is <em>dynamicNumber</em> we check if the old and new values would produce the same isPositive argument, and return false if they would, thus telling Pcp change management that we don't need to invalidate the prim index that includes the payload.</p>
<p>There is one more parameter <code>dependencyContextData</code> that exists in both <a class="el" href="class_pcp_dynamic_file_format_interface.html#a4af0bb04b1f5f6e5f708ee07892fb090">ComposeFieldsForFileFormatArguments</a> and <a class="el" href="class_pcp_dynamic_file_format_interface.html#a1a8d904695c0922ff74507d0afd1df8f">CanFieldChangeAffectFileFormatArguments</a>. This is an arbitrary typed <a class="el" href="class_vt_value.html" title="Provides a container which may hold any type, and provides introspection and iteration over array typ...">VtValue</a> that can be populated in <a class="el" href="class_pcp_dynamic_file_format_interface.html#a4af0bb04b1f5f6e5f708ee07892fb090">ComposeFieldsForFileFormatArguments</a> if there's specific information that would be helpful in determining if a field value change is relevant. The <code>dependencyContextData</code> is stored and passed back to <a class="el" href="class_pcp_dynamic_file_format_interface.html#a1a8d904695c0922ff74507d0afd1df8f">CanFieldChangeAffectFileFormatArguments</a> when processing a field change within the same prim index context. See <a class="el" href="_usd__page__dynamic_file_format.html#Usd_DynamicFileFormat_Examples">usdRecursivePayloadsExample</a> for a very basic example of how this can be used. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="usd_page_front.html">Usd : Universal Scene Description (Core)</a></li><li class="navelem"><a class="el" href="_usd__page__advanced_features.html">Advanced Scenegraph Scalability Features</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:57 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>