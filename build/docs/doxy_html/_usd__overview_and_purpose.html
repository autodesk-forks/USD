<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: Overview and Purpose</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_usd__overview_and_purpose.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Overview and Purpose </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In addition to addressing the interchange problem, USD also provides powerful mechanisms for large-scale collaboration and context-dependent asset refinement anywhere in a production pipeline. For example: </p><ul>
<li><b>layers</b> enable artists in different departments to all work simultaneously on the same "thing", whether that be a singular asset, an aggregate asset, a sequence, or a shot. </li>
<li><b>variants</b> enable asset creators to package up an enumerated set of variations, which can be selected and re-selected by downstream artists in consuming contexts. Using variants in combination with the <b>inherits</b> composition operator, a downstream artist can introduce <em>new</em> variations for all instances of an asset, in a particular (set, sequence, shot, etc.) context. Abilities like this can dramatically reduce the number of pipeline-stalling "asset fix requests" needed to support downstream artists.</li>
</ul>
<p>This set of documents describes the concrete Usd software package, its APIs, and their effective use. In contrast, the forthcoming <em>Composition Compendium</em> centers on USD composition's detailed semantics.</p>
<p>Following is an overview of the architecture, followed by information for <a class="el" href="_usd__overview_and_purpose.html#Usd_Quickstart">getting started with USD</a>, and some <a class="el" href="_usd__overview_and_purpose.html#Usd_Background">background on how the USD project came to be.</a></p>
<h1><a class="anchor" id="Usd_ArchitecturalOverview"></a>
Architectural Overview</h1>
<p>The USD repository is divided into four "core" packages, plus 3rd-party application plugins and extras:</p>
<ul>
<li><b>base</b> - Contains application-agnostic, foundation modules, upon which most Pixar software builds, including possible future open-source projects.</li>
</ul>
<ul>
<li><b>usd</b> - Contains all the modules directly related to authoring, reading, and composing universal scene description. Defines the plugin interfaces by which USD can be extended and adapted.</li>
</ul>
<ul>
<li><b>imaging</b> - Contains the embeddable Hydra hardware renderer as well as other low-level, imaging-related services.</li>
</ul>
<ul>
<li><b>usdImaging</b> - Ties usd and hydra together by providing an adapter to Hydra that reads data directly and efficiently from a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>. Defines a plugin interface by which the adapter can be extended, and provides <em>usdview</em> , the standalone graphical USD inspector tool.</li>
</ul>
<ul>
<li><b>third_party</b> - Contains USD plugins for DCC applications.</li>
</ul>
<ul>
<li><b>extras</b> - Contains a collection of tutorial material, sample code, and small example USD assets.</li>
</ul>
<p>To author and consume USD, you need only the <em>base</em> and <em>usd</em> packages. Most of the open-source third-party plugins, however, do make use of <em>usdImaging</em> for fast preview, and as part of the answer to the question of what application XXX should do when it is asked to import a USD prim type of which it has no corresponding native representation. (Answer: it creates a proxy representation that delegates preview to usdImaging, and presents the prim's properties for inspection and overriding.)</p>
<p>Following is a deeper indexing of the four packages.</p>
<h2><a class="anchor" id="Usd_Package_Base"></a>
The "base" package</h2>
<ul>
<li><a class="el" href="arch_page_front.html">Arch: Architecture Dependent</a> module centralizes functionality that must be implemented differently for different operating systems or architectures, so that we can avoid littering the entire code-base with conditionally-compiled code.</li>
<li><a class="el" href="tf_page_front.html">Tf: Tools Foundations</a> module is a catch-all for low-level, commonly used services developed at Pixar, including facilities for memory tracking, error reporting and debugging, string utilities, boost python wrapping aids, threading/synchronization tools, registry and singleton management, smart pointers, and "observer pattern" support, which we call "notification".</li>
<li><a class="el" href="gf_page_front.html">Gf : Graphics Foundations</a> module provides Pixar's equivalent to imath, and provides many of the types enumerated in Vt. It also provides other foundational graphics abstractions like frusta and a camera model. Given unlimited resources we would have replaced our use of the linear algebra components in Gf with imath, but Gf's use in Pixar's code-base is substantial and its API's do not map one-to-one to imath.</li>
<li><a class="el" href="js_page_front.html">Js: JSON I/O</a> module provides a thin API wrapper on top of the <a href="http://rapidjson.org/">RapidJSON</a> package, which is what our plugin system uses for multi-threaded plugin discovery.</li>
<li>trac_page_front module provides an interface for embeddable performance-profiling tagging.</li>
<li><a class="el" href="vt_page_front.html">Vt : Value Types</a> module provides many of the concrete types that Sdf is able to recognize and serialize. It provides a copy-on-write array-type, <a class="el" href="class_vt_array.html" title="Represents an arbitrary dimensional rectangular container class.">VtArray</a>, which is used for all array types in Usd, and an efficient type-erasure wrapper class, <a class="el" href="class_vt_value.html" title="Provides a container which may hold any type, and provides introspection and iteration over array typ...">VtValue</a>, that also provides datatype conversion facilities and support for unboxing python objects from boost python. <a class="el" href="class_vt_value.html" title="Provides a container which may hold any type, and provides introspection and iteration over array typ...">VtValue</a> is supported in all Usd API for getting and setting values.</li>
<li><a class="el" href="work_page_front.html">Work : Multi-threaded Dispatch</a> module provides a thin abstraction layer on top of Intel's TBB (Thread Building Blocks), and is leveraged extensively in Usd core and higher-level services for multi-threading.</li>
<li><a class="el" href="plug_page_front.html">Plug: Plugin Framework</a> module provides the organization and access API for all plugins. It identifies plugins by the existence of a plugInfo.json manifest file, which enumerates the number and kinds of plugins provided by a module.</li>
</ul>
<h2><a class="anchor" id="Usd_Package_Usd"></a>
The "usd" package</h2>
<p>The USD <em>package</em> begins with the low-level modules for path resolution, scene description serialization, and composition, upon which the "core" Usd module relies. The USD package is rounded out by a set of schema and utility modules that layer on top of the core. In low-to-high order, the modules are:</p>
<ul>
<li><a class="el" href="ar_page_front.html">Ar: Asset Resolution</a> module defines the abstract interface for USD's asset resolution plugin, so that clients can author asset references in their USD files that make sense to their asset management systems. It also provides a "fallback resolver" that is active when no site-level plugin has been provided; the fallback resolver provides basic search-path based resolution.</li>
<li><a class="el" href="kind_page_front.html">Kind : Extensible Categorization</a> module provides a simple, site-extensible token-based typing system, which USD uses, for example, to identify and classify types of "models".</li>
<li><a class="el" href="sdf_page_front.html">Sdf : Scene Description Foundations</a> module defines the Usd data model, namely: prims, attributes, relationships, meta-data, as well as the concrete types that attributes can possess. Sdf also provides the key abstraction <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a>, which represents a file of data subscribing to the Usd data model, and provides low-level data authoring and extraction API's. <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> also has an associated plugin mechanism known as <a class="el" href="class_sdf_file_format.html" title="Base class for file format implementations.">SdfFileFormat</a> that allows any reasonable file format to be dynamically translated into Usd; it is via this mechanism that we added a binary encoding to the pre-existing ASCII format for Usd, as well as how we support referencing and reading of Alembic files.</li>
<li><a class="el" href="pcp_page_front.html">Pcp : PrimCache Population (Composition)</a> module implements the composition logic at the heart of USD; Pcp efficiently builds and caches an "index cache" that the Usd scenegraph uses to determine which prims need to be populated, and where to look for values for any particular property in a multi-layer aggregation of assets.</li>
<li><a class="el" href="usd_page_front.html">Usd : Universal Scene Description (Core)</a> module builds the USD scene-graph (<a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>), and provides the primary API's for authoring and reading composed scene description. The Usd module and the concepts it contains are meant to be fairly generic, allowing many different domain-specific schemas to be built over it, as the USD package does for geometry, shading, etc. We make an exception for two particular concepts/schemas, "Model" and "AssetInfo", which are defined in the core Usd module, because they are extremely valuable for organizing scene description, and other core behaviors are built on top of the concept of Model.</li>
<li><a class="el" href="usd_geom_page_front.html">UsdGeom : USD Geometry Schema</a> : The primary graphics-supporting schema module for DCC interchange, UsdGeom provides geometric primitives (meshes, curves, patches, xforms, etc.), as well as a Camera schema and "Primvars" that encode UV's and various user-defined fields over a primitive. The majority of the schema classes are produced entirely via the <em>usdGenSchema</em> code generator included with the core.</li>
<li><a class="el" href="usd_physics_page_front.html">UsdPhysics : USD Physics Schema</a> : The primary physics-supporting schema module, UsdPhysics provides physics description of the USD prims (rigid bodies, joints, scenes, collisions, etc.). Physics schema also defines physics related metrics like the mass units, kilogramsPerUnit (<a class="el" href="struct_usd_physics_tokens_type.html#a24c37003b1414e39167b1132f765dfec">UsdPhysicsTokensType::kilogramsPerUnit</a>).</li>
<li><a class="el" href="usd_shade_page_front.html">UsdShade : USD Shading Schema</a> Schema module that defines Looks, Shaders, connectible Parameters, with API for building shading networks and user-facing "Look Interfaces" that allow shading networks to be shared (via instancing) by multiple Looks. UsdShade also prescribes how geometry is <em>bound</em> to Looks. With just the objects in UsdShade one can encode completely generic shading; however, it also allows renderer-specific shading schemas to be built on top of it, and a Look can host the network "terminals" for any number of renderer schemas.</li>
<li><a class="el" href="usd_ri_page_front.html">UsdRi: USD Renderman Schemas</a> module for data targeted at Pixar's RenderMan specification. Includes shading schemas for both RSL and RIS shading systems, as well as a "catch all" <code>RiStatements</code> schema for encoding various RenderMan concepts/directives, such as attributes, options, coordinate systems, etc.</li>
<li><a class="el" href="usd_utils_page_front.html">UsdUtils: USD Utilities</a> module provides a number of utilities and conventions that have proven useful in a USD-based pipeline.</li>
</ul>
<h2><a class="anchor" id="Usd_Package_Imaging"></a>
The "imaging" package</h2>
<ul>
<li><b>Garch</b> : The Graphics Architecture module provides abstractions for architecture-specific functionality that may pull in imaging-related dependencies.</li>
<li><b>Glf</b> : The GL Foundations module provides access to textures, ptextures and GL resources (such as draw targets). It also provides some basic glsl shaders used by hdSt.</li>
<li><b>Hio</b> : The Hydra Resource I/O module provides resource loaders used by Hydra, such as Pixar's shader container format (glslfx). It will eventually house the infrastructure for image loading that is currently parked in Glf.</li>
<li><b>CameraUtil</b> The Camera Utilities module provides a small but important set of common camera-related computations that don't really belong in the core <a class="el" href="class_gf_camera.html" title="Object-based representation of a camera.">GfCamera</a> class.</li>
<li><b>PxOsd</b> : The Pixar OpenSubdiv module provides some higher-level utilities on top of OpenSubdiv that may, one day make it into OpenSubdiv, but are still "cooking". Hydra interacts with OpenSubdiv through pxOsd.</li>
<li><b>Hd</b> : The Hydra module provides the Hydra renderer. Hydra uses OpenSubdiv for tessellating subdivision meshes, and supports general programmable glsl shaders, and multiple render passes.</li>
<li><b>Hdx</b> : The Hydra Extensions module provides higher-level functionality on top of Hydra, such as organization and packaging for particular kinds of multiple render-pass tasks.</li>
</ul>
<h2><a class="anchor" id="Usd_Package_UsdImaging"></a>
The "usdImaging" package</h2>
<ul>
<li><a class="el" href="usd_app_utils_page_front.html">UsdAppUtils: USD Application Utilities</a> : A library that provides a number of utilities and common functionality for applications that view and/or record images of UsdStages.</li>
<li><b>UsdImaging</b> : An adapter to Pixar's modern, high-performance GL rendering engine <em>Hydra</em> (which in turn leverages OpenSubdiv) that provides preview imaging (including streaming playback) for any <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> encoded with UsdGeom and UsdShade. UsdImaging takes full advantage of scenegraph instancing in USD, and uses multiple threads to extract data from a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> and marshal it into Hd objects.</li>
<li><b>Usdviewq</b> : A python package that provides the controller and GUI elements used by usdview. The elements are structured for ease of embedding in other python applications, also.</li>
</ul>
<h1><a class="anchor" id="Usd_PythonSupport"></a>
Python Support, numpy, etc.</h1>
<p>Usd includes python wrapping for all core classes and generated schema classes. Each module described in the last section, plus the core Usd module, are independently importable. Each module includes in-python help/documentation extracted from the doxygen docs for the module. We have chosen, initially, to keep the python API as true to the C++ API as possible, with one notable exception.</p>
<ul>
<li><b>Some underlying modules support more pythonic API's.</b> Some of the foundational modules shared with Presto, such as Sdf, provide a more pythonic API in which member-variable-like-things become properties in python. We have hesitated to deploy this level of pythonification at higher levels of the system because <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> is the only container that truly owns its data: all the primary Usd-level classes represent restricted views on data that resides in one-or-more <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> s, and don't possess any member variables/properties other than those that serve as temporary caches.</li>
</ul>
<p>USD's central array type, used to hold all array-valued scene description types, is <a class="el" href="class_vt_array.html" title="Represents an arbitrary dimensional rectangular container class.">VtArray</a>. The python wrapping for <a class="el" href="class_vt_array.html" title="Represents an arbitrary dimensional rectangular container class.">VtArray</a> supports python's "buffer protocol", so <a class="el" href="class_vt_array.html" title="Represents an arbitrary dimensional rectangular container class.">VtArray</a> 's returned by USD to python can be trivially accessed like and converted to native python containers, as well as numpy arrays. Further, USD methods that expect a <a class="el" href="class_vt_array.html" title="Represents an arbitrary dimensional rectangular container class.">VtArray</a> input argument should always successfully convert native python containers and numpy arrays whose underlying element-type is compatible.</p>
<h1><a class="anchor" id="Usd_Quickstart"></a>
Quickstart!</h1>
<p>Please visit <a href="http://openusd.org">the USD Documentation Hub</a> where you will find tutorials, FAQs, and other supporting material.</p>
<h1><a class="anchor" id="Usd_Background"></a>
USD: What's the Point, and Why Isn't it Alembic ?</h1>
<p>The outward-facing goal of Universal Scene Description is to take the next step in DCC application data interchange <em>beyond</em> what is encodable in the ground-breaking Alembic interchange package. The chief component of that step is the ability to encode, interchange, and edit entire scenes with the ability to share variation and repeated/instanced scene data across shots and sequences, by providing robust asset-level (but not restricted to asset-level) file-referencing with sparse override capabilities. Additionally, USD provides a handful of other "composition operators" and concepts that target:</p>
<ul>
<li>Encoding asset variation and preserving the ability to switch variants late in the pipeline</li>
<li>Scale to scenes of unlimited complexity by deferring reading of heavy property data until it is needed (as in Alembic), and also by providing composition semantics that allow deferred (and reversible) loading and composition of arbitrary amounts of scene description without sacrificing the ability to perform robust dependency analysis between prims in a scene. (See the discussion of <a class="el" href="_usd__page__best_practices.html#Usd_Payloads">payloads</a> for more information).</li>
</ul>
<p>The USD project also developed under a high priority inward-facing mandate to simplify and unify Pixar's binary cache-based geometry package (TidScene) with its ASCII, animation and rigging scene description and composition system (Presto core). This mandate required that the advanced rigging concepts and datatypes of Presto be layerable on top of a reduced-featureset, shared (with USD) core. Given the time and resource constraints, and necessity to not massively disrupt our in-use codebase, we chose to largely retain our existing data model, while looking to Alembic as a guide for many schema decisions along the way. While it is unlikely Pixar will attempt to expand the Alembic API and core to encompass USD composition, asset resolution, and necessary plugin mechanisms, we are committed to providing a USD "file format" plugin that allows the USD core and toolset to consume and author Alembic files as if they were native USD files (obviously writing cannot always produce an equally meaningful Alembic file because composition operators cannot be represented in Alembic).</p>
<h1><a class="anchor" id="Usd_Related"></a>
Related Pages</h1>
<ul>
<li>
<a href="http://openusd.org">USD Home Page</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:57 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>