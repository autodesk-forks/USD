<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: HdStResourceRegistry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_hd_st_resource_registry.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_hd_st_resource_registry-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HdStResourceRegistry Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A central registry of all GPU resources.  
 <a href="class_hd_st_resource_registry.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for HdStResourceRegistry:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_hd_st_resource_registry__inherit__graph.png" border="0" usemap="#_hd_st_resource_registry_inherit__map" alt="Inheritance graph"/></div>
<map name="_hd_st_resource_registry_inherit__map" id="_hd_st_resource_registry_inherit__map">
<area shape="rect"  title="A central registry of all GPU resources." alt="" coords="5,80,171,107"/>
<area shape="rect"  href="class_hd_resource_registry.html" title="A central registry for resources." alt="" coords="12,5,164,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af86eb842cd99c8a822df1209d4567373"><td class="memItemLeft" align="right" valign="top"><a id="af86eb842cd99c8a822df1209d4567373"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HF_MALLOC_TAG_NEW</b> (&quot;new <a class="el" href="class_hd_st_resource_registry.html">HdStResourceRegistry</a>&quot;)</td></tr>
<tr class="separator:af86eb842cd99c8a822df1209d4567373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12d26aa00e7e22edbc57e2f3a72e061"><td class="memItemLeft" align="right" valign="top"><a id="ad12d26aa00e7e22edbc57e2f3a72e061"></a>
HDST_API&#160;</td><td class="memItemRight" valign="bottom"><b>HdStResourceRegistry</b> (<a class="el" href="class_hgi.html">Hgi</a> *hgi)</td></tr>
<tr class="separator:ad12d26aa00e7e22edbc57e2f3a72e061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa926690de633ba967319bc98d9855c56"><td class="memItemLeft" align="right" valign="top">HDST_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#aa926690de633ba967319bc98d9855c56">InvalidateShaderRegistry</a> () override</td></tr>
<tr class="memdesc:aa926690de633ba967319bc98d9855c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate any shaders registered with this registry.  <a href="#aa926690de633ba967319bc98d9855c56">More...</a><br /></td></tr>
<tr class="separator:aa926690de633ba967319bc98d9855c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3becaa92122d1321af05df25db93f8f"><td class="memItemLeft" align="right" valign="top">HDST_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#ae3becaa92122d1321af05df25db93f8f">ReloadResource</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;resourceType, std::string const &amp;path) override</td></tr>
<tr class="memdesc:ae3becaa92122d1321af05df25db93f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic method to inform RenderDelegate a resource needs to be reloaded.  <a href="#ae3becaa92122d1321af05df25db93f8f">More...</a><br /></td></tr>
<tr class="separator:ae3becaa92122d1321af05df25db93f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf16c122f0f8558870a2d7b276e29a7"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_vt_dictionary.html">VtDictionary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#aacf16c122f0f8558870a2d7b276e29a7">GetResourceAllocation</a> () const override</td></tr>
<tr class="memdesc:aacf16c122f0f8558870a2d7b276e29a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a report of resource allocation by role in bytes and a summary total allocation of GPU memory in bytes for this registry.  <a href="#aacf16c122f0f8558870a2d7b276e29a7">More...</a><br /></td></tr>
<tr class="separator:aacf16c122f0f8558870a2d7b276e29a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a4b45033b8ae669111a29e0c1de48a"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_hgi.html">Hgi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a61a4b45033b8ae669111a29e0c1de48a">GetHgi</a> ()</td></tr>
<tr class="memdesc:a61a4b45033b8ae669111a29e0c1de48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="class_hgi.html" title="Hydra Graphics Interface.">Hgi</a> used to create/destroy GPU resources.  <a href="#a61a4b45033b8ae669111a29e0c1de48a">More...</a><br /></td></tr>
<tr class="separator:a61a4b45033b8ae669111a29e0c1de48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca726a511db9a2b74038bffedb4fe580"><td class="memItemLeft" align="right" valign="top">HDST_API HdStTextureHandleSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#aca726a511db9a2b74038bffedb4fe580">AllocateTextureHandle</a> (const <a class="el" href="class_hd_st_texture_identifier.html">HdStTextureIdentifier</a> &amp;textureId, HdTextureType textureType, const <a class="el" href="class_hd_sampler_parameters.html">HdSamplerParameters</a> &amp;samplerParams, size_t memoryRequest, HdStShaderCodePtr const &amp;shaderCode)</td></tr>
<tr class="memdesc:aca726a511db9a2b74038bffedb4fe580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate texture handle (encapsulates texture and sampler object, memory request and callback to shader).  <a href="#aca726a511db9a2b74038bffedb4fe580">More...</a><br /></td></tr>
<tr class="separator:aca726a511db9a2b74038bffedb4fe580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a1a32d34f9294663af85ba51f1bc58"><td class="memItemLeft" align="right" valign="top">HDST_API HdStTextureObjectSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#af5a1a32d34f9294663af85ba51f1bc58">AllocateTextureObject</a> (const <a class="el" href="class_hd_st_texture_identifier.html">HdStTextureIdentifier</a> &amp;textureId, HdTextureType textureType)</td></tr>
<tr class="memdesc:af5a1a32d34f9294663af85ba51f1bc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate texture object.  <a href="#af5a1a32d34f9294663af85ba51f1bc58">More...</a><br /></td></tr>
<tr class="separator:af5a1a32d34f9294663af85ba51f1bc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1c8b3ddaa19cc3a29e6b715ec8a4f4"><td class="memItemLeft" align="right" valign="top">HDST_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a3e1c8b3ddaa19cc3a29e6b715ec8a4f4">SetMemoryRequestForTextureType</a> (HdTextureType textureType, size_t memoryRequest)</td></tr>
<tr class="memdesc:a3e1c8b3ddaa19cc3a29e6b715ec8a4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets how much memory a single texture can consume in bytes by texture type.  <a href="#a3e1c8b3ddaa19cc3a29e6b715ec8a4f4">More...</a><br /></td></tr>
<tr class="separator:a3e1c8b3ddaa19cc3a29e6b715ec8a4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ad1cc492b1223de67ad9d5fc6923be"><td class="memItemLeft" align="right" valign="top">HDST_API HdBufferArrayRangeSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#ae9ad1cc492b1223de67ad9d5fc6923be">AllocateNonUniformBufferArrayRange</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;role, HdBufferSpecVector const &amp;bufferSpecs, <a class="el" href="union_hd_buffer_array_usage_hint.html">HdBufferArrayUsageHint</a> usageHint)</td></tr>
<tr class="separator:ae9ad1cc492b1223de67ad9d5fc6923be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edd3fb78d6a57bb984cb29c390eec94"><td class="memItemLeft" align="right" valign="top"><a id="a1edd3fb78d6a57bb984cb29c390eec94"></a>
HDST_API HdBufferArrayRangeSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><b>AllocateNonUniformImmutableBufferArrayRange</b> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;role, HdBufferSpecVector const &amp;bufferSpecs, <a class="el" href="union_hd_buffer_array_usage_hint.html">HdBufferArrayUsageHint</a> usageHint)</td></tr>
<tr class="separator:a1edd3fb78d6a57bb984cb29c390eec94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab542f4b61678c0f6953fe7109f1b4da"><td class="memItemLeft" align="right" valign="top"><a id="aab542f4b61678c0f6953fe7109f1b4da"></a>
HDST_API HdBufferArrayRangeSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><b>AllocateUniformBufferArrayRange</b> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;role, HdBufferSpecVector const &amp;bufferSpecs, <a class="el" href="union_hd_buffer_array_usage_hint.html">HdBufferArrayUsageHint</a> usageHint)</td></tr>
<tr class="separator:aab542f4b61678c0f6953fe7109f1b4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f904eb51749ed4994768afaf16b5803"><td class="memItemLeft" align="right" valign="top"><a id="a1f904eb51749ed4994768afaf16b5803"></a>
HDST_API HdBufferArrayRangeSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><b>AllocateShaderStorageBufferArrayRange</b> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;role, HdBufferSpecVector const &amp;bufferSpecs, <a class="el" href="union_hd_buffer_array_usage_hint.html">HdBufferArrayUsageHint</a> usageHint)</td></tr>
<tr class="separator:a1f904eb51749ed4994768afaf16b5803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c51af19875fddbeee88a43bcf246532"><td class="memItemLeft" align="right" valign="top"><a id="a0c51af19875fddbeee88a43bcf246532"></a>
HDST_API HdBufferArrayRangeSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><b>AllocateSingleBufferArrayRange</b> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;role, HdBufferSpecVector const &amp;bufferSpecs, <a class="el" href="union_hd_buffer_array_usage_hint.html">HdBufferArrayUsageHint</a> usageHint)</td></tr>
<tr class="separator:a0c51af19875fddbeee88a43bcf246532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ac78829e03e9148919f0d51bd9c601"><td class="memItemLeft" align="right" valign="top">HDST_API HdBufferArrayRangeSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a94ac78829e03e9148919f0d51bd9c601">UpdateNonUniformBufferArrayRange</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;role, HdBufferArrayRangeSharedPtr const &amp;curRange, HdBufferSpecVector const &amp;updatedOrAddedSpecs, HdBufferSpecVector const &amp;removedSpecs, <a class="el" href="union_hd_buffer_array_usage_hint.html">HdBufferArrayUsageHint</a> usageHint)</td></tr>
<tr class="separator:a94ac78829e03e9148919f0d51bd9c601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03a18c5ce2a8db31acdd4f3731804bf"><td class="memItemLeft" align="right" valign="top"><a id="af03a18c5ce2a8db31acdd4f3731804bf"></a>
HDST_API HdBufferArrayRangeSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateNonUniformImmutableBufferArrayRange</b> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;role, HdBufferArrayRangeSharedPtr const &amp;curRange, HdBufferSpecVector const &amp;updatedOrAddedSpecs, HdBufferSpecVector const &amp;removedSpecs, <a class="el" href="union_hd_buffer_array_usage_hint.html">HdBufferArrayUsageHint</a> usageHint)</td></tr>
<tr class="separator:af03a18c5ce2a8db31acdd4f3731804bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc03e27ac5621e41f3c6f0b484cb086"><td class="memItemLeft" align="right" valign="top"><a id="abbc03e27ac5621e41f3c6f0b484cb086"></a>
HDST_API HdBufferArrayRangeSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateUniformBufferArrayRange</b> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;role, HdBufferArrayRangeSharedPtr const &amp;curRange, HdBufferSpecVector const &amp;updatedOrAddedSpecs, HdBufferSpecVector const &amp;removedSpecs, <a class="el" href="union_hd_buffer_array_usage_hint.html">HdBufferArrayUsageHint</a> usageHint)</td></tr>
<tr class="separator:abbc03e27ac5621e41f3c6f0b484cb086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63d8e4a15fc44fd876adc702b2b17bc"><td class="memItemLeft" align="right" valign="top"><a id="ad63d8e4a15fc44fd876adc702b2b17bc"></a>
HDST_API HdBufferArrayRangeSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateShaderStorageBufferArrayRange</b> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;role, HdBufferArrayRangeSharedPtr const &amp;curRange, HdBufferSpecVector const &amp;updatedOrAddedSpecs, HdBufferSpecVector const &amp;removedSpecs, <a class="el" href="union_hd_buffer_array_usage_hint.html">HdBufferArrayUsageHint</a> usageHint)</td></tr>
<tr class="separator:ad63d8e4a15fc44fd876adc702b2b17bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fddcb5de7a3dc57bf86d741a5b6d8b"><td class="memItemLeft" align="right" valign="top">HDST_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a15fddcb5de7a3dc57bf86d741a5b6d8b">AddSources</a> (HdBufferArrayRangeSharedPtr const &amp;range, HdBufferSourceSharedPtrVector &amp;&amp;sources)</td></tr>
<tr class="memdesc:a15fddcb5de7a3dc57bf86d741a5b6d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append source data for given range to be committed later.  <a href="#a15fddcb5de7a3dc57bf86d741a5b6d8b">More...</a><br /></td></tr>
<tr class="separator:a15fddcb5de7a3dc57bf86d741a5b6d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1755d680bf6af7a9bc27ea860f4518c5"><td class="memItemLeft" align="right" valign="top">HDST_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a1755d680bf6af7a9bc27ea860f4518c5">AddSource</a> (HdBufferArrayRangeSharedPtr const &amp;range, HdBufferSourceSharedPtr const &amp;source)</td></tr>
<tr class="memdesc:a1755d680bf6af7a9bc27ea860f4518c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a source data for given range to be committed later.  <a href="#a1755d680bf6af7a9bc27ea860f4518c5">More...</a><br /></td></tr>
<tr class="separator:a1755d680bf6af7a9bc27ea860f4518c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e1108ceceb8a8890bf9dc96d1cdf04"><td class="memItemLeft" align="right" valign="top">HDST_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a17e1108ceceb8a8890bf9dc96d1cdf04">AddSource</a> (HdBufferSourceSharedPtr const &amp;source)</td></tr>
<tr class="memdesc:a17e1108ceceb8a8890bf9dc96d1cdf04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a source data just to be resolved (used for cpu computations).  <a href="#a17e1108ceceb8a8890bf9dc96d1cdf04">More...</a><br /></td></tr>
<tr class="separator:a17e1108ceceb8a8890bf9dc96d1cdf04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee415723d8899af5cb6d3f0d4878feb"><td class="memItemLeft" align="right" valign="top">HDST_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a7ee415723d8899af5cb6d3f0d4878feb">AddComputation</a> (HdBufferArrayRangeSharedPtr const &amp;range, HdStComputationSharedPtr const &amp;computation, HdStComputeQueue const queue)</td></tr>
<tr class="memdesc:a7ee415723d8899af5cb6d3f0d4878feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a gpu computation into queue.  <a href="#a7ee415723d8899af5cb6d3f0d4878feb">More...</a><br /></td></tr>
<tr class="separator:a7ee415723d8899af5cb6d3f0d4878feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4cd2725be096167ab8c9d835fb7430"><td class="memItemLeft" align="right" valign="top">HDST_API HdStDispatchBufferSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#afb4cd2725be096167ab8c9d835fb7430">RegisterDispatchBuffer</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;role, int count, int commandNumUints)</td></tr>
<tr class="memdesc:afb4cd2725be096167ab8c9d835fb7430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a buffer allocated with <em>count</em> * <em>commandNumUints</em> * sizeof(uint32_t) to be used as an indirect dispatch buffer.  <a href="#afb4cd2725be096167ab8c9d835fb7430">More...</a><br /></td></tr>
<tr class="separator:afb4cd2725be096167ab8c9d835fb7430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24cf5032ec8075fb98a06af0e9c6ebb"><td class="memItemLeft" align="right" valign="top">HDST_API HdStBufferResourceSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#ab24cf5032ec8075fb98a06af0e9c6ebb">RegisterBufferResource</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;role, <a class="el" href="struct_hd_tuple_type.html">HdTupleType</a> tupleType, HgiBufferUsage bufferUsage)</td></tr>
<tr class="memdesc:ab24cf5032ec8075fb98a06af0e9c6ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a misc buffer resource.  <a href="#ab24cf5032ec8075fb98a06af0e9c6ebb">More...</a><br /></td></tr>
<tr class="separator:ab24cf5032ec8075fb98a06af0e9c6ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4fd758c068cd1f3db1f16980fee3cb"><td class="memItemLeft" align="right" valign="top">HDST_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a9f4fd758c068cd1f3db1f16980fee3cb">GarbageCollectDispatchBuffers</a> ()</td></tr>
<tr class="memdesc:a9f4fd758c068cd1f3db1f16980fee3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any entries associated with expired dispatch buffers.  <a href="#a9f4fd758c068cd1f3db1f16980fee3cb">More...</a><br /></td></tr>
<tr class="separator:a9f4fd758c068cd1f3db1f16980fee3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad258c327a6f4a93ca88dd74f174a59"><td class="memItemLeft" align="right" valign="top">HDST_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#adad258c327a6f4a93ca88dd74f174a59">GarbageCollectBufferResources</a> ()</td></tr>
<tr class="memdesc:adad258c327a6f4a93ca88dd74f174a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any entries associated with expired misc buffers.  <a href="#adad258c327a6f4a93ca88dd74f174a59">More...</a><br /></td></tr>
<tr class="separator:adad258c327a6f4a93ca88dd74f174a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c15d046b5421af7dea2929c4856b9e3"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdSt_MeshTopologySharedPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a5c15d046b5421af7dea2929c4856b9e3">RegisterMeshTopology</a> (<a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdSt_MeshTopologySharedPtr &gt;::ID id)</td></tr>
<tr class="memdesc:a5c15d046b5421af7dea2929c4856b9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">These registries implement sharing and deduplication of data based on computed hash identifiers.  <a href="#a5c15d046b5421af7dea2929c4856b9e3">More...</a><br /></td></tr>
<tr class="separator:a5c15d046b5421af7dea2929c4856b9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae03f88a97d2773fa28203997c2fd9e"><td class="memItemLeft" align="right" valign="top"><a id="a1ae03f88a97d2773fa28203997c2fd9e"></a>
HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdSt_BasisCurvesTopologySharedPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterBasisCurvesTopology</b> (<a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdSt_BasisCurvesTopologySharedPtr &gt;::ID id)</td></tr>
<tr class="separator:a1ae03f88a97d2773fa28203997c2fd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdee38e15cc03d0c07eeb3b6a040523"><td class="memItemLeft" align="right" valign="top"><a id="abfdee38e15cc03d0c07eeb3b6a040523"></a>
HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdSt_VertexAdjacencyBuilderSharedPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterVertexAdjacencyBuilder</b> (<a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdSt_VertexAdjacencyBuilderSharedPtr &gt;::ID id)</td></tr>
<tr class="separator:abfdee38e15cc03d0c07eeb3b6a040523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1873f6c24f96fbcf9e4db9fa42c73f"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdBufferArrayRangeSharedPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a8e1873f6c24f96fbcf9e4db9fa42c73f">RegisterMeshIndexRange</a> (<a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdBufferArrayRangeSharedPtr &gt;::ID id, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;name)</td></tr>
<tr class="memdesc:a8e1873f6c24f96fbcf9e4db9fa42c73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topology Index buffer array range instancing Returns the <a class="el" href="class_hd_instance.html" title="This class is used as an interface to a shared instance in HdInstanceRegistry.">HdInstance</a> points to shared <a class="el" href="class_hd_buffer_array_range.html" title="Interface class for representing range (subset) locator of HdBufferArray.">HdBufferArrayRange</a>, distinguished by given ID.  <a href="#a8e1873f6c24f96fbcf9e4db9fa42c73f">More...</a><br /></td></tr>
<tr class="separator:a8e1873f6c24f96fbcf9e4db9fa42c73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf723906ec357b36e6245383bd042796"><td class="memItemLeft" align="right" valign="top"><a id="acf723906ec357b36e6245383bd042796"></a>
HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdBufferArrayRangeSharedPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterBasisCurvesIndexRange</b> (<a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdBufferArrayRangeSharedPtr &gt;::ID id, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;name)</td></tr>
<tr class="separator:acf723906ec357b36e6245383bd042796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0636d9a11c7baf50ad80c9d07b7c0d3e"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdBufferArrayRangeSharedPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a0636d9a11c7baf50ad80c9d07b7c0d3e">RegisterPrimvarRange</a> (<a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdBufferArrayRangeSharedPtr &gt;::ID id)</td></tr>
<tr class="memdesc:a0636d9a11c7baf50ad80c9d07b7c0d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primvar array range instancing Returns the <a class="el" href="class_hd_instance.html" title="This class is used as an interface to a shared instance in HdInstanceRegistry.">HdInstance</a> pointing to shared <a class="el" href="class_hd_buffer_array_range.html" title="Interface class for representing range (subset) locator of HdBufferArray.">HdBufferArrayRange</a>, distinguished by given ID.  <a href="#a0636d9a11c7baf50ad80c9d07b7c0d3e">More...</a><br /></td></tr>
<tr class="separator:a0636d9a11c7baf50ad80c9d07b7c0d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3854e625f58c145136159280d6fb55"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdBufferArrayRangeSharedPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a7b3854e625f58c145136159280d6fb55">RegisterExtComputationDataRange</a> (<a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdBufferArrayRangeSharedPtr &gt;::ID id)</td></tr>
<tr class="memdesc:a7b3854e625f58c145136159280d6fb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">ExtComputation data array range instancing Returns the <a class="el" href="class_hd_instance.html" title="This class is used as an interface to a shared instance in HdInstanceRegistry.">HdInstance</a> pointing to shared <a class="el" href="class_hd_buffer_array_range.html" title="Interface class for representing range (subset) locator of HdBufferArray.">HdBufferArrayRange</a>, distinguished by given ID.  <a href="#a7b3854e625f58c145136159280d6fb55">More...</a><br /></td></tr>
<tr class="separator:a7b3854e625f58c145136159280d6fb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2e8d84c1a7ea7afaaa18569fd72e31"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdSt_GeometricShaderSharedPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a4b2e8d84c1a7ea7afaaa18569fd72e31">RegisterGeometricShader</a> (<a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdSt_GeometricShaderSharedPtr &gt;::ID id)</td></tr>
<tr class="memdesc:a4b2e8d84c1a7ea7afaaa18569fd72e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a geometric shader.  <a href="#a4b2e8d84c1a7ea7afaaa18569fd72e31">More...</a><br /></td></tr>
<tr class="separator:a4b2e8d84c1a7ea7afaaa18569fd72e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1f9c493b0ac2f259c05a1639c3a005"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdStGLSLProgramSharedPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#add1f9c493b0ac2f259c05a1639c3a005">RegisterGLSLProgram</a> (<a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdStGLSLProgramSharedPtr &gt;::ID id)</td></tr>
<tr class="memdesc:add1f9c493b0ac2f259c05a1639c3a005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a GLSL program into the program registry.  <a href="#add1f9c493b0ac2f259c05a1639c3a005">More...</a><br /></td></tr>
<tr class="separator:add1f9c493b0ac2f259c05a1639c3a005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7022847cc926f758d51eef190bad46ce"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HioGlslfxSharedPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a7022847cc926f758d51eef190bad46ce">RegisterGLSLFXFile</a> (<a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HioGlslfxSharedPtr &gt;::ID id)</td></tr>
<tr class="memdesc:a7022847cc926f758d51eef190bad46ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a GLSLFX file.  <a href="#a7022847cc926f758d51eef190bad46ce">More...</a><br /></td></tr>
<tr class="separator:a7022847cc926f758d51eef190bad46ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af630944169bc8e35dbb2674432bede"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HgiResourceBindingsSharedPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a7af630944169bc8e35dbb2674432bede">RegisterResourceBindings</a> (<a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HgiResourceBindingsSharedPtr &gt;::ID id)</td></tr>
<tr class="memdesc:a7af630944169bc8e35dbb2674432bede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="class_hgi.html" title="Hydra Graphics Interface.">Hgi</a> resource bindings into the registry.  <a href="#a7af630944169bc8e35dbb2674432bede">More...</a><br /></td></tr>
<tr class="separator:a7af630944169bc8e35dbb2674432bede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fcde68ea0650ccf152e2e5f7cca2a0"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HgiGraphicsPipelineSharedPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a35fcde68ea0650ccf152e2e5f7cca2a0">RegisterGraphicsPipeline</a> (<a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HgiGraphicsPipelineSharedPtr &gt;::ID id)</td></tr>
<tr class="memdesc:a35fcde68ea0650ccf152e2e5f7cca2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="class_hgi.html" title="Hydra Graphics Interface.">Hgi</a> graphics pipeline into the registry.  <a href="#a35fcde68ea0650ccf152e2e5f7cca2a0">More...</a><br /></td></tr>
<tr class="separator:a35fcde68ea0650ccf152e2e5f7cca2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46de201ecb1a674f82d721910b8c0b10"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HgiComputePipelineSharedPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a46de201ecb1a674f82d721910b8c0b10">RegisterComputePipeline</a> (<a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HgiComputePipelineSharedPtr &gt;::ID id)</td></tr>
<tr class="memdesc:a46de201ecb1a674f82d721910b8c0b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="class_hgi.html" title="Hydra Graphics Interface.">Hgi</a> compute pipeline into the registry.  <a href="#a46de201ecb1a674f82d721910b8c0b10">More...</a><br /></td></tr>
<tr class="separator:a46de201ecb1a674f82d721910b8c0b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61b861a0e993c3ab1a734a9dc2e85ff"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_hgi_blit_cmds.html">HgiBlitCmds</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#ab61b861a0e993c3ab1a734a9dc2e85ff">GetGlobalBlitCmds</a> ()</td></tr>
<tr class="memdesc:ab61b861a0e993c3ab1a734a9dc2e85ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global hgi blit command queue for recording blitting work.  <a href="#ab61b861a0e993c3ab1a734a9dc2e85ff">More...</a><br /></td></tr>
<tr class="separator:ab61b861a0e993c3ab1a734a9dc2e85ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7fabe27a81c4d9cfa4fca3117bd4d3"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_hgi_compute_cmds.html">HgiComputeCmds</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#abd7fabe27a81c4d9cfa4fca3117bd4d3">GetGlobalComputeCmds</a> (HgiComputeDispatch dispatchMethod=HgiComputeDispatchSerial)</td></tr>
<tr class="memdesc:abd7fabe27a81c4d9cfa4fca3117bd4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global hgi compute cmd queue for recording compute work.  <a href="#abd7fabe27a81c4d9cfa4fca3117bd4d3">More...</a><br /></td></tr>
<tr class="separator:abd7fabe27a81c4d9cfa4fca3117bd4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a0e97ea3f1aa44a3d0f1b9a6f545b8"><td class="memItemLeft" align="right" valign="top">HDST_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#ac5a0e97ea3f1aa44a3d0f1b9a6f545b8">SubmitBlitWork</a> (HgiSubmitWaitType wait=HgiSubmitWaitTypeNoWait)</td></tr>
<tr class="memdesc:ac5a0e97ea3f1aa44a3d0f1b9a6f545b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits blit work queued in global blit cmds for GPU execution.  <a href="#ac5a0e97ea3f1aa44a3d0f1b9a6f545b8">More...</a><br /></td></tr>
<tr class="separator:ac5a0e97ea3f1aa44a3d0f1b9a6f545b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe7a5dea9280510c3cd62a10d9e415e"><td class="memItemLeft" align="right" valign="top">HDST_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a0fe7a5dea9280510c3cd62a10d9e415e">SubmitComputeWork</a> (HgiSubmitWaitType wait=HgiSubmitWaitTypeNoWait)</td></tr>
<tr class="memdesc:a0fe7a5dea9280510c3cd62a10d9e415e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits compute work queued in global compute cmds for GPU execution.  <a href="#a0fe7a5dea9280510c3cd62a10d9e415e">More...</a><br /></td></tr>
<tr class="separator:a0fe7a5dea9280510c3cd62a10d9e415e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee53927221a7ddf071c28b52469c956"><td class="memItemLeft" align="right" valign="top">HDST_API <a class="el" href="class_hd_st_staging_buffer.html">HdStStagingBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#aeee53927221a7ddf071c28b52469c956">GetStagingBuffer</a> ()</td></tr>
<tr class="memdesc:aeee53927221a7ddf071c28b52469c956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the staging buffer used when committing data to the GPU.  <a href="#aeee53927221a7ddf071c28b52469c956">More...</a><br /></td></tr>
<tr class="separator:aeee53927221a7ddf071c28b52469c956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afada6ad99ee3ebb47800e57c1e891532"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#afada6ad99ee3ebb47800e57c1e891532">SetNonUniformAggregationStrategy</a> (std::unique_ptr&lt; <a class="el" href="class_hd_st_aggregation_strategy.html">HdStAggregationStrategy</a> &gt; &amp;&amp;strategy)</td></tr>
<tr class="memdesc:afada6ad99ee3ebb47800e57c1e891532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the aggregation strategy for non uniform parameters (vertex, varying, facevarying) Takes ownership of the passed in strategy object.  <a href="#afada6ad99ee3ebb47800e57c1e891532">More...</a><br /></td></tr>
<tr class="separator:afada6ad99ee3ebb47800e57c1e891532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a0e0abc5675daee425432fd3f05f51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a52a0e0abc5675daee425432fd3f05f51">SetNonUniformImmutableAggregationStrategy</a> (std::unique_ptr&lt; <a class="el" href="class_hd_st_aggregation_strategy.html">HdStAggregationStrategy</a> &gt; &amp;&amp;strategy)</td></tr>
<tr class="memdesc:a52a0e0abc5675daee425432fd3f05f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the aggregation strategy for non uniform immutable parameters (vertex, varying, facevarying) Takes ownership of the passed in strategy object.  <a href="#a52a0e0abc5675daee425432fd3f05f51">More...</a><br /></td></tr>
<tr class="separator:a52a0e0abc5675daee425432fd3f05f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ece72af4817c324a70cf12a54ab6c1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a8ece72af4817c324a70cf12a54ab6c1f">SetUniformAggregationStrategy</a> (std::unique_ptr&lt; <a class="el" href="class_hd_st_aggregation_strategy.html">HdStAggregationStrategy</a> &gt; &amp;&amp;strategy)</td></tr>
<tr class="memdesc:a8ece72af4817c324a70cf12a54ab6c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the aggregation strategy for uniform (shader globals) Takes ownership of the passed in strategy object.  <a href="#a8ece72af4817c324a70cf12a54ab6c1f">More...</a><br /></td></tr>
<tr class="separator:a8ece72af4817c324a70cf12a54ab6c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18baf38bf31f9edc30c800165ca621b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a18baf38bf31f9edc30c800165ca621b7">SetShaderStorageAggregationStrategy</a> (std::unique_ptr&lt; <a class="el" href="class_hd_st_aggregation_strategy.html">HdStAggregationStrategy</a> &gt; &amp;&amp;strategy)</td></tr>
<tr class="memdesc:a18baf38bf31f9edc30c800165ca621b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the aggregation strategy for SSBO (uniform primvars) Takes ownership of the passed in strategy object.  <a href="#a18baf38bf31f9edc30c800165ca621b7">More...</a><br /></td></tr>
<tr class="separator:a18baf38bf31f9edc30c800165ca621b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835ba37af5e7e3809810c37036f8c121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a835ba37af5e7e3809810c37036f8c121">SetSingleStorageAggregationStrategy</a> (std::unique_ptr&lt; <a class="el" href="class_hd_st_aggregation_strategy.html">HdStAggregationStrategy</a> &gt; &amp;&amp;strategy)</td></tr>
<tr class="memdesc:a835ba37af5e7e3809810c37036f8c121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the aggregation strategy for single buffers (for nested instancer).  <a href="#a835ba37af5e7e3809810c37036f8c121">More...</a><br /></td></tr>
<tr class="separator:a835ba37af5e7e3809810c37036f8c121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_hd_resource_registry"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_hd_resource_registry')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_hd_resource_registry.html">HdResourceRegistry</a></td></tr>
<tr class="memitem:abea3aef1033b9f56ef127a68e9fa3739 inherit pub_methods_class_hd_resource_registry"><td class="memItemLeft" align="right" valign="top"><a id="abea3aef1033b9f56ef127a68e9fa3739"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HF_MALLOC_TAG_NEW</b> (&quot;new <a class="el" href="class_hd_resource_registry.html">HdResourceRegistry</a>&quot;)</td></tr>
<tr class="separator:abea3aef1033b9f56ef127a68e9fa3739 inherit pub_methods_class_hd_resource_registry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acc6a3bb2a22c95bbda2c268a52f99b inherit pub_methods_class_hd_resource_registry"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_resource_registry.html#a6acc6a3bb2a22c95bbda2c268a52f99b">Commit</a> ()</td></tr>
<tr class="memdesc:a6acc6a3bb2a22c95bbda2c268a52f99b inherit pub_methods_class_hd_resource_registry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits all in-flight source data.  <a href="class_hd_resource_registry.html#a6acc6a3bb2a22c95bbda2c268a52f99b">More...</a><br /></td></tr>
<tr class="separator:a6acc6a3bb2a22c95bbda2c268a52f99b inherit pub_methods_class_hd_resource_registry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7db6bf77e1fcf32a585dd94cb3c549 inherit pub_methods_class_hd_resource_registry"><td class="memItemLeft" align="right" valign="top">HD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_resource_registry.html#abd7db6bf77e1fcf32a585dd94cb3c549">GarbageCollect</a> ()</td></tr>
<tr class="memdesc:abd7db6bf77e1fcf32a585dd94cb3c549 inherit pub_methods_class_hd_resource_registry"><td class="mdescLeft">&#160;</td><td class="mdescRight">cleanup all buffers and remove if empty  <a href="class_hd_resource_registry.html#abd7db6bf77e1fcf32a585dd94cb3c549">More...</a><br /></td></tr>
<tr class="separator:abd7db6bf77e1fcf32a585dd94cb3c549 inherit pub_methods_class_hd_resource_registry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abb9d11a3f974321b5633e42b7634bd91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#abb9d11a3f974321b5633e42b7634bd91">_Commit</a> () override</td></tr>
<tr class="memdesc:abb9d11a3f974321b5633e42b7634bd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hook for derived registries to perform additional resource commits.  <a href="#abb9d11a3f974321b5633e42b7634bd91">More...</a><br /></td></tr>
<tr class="separator:abb9d11a3f974321b5633e42b7634bd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5934824e9aa81ecfebab1bea9212d9d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a5934824e9aa81ecfebab1bea9212d9d9">_GarbageCollect</a> () override</td></tr>
<tr class="memdesc:a5934824e9aa81ecfebab1bea9212d9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hooks for derived registries to perform additional GC when <a class="el" href="class_hd_resource_registry.html#abd7db6bf77e1fcf32a585dd94cb3c549" title="cleanup all buffers and remove if empty">GarbageCollect()</a> is invoked.  <a href="#a5934824e9aa81ecfebab1bea9212d9d9">More...</a><br /></td></tr>
<tr class="separator:a5934824e9aa81ecfebab1bea9212d9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6523721933b4ac464bbf938565ee6bf5"><td class="memItemLeft" align="right" valign="top">HDST_API friend std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_st_resource_registry.html#a6523721933b4ac464bbf938565ee6bf5">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="class_hd_st_resource_registry.html">HdStResourceRegistry</a> &amp;self)</td></tr>
<tr class="memdesc:a6523721933b4ac464bbf938565ee6bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug dump.  <a href="#a6523721933b4ac464bbf938565ee6bf5">More...</a><br /></td></tr>
<tr class="separator:a6523721933b4ac464bbf938565ee6bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_class_hd_resource_registry"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_hd_resource_registry')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_hd_resource_registry.html">HdResourceRegistry</a></td></tr>
<tr class="memitem:a43ce5b43554ef7d06e7935c65ffebfbc inherit pub_types_class_hd_resource_registry"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hd_resource_registry.html#a43ce5b43554ef7d06e7935c65ffebfbc">TextureKey</a></td></tr>
<tr class="memdesc:a43ce5b43554ef7d06e7935c65ffebfbc inherit pub_types_class_hd_resource_registry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Globally unique id for texture, see HdRenderIndex::GetTextureKey() for details.  <a href="class_hd_resource_registry.html#a43ce5b43554ef7d06e7935c65ffebfbc">More...</a><br /></td></tr>
<tr class="separator:a43ce5b43554ef7d06e7935c65ffebfbc inherit pub_types_class_hd_resource_registry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A central registry of all GPU resources. </p>

<p class="definition">Definition at line <a class="el" href="t_2resource_registry_8h_source.html#l00121">121</a> of file <a class="el" href="t_2resource_registry_8h_source.html">resourceRegistry.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abb9d11a3f974321b5633e42b7634bd91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9d11a3f974321b5633e42b7634bd91">&#9670;&nbsp;</a></span>_Commit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void _Commit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A hook for derived registries to perform additional resource commits. </p>

<p>Reimplemented from <a class="el" href="class_hd_resource_registry.html#a2dfcb3e2a701bf3cc0b77d8a89169309">HdResourceRegistry</a>.</p>

</div>
</div>
<a id="a5934824e9aa81ecfebab1bea9212d9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5934824e9aa81ecfebab1bea9212d9d9">&#9670;&nbsp;</a></span>_GarbageCollect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void _GarbageCollect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hooks for derived registries to perform additional GC when <a class="el" href="class_hd_resource_registry.html#abd7db6bf77e1fcf32a585dd94cb3c549" title="cleanup all buffers and remove if empty">GarbageCollect()</a> is invoked. </p>

<p>Reimplemented from <a class="el" href="class_hd_resource_registry.html#ab1d18e80d562dd7a93b2c15096f9ee94">HdResourceRegistry</a>.</p>

</div>
</div>
<a id="a7ee415723d8899af5cb6d3f0d4878feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee415723d8899af5cb6d3f0d4878feb">&#9670;&nbsp;</a></span>AddComputation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API void AddComputation </td>
          <td>(</td>
          <td class="paramtype">HdBufferArrayRangeSharedPtr const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HdStComputationSharedPtr const &amp;&#160;</td>
          <td class="paramname"><em>computation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HdStComputeQueue const&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a gpu computation into queue. </p>
<p>The parameter 'range' specifies the destination buffer range, which has to be allocated by caller of this function.</p>
<p>note: GPU computations will be executed in the order that they are registered. </p>

</div>
</div>
<a id="a1755d680bf6af7a9bc27ea860f4518c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1755d680bf6af7a9bc27ea860f4518c5">&#9670;&nbsp;</a></span>AddSource() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API void AddSource </td>
          <td>(</td>
          <td class="paramtype">HdBufferArrayRangeSharedPtr const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HdBufferSourceSharedPtr const &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a source data for given range to be committed later. </p>

</div>
</div>
<a id="a17e1108ceceb8a8890bf9dc96d1cdf04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e1108ceceb8a8890bf9dc96d1cdf04">&#9670;&nbsp;</a></span>AddSource() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API void AddSource </td>
          <td>(</td>
          <td class="paramtype">HdBufferSourceSharedPtr const &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a source data just to be resolved (used for cpu computations). </p>

</div>
</div>
<a id="a15fddcb5de7a3dc57bf86d741a5b6d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fddcb5de7a3dc57bf86d741a5b6d8b">&#9670;&nbsp;</a></span>AddSources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API void AddSources </td>
          <td>(</td>
          <td class="paramtype">HdBufferArrayRangeSharedPtr const &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HdBufferSourceSharedPtrVector &amp;&amp;&#160;</td>
          <td class="paramname"><em>sources</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append source data for given range to be committed later. </p>
<hr/>
 <h2>Resource update &amp; computation queuing API </h2>

</div>
</div>
<a id="ae9ad1cc492b1223de67ad9d5fc6923be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ad1cc492b1223de67ad9d5fc6923be">&#9670;&nbsp;</a></span>AllocateNonUniformBufferArrayRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API HdBufferArrayRangeSharedPtr AllocateNonUniformBufferArrayRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_token.html">TfToken</a> const &amp;&#160;</td>
          <td class="paramname"><em>role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HdBufferSpecVector const &amp;&#160;</td>
          <td class="paramname"><em>bufferSpecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_hd_buffer_array_usage_hint.html">HdBufferArrayUsageHint</a>&#160;</td>
          <td class="paramname"><em>usageHint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
 <h2>BAR allocation API </h2>
<p>The Allocate* flavor of methods allocate a new BAR for the given buffer specs using the chosen aggregation strategy. </p>

</div>
</div>
<a id="aca726a511db9a2b74038bffedb4fe580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca726a511db9a2b74038bffedb4fe580">&#9670;&nbsp;</a></span>AllocateTextureHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API HdStTextureHandleSharedPtr AllocateTextureHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_hd_st_texture_identifier.html">HdStTextureIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>textureId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HdTextureType&#160;</td>
          <td class="paramname"><em>textureType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_hd_sampler_parameters.html">HdSamplerParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>samplerParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HdStShaderCodePtr const &amp;&#160;</td>
          <td class="paramname"><em>shaderCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate texture handle (encapsulates texture and sampler object, memory request and callback to shader). </p>
<hr/>
 <h2>Texture allocation API </h2>
<p>The actual allocation of the associated GPU texture and sampler resources and loading of the texture file is delayed until the commit phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureId</td><td>Path to file and information to identify a texture if the file is a container for several textures (e.g., OpenVDB file containing several grids, movie file containing frames). </td></tr>
    <tr><td class="paramname">textureType</td><td>Texture type, e.g., uv, ptex, ... </td></tr>
    <tr><td class="paramname">samplerParams</td><td>Sampling parameters such as wrapS, ... wrapS, wrapT, wrapR mode, min filer, mag filter </td></tr>
    <tr><td class="paramname">memoryRequest</td><td>Memory request. The texture is down-sampled to meet the target memory which is the maximum of all memory requests associated to the texture. If all memory requests are 0, no down-sampling will happen. </td></tr>
    <tr><td class="paramname">shaderCode</td><td>After the texture is committed (or after it has been changed) the given shader code can add additional buffer sources and computations using the texture metadata with AddResourcesFromTextures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5a1a32d34f9294663af85ba51f1bc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a1a32d34f9294663af85ba51f1bc58">&#9670;&nbsp;</a></span>AllocateTextureObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API HdStTextureObjectSharedPtr AllocateTextureObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_hd_st_texture_identifier.html">HdStTextureIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>textureId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HdTextureType&#160;</td>
          <td class="paramname"><em>textureType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate texture object. </p>
<p>The actual allocation of the associated GPU texture and sampler resources and loading of the texture file is delayed until the commit phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureId</td><td>Path to file and information to identify a texture if the file is a container for several textures (e.g., OpenVDB file containing several grids, movie file containing frames). </td></tr>
    <tr><td class="paramname">textureType</td><td>Texture type, e.g., uv, ptex, ... </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adad258c327a6f4a93ca88dd74f174a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad258c327a6f4a93ca88dd74f174a59">&#9670;&nbsp;</a></span>GarbageCollectBufferResources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API void GarbageCollectBufferResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove any entries associated with expired misc buffers. </p>

</div>
</div>
<a id="a9f4fd758c068cd1f3db1f16980fee3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4fd758c068cd1f3db1f16980fee3cb">&#9670;&nbsp;</a></span>GarbageCollectDispatchBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API void GarbageCollectDispatchBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove any entries associated with expired dispatch buffers. </p>

</div>
</div>
<a id="ab61b861a0e993c3ab1a734a9dc2e85ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61b861a0e993c3ab1a734a9dc2e85ff">&#9670;&nbsp;</a></span>GetGlobalBlitCmds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_hgi_blit_cmds.html">HgiBlitCmds</a>* GetGlobalBlitCmds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the global hgi blit command queue for recording blitting work. </p>
<p>When using this global cmd instead of creating a new <a class="el" href="class_hgi_blit_cmds.html" title="A graphics API independent abstraction of resource copy commands.">HgiBlitCmds</a> we reduce the number of command buffers being created. The returned pointer should not be held onto by the client as it is only valid until the <a class="el" href="class_hgi_blit_cmds.html" title="A graphics API independent abstraction of resource copy commands.">HgiBlitCmds</a> has been submitted. </p>

</div>
</div>
<a id="abd7fabe27a81c4d9cfa4fca3117bd4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7fabe27a81c4d9cfa4fca3117bd4d3">&#9670;&nbsp;</a></span>GetGlobalComputeCmds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_hgi_compute_cmds.html">HgiComputeCmds</a>* GetGlobalComputeCmds </td>
          <td>(</td>
          <td class="paramtype">HgiComputeDispatch&#160;</td>
          <td class="paramname"><em>dispatchMethod</em> = <code>HgiComputeDispatchSerial</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the global hgi compute cmd queue for recording compute work. </p>
<p>When using this global cmd instead of creating a new <a class="el" href="class_hgi_compute_cmds.html" title="A graphics API independent abstraction of compute commands.">HgiComputeCmds</a> we reduce the number of command buffers being created. The returned pointer should not be held onto by the client as it is only valid until the <a class="el" href="class_hgi_compute_cmds.html" title="A graphics API independent abstraction of compute commands.">HgiComputeCmds</a> has been submitted. </p>

</div>
</div>
<a id="a61a4b45033b8ae669111a29e0c1de48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a4b45033b8ae669111a29e0c1de48a">&#9670;&nbsp;</a></span>GetHgi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_hgi.html">Hgi</a>* GetHgi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <a class="el" href="class_hgi.html" title="Hydra Graphics Interface.">Hgi</a> used to create/destroy GPU resources. </p>

</div>
</div>
<a id="aacf16c122f0f8558870a2d7b276e29a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf16c122f0f8558870a2d7b276e29a7">&#9670;&nbsp;</a></span>GetResourceAllocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_vt_dictionary.html">VtDictionary</a> GetResourceAllocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a report of resource allocation by role in bytes and a summary total allocation of GPU memory in bytes for this registry. </p>

<p>Reimplemented from <a class="el" href="class_hd_resource_registry.html#abeab7ba4c8d0c00636b4c88ea644d944">HdResourceRegistry</a>.</p>

</div>
</div>
<a id="aeee53927221a7ddf071c28b52469c956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee53927221a7ddf071c28b52469c956">&#9670;&nbsp;</a></span>GetStagingBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_hd_st_staging_buffer.html">HdStStagingBuffer</a>* GetStagingBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the staging buffer used when committing data to the GPU. </p>

</div>
</div>
<a id="aa926690de633ba967319bc98d9855c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa926690de633ba967319bc98d9855c56">&#9670;&nbsp;</a></span>InvalidateShaderRegistry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API void InvalidateShaderRegistry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidate any shaders registered with this registry. </p>

<p>Reimplemented from <a class="el" href="class_hd_resource_registry.html#a9326094a31651c7f5db81f75dbc21c4f">HdResourceRegistry</a>.</p>

</div>
</div>
<a id="ab24cf5032ec8075fb98a06af0e9c6ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24cf5032ec8075fb98a06af0e9c6ebb">&#9670;&nbsp;</a></span>RegisterBufferResource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API HdStBufferResourceSharedPtr RegisterBufferResource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_token.html">TfToken</a> const &amp;&#160;</td>
          <td class="paramname"><em>role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_hd_tuple_type.html">HdTupleType</a>&#160;</td>
          <td class="paramname"><em>tupleType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HgiBufferUsage&#160;</td>
          <td class="paramname"><em>bufferUsage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a misc buffer resource. </p>
<p>Usually buffers are part of a buffer array (buffer aggregation) and are managed via buffer array APIs. RegisterBufferResource lets you create a standalone buffer that can be used for misc purposes (Eg. GPU frustum cull prim count read back). </p>

</div>
</div>
<a id="a46de201ecb1a674f82d721910b8c0b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46de201ecb1a674f82d721910b8c0b10">&#9670;&nbsp;</a></span>RegisterComputePipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt;HgiComputePipelineSharedPtr&gt; RegisterComputePipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HgiComputePipelineSharedPtr &gt;::ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a <a class="el" href="class_hgi.html" title="Hydra Graphics Interface.">Hgi</a> compute pipeline into the registry. </p>

</div>
</div>
<a id="afb4cd2725be096167ab8c9d835fb7430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4cd2725be096167ab8c9d835fb7430">&#9670;&nbsp;</a></span>RegisterDispatchBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API HdStDispatchBufferSharedPtr RegisterDispatchBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_token.html">TfToken</a> const &amp;&#160;</td>
          <td class="paramname"><em>role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>commandNumUints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a buffer allocated with <em>count</em> * <em>commandNumUints</em> * sizeof(uint32_t) to be used as an indirect dispatch buffer. </p>
<hr/>
 <h2>Dispatch &amp; buffer API </h2>

</div>
</div>
<a id="a7b3854e625f58c145136159280d6fb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3854e625f58c145136159280d6fb55">&#9670;&nbsp;</a></span>RegisterExtComputationDataRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt;HdBufferArrayRangeSharedPtr&gt; RegisterExtComputationDataRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdBufferArrayRangeSharedPtr &gt;::ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ExtComputation data array range instancing Returns the <a class="el" href="class_hd_instance.html" title="This class is used as an interface to a shared instance in HdInstanceRegistry.">HdInstance</a> pointing to shared <a class="el" href="class_hd_buffer_array_range.html" title="Interface class for representing range (subset) locator of HdBufferArray.">HdBufferArrayRange</a>, distinguished by given ID. </p>
<p>*Refer the comment on RegisterTopology for the same consideration. </p>

</div>
</div>
<a id="a4b2e8d84c1a7ea7afaaa18569fd72e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2e8d84c1a7ea7afaaa18569fd72e31">&#9670;&nbsp;</a></span>RegisterGeometricShader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt;HdSt_GeometricShaderSharedPtr&gt; RegisterGeometricShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdSt_GeometricShaderSharedPtr &gt;::ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a geometric shader. </p>

</div>
</div>
<a id="a7022847cc926f758d51eef190bad46ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7022847cc926f758d51eef190bad46ce">&#9670;&nbsp;</a></span>RegisterGLSLFXFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt;HioGlslfxSharedPtr&gt; RegisterGLSLFXFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HioGlslfxSharedPtr &gt;::ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a GLSLFX file. </p>

</div>
</div>
<a id="add1f9c493b0ac2f259c05a1639c3a005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1f9c493b0ac2f259c05a1639c3a005">&#9670;&nbsp;</a></span>RegisterGLSLProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt;HdStGLSLProgramSharedPtr&gt; RegisterGLSLProgram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdStGLSLProgramSharedPtr &gt;::ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a GLSL program into the program registry. </p>

</div>
</div>
<a id="a35fcde68ea0650ccf152e2e5f7cca2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35fcde68ea0650ccf152e2e5f7cca2a0">&#9670;&nbsp;</a></span>RegisterGraphicsPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt;HgiGraphicsPipelineSharedPtr&gt; RegisterGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HgiGraphicsPipelineSharedPtr &gt;::ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a <a class="el" href="class_hgi.html" title="Hydra Graphics Interface.">Hgi</a> graphics pipeline into the registry. </p>

</div>
</div>
<a id="a8e1873f6c24f96fbcf9e4db9fa42c73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1873f6c24f96fbcf9e4db9fa42c73f">&#9670;&nbsp;</a></span>RegisterMeshIndexRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt;HdBufferArrayRangeSharedPtr&gt; RegisterMeshIndexRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdBufferArrayRangeSharedPtr &gt;::ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tf_token.html">TfToken</a> const &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Topology Index buffer array range instancing Returns the <a class="el" href="class_hd_instance.html" title="This class is used as an interface to a shared instance in HdInstanceRegistry.">HdInstance</a> points to shared <a class="el" href="class_hd_buffer_array_range.html" title="Interface class for representing range (subset) locator of HdBufferArray.">HdBufferArrayRange</a>, distinguished by given ID. </p>
<p>*Refer the comment on RegisterTopology for the same consideration. </p>

</div>
</div>
<a id="a5c15d046b5421af7dea2929c4856b9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c15d046b5421af7dea2929c4856b9e3">&#9670;&nbsp;</a></span>RegisterMeshTopology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt;HdSt_MeshTopologySharedPtr&gt; RegisterMeshTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdSt_MeshTopologySharedPtr &gt;::ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These registries implement sharing and deduplication of data based on computed hash identifiers. </p>
<hr/>
 <h2>Instance Registries </h2>
<p>Each returned <a class="el" href="class_hd_instance.html" title="This class is used as an interface to a shared instance in HdInstanceRegistry.">HdInstance</a> object retains a shared pointer to a data instance. When an <a class="el" href="class_hd_instance.html" title="This class is used as an interface to a shared instance in HdInstanceRegistry.">HdInstance</a> is registered for a previously unused ID, the data pointer will be null and it is the caller's responsibility to set its value. The instance registries are cleaned of unreferenced entries during garbage collection.</p>
<p>Note: As entries can be registered from multiple threads, the returned object holds a lock on the instance registry. This lock is held until the returned <a class="el" href="class_hd_instance.html" title="This class is used as an interface to a shared instance in HdInstanceRegistry.">HdInstance</a> object is destroyed. Topology instancing </p>

</div>
</div>
<a id="a0636d9a11c7baf50ad80c9d07b7c0d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0636d9a11c7baf50ad80c9d07b7c0d3e">&#9670;&nbsp;</a></span>RegisterPrimvarRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt;HdBufferArrayRangeSharedPtr&gt; RegisterPrimvarRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HdBufferArrayRangeSharedPtr &gt;::ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Primvar array range instancing Returns the <a class="el" href="class_hd_instance.html" title="This class is used as an interface to a shared instance in HdInstanceRegistry.">HdInstance</a> pointing to shared <a class="el" href="class_hd_buffer_array_range.html" title="Interface class for representing range (subset) locator of HdBufferArray.">HdBufferArrayRange</a>, distinguished by given ID. </p>
<p>*Refer the comment on RegisterTopology for the same consideration. </p>

</div>
</div>
<a id="a7af630944169bc8e35dbb2674432bede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af630944169bc8e35dbb2674432bede">&#9670;&nbsp;</a></span>RegisterResourceBindings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API <a class="el" href="class_hd_instance.html">HdInstance</a>&lt;HgiResourceBindingsSharedPtr&gt; RegisterResourceBindings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hd_instance.html">HdInstance</a>&lt; HgiResourceBindingsSharedPtr &gt;::ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a <a class="el" href="class_hgi.html" title="Hydra Graphics Interface.">Hgi</a> resource bindings into the registry. </p>

</div>
</div>
<a id="ae3becaa92122d1321af05df25db93f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3becaa92122d1321af05df25db93f8f">&#9670;&nbsp;</a></span>ReloadResource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API void ReloadResource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_token.html">TfToken</a> const &amp;&#160;</td>
          <td class="paramname"><em>resourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic method to inform RenderDelegate a resource needs to be reloaded. </p>
<p>This method can be used by the application to inform the renderDelegate that a resource, which may not have any prim representation in Hydra, needs to be reloaded. For example a texture found in a material network. The <code>path</code> can be absolute or relative. It should usually match the path found for textures during <a class="el" href="class_hd_sprim.html#ac100b9064606ab088306512425439cf7" title="Synchronizes state from the delegate to this object.">HdMaterial::Sync</a>. </p>

<p>Reimplemented from <a class="el" href="class_hd_resource_registry.html#afc98a7a0ec81483c6c07de25651554c2">HdResourceRegistry</a>.</p>

</div>
</div>
<a id="a3e1c8b3ddaa19cc3a29e6b715ec8a4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1c8b3ddaa19cc3a29e6b715ec8a4f4">&#9670;&nbsp;</a></span>SetMemoryRequestForTextureType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API void SetMemoryRequestForTextureType </td>
          <td>(</td>
          <td class="paramtype">HdTextureType&#160;</td>
          <td class="paramname"><em>textureType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryRequest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets how much memory a single texture can consume in bytes by texture type. </p>
<p>Only has an effect if non-zero and only applies to textures if no texture handle referencing the texture has a memory request. </p>

</div>
</div>
<a id="afada6ad99ee3ebb47800e57c1e891532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afada6ad99ee3ebb47800e57c1e891532">&#9670;&nbsp;</a></span>SetNonUniformAggregationStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetNonUniformAggregationStrategy </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_hd_st_aggregation_strategy.html">HdStAggregationStrategy</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the aggregation strategy for non uniform parameters (vertex, varying, facevarying) Takes ownership of the passed in strategy object. </p>

<p class="definition">Definition at line <a class="el" href="t_2resource_registry_8h_source.html#l00492">492</a> of file <a class="el" href="t_2resource_registry_8h_source.html">resourceRegistry.h</a>.</p>

</div>
</div>
<a id="a52a0e0abc5675daee425432fd3f05f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a0e0abc5675daee425432fd3f05f51">&#9670;&nbsp;</a></span>SetNonUniformImmutableAggregationStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetNonUniformImmutableAggregationStrategy </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_hd_st_aggregation_strategy.html">HdStAggregationStrategy</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the aggregation strategy for non uniform immutable parameters (vertex, varying, facevarying) Takes ownership of the passed in strategy object. </p>

<p class="definition">Definition at line <a class="el" href="t_2resource_registry_8h_source.html#l00500">500</a> of file <a class="el" href="t_2resource_registry_8h_source.html">resourceRegistry.h</a>.</p>

</div>
</div>
<a id="a18baf38bf31f9edc30c800165ca621b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18baf38bf31f9edc30c800165ca621b7">&#9670;&nbsp;</a></span>SetShaderStorageAggregationStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetShaderStorageAggregationStrategy </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_hd_st_aggregation_strategy.html">HdStAggregationStrategy</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the aggregation strategy for SSBO (uniform primvars) Takes ownership of the passed in strategy object. </p>

<p class="definition">Definition at line <a class="el" href="t_2resource_registry_8h_source.html#l00514">514</a> of file <a class="el" href="t_2resource_registry_8h_source.html">resourceRegistry.h</a>.</p>

</div>
</div>
<a id="a835ba37af5e7e3809810c37036f8c121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835ba37af5e7e3809810c37036f8c121">&#9670;&nbsp;</a></span>SetSingleStorageAggregationStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetSingleStorageAggregationStrategy </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_hd_st_aggregation_strategy.html">HdStAggregationStrategy</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the aggregation strategy for single buffers (for nested instancer). </p>
<p>Takes ownership of the passed in strategy object. </p>

<p class="definition">Definition at line <a class="el" href="t_2resource_registry_8h_source.html#l00521">521</a> of file <a class="el" href="t_2resource_registry_8h_source.html">resourceRegistry.h</a>.</p>

</div>
</div>
<a id="a8ece72af4817c324a70cf12a54ab6c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ece72af4817c324a70cf12a54ab6c1f">&#9670;&nbsp;</a></span>SetUniformAggregationStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetUniformAggregationStrategy </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_hd_st_aggregation_strategy.html">HdStAggregationStrategy</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the aggregation strategy for uniform (shader globals) Takes ownership of the passed in strategy object. </p>

<p class="definition">Definition at line <a class="el" href="t_2resource_registry_8h_source.html#l00507">507</a> of file <a class="el" href="t_2resource_registry_8h_source.html">resourceRegistry.h</a>.</p>

</div>
</div>
<a id="ac5a0e97ea3f1aa44a3d0f1b9a6f545b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a0e97ea3f1aa44a3d0f1b9a6f545b8">&#9670;&nbsp;</a></span>SubmitBlitWork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API void SubmitBlitWork </td>
          <td>(</td>
          <td class="paramtype">HgiSubmitWaitType&#160;</td>
          <td class="paramname"><em>wait</em> = <code>HgiSubmitWaitTypeNoWait</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits blit work queued in global blit cmds for GPU execution. </p>
<p>We can call this when we want to submit some work to the GPU. To stall the CPU and wait for the GPU to finish, 'wait' can be provided. To insert a barrier to ensure memory writes are visible after the barrier a HgiMemoryBarrier can be provided. </p>

</div>
</div>
<a id="a0fe7a5dea9280510c3cd62a10d9e415e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe7a5dea9280510c3cd62a10d9e415e">&#9670;&nbsp;</a></span>SubmitComputeWork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API void SubmitComputeWork </td>
          <td>(</td>
          <td class="paramtype">HgiSubmitWaitType&#160;</td>
          <td class="paramname"><em>wait</em> = <code>HgiSubmitWaitTypeNoWait</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits compute work queued in global compute cmds for GPU execution. </p>
<p>We can call this when we want to submit some work to the GPU. To stall the CPU and wait for the GPU to finish, 'wait' can be provided. To insert a barrier to ensure memory writes are visible after the barrier a HgiMemoryBarrier can be provided. </p>

</div>
</div>
<a id="a94ac78829e03e9148919f0d51bd9c601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ac78829e03e9148919f0d51bd9c601">&#9670;&nbsp;</a></span>UpdateNonUniformBufferArrayRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API HdBufferArrayRangeSharedPtr UpdateNonUniformBufferArrayRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_token.html">TfToken</a> const &amp;&#160;</td>
          <td class="paramname"><em>role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HdBufferArrayRangeSharedPtr const &amp;&#160;</td>
          <td class="paramname"><em>curRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HdBufferSpecVector const &amp;&#160;</td>
          <td class="paramname"><em>updatedOrAddedSpecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HdBufferSpecVector const &amp;&#160;</td>
          <td class="paramname"><em>removedSpecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_hd_buffer_array_usage_hint.html">HdBufferArrayUsageHint</a>&#160;</td>
          <td class="paramname"><em>usageHint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
 <h2>BAR allocation/migration/update API </h2>
<p>The Update* flavor of methods handle both allocation of a new BAR and reallocation-migration based on the existing range, updated/added specs, removed specs and usage hint. This allows client code to be less verbose when a range's signature (specs) can change.</p>
<p>If <code>curRange</code> is invalid, this is equivalent to calling Allocate*. Otherwise, checks if <code>curRange</code> needs to be migrated to a new range (based on <code>updatedOrAddedSpecs</code> and <code>removedSpecs</code> and <code>usageHint</code>). If migration is necessary, allocate a new range and register necessary migration computations and return the new range. Otherwise, just return the same range. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a6523721933b4ac464bbf938565ee6bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6523721933b4ac464bbf938565ee6bf5">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HDST_API friend std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_hd_st_resource_registry.html">HdStResourceRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>self</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Debug dump. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pxr/imaging/hdSt/<a class="el" href="t_2resource_registry_8h_source.html">resourceRegistry.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_hd_st_resource_registry.html">HdStResourceRegistry</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:01 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>