<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: UsdGeomPointInstancer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_usd_geom_point_instancer.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_usd_geom_point_instancer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">UsdGeomPointInstancer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters), which can be arbitrary prims/subtrees on a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>.  
 <a href="class_usd_geom_point_instancer.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for UsdGeomPointInstancer:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_usd_geom_point_instancer__inherit__graph.png" border="0" usemap="#_usd_geom_point_instancer_inherit__map" alt="Inheritance graph"/></div>
<map name="_usd_geom_point_instancer_inherit__map" id="_usd_geom_point_instancer_inherit__map">
<area shape="rect"  title="Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters)..." alt="" coords="5,379,184,405"/>
<area shape="rect"  href="class_usd_geom_boundable.html" title="Boundable introduces the ability for a prim to persistently cache a rectilinear, local&#45;space,..." alt="" coords="17,304,172,331"/>
<area shape="rect"  href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor..." alt="" coords="17,229,172,256"/>
<area shape="rect"  href="class_usd_geom_imageable.html" title="Base class for all prims that may require rendering or visualization of some sort." alt="" coords="17,155,172,181"/>
<area shape="rect"  href="class_usd_typed.html" title="The base class for all typed schemas (those that can impart a typeName to a UsdPrim),..." alt="" coords="52,80,137,107"/>
<area shape="rect"  href="class_usd_schema_base.html" title="The base class for all schema types in Usd." alt="" coords="29,5,160,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa184c49dc6b24efa4d160c1fe505a403"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#aa184c49dc6b24efa4d160c1fe505a403">ProtoXformInclusion</a> { <a class="el" href="class_usd_geom_point_instancer.html#aa184c49dc6b24efa4d160c1fe505a403afddf3d32b5aaf5e37ad0caa2a5b2b8ff">IncludeProtoXform</a>, 
<a class="el" href="class_usd_geom_point_instancer.html#aa184c49dc6b24efa4d160c1fe505a403a56a11959aa28115d253d01e56f1bdf1c">ExcludeProtoXform</a>
 }</td></tr>
<tr class="memdesc:aa184c49dc6b24efa4d160c1fe505a403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes whether to include each prototype's root prim's transformation as the most-local component of computed instance transforms.  <a href="class_usd_geom_point_instancer.html#aa184c49dc6b24efa4d160c1fe505a403">More...</a><br /></td></tr>
<tr class="separator:aa184c49dc6b24efa4d160c1fe505a403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2257e2db6d6aea4856489ceece508a8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#aa2257e2db6d6aea4856489ceece508a8">MaskApplication</a> { <a class="el" href="class_usd_geom_point_instancer.html#aa2257e2db6d6aea4856489ceece508a8a4b4edcf3676c20fc90a1367af05379d1">ApplyMask</a>, 
<a class="el" href="class_usd_geom_point_instancer.html#aa2257e2db6d6aea4856489ceece508a8ab749281e998b40f076ace0c021d8ec9e">IgnoreMask</a>
 }</td></tr>
<tr class="memdesc:aa2257e2db6d6aea4856489ceece508a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes whether to evaluate and apply the PointInstancer's mask to computed results.  <a href="class_usd_geom_point_instancer.html#aa2257e2db6d6aea4856489ceece508a8">More...</a><br /></td></tr>
<tr class="separator:aa2257e2db6d6aea4856489ceece508a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af3d9eb4de0568b41fb590380e0ebf73f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#af3d9eb4de0568b41fb590380e0ebf73f">UsdGeomPointInstancer</a> (const <a class="el" href="class_usd_prim.html">UsdPrim</a> &amp;prim=<a class="el" href="class_usd_prim.html">UsdPrim</a>())</td></tr>
<tr class="memdesc:af3d9eb4de0568b41fb590380e0ebf73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_usd_geom_point_instancer.html" title="Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters)...">UsdGeomPointInstancer</a> on <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> <code>prim</code> .  <a href="#af3d9eb4de0568b41fb590380e0ebf73f">More...</a><br /></td></tr>
<tr class="separator:af3d9eb4de0568b41fb590380e0ebf73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e3a5ff1c51841ac28393aa253b8dd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a43e3a5ff1c51841ac28393aa253b8dd2">UsdGeomPointInstancer</a> (const <a class="el" href="class_usd_schema_base.html">UsdSchemaBase</a> &amp;schemaObj)</td></tr>
<tr class="memdesc:a43e3a5ff1c51841ac28393aa253b8dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_usd_geom_point_instancer.html" title="Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters)...">UsdGeomPointInstancer</a> on the prim held by <code>schemaObj</code> .  <a href="#a43e3a5ff1c51841ac28393aa253b8dd2">More...</a><br /></td></tr>
<tr class="separator:a43e3a5ff1c51841ac28393aa253b8dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5a2f45d599d277dcffec23e73f863c"><td class="memItemLeft" align="right" valign="top">virtual USDGEOM_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a5f5a2f45d599d277dcffec23e73f863c">~UsdGeomPointInstancer</a> ()</td></tr>
<tr class="memdesc:a5f5a2f45d599d277dcffec23e73f863c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a5f5a2f45d599d277dcffec23e73f863c">More...</a><br /></td></tr>
<tr class="separator:a5f5a2f45d599d277dcffec23e73f863c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0a46b50806ce1922c5ebd03ad94bd6"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a1f0a46b50806ce1922c5ebd03ad94bd6">GetProtoIndicesAttr</a> () const</td></tr>
<tr class="memdesc:a1f0a46b50806ce1922c5ebd03ad94bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Required property</b>.  <a href="#a1f0a46b50806ce1922c5ebd03ad94bd6">More...</a><br /></td></tr>
<tr class="separator:a1f0a46b50806ce1922c5ebd03ad94bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c07674a5ce95e00b87e1d4e70b047d"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a87c07674a5ce95e00b87e1d4e70b047d">CreateProtoIndicesAttr</a> (<a class="el" href="class_vt_value.html">VtValue</a> const &amp;defaultValue=<a class="el" href="class_vt_value.html">VtValue</a>(), bool writeSparsely=false) const</td></tr>
<tr class="memdesc:a87c07674a5ce95e00b87e1d4e70b047d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_point_instancer.html#a1f0a46b50806ce1922c5ebd03ad94bd6" title="Required property.">GetProtoIndicesAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="#a87c07674a5ce95e00b87e1d4e70b047d">More...</a><br /></td></tr>
<tr class="separator:a87c07674a5ce95e00b87e1d4e70b047d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab649953d4c84eae16d2b821bc3627b3a"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#ab649953d4c84eae16d2b821bc3627b3a">GetIdsAttr</a> () const</td></tr>
<tr class="memdesc:ab649953d4c84eae16d2b821bc3627b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ids are optional; if authored, the ids array should be the same length as the <em>protoIndices</em> array, specifying (at each timeSample if instance identities are changing) the id of each instance.  <a href="#ab649953d4c84eae16d2b821bc3627b3a">More...</a><br /></td></tr>
<tr class="separator:ab649953d4c84eae16d2b821bc3627b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836153b8fed90436fea28a1ff0de5966"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a836153b8fed90436fea28a1ff0de5966">CreateIdsAttr</a> (<a class="el" href="class_vt_value.html">VtValue</a> const &amp;defaultValue=<a class="el" href="class_vt_value.html">VtValue</a>(), bool writeSparsely=false) const</td></tr>
<tr class="memdesc:a836153b8fed90436fea28a1ff0de5966"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_point_instancer.html#ab649953d4c84eae16d2b821bc3627b3a" title="Ids are optional; if authored, the ids array should be the same length as the protoIndices array,...">GetIdsAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="#a836153b8fed90436fea28a1ff0de5966">More...</a><br /></td></tr>
<tr class="separator:a836153b8fed90436fea28a1ff0de5966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30684ce10025f54b6b9fdab13700ae99"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a30684ce10025f54b6b9fdab13700ae99">GetPositionsAttr</a> () const</td></tr>
<tr class="memdesc:a30684ce10025f54b6b9fdab13700ae99"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Required property</b>.  <a href="#a30684ce10025f54b6b9fdab13700ae99">More...</a><br /></td></tr>
<tr class="separator:a30684ce10025f54b6b9fdab13700ae99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187eb8f0aeb00ec937c0516aec82dfe8"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a187eb8f0aeb00ec937c0516aec82dfe8">CreatePositionsAttr</a> (<a class="el" href="class_vt_value.html">VtValue</a> const &amp;defaultValue=<a class="el" href="class_vt_value.html">VtValue</a>(), bool writeSparsely=false) const</td></tr>
<tr class="memdesc:a187eb8f0aeb00ec937c0516aec82dfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_point_instancer.html#a30684ce10025f54b6b9fdab13700ae99" title="Required property.">GetPositionsAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="#a187eb8f0aeb00ec937c0516aec82dfe8">More...</a><br /></td></tr>
<tr class="separator:a187eb8f0aeb00ec937c0516aec82dfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5000a8b2f38c6d4b3ea550a91aa069"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#ada5000a8b2f38c6d4b3ea550a91aa069">GetOrientationsAttr</a> () const</td></tr>
<tr class="memdesc:ada5000a8b2f38c6d4b3ea550a91aa069"><td class="mdescLeft">&#160;</td><td class="mdescRight">If authored, per-instance orientation of each instance about its prototype's origin, represented as a unit length quaternion, which allows us to encode it with sufficient precision in a compact <a class="el" href="class_gf_quath.html" title="Basic type: a quaternion, a complex number with a real coefficient and three imaginary coefficients,...">GfQuath</a>.  <a href="#ada5000a8b2f38c6d4b3ea550a91aa069">More...</a><br /></td></tr>
<tr class="separator:ada5000a8b2f38c6d4b3ea550a91aa069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc7993e9c906a2b4ad227140604be5b"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a8dc7993e9c906a2b4ad227140604be5b">CreateOrientationsAttr</a> (<a class="el" href="class_vt_value.html">VtValue</a> const &amp;defaultValue=<a class="el" href="class_vt_value.html">VtValue</a>(), bool writeSparsely=false) const</td></tr>
<tr class="memdesc:a8dc7993e9c906a2b4ad227140604be5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_point_instancer.html#ada5000a8b2f38c6d4b3ea550a91aa069" title="If authored, per-instance orientation of each instance about its prototype&#39;s origin,...">GetOrientationsAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="#a8dc7993e9c906a2b4ad227140604be5b">More...</a><br /></td></tr>
<tr class="separator:a8dc7993e9c906a2b4ad227140604be5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0e562b36e2413ba95616bd4eed98a5"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a0b0e562b36e2413ba95616bd4eed98a5">GetScalesAttr</a> () const</td></tr>
<tr class="memdesc:a0b0e562b36e2413ba95616bd4eed98a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If authored, per-instance scale to be applied to each instance, before any rotation is applied.  <a href="#a0b0e562b36e2413ba95616bd4eed98a5">More...</a><br /></td></tr>
<tr class="separator:a0b0e562b36e2413ba95616bd4eed98a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b02522ca738f4b1801f8a7a6b061240"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a4b02522ca738f4b1801f8a7a6b061240">CreateScalesAttr</a> (<a class="el" href="class_vt_value.html">VtValue</a> const &amp;defaultValue=<a class="el" href="class_vt_value.html">VtValue</a>(), bool writeSparsely=false) const</td></tr>
<tr class="memdesc:a4b02522ca738f4b1801f8a7a6b061240"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_point_instancer.html#a0b0e562b36e2413ba95616bd4eed98a5" title="If authored, per-instance scale to be applied to each instance, before any rotation is applied.">GetScalesAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="#a4b02522ca738f4b1801f8a7a6b061240">More...</a><br /></td></tr>
<tr class="separator:a4b02522ca738f4b1801f8a7a6b061240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2840a996c8a768ecea390147390dc222"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a2840a996c8a768ecea390147390dc222">GetVelocitiesAttr</a> () const</td></tr>
<tr class="memdesc:a2840a996c8a768ecea390147390dc222"><td class="mdescLeft">&#160;</td><td class="mdescRight">If provided, per-instance 'velocities' will be used to compute positions between samples for the 'positions' attribute, rather than interpolating between neighboring 'positions' samples.  <a href="#a2840a996c8a768ecea390147390dc222">More...</a><br /></td></tr>
<tr class="separator:a2840a996c8a768ecea390147390dc222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf96c3a4bc0546725bc50c23067b7d1a"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#aaf96c3a4bc0546725bc50c23067b7d1a">CreateVelocitiesAttr</a> (<a class="el" href="class_vt_value.html">VtValue</a> const &amp;defaultValue=<a class="el" href="class_vt_value.html">VtValue</a>(), bool writeSparsely=false) const</td></tr>
<tr class="memdesc:aaf96c3a4bc0546725bc50c23067b7d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_point_instancer.html#a2840a996c8a768ecea390147390dc222" title="If provided, per-instance &#39;velocities&#39; will be used to compute positions between samples for the &#39;pos...">GetVelocitiesAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="#aaf96c3a4bc0546725bc50c23067b7d1a">More...</a><br /></td></tr>
<tr class="separator:aaf96c3a4bc0546725bc50c23067b7d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4df1035f2f759d5119392f94a73626"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#abf4df1035f2f759d5119392f94a73626">GetAccelerationsAttr</a> () const</td></tr>
<tr class="memdesc:abf4df1035f2f759d5119392f94a73626"><td class="mdescLeft">&#160;</td><td class="mdescRight">If authored, per-instance 'accelerations' will be used with velocities to compute positions between samples for the 'positions' attribute rather than interpolating between neighboring 'positions' samples.  <a href="#abf4df1035f2f759d5119392f94a73626">More...</a><br /></td></tr>
<tr class="separator:abf4df1035f2f759d5119392f94a73626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13702eda2c800254bc40d3948420457"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#ae13702eda2c800254bc40d3948420457">CreateAccelerationsAttr</a> (<a class="el" href="class_vt_value.html">VtValue</a> const &amp;defaultValue=<a class="el" href="class_vt_value.html">VtValue</a>(), bool writeSparsely=false) const</td></tr>
<tr class="memdesc:ae13702eda2c800254bc40d3948420457"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_point_instancer.html#abf4df1035f2f759d5119392f94a73626" title="If authored, per-instance &#39;accelerations&#39; will be used with velocities to compute positions between s...">GetAccelerationsAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="#ae13702eda2c800254bc40d3948420457">More...</a><br /></td></tr>
<tr class="separator:ae13702eda2c800254bc40d3948420457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98bc3fe0a980a0fb0d5a67e6b4901f2"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#af98bc3fe0a980a0fb0d5a67e6b4901f2">GetAngularVelocitiesAttr</a> () const</td></tr>
<tr class="memdesc:af98bc3fe0a980a0fb0d5a67e6b4901f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">If authored, per-instance angular velocity vector to be used for interoplating orientations.  <a href="#af98bc3fe0a980a0fb0d5a67e6b4901f2">More...</a><br /></td></tr>
<tr class="separator:af98bc3fe0a980a0fb0d5a67e6b4901f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26932e7a9f211578f436a14683ac58c1"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a26932e7a9f211578f436a14683ac58c1">CreateAngularVelocitiesAttr</a> (<a class="el" href="class_vt_value.html">VtValue</a> const &amp;defaultValue=<a class="el" href="class_vt_value.html">VtValue</a>(), bool writeSparsely=false) const</td></tr>
<tr class="memdesc:a26932e7a9f211578f436a14683ac58c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_point_instancer.html#af98bc3fe0a980a0fb0d5a67e6b4901f2" title="If authored, per-instance angular velocity vector to be used for interoplating orientations.">GetAngularVelocitiesAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="#a26932e7a9f211578f436a14683ac58c1">More...</a><br /></td></tr>
<tr class="separator:a26932e7a9f211578f436a14683ac58c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccd01db405d601c5cc12645d1f9a8d3"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a4ccd01db405d601c5cc12645d1f9a8d3">GetInvisibleIdsAttr</a> () const</td></tr>
<tr class="memdesc:a4ccd01db405d601c5cc12645d1f9a8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of id's to make invisible at the evaluation time.  <a href="#a4ccd01db405d601c5cc12645d1f9a8d3">More...</a><br /></td></tr>
<tr class="separator:a4ccd01db405d601c5cc12645d1f9a8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab7826296b1bb8d647439f5bb6f5167"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#abab7826296b1bb8d647439f5bb6f5167">CreateInvisibleIdsAttr</a> (<a class="el" href="class_vt_value.html">VtValue</a> const &amp;defaultValue=<a class="el" href="class_vt_value.html">VtValue</a>(), bool writeSparsely=false) const</td></tr>
<tr class="memdesc:abab7826296b1bb8d647439f5bb6f5167"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_point_instancer.html#a4ccd01db405d601c5cc12645d1f9a8d3" title="A list of id&#39;s to make invisible at the evaluation time.">GetInvisibleIdsAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="#abab7826296b1bb8d647439f5bb6f5167">More...</a><br /></td></tr>
<tr class="separator:abab7826296b1bb8d647439f5bb6f5167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612b93e2bca96a78c93967a20555bb3d"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_relationship.html">UsdRelationship</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a612b93e2bca96a78c93967a20555bb3d">GetPrototypesRel</a> () const</td></tr>
<tr class="memdesc:a612b93e2bca96a78c93967a20555bb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Required property</b>.  <a href="#a612b93e2bca96a78c93967a20555bb3d">More...</a><br /></td></tr>
<tr class="separator:a612b93e2bca96a78c93967a20555bb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec51385816998f993b365e6a2266150"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_relationship.html">UsdRelationship</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#afec51385816998f993b365e6a2266150">CreatePrototypesRel</a> () const</td></tr>
<tr class="memdesc:afec51385816998f993b365e6a2266150"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_point_instancer.html#a612b93e2bca96a78c93967a20555bb3d" title="Required property.">GetPrototypesRel()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="#afec51385816998f993b365e6a2266150">More...</a><br /></td></tr>
<tr class="separator:afec51385816998f993b365e6a2266150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619b5f21f6c0fc26e6bd25c86c82b390"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a619b5f21f6c0fc26e6bd25c86c82b390">ComputeInstanceTransformsAtTime</a> (<a class="el" href="class_vt_array.html">VtArray</a>&lt; <a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a> &gt; *xforms, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> time, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> baseTime, const <a class="el" href="class_usd_geom_point_instancer.html#aa184c49dc6b24efa4d160c1fe505a403">ProtoXformInclusion</a> doProtoXforms=<a class="el" href="class_usd_geom_point_instancer.html#aa184c49dc6b24efa4d160c1fe505a403afddf3d32b5aaf5e37ad0caa2a5b2b8ff">IncludeProtoXform</a>, const <a class="el" href="class_usd_geom_point_instancer.html#aa2257e2db6d6aea4856489ceece508a8">MaskApplication</a> applyMask=<a class="el" href="class_usd_geom_point_instancer.html#aa2257e2db6d6aea4856489ceece508a8a4b4edcf3676c20fc90a1367af05379d1">ApplyMask</a>) const</td></tr>
<tr class="memdesc:a619b5f21f6c0fc26e6bd25c86c82b390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the per-instance, "PointInstancer relative" transforms given the positions, scales, orientations, velocities and angularVelocities at <code>time</code>, as described in <a class="el" href="class_usd_geom_point_instancer.html#UsdGeomPointInstancer_transform">Computing an Instance Transform</a> .  <a href="#a619b5f21f6c0fc26e6bd25c86c82b390">More...</a><br /></td></tr>
<tr class="separator:a619b5f21f6c0fc26e6bd25c86c82b390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8468b44a2996504b0caa828e7414b68f"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a8468b44a2996504b0caa828e7414b68f">ComputeInstanceTransformsAtTimes</a> (std::vector&lt; <a class="el" href="class_vt_array.html">VtArray</a>&lt; <a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a> &gt;&gt; *xformsArray, const std::vector&lt; <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> &gt; &amp;times, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> baseTime, const <a class="el" href="class_usd_geom_point_instancer.html#aa184c49dc6b24efa4d160c1fe505a403">ProtoXformInclusion</a> doProtoXforms=<a class="el" href="class_usd_geom_point_instancer.html#aa184c49dc6b24efa4d160c1fe505a403afddf3d32b5aaf5e37ad0caa2a5b2b8ff">IncludeProtoXform</a>, const <a class="el" href="class_usd_geom_point_instancer.html#aa2257e2db6d6aea4856489ceece508a8">MaskApplication</a> applyMask=<a class="el" href="class_usd_geom_point_instancer.html#aa2257e2db6d6aea4856489ceece508a8a4b4edcf3676c20fc90a1367af05379d1">ApplyMask</a>) const</td></tr>
<tr class="memdesc:a8468b44a2996504b0caa828e7414b68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the per-instance transforms as in ComputeInstanceTransformsAtTime, but using multiple sample times.  <a href="#a8468b44a2996504b0caa828e7414b68f">More...</a><br /></td></tr>
<tr class="separator:a8468b44a2996504b0caa828e7414b68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d339584167e16e1f38aa2f9c95476c"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a93d339584167e16e1f38aa2f9c95476c">ComputeExtentAtTime</a> (VtVec3fArray *extent, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> time, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> baseTime) const</td></tr>
<tr class="memdesc:a93d339584167e16e1f38aa2f9c95476c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the extent of the point instancer based on the per-instance, "PointInstancer relative" transforms at <code>time</code>, as described in <a class="el" href="class_usd_geom_point_instancer.html#UsdGeomPointInstancer_transform">Computing an Instance Transform</a> .  <a href="#a93d339584167e16e1f38aa2f9c95476c">More...</a><br /></td></tr>
<tr class="separator:a93d339584167e16e1f38aa2f9c95476c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273cc4b4b5e2adf815d7e5ae6c6b2023"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a273cc4b4b5e2adf815d7e5ae6c6b2023">ComputeExtentAtTime</a> (VtVec3fArray *extent, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> time, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> baseTime, const <a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a> &amp;transform) const</td></tr>
<tr class="memdesc:a273cc4b4b5e2adf815d7e5ae6c6b2023"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Computes the extent as if the matrix <code>transform</code> was first applied.  <a href="#a273cc4b4b5e2adf815d7e5ae6c6b2023">More...</a><br /></td></tr>
<tr class="separator:a273cc4b4b5e2adf815d7e5ae6c6b2023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c01e24e2adbf6c1521771f8357da57"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#ac3c01e24e2adbf6c1521771f8357da57">ComputeExtentAtTimes</a> (std::vector&lt; VtVec3fArray &gt; *extents, const std::vector&lt; <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> &gt; &amp;times, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> baseTime) const</td></tr>
<tr class="memdesc:ac3c01e24e2adbf6c1521771f8357da57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the extent of the point instancer as in <a class="el" href="class_usd_geom_point_instancer.html#a93d339584167e16e1f38aa2f9c95476c">ComputeExtentAtTime</a> , but across multiple <code>times</code> .  <a href="#ac3c01e24e2adbf6c1521771f8357da57">More...</a><br /></td></tr>
<tr class="separator:ac3c01e24e2adbf6c1521771f8357da57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70faad65f77bbaa27dff8c133da7d6ba"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a70faad65f77bbaa27dff8c133da7d6ba">ComputeExtentAtTimes</a> (std::vector&lt; VtVec3fArray &gt; *extents, const std::vector&lt; <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> &gt; &amp;times, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> baseTime, const <a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a> &amp;transform) const</td></tr>
<tr class="memdesc:a70faad65f77bbaa27dff8c133da7d6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Computes the extent as if the matrix <code>transform</code> was first applied at each time.  <a href="#a70faad65f77bbaa27dff8c133da7d6ba">More...</a><br /></td></tr>
<tr class="separator:a70faad65f77bbaa27dff8c133da7d6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94eab71913905f429534a527af9a7006"><td class="memItemLeft" align="right" valign="top">USDGEOM_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a94eab71913905f429534a527af9a7006">GetInstanceCount</a> (<a class="el" href="class_usd_time_code.html">UsdTimeCode</a> timeCode=<a class="el" href="class_usd_time_code.html#a8a2192045dc22e90fe08ef2d8d68f3b8">UsdTimeCode::Default</a>()) const</td></tr>
<tr class="memdesc:a94eab71913905f429534a527af9a7006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of instances as defined by the size of the <em>protoIndices</em> array at <em>timeCode</em>.  <a href="#a94eab71913905f429534a527af9a7006">More...</a><br /></td></tr>
<tr class="separator:a94eab71913905f429534a527af9a7006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_usd_geom_boundable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_usd_geom_boundable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_usd_geom_boundable.html">UsdGeomBoundable</a></td></tr>
<tr class="memitem:a93364dd184714cc86a93a4e6c943f54f inherit pub_methods_class_usd_geom_boundable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_boundable.html#a93364dd184714cc86a93a4e6c943f54f">UsdGeomBoundable</a> (const <a class="el" href="class_usd_prim.html">UsdPrim</a> &amp;prim=<a class="el" href="class_usd_prim.html">UsdPrim</a>())</td></tr>
<tr class="memdesc:a93364dd184714cc86a93a4e6c943f54f inherit pub_methods_class_usd_geom_boundable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_usd_geom_boundable.html" title="Boundable introduces the ability for a prim to persistently cache a rectilinear, local-space,...">UsdGeomBoundable</a> on <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> <code>prim</code> .  <a href="class_usd_geom_boundable.html#a93364dd184714cc86a93a4e6c943f54f">More...</a><br /></td></tr>
<tr class="separator:a93364dd184714cc86a93a4e6c943f54f inherit pub_methods_class_usd_geom_boundable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddb485259d4c8d3c0fdb9445b85a19e inherit pub_methods_class_usd_geom_boundable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_boundable.html#acddb485259d4c8d3c0fdb9445b85a19e">UsdGeomBoundable</a> (const <a class="el" href="class_usd_schema_base.html">UsdSchemaBase</a> &amp;schemaObj)</td></tr>
<tr class="memdesc:acddb485259d4c8d3c0fdb9445b85a19e inherit pub_methods_class_usd_geom_boundable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_usd_geom_boundable.html" title="Boundable introduces the ability for a prim to persistently cache a rectilinear, local-space,...">UsdGeomBoundable</a> on the prim held by <code>schemaObj</code> .  <a href="class_usd_geom_boundable.html#acddb485259d4c8d3c0fdb9445b85a19e">More...</a><br /></td></tr>
<tr class="separator:acddb485259d4c8d3c0fdb9445b85a19e inherit pub_methods_class_usd_geom_boundable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dfc6e58452966f10c6f8d0a771c346 inherit pub_methods_class_usd_geom_boundable"><td class="memItemLeft" align="right" valign="top">virtual USDGEOM_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_boundable.html#af5dfc6e58452966f10c6f8d0a771c346">~UsdGeomBoundable</a> ()</td></tr>
<tr class="memdesc:af5dfc6e58452966f10c6f8d0a771c346 inherit pub_methods_class_usd_geom_boundable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_usd_geom_boundable.html#af5dfc6e58452966f10c6f8d0a771c346">More...</a><br /></td></tr>
<tr class="separator:af5dfc6e58452966f10c6f8d0a771c346 inherit pub_methods_class_usd_geom_boundable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecc87b5433fec139295a78b439b0531 inherit pub_methods_class_usd_geom_boundable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_boundable.html#abecc87b5433fec139295a78b439b0531">GetExtentAttr</a> () const</td></tr>
<tr class="memdesc:abecc87b5433fec139295a78b439b0531 inherit pub_methods_class_usd_geom_boundable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extent is a three dimensional range measuring the geometric extent of the authored gprim in its own local space (i.e.  <a href="class_usd_geom_boundable.html#abecc87b5433fec139295a78b439b0531">More...</a><br /></td></tr>
<tr class="separator:abecc87b5433fec139295a78b439b0531 inherit pub_methods_class_usd_geom_boundable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dfcd57796694016d7d852e798458d8 inherit pub_methods_class_usd_geom_boundable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_boundable.html#a20dfcd57796694016d7d852e798458d8">CreateExtentAttr</a> (<a class="el" href="class_vt_value.html">VtValue</a> const &amp;defaultValue=<a class="el" href="class_vt_value.html">VtValue</a>(), bool writeSparsely=false) const</td></tr>
<tr class="memdesc:a20dfcd57796694016d7d852e798458d8 inherit pub_methods_class_usd_geom_boundable"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_boundable.html#abecc87b5433fec139295a78b439b0531" title="Extent is a three dimensional range measuring the geometric extent of the authored gprim in its own l...">GetExtentAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="class_usd_geom_boundable.html#a20dfcd57796694016d7d852e798458d8">More...</a><br /></td></tr>
<tr class="separator:a20dfcd57796694016d7d852e798458d8 inherit pub_methods_class_usd_geom_boundable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f4a8f288a211fc286c3f12f0e87fda inherit pub_methods_class_usd_geom_boundable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_boundable.html#a99f4a8f288a211fc286c3f12f0e87fda">ComputeExtent</a> (const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> &amp;time, VtVec3fArray *extent)</td></tr>
<tr class="memdesc:a99f4a8f288a211fc286c3f12f0e87fda inherit pub_methods_class_usd_geom_boundable"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an extent is authored on this boundable, it queries the <code>extent</code> from the extent attribute, otherwise if ComputeExtentFunction is registered for the boundable's type, it computes the <code>extent</code> at <code>time</code>.  <a href="class_usd_geom_boundable.html#a99f4a8f288a211fc286c3f12f0e87fda">More...</a><br /></td></tr>
<tr class="separator:a99f4a8f288a211fc286c3f12f0e87fda inherit pub_methods_class_usd_geom_boundable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_usd_geom_xformable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_usd_geom_xformable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_usd_geom_xformable.html">UsdGeomXformable</a></td></tr>
<tr class="memitem:adf53f566e1d4a6ff2c4e6e90590b0510 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#adf53f566e1d4a6ff2c4e6e90590b0510">UsdGeomXformable</a> (const <a class="el" href="class_usd_prim.html">UsdPrim</a> &amp;prim=<a class="el" href="class_usd_prim.html">UsdPrim</a>())</td></tr>
<tr class="memdesc:adf53f566e1d4a6ff2c4e6e90590b0510 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable</a> on <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> <code>prim</code> .  <a href="class_usd_geom_xformable.html#adf53f566e1d4a6ff2c4e6e90590b0510">More...</a><br /></td></tr>
<tr class="separator:adf53f566e1d4a6ff2c4e6e90590b0510 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5550d15c8a43ef4ac30a063f96d0cd inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a4f5550d15c8a43ef4ac30a063f96d0cd">UsdGeomXformable</a> (const <a class="el" href="class_usd_schema_base.html">UsdSchemaBase</a> &amp;schemaObj)</td></tr>
<tr class="memdesc:a4f5550d15c8a43ef4ac30a063f96d0cd inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable</a> on the prim held by <code>schemaObj</code> .  <a href="class_usd_geom_xformable.html#a4f5550d15c8a43ef4ac30a063f96d0cd">More...</a><br /></td></tr>
<tr class="separator:a4f5550d15c8a43ef4ac30a063f96d0cd inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8f037aa67ff544aea009f0881ed530 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">virtual USDGEOM_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a8c8f037aa67ff544aea009f0881ed530">~UsdGeomXformable</a> ()</td></tr>
<tr class="memdesc:a8c8f037aa67ff544aea009f0881ed530 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_usd_geom_xformable.html#a8c8f037aa67ff544aea009f0881ed530">More...</a><br /></td></tr>
<tr class="separator:a8c8f037aa67ff544aea009f0881ed530 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8533621f9f141dfd016711171433caf inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#af8533621f9f141dfd016711171433caf">GetXformOpOrderAttr</a> () const</td></tr>
<tr class="memdesc:af8533621f9f141dfd016711171433caf inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the sequence of transformation operations in the order in which they should be pushed onto a transform stack while visiting a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>'s prims in a graph traversal that will effect the desired positioning for this prim and its descendant prims.  <a href="class_usd_geom_xformable.html#af8533621f9f141dfd016711171433caf">More...</a><br /></td></tr>
<tr class="separator:af8533621f9f141dfd016711171433caf inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e49a63dc0bed6c97cee6bbc10aa182 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a03e49a63dc0bed6c97cee6bbc10aa182">CreateXformOpOrderAttr</a> (<a class="el" href="class_vt_value.html">VtValue</a> const &amp;defaultValue=<a class="el" href="class_vt_value.html">VtValue</a>(), bool writeSparsely=false) const</td></tr>
<tr class="memdesc:a03e49a63dc0bed6c97cee6bbc10aa182 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_xformable.html#af8533621f9f141dfd016711171433caf" title="Encodes the sequence of transformation operations in the order in which they should be pushed onto a ...">GetXformOpOrderAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="class_usd_geom_xformable.html#a03e49a63dc0bed6c97cee6bbc10aa182">More...</a><br /></td></tr>
<tr class="separator:a03e49a63dc0bed6c97cee6bbc10aa182 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dfc740dcec052482489647af9ed36b inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#ad6dfc740dcec052482489647af9ed36b">AddXformOp</a> (<a class="el" href="class_usd_geom_xform_op.html#a1d1cfd8ffb84e947f82999c682b666a7">UsdGeomXformOp::Type</a> const opType, <a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2">UsdGeomXformOp::Precision</a> const precision=<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2a5c205bb93ab724aad7931d0c2271fd9c">UsdGeomXformOp::PrecisionDouble</a>, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:ad6dfc740dcec052482489647af9ed36b inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an affine transformation to the local stack represented by this Xformable.  <a href="class_usd_geom_xformable.html#ad6dfc740dcec052482489647af9ed36b">More...</a><br /></td></tr>
<tr class="separator:ad6dfc740dcec052482489647af9ed36b inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab153aead880eebecaf2138706c4bdbf2 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#ab153aead880eebecaf2138706c4bdbf2">GetXformOp</a> (<a class="el" href="class_usd_geom_xform_op.html#a1d1cfd8ffb84e947f82999c682b666a7">UsdGeomXformOp::Type</a> const opType, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:ab153aead880eebecaf2138706c4bdbf2 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an affine transformation from the local stack represented by this Xformable.  <a href="class_usd_geom_xformable.html#ab153aead880eebecaf2138706c4bdbf2">More...</a><br /></td></tr>
<tr class="separator:ab153aead880eebecaf2138706c4bdbf2 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782fe5d36ac6657235b80741d47a8b1f inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a782fe5d36ac6657235b80741d47a8b1f">AddTranslateOp</a> (<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2">UsdGeomXformOp::Precision</a> const precision=<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2a5c205bb93ab724aad7931d0c2271fd9c">UsdGeomXformOp::PrecisionDouble</a>, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a782fe5d36ac6657235b80741d47a8b1f inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a translate operation to the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a782fe5d36ac6657235b80741d47a8b1f">More...</a><br /></td></tr>
<tr class="separator:a782fe5d36ac6657235b80741d47a8b1f inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81f8a9eb062d2c726dbb8303188408c inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#ab81f8a9eb062d2c726dbb8303188408c">GetTranslateOp</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:ab81f8a9eb062d2c726dbb8303188408c inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a translate operation from the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#ab81f8a9eb062d2c726dbb8303188408c">More...</a><br /></td></tr>
<tr class="separator:ab81f8a9eb062d2c726dbb8303188408c inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f84556fa9b1fab0432b8c4342e98045 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a4f84556fa9b1fab0432b8c4342e98045">AddScaleOp</a> (<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2">UsdGeomXformOp::Precision</a> const precision=<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2a00752a6adacf6d7b01d8775399ecc06b">UsdGeomXformOp::PrecisionFloat</a>, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a4f84556fa9b1fab0432b8c4342e98045 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a scale operation to the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a4f84556fa9b1fab0432b8c4342e98045">More...</a><br /></td></tr>
<tr class="separator:a4f84556fa9b1fab0432b8c4342e98045 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2029e0b90a0684a9a8c31e62aa98d317 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a2029e0b90a0684a9a8c31e62aa98d317">GetScaleOp</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a2029e0b90a0684a9a8c31e62aa98d317 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a scale operation from the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a2029e0b90a0684a9a8c31e62aa98d317">More...</a><br /></td></tr>
<tr class="separator:a2029e0b90a0684a9a8c31e62aa98d317 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01badf7416ca43636d9e479bc47da33 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#ac01badf7416ca43636d9e479bc47da33">AddRotateXOp</a> (<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2">UsdGeomXformOp::Precision</a> const precision=<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2a00752a6adacf6d7b01d8775399ecc06b">UsdGeomXformOp::PrecisionFloat</a>, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:ac01badf7416ca43636d9e479bc47da33 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rotation about the X-axis to the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#ac01badf7416ca43636d9e479bc47da33">More...</a><br /></td></tr>
<tr class="separator:ac01badf7416ca43636d9e479bc47da33 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc1cc0684aad279a9f7954cce0ad083 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#adbc1cc0684aad279a9f7954cce0ad083">GetRotateXOp</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:adbc1cc0684aad279a9f7954cce0ad083 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rotation about the X-axis from the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#adbc1cc0684aad279a9f7954cce0ad083">More...</a><br /></td></tr>
<tr class="separator:adbc1cc0684aad279a9f7954cce0ad083 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af9af5dc523e80fce81a88014edef19 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a4af9af5dc523e80fce81a88014edef19">AddRotateYOp</a> (<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2">UsdGeomXformOp::Precision</a> const precision=<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2a00752a6adacf6d7b01d8775399ecc06b">UsdGeomXformOp::PrecisionFloat</a>, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a4af9af5dc523e80fce81a88014edef19 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rotation about the Y-axis to the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a4af9af5dc523e80fce81a88014edef19">More...</a><br /></td></tr>
<tr class="separator:a4af9af5dc523e80fce81a88014edef19 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9846b234308946bb9f91e1520f97de05 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a9846b234308946bb9f91e1520f97de05">GetRotateYOp</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a9846b234308946bb9f91e1520f97de05 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rotation about the Y-axis from the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a9846b234308946bb9f91e1520f97de05">More...</a><br /></td></tr>
<tr class="separator:a9846b234308946bb9f91e1520f97de05 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c089e1932ce91477becbc1f01bdfb02 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a9c089e1932ce91477becbc1f01bdfb02">AddRotateZOp</a> (<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2">UsdGeomXformOp::Precision</a> const precision=<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2a00752a6adacf6d7b01d8775399ecc06b">UsdGeomXformOp::PrecisionFloat</a>, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a9c089e1932ce91477becbc1f01bdfb02 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rotation about the Z-axis to the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a9c089e1932ce91477becbc1f01bdfb02">More...</a><br /></td></tr>
<tr class="separator:a9c089e1932ce91477becbc1f01bdfb02 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478e11c424f265543b333a00fb4268d0 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a478e11c424f265543b333a00fb4268d0">GetRotateZOp</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a478e11c424f265543b333a00fb4268d0 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rotation about the Z-axis from the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a478e11c424f265543b333a00fb4268d0">More...</a><br /></td></tr>
<tr class="separator:a478e11c424f265543b333a00fb4268d0 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba511327f305e9a8b3f8941e244c8992 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#aba511327f305e9a8b3f8941e244c8992">AddRotateXYZOp</a> (<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2">UsdGeomXformOp::Precision</a> const precision=<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2a00752a6adacf6d7b01d8775399ecc06b">UsdGeomXformOp::PrecisionFloat</a>, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:aba511327f305e9a8b3f8941e244c8992 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rotation op with XYZ rotation order to the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#aba511327f305e9a8b3f8941e244c8992">More...</a><br /></td></tr>
<tr class="separator:aba511327f305e9a8b3f8941e244c8992 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b871424ffaff814ec4595b406198e12 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a8b871424ffaff814ec4595b406198e12">GetRotateXYZOp</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a8b871424ffaff814ec4595b406198e12 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rotation op with XYZ rotation order from the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a8b871424ffaff814ec4595b406198e12">More...</a><br /></td></tr>
<tr class="separator:a8b871424ffaff814ec4595b406198e12 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ffbff66e60a314adac3380d533469f inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a63ffbff66e60a314adac3380d533469f">AddRotateXZYOp</a> (<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2">UsdGeomXformOp::Precision</a> const precision=<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2a00752a6adacf6d7b01d8775399ecc06b">UsdGeomXformOp::PrecisionFloat</a>, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a63ffbff66e60a314adac3380d533469f inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rotation op with XZY rotation order to the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a63ffbff66e60a314adac3380d533469f">More...</a><br /></td></tr>
<tr class="separator:a63ffbff66e60a314adac3380d533469f inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabbd1a4b1e09254ddf700bfc1d83790 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#aeabbd1a4b1e09254ddf700bfc1d83790">GetRotateXZYOp</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:aeabbd1a4b1e09254ddf700bfc1d83790 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rotation op with XZY rotation order from the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#aeabbd1a4b1e09254ddf700bfc1d83790">More...</a><br /></td></tr>
<tr class="separator:aeabbd1a4b1e09254ddf700bfc1d83790 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7235be9524c6eb1a906f3247f9833f0 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#ac7235be9524c6eb1a906f3247f9833f0">AddRotateYXZOp</a> (<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2">UsdGeomXformOp::Precision</a> const precision=<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2a00752a6adacf6d7b01d8775399ecc06b">UsdGeomXformOp::PrecisionFloat</a>, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:ac7235be9524c6eb1a906f3247f9833f0 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rotation op with YXZ rotation order to the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#ac7235be9524c6eb1a906f3247f9833f0">More...</a><br /></td></tr>
<tr class="separator:ac7235be9524c6eb1a906f3247f9833f0 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803cfbc1fe2750bf9c5aadd83bd50a4c inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a803cfbc1fe2750bf9c5aadd83bd50a4c">GetRotateYXZOp</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a803cfbc1fe2750bf9c5aadd83bd50a4c inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rotation op with YXZ rotation order from the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a803cfbc1fe2750bf9c5aadd83bd50a4c">More...</a><br /></td></tr>
<tr class="separator:a803cfbc1fe2750bf9c5aadd83bd50a4c inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353b43cb6f6d04b2db5b68c057d0494f inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a353b43cb6f6d04b2db5b68c057d0494f">AddRotateYZXOp</a> (<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2">UsdGeomXformOp::Precision</a> const precision=<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2a00752a6adacf6d7b01d8775399ecc06b">UsdGeomXformOp::PrecisionFloat</a>, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a353b43cb6f6d04b2db5b68c057d0494f inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rotation op with YZX rotation order to the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a353b43cb6f6d04b2db5b68c057d0494f">More...</a><br /></td></tr>
<tr class="separator:a353b43cb6f6d04b2db5b68c057d0494f inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa244d99dd6e7f5abecc57f8ece422c93 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#aa244d99dd6e7f5abecc57f8ece422c93">GetRotateYZXOp</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:aa244d99dd6e7f5abecc57f8ece422c93 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rotation op with YZX rotation order from the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#aa244d99dd6e7f5abecc57f8ece422c93">More...</a><br /></td></tr>
<tr class="separator:aa244d99dd6e7f5abecc57f8ece422c93 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd6174a48238d6a9564128f43362ce2 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a6dd6174a48238d6a9564128f43362ce2">AddRotateZXYOp</a> (<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2">UsdGeomXformOp::Precision</a> const precision=<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2a00752a6adacf6d7b01d8775399ecc06b">UsdGeomXformOp::PrecisionFloat</a>, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a6dd6174a48238d6a9564128f43362ce2 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rotation op with ZXY rotation order to the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a6dd6174a48238d6a9564128f43362ce2">More...</a><br /></td></tr>
<tr class="separator:a6dd6174a48238d6a9564128f43362ce2 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12311efeb62f64b39a02a1c001169ec6 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a12311efeb62f64b39a02a1c001169ec6">GetRotateZXYOp</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a12311efeb62f64b39a02a1c001169ec6 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rotation op with ZXY rotation order from the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a12311efeb62f64b39a02a1c001169ec6">More...</a><br /></td></tr>
<tr class="separator:a12311efeb62f64b39a02a1c001169ec6 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5938bf453b0f07bfaf80d121b916d720 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a5938bf453b0f07bfaf80d121b916d720">AddRotateZYXOp</a> (<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2">UsdGeomXformOp::Precision</a> const precision=<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2a00752a6adacf6d7b01d8775399ecc06b">UsdGeomXformOp::PrecisionFloat</a>, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a5938bf453b0f07bfaf80d121b916d720 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rotation op with ZYX rotation order to the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a5938bf453b0f07bfaf80d121b916d720">More...</a><br /></td></tr>
<tr class="separator:a5938bf453b0f07bfaf80d121b916d720 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac8cec6efb64e0cbdd4b7a72f71c7f3 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a4ac8cec6efb64e0cbdd4b7a72f71c7f3">GetRotateZYXOp</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a4ac8cec6efb64e0cbdd4b7a72f71c7f3 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rotation op with ZYX rotation order from the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a4ac8cec6efb64e0cbdd4b7a72f71c7f3">More...</a><br /></td></tr>
<tr class="separator:a4ac8cec6efb64e0cbdd4b7a72f71c7f3 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0d6e551f3705724405ddf6795756a7 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a8b0d6e551f3705724405ddf6795756a7">AddOrientOp</a> (<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2">UsdGeomXformOp::Precision</a> const precision=<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2a00752a6adacf6d7b01d8775399ecc06b">UsdGeomXformOp::PrecisionFloat</a>, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a8b0d6e551f3705724405ddf6795756a7 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a orient op (arbitrary axis/angle rotation) to the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a8b0d6e551f3705724405ddf6795756a7">More...</a><br /></td></tr>
<tr class="separator:a8b0d6e551f3705724405ddf6795756a7 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618c9b0ad5f39a8ebfc7f8e1b9319e5f inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a618c9b0ad5f39a8ebfc7f8e1b9319e5f">GetOrientOp</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a618c9b0ad5f39a8ebfc7f8e1b9319e5f inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an orient op (arbitrary axis/angle rotation) from the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a618c9b0ad5f39a8ebfc7f8e1b9319e5f">More...</a><br /></td></tr>
<tr class="separator:a618c9b0ad5f39a8ebfc7f8e1b9319e5f inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd59cb1cdd089e0d93fa755fb0da268 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a0fd59cb1cdd089e0d93fa755fb0da268">AddTransformOp</a> (<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2">UsdGeomXformOp::Precision</a> const precision=<a class="el" href="class_usd_geom_xform_op.html#ad1fbd6a28bdb0f04414d526ebeaed0e2a5c205bb93ab724aad7931d0c2271fd9c">UsdGeomXformOp::PrecisionDouble</a>, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a0fd59cb1cdd089e0d93fa755fb0da268 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a tranform op (4x4 matrix transformation) to the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a0fd59cb1cdd089e0d93fa755fb0da268">More...</a><br /></td></tr>
<tr class="separator:a0fd59cb1cdd089e0d93fa755fb0da268 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b425fbfdfe0f254add07f904ab231aa inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a0b425fbfdfe0f254add07f904ab231aa">GetTransformOp</a> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;opSuffix=<a class="el" href="class_tf_token.html">TfToken</a>(), bool isInverseOp=false) const</td></tr>
<tr class="memdesc:a0b425fbfdfe0f254add07f904ab231aa inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a tranform op (4x4 matrix transformation) from the local stack represented by this xformable.  <a href="class_usd_geom_xformable.html#a0b425fbfdfe0f254add07f904ab231aa">More...</a><br /></td></tr>
<tr class="separator:a0b425fbfdfe0f254add07f904ab231aa inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c4c768f58d6375edad8c9c7cb4bee2 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a99c4c768f58d6375edad8c9c7cb4bee2">SetResetXformStack</a> (bool resetXform) const</td></tr>
<tr class="memdesc:a99c4c768f58d6375edad8c9c7cb4bee2 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether this prim's transform should reset the transformation stack inherited from its parent prim.  <a href="class_usd_geom_xformable.html#a99c4c768f58d6375edad8c9c7cb4bee2">More...</a><br /></td></tr>
<tr class="separator:a99c4c768f58d6375edad8c9c7cb4bee2 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d16bc5455344e131683d91e14ab62db inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a6d16bc5455344e131683d91e14ab62db">GetResetXformStack</a> () const</td></tr>
<tr class="memdesc:a6d16bc5455344e131683d91e14ab62db inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this prim reset its parent's inherited transformation?  <a href="class_usd_geom_xformable.html#a6d16bc5455344e131683d91e14ab62db">More...</a><br /></td></tr>
<tr class="separator:a6d16bc5455344e131683d91e14ab62db inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6dd6e51eb84725c763d064c4f9f3ba inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a4b6dd6e51eb84725c763d064c4f9f3ba">SetXformOpOrder</a> (std::vector&lt; <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a> &gt; const &amp;orderedXformOps, bool resetXformStack=false) const</td></tr>
<tr class="memdesc:a4b6dd6e51eb84725c763d064c4f9f3ba inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder the already-existing transform ops on this prim.  <a href="class_usd_geom_xformable.html#a4b6dd6e51eb84725c763d064c4f9f3ba">More...</a><br /></td></tr>
<tr class="separator:a4b6dd6e51eb84725c763d064c4f9f3ba inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7cd1ac98925aa41af4f83d1efe6375 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API std::vector&lt; <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a5e7cd1ac98925aa41af4f83d1efe6375">GetOrderedXformOps</a> (bool *resetsXformStack) const</td></tr>
<tr class="memdesc:a5e7cd1ac98925aa41af4f83d1efe6375 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ordered list of transform operations to be applied to this prim, in least-to-most-local order.  <a href="class_usd_geom_xformable.html#a5e7cd1ac98925aa41af4f83d1efe6375">More...</a><br /></td></tr>
<tr class="separator:a5e7cd1ac98925aa41af4f83d1efe6375 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a241711290631508cfc349ad4ab64d inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a10a241711290631508cfc349ad4ab64d">ClearXformOpOrder</a> () const</td></tr>
<tr class="memdesc:a10a241711290631508cfc349ad4ab64d inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the local transform stack.  <a href="class_usd_geom_xformable.html#a10a241711290631508cfc349ad4ab64d">More...</a><br /></td></tr>
<tr class="separator:a10a241711290631508cfc349ad4ab64d inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e5c56a739490600e4e7e37b3953a08 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a97e5c56a739490600e4e7e37b3953a08">MakeMatrixXform</a> () const</td></tr>
<tr class="memdesc:a97e5c56a739490600e4e7e37b3953a08 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the existing local transform stack and creates a new xform op of type 'transform'.  <a href="class_usd_geom_xformable.html#a97e5c56a739490600e4e7e37b3953a08">More...</a><br /></td></tr>
<tr class="separator:a97e5c56a739490600e4e7e37b3953a08 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0c1f0eb2639bd9e126f5e6a16e856f inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#aca0c1f0eb2639bd9e126f5e6a16e856f">TransformMightBeTimeVarying</a> () const</td></tr>
<tr class="memdesc:aca0c1f0eb2639bd9e126f5e6a16e856f inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether there is any possibility that this prim's <em>local</em> transformation may vary over time.  <a href="class_usd_geom_xformable.html#aca0c1f0eb2639bd9e126f5e6a16e856f">More...</a><br /></td></tr>
<tr class="separator:aca0c1f0eb2639bd9e126f5e6a16e856f inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e63cb240ddb36f550b3c86a22252c6 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a43e63cb240ddb36f550b3c86a22252c6">TransformMightBeTimeVarying</a> (const std::vector&lt; <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a> &gt; &amp;ops) const</td></tr>
<tr class="memdesc:a43e63cb240ddb36f550b3c86a22252c6 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Determine whether there is any possibility that this prim's <em>local</em> transformation may vary over time, using a pre-fetched (cached) list of ordered xform ops supplied by the client.  <a href="class_usd_geom_xformable.html#a43e63cb240ddb36f550b3c86a22252c6">More...</a><br /></td></tr>
<tr class="separator:a43e63cb240ddb36f550b3c86a22252c6 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0384cb87a595fa56c29463ff4fe73015 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a0384cb87a595fa56c29463ff4fe73015">GetTimeSamples</a> (std::vector&lt; double &gt; *times) const</td></tr>
<tr class="memdesc:a0384cb87a595fa56c29463ff4fe73015 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>times</code> to the union of all the timesamples at which xformOps that are included in the xformOpOrder attribute are authored.  <a href="class_usd_geom_xformable.html#a0384cb87a595fa56c29463ff4fe73015">More...</a><br /></td></tr>
<tr class="separator:a0384cb87a595fa56c29463ff4fe73015 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d8dabfbe974503daf5e8f2057424f7 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a64d8dabfbe974503daf5e8f2057424f7">GetTimeSamplesInInterval</a> (const <a class="el" href="class_gf_interval.html">GfInterval</a> &amp;interval, std::vector&lt; double &gt; *times) const</td></tr>
<tr class="memdesc:a64d8dabfbe974503daf5e8f2057424f7 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>times</code> to the union of all the timesamples in the interval, <code>interval</code>, at which xformOps that are included in the xformOpOrder attribute are authored.  <a href="class_usd_geom_xformable.html#a64d8dabfbe974503daf5e8f2057424f7">More...</a><br /></td></tr>
<tr class="separator:a64d8dabfbe974503daf5e8f2057424f7 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a04ccb1ba8aa16e8cc1e878c2c92969 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a9a04ccb1ba8aa16e8cc1e878c2c92969">GetLocalTransformation</a> (<a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a> *transform, bool *resetsXformStack, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> time=<a class="el" href="class_usd_time_code.html#a8a2192045dc22e90fe08ef2d8d68f3b8">UsdTimeCode::Default</a>()) const</td></tr>
<tr class="memdesc:a9a04ccb1ba8aa16e8cc1e878c2c92969 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the fully-combined, local-to-parent transformation for this prim.  <a href="class_usd_geom_xformable.html#a9a04ccb1ba8aa16e8cc1e878c2c92969">More...</a><br /></td></tr>
<tr class="separator:a9a04ccb1ba8aa16e8cc1e878c2c92969 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdae958563500cfdf2b4f3bcf34c465 inherit pub_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a3bdae958563500cfdf2b4f3bcf34c465">GetLocalTransformation</a> (<a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a> *transform, bool *resetsXformStack, const std::vector&lt; <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a> &gt; &amp;ops, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> time=<a class="el" href="class_usd_time_code.html#a8a2192045dc22e90fe08ef2d8d68f3b8">UsdTimeCode::Default</a>()) const</td></tr>
<tr class="memdesc:a3bdae958563500cfdf2b4f3bcf34c465 inherit pub_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Computes the fully-combined, local-to-parent transformation for this prim as efficiently as possible, using a pre-fetched (cached) list of ordered xform ops supplied by the client.  <a href="class_usd_geom_xformable.html#a3bdae958563500cfdf2b4f3bcf34c465">More...</a><br /></td></tr>
<tr class="separator:a3bdae958563500cfdf2b4f3bcf34c465 inherit pub_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_usd_geom_imageable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_usd_geom_imageable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_usd_geom_imageable.html">UsdGeomImageable</a></td></tr>
<tr class="memitem:a00ea23bdac8d751c2b97dc8fe5cd7f73 inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a00ea23bdac8d751c2b97dc8fe5cd7f73">UsdGeomImageable</a> (const <a class="el" href="class_usd_prim.html">UsdPrim</a> &amp;prim=<a class="el" href="class_usd_prim.html">UsdPrim</a>())</td></tr>
<tr class="memdesc:a00ea23bdac8d751c2b97dc8fe5cd7f73 inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_usd_geom_imageable.html" title="Base class for all prims that may require rendering or visualization of some sort.">UsdGeomImageable</a> on <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> <code>prim</code> .  <a href="class_usd_geom_imageable.html#a00ea23bdac8d751c2b97dc8fe5cd7f73">More...</a><br /></td></tr>
<tr class="separator:a00ea23bdac8d751c2b97dc8fe5cd7f73 inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912f3e5572536e0492914fe251446bc9 inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a912f3e5572536e0492914fe251446bc9">UsdGeomImageable</a> (const <a class="el" href="class_usd_schema_base.html">UsdSchemaBase</a> &amp;schemaObj)</td></tr>
<tr class="memdesc:a912f3e5572536e0492914fe251446bc9 inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_usd_geom_imageable.html" title="Base class for all prims that may require rendering or visualization of some sort.">UsdGeomImageable</a> on the prim held by <code>schemaObj</code> .  <a href="class_usd_geom_imageable.html#a912f3e5572536e0492914fe251446bc9">More...</a><br /></td></tr>
<tr class="separator:a912f3e5572536e0492914fe251446bc9 inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd981c2779c70ec4c3fd5d8cc610925 inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">virtual USDGEOM_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#acbd981c2779c70ec4c3fd5d8cc610925">~UsdGeomImageable</a> ()</td></tr>
<tr class="memdesc:acbd981c2779c70ec4c3fd5d8cc610925 inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_usd_geom_imageable.html#acbd981c2779c70ec4c3fd5d8cc610925">More...</a><br /></td></tr>
<tr class="separator:acbd981c2779c70ec4c3fd5d8cc610925 inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943eddc325190bd67789407400f122b7 inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a943eddc325190bd67789407400f122b7">GetVisibilityAttr</a> () const</td></tr>
<tr class="memdesc:a943eddc325190bd67789407400f122b7 inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visibility is meant to be the simplest form of "pruning" visibility that is supported by most DCC apps.  <a href="class_usd_geom_imageable.html#a943eddc325190bd67789407400f122b7">More...</a><br /></td></tr>
<tr class="separator:a943eddc325190bd67789407400f122b7 inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d4959f4d99367dfa3a79a3371e278a inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a96d4959f4d99367dfa3a79a3371e278a">CreateVisibilityAttr</a> (<a class="el" href="class_vt_value.html">VtValue</a> const &amp;defaultValue=<a class="el" href="class_vt_value.html">VtValue</a>(), bool writeSparsely=false) const</td></tr>
<tr class="memdesc:a96d4959f4d99367dfa3a79a3371e278a inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_imageable.html#a943eddc325190bd67789407400f122b7" title="Visibility is meant to be the simplest form of &quot;pruning&quot; visibility that is supported by most DCC app...">GetVisibilityAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="class_usd_geom_imageable.html#a96d4959f4d99367dfa3a79a3371e278a">More...</a><br /></td></tr>
<tr class="separator:a96d4959f4d99367dfa3a79a3371e278a inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff531252fb2787a973eb028f2b04bdd inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#acff531252fb2787a973eb028f2b04bdd">GetPurposeAttr</a> () const</td></tr>
<tr class="memdesc:acff531252fb2787a973eb028f2b04bdd inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purpose is a classification of geometry into categories that can each be independently included or excluded from traversals of prims on a stage, such as rendering or bounding-box computation traversals.  <a href="class_usd_geom_imageable.html#acff531252fb2787a973eb028f2b04bdd">More...</a><br /></td></tr>
<tr class="separator:acff531252fb2787a973eb028f2b04bdd inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4f6685ac7cef1d8ef94c44586b84bc inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a3f4f6685ac7cef1d8ef94c44586b84bc">CreatePurposeAttr</a> (<a class="el" href="class_vt_value.html">VtValue</a> const &amp;defaultValue=<a class="el" href="class_vt_value.html">VtValue</a>(), bool writeSparsely=false) const</td></tr>
<tr class="memdesc:a3f4f6685ac7cef1d8ef94c44586b84bc inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_imageable.html#acff531252fb2787a973eb028f2b04bdd" title="Purpose is a classification of geometry into categories that can each be independently included or ex...">GetPurposeAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="class_usd_geom_imageable.html#a3f4f6685ac7cef1d8ef94c44586b84bc">More...</a><br /></td></tr>
<tr class="separator:a3f4f6685ac7cef1d8ef94c44586b84bc inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be4a4143e2b9f89f9bea44d27639a92 inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_relationship.html">UsdRelationship</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a5be4a4143e2b9f89f9bea44d27639a92">GetProxyPrimRel</a> () const</td></tr>
<tr class="memdesc:a5be4a4143e2b9f89f9bea44d27639a92 inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <em>proxyPrim</em> relationship allows us to link a prim whose <em>purpose</em> is "render" to its (single target) purpose="proxy" prim.  <a href="class_usd_geom_imageable.html#a5be4a4143e2b9f89f9bea44d27639a92">More...</a><br /></td></tr>
<tr class="separator:a5be4a4143e2b9f89f9bea44d27639a92 inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc2e3aa91cf892f7937cc46a2351472 inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_relationship.html">UsdRelationship</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#aafc2e3aa91cf892f7937cc46a2351472">CreateProxyPrimRel</a> () const</td></tr>
<tr class="memdesc:aafc2e3aa91cf892f7937cc46a2351472 inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_usd_geom_imageable.html#a5be4a4143e2b9f89f9bea44d27639a92" title="The proxyPrim relationship allows us to link a prim whose purpose is &quot;render&quot; to its (single target) ...">GetProxyPrimRel()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create.  <a href="class_usd_geom_imageable.html#aafc2e3aa91cf892f7937cc46a2351472">More...</a><br /></td></tr>
<tr class="separator:aafc2e3aa91cf892f7937cc46a2351472 inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd30c76b787e7e32180c1b454b971c7 inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a3fd30c76b787e7e32180c1b454b971c7">MakeVisible</a> (const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> &amp;time=<a class="el" href="class_usd_time_code.html#a8a2192045dc22e90fe08ef2d8d68f3b8">UsdTimeCode::Default</a>()) const</td></tr>
<tr class="memdesc:a3fd30c76b787e7e32180c1b454b971c7 inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the imageable visible if it is invisible at the given time.  <a href="class_usd_geom_imageable.html#a3fd30c76b787e7e32180c1b454b971c7">More...</a><br /></td></tr>
<tr class="separator:a3fd30c76b787e7e32180c1b454b971c7 inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91eda805326fd94cc9910cfaeb4ac4a0 inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a91eda805326fd94cc9910cfaeb4ac4a0">MakeInvisible</a> (const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> &amp;time=<a class="el" href="class_usd_time_code.html#a8a2192045dc22e90fe08ef2d8d68f3b8">UsdTimeCode::Default</a>()) const</td></tr>
<tr class="memdesc:a91eda805326fd94cc9910cfaeb4ac4a0 inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the imageable invisible if it is visible at the given time.  <a href="class_usd_geom_imageable.html#a91eda805326fd94cc9910cfaeb4ac4a0">More...</a><br /></td></tr>
<tr class="separator:a91eda805326fd94cc9910cfaeb4ac4a0 inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bfa1554d9b57303c14f71d084c578d inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#ac0bfa1554d9b57303c14f71d084c578d">ComputeVisibility</a> (<a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;time=<a class="el" href="class_usd_time_code.html#a8a2192045dc22e90fe08ef2d8d68f3b8">UsdTimeCode::Default</a>()) const</td></tr>
<tr class="memdesc:ac0bfa1554d9b57303c14f71d084c578d inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the effective visibility of this prim, as defined by its most ancestral authored "invisible" opinion, if any.  <a href="class_usd_geom_imageable.html#ac0bfa1554d9b57303c14f71d084c578d">More...</a><br /></td></tr>
<tr class="separator:ac0bfa1554d9b57303c14f71d084c578d inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfc306cddf0c522d39ba477e91ec161 inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a2dfc306cddf0c522d39ba477e91ec161">GetPurposeVisibilityAttr</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;purpose=<a class="el" href="usd_2usd_geom_2tokens_8h.html#ad9e3544e015f99ed697804fd6bfe1a88">UsdGeomTokens</a>-&gt;default_) const</td></tr>
<tr class="memdesc:a2dfc306cddf0c522d39ba477e91ec161 inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the attribute that is used for expressing visibility opinions for the given <code>purpose</code>.  <a href="class_usd_geom_imageable.html#a2dfc306cddf0c522d39ba477e91ec161">More...</a><br /></td></tr>
<tr class="separator:a2dfc306cddf0c522d39ba477e91ec161 inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1174d9985088dd364f6a56925073fe76 inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a1174d9985088dd364f6a56925073fe76">ComputeEffectiveVisibility</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;purpose=<a class="el" href="usd_2usd_geom_2tokens_8h.html#ad9e3544e015f99ed697804fd6bfe1a88">UsdGeomTokens</a>-&gt;default_, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> &amp;time=<a class="el" href="class_usd_time_code.html#a8a2192045dc22e90fe08ef2d8d68f3b8">UsdTimeCode::Default</a>()) const</td></tr>
<tr class="memdesc:a1174d9985088dd364f6a56925073fe76 inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the effective purpose visibility of this prim for the given <code>purpose</code>, taking into account opinions for the corresponding purpose attribute, along with overall visibility opinions.  <a href="class_usd_geom_imageable.html#a1174d9985088dd364f6a56925073fe76">More...</a><br /></td></tr>
<tr class="separator:a1174d9985088dd364f6a56925073fe76 inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7d61f7af1a02e095e6a8abcf8e641f inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="struct_usd_geom_imageable_1_1_purpose_info.html">PurposeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a2a7d61f7af1a02e095e6a8abcf8e641f">ComputePurposeInfo</a> () const</td></tr>
<tr class="memdesc:a2a7d61f7af1a02e095e6a8abcf8e641f inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the effective purpose information about this prim which includes final computed purpose value of the prim as well as whether the purpose value should be inherited by namespace children without their own purpose opinions.  <a href="class_usd_geom_imageable.html#a2a7d61f7af1a02e095e6a8abcf8e641f">More...</a><br /></td></tr>
<tr class="separator:a2a7d61f7af1a02e095e6a8abcf8e641f inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c5620a09313aa39cb0d79f492b340f inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="struct_usd_geom_imageable_1_1_purpose_info.html">PurposeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a00c5620a09313aa39cb0d79f492b340f">ComputePurposeInfo</a> (const <a class="el" href="struct_usd_geom_imageable_1_1_purpose_info.html">PurposeInfo</a> &amp;parentPurposeInfo) const</td></tr>
<tr class="memdesc:a00c5620a09313aa39cb0d79f492b340f inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Calculates the effective purpose information about this prim, given the computed purpose information of its parent prim.  <a href="class_usd_geom_imageable.html#a00c5620a09313aa39cb0d79f492b340f">More...</a><br /></td></tr>
<tr class="separator:a00c5620a09313aa39cb0d79f492b340f inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa2ea4240e7e12f11122d7ff8ad7f90 inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_tf_token.html">TfToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a1aa2ea4240e7e12f11122d7ff8ad7f90">ComputePurpose</a> () const</td></tr>
<tr class="memdesc:a1aa2ea4240e7e12f11122d7ff8ad7f90 inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the effective purpose information about this prim.  <a href="class_usd_geom_imageable.html#a1aa2ea4240e7e12f11122d7ff8ad7f90">More...</a><br /></td></tr>
<tr class="separator:a1aa2ea4240e7e12f11122d7ff8ad7f90 inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a114f3776eb75edc651e8c2d67f8ff inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_usd_prim.html">UsdPrim</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#ad5a114f3776eb75edc651e8c2d67f8ff">ComputeProxyPrim</a> (<a class="el" href="class_usd_prim.html">UsdPrim</a> *renderPrim=NULL) const</td></tr>
<tr class="memdesc:ad5a114f3776eb75edc651e8c2d67f8ff inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the prim whose purpose is <em>proxy</em> that serves as the proxy for this prim, as established by the <a class="el" href="class_usd_geom_imageable.html#a5be4a4143e2b9f89f9bea44d27639a92" title="The proxyPrim relationship allows us to link a prim whose purpose is &quot;render&quot; to its (single target) ...">GetProxyPrimRel()</a>, or an invalid <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> if this prim has no proxy.  <a href="class_usd_geom_imageable.html#ad5a114f3776eb75edc651e8c2d67f8ff">More...</a><br /></td></tr>
<tr class="separator:ad5a114f3776eb75edc651e8c2d67f8ff inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b808012a6a5bc9df34e794ff82bb6f0 inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a6b808012a6a5bc9df34e794ff82bb6f0">SetProxyPrim</a> (const <a class="el" href="class_usd_prim.html">UsdPrim</a> &amp;proxy) const</td></tr>
<tr class="memdesc:a6b808012a6a5bc9df34e794ff82bb6f0 inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for authoring the <em>renderProxy</em> rel on this prim to target the given <code>proxy</code> prim.  <a href="class_usd_geom_imageable.html#a6b808012a6a5bc9df34e794ff82bb6f0">More...</a><br /></td></tr>
<tr class="separator:a6b808012a6a5bc9df34e794ff82bb6f0 inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0c8b7faa4056a7267c586b2ffc0bd8 inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a8c0c8b7faa4056a7267c586b2ffc0bd8">SetProxyPrim</a> (const <a class="el" href="class_usd_schema_base.html">UsdSchemaBase</a> &amp;proxy) const</td></tr>
<tr class="separator:a8c0c8b7faa4056a7267c586b2ffc0bd8 inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae616043b0f7fbc631ef9e5c784132a6c inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_gf_b_box3d.html">GfBBox3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#ae616043b0f7fbc631ef9e5c784132a6c">ComputeWorldBound</a> (<a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;time, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;purpose1=<a class="el" href="class_tf_token.html">TfToken</a>(), <a class="el" href="class_tf_token.html">TfToken</a> const &amp;purpose2=<a class="el" href="class_tf_token.html">TfToken</a>(), <a class="el" href="class_tf_token.html">TfToken</a> const &amp;purpose3=<a class="el" href="class_tf_token.html">TfToken</a>(), <a class="el" href="class_tf_token.html">TfToken</a> const &amp;purpose4=<a class="el" href="class_tf_token.html">TfToken</a>()) const</td></tr>
<tr class="memdesc:ae616043b0f7fbc631ef9e5c784132a6c inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bound of this prim in world space, at the specified <code>time</code>, and for the specified purposes.  <a href="class_usd_geom_imageable.html#ae616043b0f7fbc631ef9e5c784132a6c">More...</a><br /></td></tr>
<tr class="separator:ae616043b0f7fbc631ef9e5c784132a6c inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503f6d39abbd1b62c3c55f227461334d inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_gf_b_box3d.html">GfBBox3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a503f6d39abbd1b62c3c55f227461334d">ComputeLocalBound</a> (<a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;time, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;purpose1=<a class="el" href="class_tf_token.html">TfToken</a>(), <a class="el" href="class_tf_token.html">TfToken</a> const &amp;purpose2=<a class="el" href="class_tf_token.html">TfToken</a>(), <a class="el" href="class_tf_token.html">TfToken</a> const &amp;purpose3=<a class="el" href="class_tf_token.html">TfToken</a>(), <a class="el" href="class_tf_token.html">TfToken</a> const &amp;purpose4=<a class="el" href="class_tf_token.html">TfToken</a>()) const</td></tr>
<tr class="memdesc:a503f6d39abbd1b62c3c55f227461334d inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bound of this prim in local space, at the specified <code>time</code>, and for the specified purposes.  <a href="class_usd_geom_imageable.html#a503f6d39abbd1b62c3c55f227461334d">More...</a><br /></td></tr>
<tr class="separator:a503f6d39abbd1b62c3c55f227461334d inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54086b2386d22b1de4aaeb5b3005533d inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_gf_b_box3d.html">GfBBox3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a54086b2386d22b1de4aaeb5b3005533d">ComputeUntransformedBound</a> (<a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;time, <a class="el" href="class_tf_token.html">TfToken</a> const &amp;purpose1=<a class="el" href="class_tf_token.html">TfToken</a>(), <a class="el" href="class_tf_token.html">TfToken</a> const &amp;purpose2=<a class="el" href="class_tf_token.html">TfToken</a>(), <a class="el" href="class_tf_token.html">TfToken</a> const &amp;purpose3=<a class="el" href="class_tf_token.html">TfToken</a>(), <a class="el" href="class_tf_token.html">TfToken</a> const &amp;purpose4=<a class="el" href="class_tf_token.html">TfToken</a>()) const</td></tr>
<tr class="memdesc:a54086b2386d22b1de4aaeb5b3005533d inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the untransformed bound of this prim, at the specified <code>time</code>, and for the specified purposes.  <a href="class_usd_geom_imageable.html#a54086b2386d22b1de4aaeb5b3005533d">More...</a><br /></td></tr>
<tr class="separator:a54086b2386d22b1de4aaeb5b3005533d inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3fb09253ba63d63921f665d63cd270 inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a8e3fb09253ba63d63921f665d63cd270">ComputeLocalToWorldTransform</a> (<a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;time) const</td></tr>
<tr class="memdesc:a8e3fb09253ba63d63921f665d63cd270 inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the transformation matrix for this prim at the given time, including the transform authored on the Prim itself, if present.  <a href="class_usd_geom_imageable.html#a8e3fb09253ba63d63921f665d63cd270">More...</a><br /></td></tr>
<tr class="separator:a8e3fb09253ba63d63921f665d63cd270 inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4313664fa692f724da56cc254bce70fc inherit pub_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a4313664fa692f724da56cc254bce70fc">ComputeParentToWorldTransform</a> (<a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;time) const</td></tr>
<tr class="memdesc:a4313664fa692f724da56cc254bce70fc inherit pub_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the transformation matrix for this prim at the given time, <em>NOT</em> including the transform authored on the prim itself.  <a href="class_usd_geom_imageable.html#a4313664fa692f724da56cc254bce70fc">More...</a><br /></td></tr>
<tr class="separator:a4313664fa692f724da56cc254bce70fc inherit pub_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_usd_typed"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_usd_typed')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_usd_typed.html">UsdTyped</a></td></tr>
<tr class="memitem:a0eedaa009a86f3b1186f709bc78d0c09 inherit pub_methods_class_usd_typed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_typed.html#a0eedaa009a86f3b1186f709bc78d0c09">UsdTyped</a> (const <a class="el" href="class_usd_prim.html">UsdPrim</a> &amp;prim=<a class="el" href="class_usd_prim.html">UsdPrim</a>())</td></tr>
<tr class="memdesc:a0eedaa009a86f3b1186f709bc78d0c09 inherit pub_methods_class_usd_typed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_usd_typed.html" title="The base class for all typed schemas (those that can impart a typeName to a UsdPrim),...">UsdTyped</a> on <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> <code>prim</code> .  <a href="class_usd_typed.html#a0eedaa009a86f3b1186f709bc78d0c09">More...</a><br /></td></tr>
<tr class="separator:a0eedaa009a86f3b1186f709bc78d0c09 inherit pub_methods_class_usd_typed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64de30966732c854c3c29616244e5250 inherit pub_methods_class_usd_typed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_typed.html#a64de30966732c854c3c29616244e5250">UsdTyped</a> (const <a class="el" href="class_usd_schema_base.html">UsdSchemaBase</a> &amp;schemaObj)</td></tr>
<tr class="memdesc:a64de30966732c854c3c29616244e5250 inherit pub_methods_class_usd_typed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_usd_typed.html" title="The base class for all typed schemas (those that can impart a typeName to a UsdPrim),...">UsdTyped</a> on the prim held by <code>schemaObj</code> .  <a href="class_usd_typed.html#a64de30966732c854c3c29616244e5250">More...</a><br /></td></tr>
<tr class="separator:a64de30966732c854c3c29616244e5250 inherit pub_methods_class_usd_typed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558859985aa8647bc068d590b5d9e08f inherit pub_methods_class_usd_typed"><td class="memItemLeft" align="right" valign="top">virtual USD_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_typed.html#a558859985aa8647bc068d590b5d9e08f">~UsdTyped</a> ()</td></tr>
<tr class="memdesc:a558859985aa8647bc068d590b5d9e08f inherit pub_methods_class_usd_typed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_usd_typed.html#a558859985aa8647bc068d590b5d9e08f">More...</a><br /></td></tr>
<tr class="separator:a558859985aa8647bc068d590b5d9e08f inherit pub_methods_class_usd_typed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_usd_schema_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_usd_schema_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_usd_schema_base.html">UsdSchemaBase</a></td></tr>
<tr class="memitem:ae2c90cefba1b2e09dc117a7d972009cb inherit pub_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#ae2c90cefba1b2e09dc117a7d972009cb">IsConcrete</a> () const</td></tr>
<tr class="memdesc:ae2c90cefba1b2e09dc117a7d972009cb inherit pub_methods_class_usd_schema_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this class corresponds to a concrete instantiable prim type in scene description.  <a href="class_usd_schema_base.html#ae2c90cefba1b2e09dc117a7d972009cb">More...</a><br /></td></tr>
<tr class="separator:ae2c90cefba1b2e09dc117a7d972009cb inherit pub_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa15659f4fa280e4c0772173d7471920 inherit pub_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#afa15659f4fa280e4c0772173d7471920">IsTyped</a> () const</td></tr>
<tr class="memdesc:afa15659f4fa280e4c0772173d7471920 inherit pub_methods_class_usd_schema_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this class inherits from <a class="el" href="class_usd_typed.html" title="The base class for all typed schemas (those that can impart a typeName to a UsdPrim),...">UsdTyped</a>.  <a href="class_usd_schema_base.html#afa15659f4fa280e4c0772173d7471920">More...</a><br /></td></tr>
<tr class="separator:afa15659f4fa280e4c0772173d7471920 inherit pub_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad658b6730d4246ee1f903ce4ce18fdfe inherit pub_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#ad658b6730d4246ee1f903ce4ce18fdfe">IsAPISchema</a> () const</td></tr>
<tr class="memdesc:ad658b6730d4246ee1f903ce4ce18fdfe inherit pub_methods_class_usd_schema_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this is an API schema or not.  <a href="class_usd_schema_base.html#ad658b6730d4246ee1f903ce4ce18fdfe">More...</a><br /></td></tr>
<tr class="separator:ad658b6730d4246ee1f903ce4ce18fdfe inherit pub_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e867971cc992c5b03e73725c405c05 inherit pub_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#a68e867971cc992c5b03e73725c405c05">IsAppliedAPISchema</a> () const</td></tr>
<tr class="memdesc:a68e867971cc992c5b03e73725c405c05 inherit pub_methods_class_usd_schema_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this is an applied API schema or not.  <a href="class_usd_schema_base.html#a68e867971cc992c5b03e73725c405c05">More...</a><br /></td></tr>
<tr class="separator:a68e867971cc992c5b03e73725c405c05 inherit pub_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af752510dea0c7106aa89832e60dfa3d5 inherit pub_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#af752510dea0c7106aa89832e60dfa3d5">IsMultipleApplyAPISchema</a> () const</td></tr>
<tr class="memdesc:af752510dea0c7106aa89832e60dfa3d5 inherit pub_methods_class_usd_schema_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this is an applied API schema or not.  <a href="class_usd_schema_base.html#af752510dea0c7106aa89832e60dfa3d5">More...</a><br /></td></tr>
<tr class="separator:af752510dea0c7106aa89832e60dfa3d5 inherit pub_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac68c5514faebb20c5ae3cb930170de inherit pub_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#aeac68c5514faebb20c5ae3cb930170de">GetSchemaKind</a> () const</td></tr>
<tr class="memdesc:aeac68c5514faebb20c5ae3cb930170de inherit pub_methods_class_usd_schema_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kind of schema this class is.  <a href="class_usd_schema_base.html#aeac68c5514faebb20c5ae3cb930170de">More...</a><br /></td></tr>
<tr class="separator:aeac68c5514faebb20c5ae3cb930170de inherit pub_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e0a9b0465ecf201fb501753baa8587 inherit pub_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top">USD_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#a32e0a9b0465ecf201fb501753baa8587">UsdSchemaBase</a> (const <a class="el" href="class_usd_prim.html">UsdPrim</a> &amp;prim=<a class="el" href="class_usd_prim.html">UsdPrim</a>())</td></tr>
<tr class="memdesc:a32e0a9b0465ecf201fb501753baa8587 inherit pub_methods_class_usd_schema_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and store <code>prim</code> as the held prim.  <a href="class_usd_schema_base.html#a32e0a9b0465ecf201fb501753baa8587">More...</a><br /></td></tr>
<tr class="separator:a32e0a9b0465ecf201fb501753baa8587 inherit pub_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73921308189043c86867d6bd9012b4af inherit pub_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top">USD_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#a73921308189043c86867d6bd9012b4af">UsdSchemaBase</a> (const <a class="el" href="class_usd_schema_base.html">UsdSchemaBase</a> &amp;otherSchema)</td></tr>
<tr class="memdesc:a73921308189043c86867d6bd9012b4af inherit pub_methods_class_usd_schema_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and store for the same prim held by <code>otherSchema</code>.  <a href="class_usd_schema_base.html#a73921308189043c86867d6bd9012b4af">More...</a><br /></td></tr>
<tr class="separator:a73921308189043c86867d6bd9012b4af inherit pub_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e97b9a7311478da9f2d168bea29560e inherit pub_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top">virtual USD_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#a3e97b9a7311478da9f2d168bea29560e">~UsdSchemaBase</a> ()</td></tr>
<tr class="memdesc:a3e97b9a7311478da9f2d168bea29560e inherit pub_methods_class_usd_schema_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_usd_schema_base.html#a3e97b9a7311478da9f2d168bea29560e">More...</a><br /></td></tr>
<tr class="separator:a3e97b9a7311478da9f2d168bea29560e inherit pub_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586531d84339318108c817f91367e626 inherit pub_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top">USD_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#a586531d84339318108c817f91367e626">operator bool</a> () const</td></tr>
<tr class="separator:a586531d84339318108c817f91367e626 inherit pub_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba10e023e7f3f3c93131bc7fc3146b7 inherit pub_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_usd_prim.html">UsdPrim</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#a4ba10e023e7f3f3c93131bc7fc3146b7">GetPrim</a> () const</td></tr>
<tr class="memdesc:a4ba10e023e7f3f3c93131bc7fc3146b7 inherit pub_methods_class_usd_schema_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this schema object's held prim.  <a href="class_usd_schema_base.html#a4ba10e023e7f3f3c93131bc7fc3146b7">More...</a><br /></td></tr>
<tr class="separator:a4ba10e023e7f3f3c93131bc7fc3146b7 inherit pub_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936bfb1e341cc81184c64af44763c433 inherit pub_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sdf_path.html">SdfPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#a936bfb1e341cc81184c64af44763c433">GetPath</a> () const</td></tr>
<tr class="memdesc:a936bfb1e341cc81184c64af44763c433 inherit pub_methods_class_usd_schema_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <a class="el" href="class_usd_schema_base.html#a4ba10e023e7f3f3c93131bc7fc3146b7" title="Return this schema object&#39;s held prim.">GetPrim()</a>-&gt;<a class="el" href="class_usd_schema_base.html#a936bfb1e341cc81184c64af44763c433" title="Shorthand for GetPrim()-&gt;GetPath().">GetPath()</a>.  <a href="class_usd_schema_base.html#a936bfb1e341cc81184c64af44763c433">More...</a><br /></td></tr>
<tr class="separator:a936bfb1e341cc81184c64af44763c433 inherit pub_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030d03e2a9839d9c3da0fbca8c3722d4 inherit pub_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top">USD_API const <a class="el" href="class_usd_prim_definition.html">UsdPrimDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#a030d03e2a9839d9c3da0fbca8c3722d4">GetSchemaClassPrimDefinition</a> () const</td></tr>
<tr class="memdesc:a030d03e2a9839d9c3da0fbca8c3722d4 inherit pub_methods_class_usd_schema_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the prim definition associated with this schema instance if one exists, otherwise return null.  <a href="class_usd_schema_base.html#a030d03e2a9839d9c3da0fbca8c3722d4">More...</a><br /></td></tr>
<tr class="separator:a030d03e2a9839d9c3da0fbca8c3722d4 inherit pub_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae40ae43320babff8a254a3a8107a255a"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API const <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#ae40ae43320babff8a254a3a8107a255a">GetSchemaAttributeNames</a> (bool includeInherited=true)</td></tr>
<tr class="memdesc:ae40ae43320babff8a254a3a8107a255a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of names of all pre-declared attributes for this schema class and all its ancestor classes.  <a href="#ae40ae43320babff8a254a3a8107a255a">More...</a><br /></td></tr>
<tr class="separator:ae40ae43320babff8a254a3a8107a255a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aecdc9be88ae26cc50c64756e37ce09"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API <a class="el" href="class_usd_geom_point_instancer.html">UsdGeomPointInstancer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a8aecdc9be88ae26cc50c64756e37ce09">Get</a> (const UsdStagePtr &amp;stage, const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path)</td></tr>
<tr class="memdesc:a8aecdc9be88ae26cc50c64756e37ce09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="class_usd_geom_point_instancer.html" title="Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters)...">UsdGeomPointInstancer</a> holding the prim adhering to this schema at <code>path</code> on <code>stage</code>.  <a href="#a8aecdc9be88ae26cc50c64756e37ce09">More...</a><br /></td></tr>
<tr class="separator:a8aecdc9be88ae26cc50c64756e37ce09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b13c0dce72dcf8af3f22df2bddd2f5a"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API <a class="el" href="class_usd_geom_point_instancer.html">UsdGeomPointInstancer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a9b13c0dce72dcf8af3f22df2bddd2f5a">Define</a> (const UsdStagePtr &amp;stage, const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path)</td></tr>
<tr class="memdesc:a9b13c0dce72dcf8af3f22df2bddd2f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to ensure a <em><a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a></em> adhering to this schema at <code>path</code> is defined (according to <a class="el" href="class_usd_prim.html#a87fbe0030c0fbb6307ee434664f1142f" title="Return true if this prim and all its ancestors have defining specifiers, false otherwise.">UsdPrim::IsDefined()</a>) on this stage.  <a href="#a9b13c0dce72dcf8af3f22df2bddd2f5a">More...</a><br /></td></tr>
<tr class="separator:a9b13c0dce72dcf8af3f22df2bddd2f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27aee7c27b72251b2dce9218ad12facd"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a27aee7c27b72251b2dce9218ad12facd">ComputeInstanceTransformsAtTime</a> (<a class="el" href="class_vt_array.html">VtArray</a>&lt; <a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a> &gt; *xforms, UsdStageWeakPtr &amp;stage, <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> time, const VtIntArray &amp;protoIndices, const VtVec3fArray &amp;positions, const VtVec3fArray &amp;velocities, <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> velocitiesSampleTime, const VtVec3fArray &amp;accelerations, const VtVec3fArray &amp;scales, const VtQuathArray &amp;orientations, const VtVec3fArray &amp;angularVelocities, <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> angularVelocitiesSampleTime, const SdfPathVector &amp;protoPaths, const std::vector&lt; bool &gt; &amp;mask, float velocityScale=1.0)</td></tr>
<tr class="memdesc:a27aee7c27b72251b2dce9218ad12facd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Perform the per-instance transform computation as described in <a class="el" href="class_usd_geom_point_instancer.html#UsdGeomPointInstancer_transform">Computing an Instance Transform</a> .  <a href="#a27aee7c27b72251b2dce9218ad12facd">More...</a><br /></td></tr>
<tr class="separator:a27aee7c27b72251b2dce9218ad12facd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_usd_geom_boundable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_usd_geom_boundable')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_usd_geom_boundable.html">UsdGeomBoundable</a></td></tr>
<tr class="memitem:ae40ae43320babff8a254a3a8107a255a inherit pub_static_methods_class_usd_geom_boundable"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API const <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_boundable.html#ae40ae43320babff8a254a3a8107a255a">GetSchemaAttributeNames</a> (bool includeInherited=true)</td></tr>
<tr class="memdesc:ae40ae43320babff8a254a3a8107a255a inherit pub_static_methods_class_usd_geom_boundable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of names of all pre-declared attributes for this schema class and all its ancestor classes.  <a href="class_usd_geom_boundable.html#ae40ae43320babff8a254a3a8107a255a">More...</a><br /></td></tr>
<tr class="separator:ae40ae43320babff8a254a3a8107a255a inherit pub_static_methods_class_usd_geom_boundable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c22f5ebc2dad00101664ca4b1ec743 inherit pub_static_methods_class_usd_geom_boundable"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API <a class="el" href="class_usd_geom_boundable.html">UsdGeomBoundable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_boundable.html#af0c22f5ebc2dad00101664ca4b1ec743">Get</a> (const UsdStagePtr &amp;stage, const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path)</td></tr>
<tr class="memdesc:af0c22f5ebc2dad00101664ca4b1ec743 inherit pub_static_methods_class_usd_geom_boundable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="class_usd_geom_boundable.html" title="Boundable introduces the ability for a prim to persistently cache a rectilinear, local-space,...">UsdGeomBoundable</a> holding the prim adhering to this schema at <code>path</code> on <code>stage</code>.  <a href="class_usd_geom_boundable.html#af0c22f5ebc2dad00101664ca4b1ec743">More...</a><br /></td></tr>
<tr class="separator:af0c22f5ebc2dad00101664ca4b1ec743 inherit pub_static_methods_class_usd_geom_boundable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413c9eb5b4e1d8fddd627cf33ed4a106 inherit pub_static_methods_class_usd_geom_boundable"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_boundable.html#a413c9eb5b4e1d8fddd627cf33ed4a106">ComputeExtentFromPlugins</a> (const <a class="el" href="class_usd_geom_boundable.html">UsdGeomBoundable</a> &amp;boundable, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> &amp;time, VtVec3fArray *extent)</td></tr>
<tr class="memdesc:a413c9eb5b4e1d8fddd627cf33ed4a106 inherit pub_static_methods_class_usd_geom_boundable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the extent for the Boundable prim <code>boundable</code> at time <code>time</code>.  <a href="class_usd_geom_boundable.html#a413c9eb5b4e1d8fddd627cf33ed4a106">More...</a><br /></td></tr>
<tr class="separator:a413c9eb5b4e1d8fddd627cf33ed4a106 inherit pub_static_methods_class_usd_geom_boundable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa34cebf9339958ad25099dd635c9c7 inherit pub_static_methods_class_usd_geom_boundable"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_boundable.html#a7fa34cebf9339958ad25099dd635c9c7">ComputeExtentFromPlugins</a> (const <a class="el" href="class_usd_geom_boundable.html">UsdGeomBoundable</a> &amp;boundable, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> &amp;time, const <a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a> &amp;transform, VtVec3fArray *extent)</td></tr>
<tr class="memdesc:a7fa34cebf9339958ad25099dd635c9c7 inherit pub_static_methods_class_usd_geom_boundable"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Computes the extent as if the matrix <code>transform</code> was first applied.  <a href="class_usd_geom_boundable.html#a7fa34cebf9339958ad25099dd635c9c7">More...</a><br /></td></tr>
<tr class="separator:a7fa34cebf9339958ad25099dd635c9c7 inherit pub_static_methods_class_usd_geom_boundable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_usd_geom_xformable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_usd_geom_xformable')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_usd_geom_xformable.html">UsdGeomXformable</a></td></tr>
<tr class="memitem:ae40ae43320babff8a254a3a8107a255a inherit pub_static_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API const <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#ae40ae43320babff8a254a3a8107a255a">GetSchemaAttributeNames</a> (bool includeInherited=true)</td></tr>
<tr class="memdesc:ae40ae43320babff8a254a3a8107a255a inherit pub_static_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of names of all pre-declared attributes for this schema class and all its ancestor classes.  <a href="class_usd_geom_xformable.html#ae40ae43320babff8a254a3a8107a255a">More...</a><br /></td></tr>
<tr class="separator:ae40ae43320babff8a254a3a8107a255a inherit pub_static_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad072bbfa1381c569964857648dbd2823 inherit pub_static_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API <a class="el" href="class_usd_geom_xformable.html">UsdGeomXformable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#ad072bbfa1381c569964857648dbd2823">Get</a> (const UsdStagePtr &amp;stage, const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path)</td></tr>
<tr class="memdesc:ad072bbfa1381c569964857648dbd2823 inherit pub_static_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable</a> holding the prim adhering to this schema at <code>path</code> on <code>stage</code>.  <a href="class_usd_geom_xformable.html#ad072bbfa1381c569964857648dbd2823">More...</a><br /></td></tr>
<tr class="separator:ad072bbfa1381c569964857648dbd2823 inherit pub_static_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab855f0ea37793df1f22d2bce3d68caff inherit pub_static_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#ab855f0ea37793df1f22d2bce3d68caff">GetTimeSamples</a> (std::vector&lt; <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a> &gt; const &amp;orderedXformOps, std::vector&lt; double &gt; *times)</td></tr>
<tr class="memdesc:ab855f0ea37793df1f22d2bce3d68caff inherit pub_static_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of all the timesamples at which the attributes belonging to the given <code>orderedXformOps</code> are authored.  <a href="class_usd_geom_xformable.html#ab855f0ea37793df1f22d2bce3d68caff">More...</a><br /></td></tr>
<tr class="separator:ab855f0ea37793df1f22d2bce3d68caff inherit pub_static_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582133c4e08813d891690f58497d4add inherit pub_static_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a582133c4e08813d891690f58497d4add">GetTimeSamplesInInterval</a> (std::vector&lt; <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a> &gt; const &amp;orderedXformOps, const <a class="el" href="class_gf_interval.html">GfInterval</a> &amp;interval, std::vector&lt; double &gt; *times)</td></tr>
<tr class="memdesc:a582133c4e08813d891690f58497d4add inherit pub_static_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of all the timesamples in the <code>interval</code> at which the attributes belonging to the given <code>orderedXformOps</code> are authored.  <a href="class_usd_geom_xformable.html#a582133c4e08813d891690f58497d4add">More...</a><br /></td></tr>
<tr class="separator:a582133c4e08813d891690f58497d4add inherit pub_static_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0838e193af826f5bbde3c274e9839ce inherit pub_static_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#ad0838e193af826f5bbde3c274e9839ce">GetLocalTransformation</a> (<a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a> *transform, std::vector&lt; <a class="el" href="class_usd_geom_xform_op.html">UsdGeomXformOp</a> &gt; const &amp;ops, const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> time)</td></tr>
<tr class="memdesc:ad0838e193af826f5bbde3c274e9839ce inherit pub_static_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This is a static version of the preceding function that takes a cached list of ordered xform ops.  <a href="class_usd_geom_xformable.html#ad0838e193af826f5bbde3c274e9839ce">More...</a><br /></td></tr>
<tr class="separator:ad0838e193af826f5bbde3c274e9839ce inherit pub_static_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb444654a8443f3413213cc526ee6c1a inherit pub_static_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#adb444654a8443f3413213cc526ee6c1a">IsTransformationAffectedByAttrNamed</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;attrName)</td></tr>
<tr class="memdesc:adb444654a8443f3413213cc526ee6c1a inherit pub_static_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the attribute named <code>attrName</code> could affect the local transformation of an xformable prim.  <a href="class_usd_geom_xformable.html#adb444654a8443f3413213cc526ee6c1a">More...</a><br /></td></tr>
<tr class="separator:adb444654a8443f3413213cc526ee6c1a inherit pub_static_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_usd_geom_imageable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_usd_geom_imageable')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_usd_geom_imageable.html">UsdGeomImageable</a></td></tr>
<tr class="memitem:ae40ae43320babff8a254a3a8107a255a inherit pub_static_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API const <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#ae40ae43320babff8a254a3a8107a255a">GetSchemaAttributeNames</a> (bool includeInherited=true)</td></tr>
<tr class="memdesc:ae40ae43320babff8a254a3a8107a255a inherit pub_static_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of names of all pre-declared attributes for this schema class and all its ancestor classes.  <a href="class_usd_geom_imageable.html#ae40ae43320babff8a254a3a8107a255a">More...</a><br /></td></tr>
<tr class="separator:ae40ae43320babff8a254a3a8107a255a inherit pub_static_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e431a573772ed7a37f3bc01181a230 inherit pub_static_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API <a class="el" href="class_usd_geom_imageable.html">UsdGeomImageable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a07e431a573772ed7a37f3bc01181a230">Get</a> (const UsdStagePtr &amp;stage, const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path)</td></tr>
<tr class="memdesc:a07e431a573772ed7a37f3bc01181a230 inherit pub_static_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="class_usd_geom_imageable.html" title="Base class for all prims that may require rendering or visualization of some sort.">UsdGeomImageable</a> holding the prim adhering to this schema at <code>path</code> on <code>stage</code>.  <a href="class_usd_geom_imageable.html#a07e431a573772ed7a37f3bc01181a230">More...</a><br /></td></tr>
<tr class="separator:a07e431a573772ed7a37f3bc01181a230 inherit pub_static_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d41ddd5b5d274785f4a109a7cebad5 inherit pub_static_methods_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">static USDGEOM_API const <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#ac7d41ddd5b5d274785f4a109a7cebad5">GetOrderedPurposeTokens</a> ()</td></tr>
<tr class="memdesc:ac7d41ddd5b5d274785f4a109a7cebad5 inherit pub_static_methods_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an ordered list of allowed values of the purpose attribute.  <a href="class_usd_geom_imageable.html#ac7d41ddd5b5d274785f4a109a7cebad5">More...</a><br /></td></tr>
<tr class="separator:ac7d41ddd5b5d274785f4a109a7cebad5 inherit pub_static_methods_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_usd_typed"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_usd_typed')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_usd_typed.html">UsdTyped</a></td></tr>
<tr class="memitem:a5988bc4012f6a54f866f883727b9ce10 inherit pub_static_methods_class_usd_typed"><td class="memItemLeft" align="right" valign="top">static USD_API const <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_typed.html#a5988bc4012f6a54f866f883727b9ce10">GetSchemaAttributeNames</a> (bool includeInherited=true)</td></tr>
<tr class="memdesc:a5988bc4012f6a54f866f883727b9ce10 inherit pub_static_methods_class_usd_typed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of names of all pre-declared attributes for this schema class and all its ancestor classes.  <a href="class_usd_typed.html#a5988bc4012f6a54f866f883727b9ce10">More...</a><br /></td></tr>
<tr class="separator:a5988bc4012f6a54f866f883727b9ce10 inherit pub_static_methods_class_usd_typed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e726cf0a1485bcdd18a01bf0ab6c368 inherit pub_static_methods_class_usd_typed"><td class="memItemLeft" align="right" valign="top">static USD_API <a class="el" href="class_usd_typed.html">UsdTyped</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_typed.html#a1e726cf0a1485bcdd18a01bf0ab6c368">Get</a> (const UsdStagePtr &amp;stage, const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;path)</td></tr>
<tr class="memdesc:a1e726cf0a1485bcdd18a01bf0ab6c368 inherit pub_static_methods_class_usd_typed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="class_usd_typed.html" title="The base class for all typed schemas (those that can impart a typeName to a UsdPrim),...">UsdTyped</a> holding the prim adhering to this schema at <code>path</code> on <code>stage</code>.  <a href="class_usd_typed.html#a1e726cf0a1485bcdd18a01bf0ab6c368">More...</a><br /></td></tr>
<tr class="separator:a1e726cf0a1485bcdd18a01bf0ab6c368 inherit pub_static_methods_class_usd_typed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_usd_schema_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_usd_schema_base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_usd_schema_base.html">UsdSchemaBase</a></td></tr>
<tr class="memitem:a47f45785a354d4ded0315458f4978980 inherit pub_static_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top"><a id="a47f45785a354d4ded0315458f4978980"></a>
static const <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSchemaAttributeNames</b> (bool includeInherited=true)</td></tr>
<tr class="separator:a47f45785a354d4ded0315458f4978980 inherit pub_static_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3e5fc43aea5aea4908c3ce980fdf8908"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a3e5fc43aea5aea4908c3ce980fdf8908">schemaKind</a> = <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741aa6650141c3d230f8e4e51461e1d9e645">UsdSchemaKind::ConcreteTyped</a></td></tr>
<tr class="memdesc:a3e5fc43aea5aea4908c3ce980fdf8908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant representing what kind of schema this class is.  <a href="#a3e5fc43aea5aea4908c3ce980fdf8908">More...</a><br /></td></tr>
<tr class="separator:a3e5fc43aea5aea4908c3ce980fdf8908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_class_usd_geom_boundable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_usd_geom_boundable')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_usd_geom_boundable.html">UsdGeomBoundable</a></td></tr>
<tr class="memitem:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_geom_boundable"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_boundable.html#a3e5fc43aea5aea4908c3ce980fdf8908">schemaKind</a> = <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741a033ea5f40e4407ad16629e9a769ac9c1">UsdSchemaKind::AbstractTyped</a></td></tr>
<tr class="memdesc:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_geom_boundable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant representing what kind of schema this class is.  <a href="class_usd_geom_boundable.html#a3e5fc43aea5aea4908c3ce980fdf8908">More...</a><br /></td></tr>
<tr class="separator:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_geom_boundable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_class_usd_geom_xformable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_usd_geom_xformable')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_usd_geom_xformable.html">UsdGeomXformable</a></td></tr>
<tr class="memitem:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a3e5fc43aea5aea4908c3ce980fdf8908">schemaKind</a> = <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741a033ea5f40e4407ad16629e9a769ac9c1">UsdSchemaKind::AbstractTyped</a></td></tr>
<tr class="memdesc:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant representing what kind of schema this class is.  <a href="class_usd_geom_xformable.html#a3e5fc43aea5aea4908c3ce980fdf8908">More...</a><br /></td></tr>
<tr class="separator:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_class_usd_geom_imageable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_usd_geom_imageable')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_usd_geom_imageable.html">UsdGeomImageable</a></td></tr>
<tr class="memitem:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_geom_imageable"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_imageable.html#a3e5fc43aea5aea4908c3ce980fdf8908">schemaKind</a> = <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741a033ea5f40e4407ad16629e9a769ac9c1">UsdSchemaKind::AbstractTyped</a></td></tr>
<tr class="memdesc:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_geom_imageable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant representing what kind of schema this class is.  <a href="class_usd_geom_imageable.html#a3e5fc43aea5aea4908c3ce980fdf8908">More...</a><br /></td></tr>
<tr class="separator:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_geom_imageable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_class_usd_typed"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_usd_typed')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_usd_typed.html">UsdTyped</a></td></tr>
<tr class="memitem:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_typed"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_typed.html#a3e5fc43aea5aea4908c3ce980fdf8908">schemaKind</a> = <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741a1823d42f4a7ead4b97d8c73167795ef8">UsdSchemaKind::AbstractBase</a></td></tr>
<tr class="memdesc:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_typed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant representing what kind of schema this class is.  <a href="class_usd_typed.html#a3e5fc43aea5aea4908c3ce980fdf8908">More...</a><br /></td></tr>
<tr class="separator:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_typed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_class_usd_schema_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_usd_schema_base')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_usd_schema_base.html">UsdSchemaBase</a></td></tr>
<tr class="memitem:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#a3e5fc43aea5aea4908c3ce980fdf8908">schemaKind</a> = <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741a1823d42f4a7ead4b97d8c73167795ef8">UsdSchemaKind::AbstractBase</a></td></tr>
<tr class="memdesc:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_schema_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant representing what kind of schema this class is.  <a href="class_usd_schema_base.html#a3e5fc43aea5aea4908c3ce980fdf8908">More...</a><br /></td></tr>
<tr class="separator:a3e5fc43aea5aea4908c3ce980fdf8908 inherit pub_static_attribs_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a71a1af4672754da617b8cb537f29c5f4"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a71a1af4672754da617b8cb537f29c5f4">_GetSchemaKind</a> () const override</td></tr>
<tr class="memdesc:a71a1af4672754da617b8cb537f29c5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kind of schema this class belongs to.  <a href="#a71a1af4672754da617b8cb537f29c5f4">More...</a><br /></td></tr>
<tr class="separator:a71a1af4672754da617b8cb537f29c5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_usd_geom_xformable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_usd_geom_xformable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_usd_geom_xformable.html">UsdGeomXformable</a></td></tr>
<tr class="memitem:a71a1af4672754da617b8cb537f29c5f4 inherit pro_methods_class_usd_geom_xformable"><td class="memItemLeft" align="right" valign="top">USDGEOM_API <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_xformable.html#a71a1af4672754da617b8cb537f29c5f4">_GetSchemaKind</a> () const override</td></tr>
<tr class="memdesc:a71a1af4672754da617b8cb537f29c5f4 inherit pro_methods_class_usd_geom_xformable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kind of schema this class belongs to.  <a href="class_usd_geom_xformable.html#a71a1af4672754da617b8cb537f29c5f4">More...</a><br /></td></tr>
<tr class="separator:a71a1af4672754da617b8cb537f29c5f4 inherit pro_methods_class_usd_geom_xformable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_usd_typed"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_usd_typed')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_usd_typed.html">UsdTyped</a></td></tr>
<tr class="memitem:ad91204cc9fb92f0306372e074052190f inherit pro_methods_class_usd_typed"><td class="memItemLeft" align="right" valign="top">USD_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_typed.html#ad91204cc9fb92f0306372e074052190f">_IsCompatible</a> () const override</td></tr>
<tr class="memdesc:ad91204cc9fb92f0306372e074052190f inherit pro_methods_class_usd_typed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclasses may override _IsCompatible to do specific compatibility checking with the given prim, such as type compatibility or value compatibility.  <a href="class_usd_typed.html#ad91204cc9fb92f0306372e074052190f">More...</a><br /></td></tr>
<tr class="separator:ad91204cc9fb92f0306372e074052190f inherit pro_methods_class_usd_typed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_usd_schema_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_usd_schema_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_usd_schema_base.html">UsdSchemaBase</a></td></tr>
<tr class="memitem:a6c51fb3251d5fde5ffa9fe7a998ce970 inherit pro_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_schema_base.html#a6c51fb3251d5fde5ffa9fe7a998ce970">_GetSchemaType</a> () const</td></tr>
<tr class="separator:a6c51fb3251d5fde5ffa9fe7a998ce970 inherit pro_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29ea4c951d8debfd8085a28c6aa80ca inherit pro_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top"><a id="aa29ea4c951d8debfd8085a28c6aa80ca"></a>
const <a class="el" href="class_tf_type.html">TfType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_GetType</b> () const</td></tr>
<tr class="separator:aa29ea4c951d8debfd8085a28c6aa80ca inherit pro_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99ec8284868478b50e8fc3475880dab inherit pro_methods_class_usd_schema_base"><td class="memItemLeft" align="right" valign="top"><a id="ad99ec8284868478b50e8fc3475880dab"></a>
USD_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_CreateAttr</b> (<a class="el" href="class_tf_token.html">TfToken</a> const &amp;attrName, <a class="el" href="class_sdf_value_type_name.html">SdfValueTypeName</a> const &amp;typeName, bool custom, <a class="el" href="usd_2sdf_2types_8h.html#a71cdb29b28ede8b72fcf36fa6f8d320f">SdfVariability</a> variability, <a class="el" href="class_vt_value.html">VtValue</a> const &amp;defaultValue, bool writeSparsely) const</td></tr>
<tr class="separator:ad99ec8284868478b50e8fc3475880dab inherit pro_methods_class_usd_schema_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aff8b8d83211f127c6c4cba48fb7d3334"><td class="memItemLeft" align="right" valign="top"><a id="aff8b8d83211f127c6c4cba48fb7d3334"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UsdSchemaRegistry</b></td></tr>
<tr class="separator:aff8b8d83211f127c6c4cba48fb7d3334"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Id-based Instance Masking/Pruning</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2a3e63a9539688cc2e46067a0e126b67"></a>See <a class="el" href="class_usd_geom_point_instancer.html#UsdGeomPointInstancer_masking">Masking Instances: "Deactivating" and Invising</a> </p>
</td></tr>
<tr class="memitem:a8c252eec2616b2d883a2db5b8b0f3d60"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a8c252eec2616b2d883a2db5b8b0f3d60">ActivateId</a> (int64_t id) const</td></tr>
<tr class="memdesc:a8c252eec2616b2d883a2db5b8b0f3d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the instance identified by <code>id</code> is active over all time.  <a href="#a8c252eec2616b2d883a2db5b8b0f3d60">More...</a><br /></td></tr>
<tr class="separator:a8c252eec2616b2d883a2db5b8b0f3d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fc012cd705f67c61c7d8e0f2df59df"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a20fc012cd705f67c61c7d8e0f2df59df">ActivateIds</a> (VtInt64Array const &amp;ids) const</td></tr>
<tr class="memdesc:a20fc012cd705f67c61c7d8e0f2df59df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the instances identified by <code>ids</code> are active over all time.  <a href="#a20fc012cd705f67c61c7d8e0f2df59df">More...</a><br /></td></tr>
<tr class="separator:a20fc012cd705f67c61c7d8e0f2df59df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dfcdcc6094dcfe1abf108fb491f75c"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a85dfcdcc6094dcfe1abf108fb491f75c">ActivateAllIds</a> () const</td></tr>
<tr class="memdesc:a85dfcdcc6094dcfe1abf108fb491f75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that all instances are active over all time.  <a href="#a85dfcdcc6094dcfe1abf108fb491f75c">More...</a><br /></td></tr>
<tr class="separator:a85dfcdcc6094dcfe1abf108fb491f75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62e7d7882ad88c1ed4f22328e91263c"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#af62e7d7882ad88c1ed4f22328e91263c">DeactivateId</a> (int64_t id) const</td></tr>
<tr class="memdesc:af62e7d7882ad88c1ed4f22328e91263c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the instance identified by <code>id</code> is inactive over all time.  <a href="#af62e7d7882ad88c1ed4f22328e91263c">More...</a><br /></td></tr>
<tr class="separator:af62e7d7882ad88c1ed4f22328e91263c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263554417f6a285d071fdfd85b725e23"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a263554417f6a285d071fdfd85b725e23">DeactivateIds</a> (VtInt64Array const &amp;ids) const</td></tr>
<tr class="memdesc:a263554417f6a285d071fdfd85b725e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the instances identified by <code>ids</code> are inactive over all time.  <a href="#a263554417f6a285d071fdfd85b725e23">More...</a><br /></td></tr>
<tr class="separator:a263554417f6a285d071fdfd85b725e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1ac95ca33821f69586590df694ee35"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#abf1ac95ca33821f69586590df694ee35">VisId</a> (int64_t id, <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;time) const</td></tr>
<tr class="memdesc:abf1ac95ca33821f69586590df694ee35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the instance identified by <code>id</code> is visible at <code>time</code>.  <a href="#abf1ac95ca33821f69586590df694ee35">More...</a><br /></td></tr>
<tr class="separator:abf1ac95ca33821f69586590df694ee35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1233046a057a7befb515aaa1b5fee9c6"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a1233046a057a7befb515aaa1b5fee9c6">VisIds</a> (VtInt64Array const &amp;ids, <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;time) const</td></tr>
<tr class="memdesc:a1233046a057a7befb515aaa1b5fee9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the instances identified by <code>ids</code> are visible at <code>time</code>.  <a href="#a1233046a057a7befb515aaa1b5fee9c6">More...</a><br /></td></tr>
<tr class="separator:a1233046a057a7befb515aaa1b5fee9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4d919761befd2ee076188f02419272"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a9a4d919761befd2ee076188f02419272">VisAllIds</a> (<a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;time) const</td></tr>
<tr class="memdesc:a9a4d919761befd2ee076188f02419272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that all instances are visible at <code>time</code>.  <a href="#a9a4d919761befd2ee076188f02419272">More...</a><br /></td></tr>
<tr class="separator:a9a4d919761befd2ee076188f02419272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc2315ea6be2e129f1732e6d33e363f"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a9cc2315ea6be2e129f1732e6d33e363f">InvisId</a> (int64_t id, <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;time) const</td></tr>
<tr class="memdesc:a9cc2315ea6be2e129f1732e6d33e363f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the instance identified by <code>id</code> is invisible at <code>time</code>.  <a href="#a9cc2315ea6be2e129f1732e6d33e363f">More...</a><br /></td></tr>
<tr class="separator:a9cc2315ea6be2e129f1732e6d33e363f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88b2c5d831432796b69d7b85bc39bd5"><td class="memItemLeft" align="right" valign="top">USDGEOM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#aa88b2c5d831432796b69d7b85bc39bd5">InvisIds</a> (VtInt64Array const &amp;ids, <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;time) const</td></tr>
<tr class="memdesc:aa88b2c5d831432796b69d7b85bc39bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the instances identified by <code>ids</code> are invisible at <code>time</code>.  <a href="#aa88b2c5d831432796b69d7b85bc39bd5">More...</a><br /></td></tr>
<tr class="separator:aa88b2c5d831432796b69d7b85bc39bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cd85f70313ba3118d2a7416d309d4a"><td class="memItemLeft" align="right" valign="top">USDGEOM_API std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#ac8cd85f70313ba3118d2a7416d309d4a">ComputeMaskAtTime</a> (<a class="el" href="class_usd_time_code.html">UsdTimeCode</a> time, VtInt64Array const *ids=nullptr) const</td></tr>
<tr class="memdesc:ac8cd85f70313ba3118d2a7416d309d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a presence mask to be applied to per-instance data arrays based on authored <em>inactiveIds</em>, <em>invisibleIds</em>, and <em>ids</em> .  <a href="#ac8cd85f70313ba3118d2a7416d309d4a">More...</a><br /></td></tr>
<tr class="separator:ac8cd85f70313ba3118d2a7416d309d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd64ffb5f621575fcc9c89c17c9c04a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4fd64ffb5f621575fcc9c89c17c9c04a"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_usd_geom_point_instancer.html#a4fd64ffb5f621575fcc9c89c17c9c04a">ApplyMaskToArray</a> (std::vector&lt; bool &gt; const &amp;mask, <a class="el" href="class_vt_array.html">VtArray</a>&lt; T &gt; *dataArray, const int elementSize=1)</td></tr>
<tr class="memdesc:a4fd64ffb5f621575fcc9c89c17c9c04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract <code>dataArray</code> in-place to contain only the elements whose index in <code>mask</code> is <code>true</code>.  <a href="#a4fd64ffb5f621575fcc9c89c17c9c04a">More...</a><br /></td></tr>
<tr class="separator:a4fd64ffb5f621575fcc9c89c17c9c04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters), which can be arbitrary prims/subtrees on a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a>. </p>
<p>PointInstancer is a "multi instancer", as it allows multiple prototypes to be scattered among its "points". We use a <a class="el" href="class_usd_relationship.html" title="A UsdRelationship creates dependencies between scenegraph objects by allowing a prim to target other ...">UsdRelationship</a> <em>prototypes</em> to identify and order all of the possible prototypes, by targeting the root prim of each prototype. The ordering imparted by relationships associates a zero-based integer with each prototype, and it is these integers we use to identify the prototype of each instance, compactly, and allowing prototypes to be swapped out without needing to reauthor all of the per-instance data.</p>
<p>The PointInstancer schema is designed to scale to billions of instances, which motivates the choice to split the per-instance transformation into position, (quaternion) orientation, and scales, rather than a 4x4 matrix per-instance. In addition to requiring fewer bytes even if all elements are authored (32 bytes vs 64 for a single-precision 4x4 matrix), we can also be selective about which attributes need to animate over time, for substantial data reduction in many cases.</p>
<p>Note that PointInstancer is <em>not</em> a Gprim, since it is not a graphical primitive by any stretch of the imagination. It <em>is</em>, however, Boundable, since we will sometimes want to treat the entire PointInstancer similarly to a procedural, from the perspective of inclusion or framing.</p>
<h1><a class="anchor" id="UsdGeomPointInstancer_varyingTopo"></a>
Varying Instance Identity over Time</h1>
<p>PointInstancers originating from simulations often have the characteristic that points/instances are "born", move around for some time period, and then die (or leave the area of interest). In such cases, billions of instances may be birthed over time, while at any <em>specific</em> time, only a much smaller number are actually alive. To encode this situation efficiently, the simulator may re-use indices in the instance arrays, when a particle dies, its index will be taken over by a new particle that may be birthed in a much different location. This presents challenges both for identity-tracking, and for motion-blur.</p>
<p>We facilitate identity tracking by providing an optional, animatable <em>ids</em> attribute, that specifies the 64 bit integer ID of the particle at each index, at each point in time. If the simulator keeps monotonically increasing a particle-count each time a new particle is birthed, it will serve perfectly as particle <em>ids</em>.</p>
<p>We facilitate motion blur for varying-topology particle streams by optionally allowing per-instance <em>velocities</em> and <em>angularVelocities</em> to be authored. If instance transforms are requested at a time between samples and either of the velocity attributes is authored, then we will not attempt to interpolate samples of <em>positions</em> or <em>orientations</em>. If not authored, and the bracketing samples have the same length, then we will interpolate.</p>
<h1><a class="anchor" id="UsdGeomPointInstancer_transform"></a>
Computing an Instance Transform</h1>
<p>Each instance's transformation is a combination of the SRT affine transform described by its scale, orientation, and position, applied <em>after</em> (i.e. less locally than) the local to parent transformation computed at the root of the prototype it is instancing.</p>
<p>If your processing of prototype geometry naturally takes into account the transform of the prototype root, then this term can be omitted from the computation of each instance transform, and this can be controlled when computing instance transformation matrices using the UsdGeomPointInstancer::PrototypeXformInclusion enumeration.</p>
<p>To understand the computation of the instance transform, in order to put an instance of a PointInstancer into the space of the PointInstancer's parent prim we do the following:</p>
<ol type="1">
<li>Apply (most locally) the authored local to parent transformation for <em>prototypes[protoIndices[i]]</em></li>
<li>If <em>scales</em> is authored, next apply the scaling matrix from <em>scales[i]</em></li>
<li>If <em>orientations</em> is authored: <b>if <em>angularVelocities</em> is authored</b>, first multiply <em>orientations[i]</em> by the unit quaternion derived by scaling <em>angularVelocities[i]</em> by the <a class="el" href="class_usd_geom_point_instancer.html#UsdGeom_PITimeScaling">time differential</a> from the left-bracketing timeSample for <em>orientation</em> to the requested evaluation time <em>t</em>, storing the result in <em>R</em>, <b>else</b> assign <em>R</em> directly from <em>orientations[i]</em>. Apply the rotation matrix derived from <em>R</em>.</li>
<li>Apply the translation derived from <em>positions[i]</em>. If <em>velocities</em> is authored, apply the translation deriving from <em>velocities[i]</em> scaled by the time differential from the left-bracketing timeSample for <em>positions</em> to the requested evaluation time <em>t</em>.</li>
<li>Least locally, apply the transformation authored on the PointInstancer prim itself (or the <a class="el" href="class_usd_geom_imageable.html#a8e3fb09253ba63d63921f665d63cd270" title="Compute the transformation matrix for this prim at the given time, including the transform authored o...">UsdGeomImageable::ComputeLocalToWorldTransform()</a> of the PointInstancer to put the instance directly into world space)</li>
</ol>
<p>If neither <em>velocities</em> nor <em>angularVelocities</em> are authored, we fallback to standard position and orientation computation logic (using linear interpolation between timeSamples) as described by <a class="el" href="usd_geom_page_front.html#UsdGeom_VelocityInterpolation">Applying Timesampled Velocities to Geometry</a> .</p>
<p><a class="anchor" id="UsdGeom_PITimeScaling"></a><b>Scaling Velocities for Interpolation</b></p>
<p>When computing time-differentials by which to apply velocity or angularVelocity to positions or orientations, we must scale by ( 1.0 / <a class="el" href="class_usd_stage.html#a85092d7455ae894d50224e761dc6e840" title="Returns the stage&#39;s timeCodesPerSecond value.">UsdStage::GetTimeCodesPerSecond()</a> ), because velocities are recorded in units/second, while we are interpolating in <a class="el" href="class_usd_time_code.html" title="Represent a time value, which may be either numeric, holding a double value, or a sentinel value UsdT...">UsdTimeCode</a> ordinates.</p>
<p>We provide both high and low-level API's for dealing with the transformation as a matrix, both will compute the instance matrices using multiple threads; the low-level API allows the client to cache unvarying inputs so that they need not be read duplicately when computing over time.</p>
<p>See also <a class="el" href="usd_geom_page_front.html#UsdGeom_VelocityInterpolation">Applying Timesampled Velocities to Geometry</a> .</p>
<h1><a class="anchor" id="UsdGeomPointInstancer_primvars"></a>
Primvars on PointInstancer</h1>
<p><a class="el" href="class_usd_geom_primvar.html">Primvars</a> authored on a PointInstancer prim should always be applied to each instance with <em>constant</em> interpolation at the root of the instance. When you are authoring primvars on a PointInstancer, think about it as if you were authoring them on a point-cloud (e.g. a <a class="el" href="class_usd_geom_points.html" title="Points are analogous to the RiPoints spec.">UsdGeomPoints</a> gprim). The same <a href="https://renderman.pixar.com/resources/RenderMan_20/appnote.22.html#classSpecifiers">interpolation rules for points</a> apply here, substituting "instance" for "point".</p>
<p>In other words, the (constant) value extracted for each instance from the authored primvar value depends on the authored <em>interpolation</em> and <em>elementSize</em> of the primvar, as follows: </p><ul>
<li><b>constant</b> or <b>uniform</b> : the entire authored value of the primvar should be applied exactly to each instance. </li>
<li><b>varying</b>, <b>vertex</b>, or <b>faceVarying</b>: the first <em>elementSize</em> elements of the authored primvar array should be assigned to instance zero, the second <em>elementSize</em> elements should be assigned to instance one, and so forth.</li>
</ul>
<h1><a class="anchor" id="UsdGeomPointInstancer_masking"></a>
Masking Instances: "Deactivating" and Invising</h1>
<p>Often a PointInstancer is created "upstream" in a graphics pipeline, and the needs of "downstream" clients necessitate eliminating some of the instances from further consideration. Accomplishing this pruning by re-authoring all of the per-instance attributes is not very attractive, since it may mean destructively editing a large quantity of data. We therefore provide means of "masking" instances by ID, such that the instance data is unmolested, but per-instance transform and primvar data can be retrieved with the no-longer-desired instances eliminated from the (smaller) arrays. PointInstancer allows two independent means of masking instances by ID, each with different features that meet the needs of various clients in a pipeline. Both pruning features' lists of ID's are combined to produce the mask returned by <a class="el" href="class_usd_geom_point_instancer.html#ac8cd85f70313ba3118d2a7416d309d4a" title="Computes a presence mask to be applied to per-instance data arrays based on authored inactiveIds,...">ComputeMaskAtTime()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If a PointInstancer has no authored <em>ids</em> attribute, the masking features will still be available, with the integers specifying element position in the <em>protoIndices</em> array rather than ID.</dd></dl>
<h2><a class="anchor" id="UsdGeomPointInstancer_inactiveIds"></a>
InactiveIds: List-edited, Unvarying Masking</h2>
<p>The first masking feature encodes a list of IDs in a list-editable metadatum called <em>inactiveIds</em>, which, although it does not have any similar impact to stage population as <a class="el" href="class_usd_prim.html#ac156eed30c42c013c4a4debf580ce17f">prim activation</a>, it shares with that feature that its application is uniform over all time. Because it is list-editable, we can <em>sparsely</em> add and remove instances from it in many layers.</p>
<p>This sparse application pattern makes <em>inactiveIds</em> a good choice when further downstream clients may need to reverse masking decisions made upstream, in a manner that is robust to many kinds of future changes to the upstream data.</p>
<p>See <a class="el" href="class_usd_geom_point_instancer.html#a8c252eec2616b2d883a2db5b8b0f3d60" title="Ensure that the instance identified by id is active over all time.">ActivateId()</a>, <a class="el" href="class_usd_geom_point_instancer.html#a20fc012cd705f67c61c7d8e0f2df59df" title="Ensure that the instances identified by ids are active over all time.">ActivateIds()</a>, <a class="el" href="class_usd_geom_point_instancer.html#af62e7d7882ad88c1ed4f22328e91263c" title="Ensure that the instance identified by id is inactive over all time.">DeactivateId()</a>, <a class="el" href="class_usd_geom_point_instancer.html#a263554417f6a285d071fdfd85b725e23" title="Ensure that the instances identified by ids are inactive over all time.">DeactivateIds()</a>, <a class="el" href="class_usd_geom_point_instancer.html#a85dfcdcc6094dcfe1abf108fb491f75c" title="Ensure that all instances are active over all time.">ActivateAllIds()</a></p>
<h2><a class="anchor" id="UsdGeomPointInstancer_invisibleIds"></a>
invisibleIds: Animatable Masking</h2>
<p>The second masking feature encodes a list of IDs in a time-varying Int64Array-valued <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> called <em>invisibleIds</em> , since it shares with <a class="el" href="class_usd_geom_imageable.html#a943eddc325190bd67789407400f122b7">Imageable visibility</a> the ability to animate object visibility.</p>
<p>Unlike <em>inactiveIds</em>, overriding a set of opinions for <em>invisibleIds</em> is not at all straightforward, because one will, in general need to reauthor (in the overriding layer) <b>all</b> timeSamples for the attribute just to change one Id's visibility state, so it cannot be authored sparsely. But it can be a very useful tool for situations like encoding pre-computed camera-frustum culling of geometry when either or both of the instances or the camera is animated.</p>
<p>See <a class="el" href="class_usd_geom_point_instancer.html#abf1ac95ca33821f69586590df694ee35" title="Ensure that the instance identified by id is visible at time.">VisId()</a>, <a class="el" href="class_usd_geom_point_instancer.html#a1233046a057a7befb515aaa1b5fee9c6" title="Ensure that the instances identified by ids are visible at time.">VisIds()</a>, <a class="el" href="class_usd_geom_point_instancer.html#a9cc2315ea6be2e129f1732e6d33e363f" title="Ensure that the instance identified by id is invisible at time.">InvisId()</a>, <a class="el" href="class_usd_geom_point_instancer.html#aa88b2c5d831432796b69d7b85bc39bd5" title="Ensure that the instances identified by ids are invisible at time.">InvisIds()</a>, <a class="el" href="class_usd_geom_point_instancer.html#a9a4d919761befd2ee076188f02419272" title="Ensure that all instances are visible at time.">VisAllIds()</a></p>
<h1><a class="anchor" id="UsdGeomPointInstancer_protoProcessing"></a>
Processing and Not Processing Prototypes</h1>
<p>Any prim in the scenegraph can be targeted as a prototype by the <em>prototypes</em> relationship. We do not, however, provide a specific mechanism for identifying prototypes as geometry that should not be drawn (or processed) in their own, local spaces in the scenegraph. We encourage organizing all prototypes as children of the PointInstancer prim that consumes them, and pruning "raw" processing and drawing traversals when they encounter a PointInstancer prim; this is what the <a class="el" href="class_usd_geom_b_box_cache.html" title="Caches bounds by recursively computing and aggregating bounds of children in world space and aggregat...">UsdGeomBBoxCache</a> and UsdImaging engines do.</p>
<p>There <em>is</em> a pattern one can deploy for organizing the prototypes such that they will automatically be skipped by basic <a class="el" href="class_usd_prim.html#a2619563fc9180d8ead597944fd7f6ec7" title="Return this prim&#39;s active, loaded, defined, non-abstract children as an iterable range.">UsdPrim::GetChildren()</a> or <a class="el" href="class_usd_prim_range.html" title="An forward-iterable range that traverses a subtree of prims rooted at a given prim in depth-first ord...">UsdPrimRange</a> traversals. Usd prims each have a <a class="el" href="_usd__page__properties_of_scene_description.html#Usd_PrimSpecifiers">specifier</a> of "def", "over", or "class". The default traversals skip over prims that are "pure overs" or classes. So to protect prototypes from all generic traversals and processing, place them under a prim that is just an "over". For example, </p><div class="fragment"><div class="line">01 def PointInstancer <span class="stringliteral">&quot;Crowd_Mid&quot;</span></div><div class="line">02 {</div><div class="line">03     rel prototypes = [ &lt;/Crowd_Mid/Prototypes/MaleThin_Business&gt;, &lt;/Crowd_Mid/Prototypes/MaleThin_Casual&gt; ]</div><div class="line">04     </div><div class="line">05     over <span class="stringliteral">&quot;Prototypes&quot;</span> </div><div class="line">06     {</div><div class="line">07          def <span class="stringliteral">&quot;MaleThin_Business&quot;</span> (</div><div class="line">08              references = [@MaleGroupA/usd/MaleGroupA.usd@&lt;/MaleGroupA&gt;]</div><div class="line">09              variants = {</div><div class="line">10                  <span class="keywordtype">string</span> modelingVariant = <span class="stringliteral">&quot;Thin&quot;</span></div><div class="line">11                  <span class="keywordtype">string</span> costumeVariant = <span class="stringliteral">&quot;BusinessAttire&quot;</span></div><div class="line">12              }</div><div class="line">13          )</div><div class="line">14          { ... }</div><div class="line">15          </div><div class="line">16          def <span class="stringliteral">&quot;MaleThin_Casual&quot;</span></div><div class="line">17          ...</div><div class="line">18     }</div><div class="line">19 }</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="point_instancer_8h_source.html#l00278">278</a> of file <a class="el" href="point_instancer_8h_source.html">pointInstancer.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa2257e2db6d6aea4856489ceece508a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2257e2db6d6aea4856489ceece508a8">&#9670;&nbsp;</a></span>MaskApplication</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_usd_geom_point_instancer.html#aa2257e2db6d6aea4856489ceece508a8">MaskApplication</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes whether to evaluate and apply the PointInstancer's mask to computed results. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_geom_point_instancer.html#ac8cd85f70313ba3118d2a7416d309d4a" title="Computes a presence mask to be applied to per-instance data arrays based on authored inactiveIds,...">ComputeMaskAtTime()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa2257e2db6d6aea4856489ceece508a8a4b4edcf3676c20fc90a1367af05379d1"></a>ApplyMask&#160;</td><td class="fielddoc"><p>Compute and apply the PointInstancer mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa2257e2db6d6aea4856489ceece508a8ab749281e998b40f076ace0c021d8ec9e"></a>IgnoreMask&#160;</td><td class="fielddoc"><p>Ignore the PointInstancer mask. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="point_instancer_8h_source.html#l00811">811</a> of file <a class="el" href="point_instancer_8h_source.html">pointInstancer.h</a>.</p>

</div>
</div>
<a id="aa184c49dc6b24efa4d160c1fe505a403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa184c49dc6b24efa4d160c1fe505a403">&#9670;&nbsp;</a></span>ProtoXformInclusion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_usd_geom_point_instancer.html#aa184c49dc6b24efa4d160c1fe505a403">ProtoXformInclusion</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes whether to include each prototype's root prim's transformation as the most-local component of computed instance transforms. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa184c49dc6b24efa4d160c1fe505a403afddf3d32b5aaf5e37ad0caa2a5b2b8ff"></a>IncludeProtoXform&#160;</td><td class="fielddoc"><p>Include the transform on the proto's root. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa184c49dc6b24efa4d160c1fe505a403a56a11959aa28115d253d01e56f1bdf1c"></a>ExcludeProtoXform&#160;</td><td class="fielddoc"><p>Exclude the transform on the proto's root. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="point_instancer_8h_source.html#l00800">800</a> of file <a class="el" href="point_instancer_8h_source.html">pointInstancer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af3d9eb4de0568b41fb590380e0ebf73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d9eb4de0568b41fb590380e0ebf73f">&#9670;&nbsp;</a></span>UsdGeomPointInstancer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_usd_geom_point_instancer.html">UsdGeomPointInstancer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_usd_prim.html">UsdPrim</a> &amp;&#160;</td>
          <td class="paramname"><em>prim</em> = <code><a class="el" href="class_usd_prim.html">UsdPrim</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_usd_geom_point_instancer.html" title="Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters)...">UsdGeomPointInstancer</a> on <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> <code>prim</code> . </p>
<p>Equivalent to <a class="el" href="class_usd_geom_point_instancer.html#a8aecdc9be88ae26cc50c64756e37ce09" title="Return a UsdGeomPointInstancer holding the prim adhering to this schema at path on stage.">UsdGeomPointInstancer::Get</a>(prim.GetStage(), prim.GetPath()) for a <em>valid</em> <code>prim</code>, but will not immediately throw an error for an invalid <code>prim</code> </p>

<p class="definition">Definition at line <a class="el" href="point_instancer_8h_source.html#l00290">290</a> of file <a class="el" href="point_instancer_8h_source.html">pointInstancer.h</a>.</p>

</div>
</div>
<a id="a43e3a5ff1c51841ac28393aa253b8dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e3a5ff1c51841ac28393aa253b8dd2">&#9670;&nbsp;</a></span>UsdGeomPointInstancer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_usd_geom_point_instancer.html">UsdGeomPointInstancer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_usd_schema_base.html">UsdSchemaBase</a> &amp;&#160;</td>
          <td class="paramname"><em>schemaObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_usd_geom_point_instancer.html" title="Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters)...">UsdGeomPointInstancer</a> on the prim held by <code>schemaObj</code> . </p>
<p>Should be preferred over <a class="el" href="class_usd_geom_point_instancer.html" title="Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters)...">UsdGeomPointInstancer</a>(schemaObj.GetPrim()), as it preserves SchemaBase state. </p>

<p class="definition">Definition at line <a class="el" href="point_instancer_8h_source.html#l00298">298</a> of file <a class="el" href="point_instancer_8h_source.html">pointInstancer.h</a>.</p>

</div>
</div>
<a id="a5f5a2f45d599d277dcffec23e73f863c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5a2f45d599d277dcffec23e73f863c">&#9670;&nbsp;</a></span>~UsdGeomPointInstancer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual USDGEOM_API ~<a class="el" href="class_usd_geom_point_instancer.html">UsdGeomPointInstancer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a71a1af4672754da617b8cb537f29c5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a1af4672754da617b8cb537f29c5f4">&#9670;&nbsp;</a></span>_GetSchemaKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a> _GetSchemaKind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the kind of schema this class belongs to. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741" title="An enum representing which kind of schema a given schema class belongs to.">UsdSchemaKind</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_usd_geom_boundable.html#a71a1af4672754da617b8cb537f29c5f4">UsdGeomBoundable</a>.</p>

</div>
</div>
<a id="a85dfcdcc6094dcfe1abf108fb491f75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85dfcdcc6094dcfe1abf108fb491f75c">&#9670;&nbsp;</a></span>ActivateAllIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool ActivateAllIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that all instances are active over all time. </p>
<p>This does not guarantee that the instances will be rendered, because each may still be "invisible" due to its presence in the <em>invisibleIds</em> attribute (see <a class="el" href="class_usd_geom_point_instancer.html#abf1ac95ca33821f69586590df694ee35" title="Ensure that the instance identified by id is visible at time.">VisId()</a>, <a class="el" href="class_usd_geom_point_instancer.html#a9cc2315ea6be2e129f1732e6d33e363f" title="Ensure that the instance identified by id is invisible at time.">InvisId()</a>) </p>

</div>
</div>
<a id="a8c252eec2616b2d883a2db5b8b0f3d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c252eec2616b2d883a2db5b8b0f3d60">&#9670;&nbsp;</a></span>ActivateId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool ActivateId </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that the instance identified by <code>id</code> is active over all time. </p>
<p>This activation is encoded sparsely, affecting no other instances.</p>
<p>This does not guarantee that the instance will be rendered, because it may still be "invisible" due to <code>id</code> being present in the <em>invisibleIds</em> attribute (see <a class="el" href="class_usd_geom_point_instancer.html#abf1ac95ca33821f69586590df694ee35" title="Ensure that the instance identified by id is visible at time.">VisId()</a>, <a class="el" href="class_usd_geom_point_instancer.html#a9cc2315ea6be2e129f1732e6d33e363f" title="Ensure that the instance identified by id is invisible at time.">InvisId()</a>) </p>

</div>
</div>
<a id="a20fc012cd705f67c61c7d8e0f2df59df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fc012cd705f67c61c7d8e0f2df59df">&#9670;&nbsp;</a></span>ActivateIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool ActivateIds </td>
          <td>(</td>
          <td class="paramtype">VtInt64Array const &amp;&#160;</td>
          <td class="paramname"><em>ids</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that the instances identified by <code>ids</code> are active over all time. </p>
<p>This activation is encoded sparsely, affecting no other instances.</p>
<p>This does not guarantee that the instances will be rendered, because each may still be "invisible" due to its presence in the <em>invisibleIds</em> attribute (see <a class="el" href="class_usd_geom_point_instancer.html#abf1ac95ca33821f69586590df694ee35" title="Ensure that the instance identified by id is visible at time.">VisId()</a>, <a class="el" href="class_usd_geom_point_instancer.html#a9cc2315ea6be2e129f1732e6d33e363f" title="Ensure that the instance identified by id is invisible at time.">InvisId()</a>) </p>

</div>
</div>
<a id="a4fd64ffb5f621575fcc9c89c17c9c04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd64ffb5f621575fcc9c89c17c9c04a">&#9670;&nbsp;</a></span>ApplyMaskToArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ApplyMaskToArray </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vt_array.html">VtArray</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>dataArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>elementSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contract <code>dataArray</code> in-place to contain only the elements whose index in <code>mask</code> is <code>true</code>. </p>
<dl class="section note"><dt>Note</dt><dd>an empty <code>mask</code> specifies "all pass", in which case <code>dataArray</code> is trivially unmodified</dd></dl>
<ul>
<li>It is an error for <code>dataArray</code> to be NULL .</li>
<li>If <em>elementSize</em> times <em>mask.size()</em> does not equal <em>dataArray-&gt;size()</em>, warn and fail.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_geom_point_instancer.html#ac8cd85f70313ba3118d2a7416d309d4a" title="Computes a presence mask to be applied to per-instance data arrays based on authored inactiveIds,...">ComputeMaskAtTime()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="point_instancer_8h_source.html#l01114">1114</a> of file <a class="el" href="point_instancer_8h_source.html">pointInstancer.h</a>.</p>

</div>
</div>
<a id="a93d339584167e16e1f38aa2f9c95476c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d339584167e16e1f38aa2f9c95476c">&#9670;&nbsp;</a></span>ComputeExtentAtTime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool ComputeExtentAtTime </td>
          <td>(</td>
          <td class="paramtype">VtVec3fArray *&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a>&#160;</td>
          <td class="paramname"><em>baseTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the extent of the point instancer based on the per-instance, "PointInstancer relative" transforms at <code>time</code>, as described in <a class="el" href="class_usd_geom_point_instancer.html#UsdGeomPointInstancer_transform">Computing an Instance Transform</a> . </p>
<p>If there is no error, we return <code>true</code> and <code>extent</code> will be the tightest bounds we can compute efficiently. If an error occurs, <code>false</code> will be returned and <code>extent</code> will be left untouched.</p>
<p>For now, this uses a <a class="el" href="class_usd_geom_b_box_cache.html" title="Caches bounds by recursively computing and aggregating bounds of children in world space and aggregat...">UsdGeomBBoxCache</a> with the "default", "proxy", and "render" purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>- the out parameter for the extent. On success, it will contain two elements representing the min and max. </td></tr>
    <tr><td class="paramname">time</td><td>- <a class="el" href="class_usd_time_code.html" title="Represent a time value, which may be either numeric, holding a double value, or a sentinel value UsdT...">UsdTimeCode</a> at which we want to evaluate the extent </td></tr>
    <tr><td class="paramname">baseTime</td><td>- required for correct interpolation between samples when <em>velocities</em> or <em>angularVelocities</em> are present. If there are samples for <em>positions</em> and <em>velocities</em> at t1 and t2, normal value resolution would attempt to interpolate between the two samples, and if they could not be interpolated because they differ in size (common in cases where velocity is authored), will choose the sample at t1. When sampling for the purposes of motion-blur, for example, it is common, when rendering the frame at t2, to sample at [ t2-shutter/2, t2+shutter/2 ] for a shutter interval of <em>shutter</em>. The first sample falls between t1 and t2, but we must sample at t2 and apply velocity-based interpolation based on those samples to get a correct result. In such scenarios, one should provide a <code>baseTime</code> of t2 when querying <em>both</em> samples. If your application does not care about off-sample interpolation, it can supply the same value for <code>baseTime</code> that it does for <code>time</code>. When <code>baseTime</code> is less than or equal to <code>time</code>, we will choose the lower bracketing timeSample. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a273cc4b4b5e2adf815d7e5ae6c6b2023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273cc4b4b5e2adf815d7e5ae6c6b2023">&#9670;&nbsp;</a></span>ComputeExtentAtTime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool ComputeExtentAtTime </td>
          <td>(</td>
          <td class="paramtype">VtVec3fArray *&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a>&#160;</td>
          <td class="paramname"><em>baseTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Computes the extent as if the matrix <code>transform</code> was first applied. </p>

</div>
</div>
<a id="ac3c01e24e2adbf6c1521771f8357da57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c01e24e2adbf6c1521771f8357da57">&#9670;&nbsp;</a></span>ComputeExtentAtTimes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool ComputeExtentAtTimes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; VtVec3fArray &gt; *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a>&#160;</td>
          <td class="paramname"><em>baseTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the extent of the point instancer as in <a class="el" href="class_usd_geom_point_instancer.html#a93d339584167e16e1f38aa2f9c95476c">ComputeExtentAtTime</a> , but across multiple <code>times</code> . </p>
<p>This is equivalent to, but more efficient than, calling ComputeExtentAtTime several times. Each element in <code>extents</code> is the computed extent at the corresponding time in <code>times</code> .</p>
<p>As in <a class="el" href="class_usd_geom_point_instancer.html#a93d339584167e16e1f38aa2f9c95476c">ComputeExtentAtTime</a>, if there is no error, we return <code>true</code> and <code>extents</code> will be the tightest bounds we can compute efficiently. If an error occurs computing the extent at any time, <code>false</code> will be returned and <code>extents</code> will be left untouched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">times</td><td>- A vector containing the UsdTimeCodes at which we want to sample. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70faad65f77bbaa27dff8c133da7d6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70faad65f77bbaa27dff8c133da7d6ba">&#9670;&nbsp;</a></span>ComputeExtentAtTimes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool ComputeExtentAtTimes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; VtVec3fArray &gt; *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a>&#160;</td>
          <td class="paramname"><em>baseTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Computes the extent as if the matrix <code>transform</code> was first applied at each time. </p>

</div>
</div>
<a id="a619b5f21f6c0fc26e6bd25c86c82b390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619b5f21f6c0fc26e6bd25c86c82b390">&#9670;&nbsp;</a></span>ComputeInstanceTransformsAtTime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool ComputeInstanceTransformsAtTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_array.html">VtArray</a>&lt; <a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a> &gt; *&#160;</td>
          <td class="paramname"><em>xforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a>&#160;</td>
          <td class="paramname"><em>baseTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_geom_point_instancer.html#aa184c49dc6b24efa4d160c1fe505a403">ProtoXformInclusion</a>&#160;</td>
          <td class="paramname"><em>doProtoXforms</em> = <code><a class="el" href="class_usd_geom_point_instancer.html#aa184c49dc6b24efa4d160c1fe505a403afddf3d32b5aaf5e37ad0caa2a5b2b8ff">IncludeProtoXform</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_geom_point_instancer.html#aa2257e2db6d6aea4856489ceece508a8">MaskApplication</a>&#160;</td>
          <td class="paramname"><em>applyMask</em> = <code><a class="el" href="class_usd_geom_point_instancer.html#aa2257e2db6d6aea4856489ceece508a8a4b4edcf3676c20fc90a1367af05379d1">ApplyMask</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the per-instance, "PointInstancer relative" transforms given the positions, scales, orientations, velocities and angularVelocities at <code>time</code>, as described in <a class="el" href="class_usd_geom_point_instancer.html#UsdGeomPointInstancer_transform">Computing an Instance Transform</a> . </p>
<p>This will return <code>false</code> and leave <code>xforms</code> untouched if:</p><ul>
<li><code>xforms</code> is NULL</li>
<li>one of <code>time</code> and <code>baseTime</code> is numeric and the other is <a class="el" href="class_usd_time_code.html#a8a2192045dc22e90fe08ef2d8d68f3b8" title="Produce a UsdTimeCode representing the sentinel value for &#39;default&#39;.">UsdTimeCode::Default()</a> (they must either both be numeric or both be default)</li>
<li>there is no authored <em>protoIndices</em> attribute or <em>positions</em> attribute</li>
<li>the size of any of the per-instance attributes does not match the size of <em>protoIndices</em> </li>
<li><code>doProtoXforms</code> is <code>IncludeProtoXform</code> but an index value in <em>protoIndices</em> is outside the range [0, prototypes.size())</li>
<li><code>applyMask</code> is <code>ApplyMask</code> and a mask is set but the size of the mask does not match the size of <em>protoIndices</em>.</li>
</ul>
<p>If there is no error, we will return <code>true</code> and <code>xforms</code> will contain the computed transformations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xforms</td><td>- the out parameter for the transformations. Its size will depend on the authored data and <code>applyMask</code> </td></tr>
    <tr><td class="paramname">time</td><td>- <a class="el" href="class_usd_time_code.html" title="Represent a time value, which may be either numeric, holding a double value, or a sentinel value UsdT...">UsdTimeCode</a> at which we want to evaluate the transforms </td></tr>
    <tr><td class="paramname">baseTime</td><td>- required for correct interpolation between samples when <em>velocities</em> or <em>angularVelocities</em> are present. If there are samples for <em>positions</em> and <em>velocities</em> at t1 and t2, normal value resolution would attempt to interpolate between the two samples, and if they could not be interpolated because they differ in size (common in cases where velocity is authored), will choose the sample at t1. When sampling for the purposes of motion-blur, for example, it is common, when rendering the frame at t2, to sample at [ t2-shutter/2, t2+shutter/2 ] for a shutter interval of <em>shutter</em>. The first sample falls between t1 and t2, but we must sample at t2 and apply velocity-based interpolation based on those samples to get a correct result. In such scenarios, one should provide a <code>baseTime</code> of t2 when querying <em>both</em> samples. If your application does not care about off-sample interpolation, it can supply the same value for <code>baseTime</code> that it does for <code>time</code>. When <code>baseTime</code> is less than or equal to <code>time</code>, we will choose the lower bracketing timeSample. Selecting sample times with respect to baseTime will be performed independently for positions and orientations. </td></tr>
    <tr><td class="paramname">doProtoXforms</td><td>- specifies whether to include the root transformation of each instance's prototype in the instance's transform. Default is to include it, but some clients may want to apply the proto transform as part of the prototype itself, so they can specify <code>ExcludeProtoXform</code> instead. </td></tr>
    <tr><td class="paramname">applyMask</td><td>- specifies whether to apply <a class="el" href="class_usd_geom_point_instancer.html#a4fd64ffb5f621575fcc9c89c17c9c04a" title="Contract dataArray in-place to contain only the elements whose index in mask is true.">ApplyMaskToArray()</a> to the computed result. The default is <code>ApplyMask</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27aee7c27b72251b2dce9218ad12facd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27aee7c27b72251b2dce9218ad12facd">&#9670;&nbsp;</a></span>ComputeInstanceTransformsAtTime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USDGEOM_API bool ComputeInstanceTransformsAtTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_array.html">VtArray</a>&lt; <a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a> &gt; *&#160;</td>
          <td class="paramname"><em>xforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UsdStageWeakPtr &amp;&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_time_code.html">UsdTimeCode</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VtIntArray &amp;&#160;</td>
          <td class="paramname"><em>protoIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VtVec3fArray &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VtVec3fArray &amp;&#160;</td>
          <td class="paramname"><em>velocities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_time_code.html">UsdTimeCode</a>&#160;</td>
          <td class="paramname"><em>velocitiesSampleTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VtVec3fArray &amp;&#160;</td>
          <td class="paramname"><em>accelerations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VtVec3fArray &amp;&#160;</td>
          <td class="paramname"><em>scales</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VtQuathArray &amp;&#160;</td>
          <td class="paramname"><em>orientations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VtVec3fArray &amp;&#160;</td>
          <td class="paramname"><em>angularVelocities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_time_code.html">UsdTimeCode</a>&#160;</td>
          <td class="paramname"><em>angularVelocitiesSampleTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SdfPathVector &amp;&#160;</td>
          <td class="paramname"><em>protoPaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>velocityScale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Perform the per-instance transform computation as described in <a class="el" href="class_usd_geom_point_instancer.html#UsdGeomPointInstancer_transform">Computing an Instance Transform</a> . </p>
<p>This does the same computation as the non-static ComputeInstanceTransformsAtTime method, but takes all data as parameters rather than accessing authored data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xforms</td><td>- the out parameter for the transformations. Its size will depend on the given data and <code>applyMask</code> </td></tr>
    <tr><td class="paramname">stage</td><td>- the <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> </td></tr>
    <tr><td class="paramname">time</td><td>- time at which we want to evaluate the transforms </td></tr>
    <tr><td class="paramname">protoIndices</td><td>- array containing all instance prototype indices. </td></tr>
    <tr><td class="paramname">positions</td><td>- array containing all instance positions. This array must be the same size as <code>protoIndices</code> . </td></tr>
    <tr><td class="paramname">velocities</td><td>- array containing all instance velocities. This array must be either the same size as <code>protoIndices</code> or empty. If it is empty, transforms are computed as if all velocities were zero in all dimensions. </td></tr>
    <tr><td class="paramname">velocitiesSampleTime</td><td>- time at which the samples from <code>velocities</code> were taken. </td></tr>
    <tr><td class="paramname">accelerations</td><td>- array containing all instance accelerations. This array must be either the same size as <code>protoIndicesor</code> empty. If it is empty, transforms are computed as if all accelerations were zero in all dimensions. </td></tr>
    <tr><td class="paramname">scales</td><td>- array containing all instance scales. This array must be either the same size as <code>protoIndices</code> or empty. If it is empty, transforms are computed with no change in scale. </td></tr>
    <tr><td class="paramname">orientations</td><td>- array containing all instance orientations. This array must be either the same size as <code>protoIndices</code> or empty. If it is empty, transforms are computed with no change in orientation </td></tr>
    <tr><td class="paramname">angularVelocities</td><td>- array containing all instance angular velocities. This array must be either the same size as <code>protoIndices</code> or empty. If it is empty, transforms are computed as if all angular velocities were zero in all dimensions. </td></tr>
    <tr><td class="paramname">angularVelocitiesSampleTime</td><td>- time at which the samples from <code>angularVelocities</code> were taken. </td></tr>
    <tr><td class="paramname">protoPaths</td><td>- array containing the paths for all instance prototypes. If this array is not empty, prototype transforms are applied to the instance transforms. </td></tr>
    <tr><td class="paramname">mask</td><td>- vector containing a mask to apply to the computed result. This vector must be either the same size as <code>protoIndices</code> or empty. If it is empty, no mask is applied. </td></tr>
    <tr><td class="paramname">velocityScale</td><td>- </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000081">Deprecated:</a></b></dt><dd>. </dd></dl>

</div>
</div>
<a id="a8468b44a2996504b0caa828e7414b68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8468b44a2996504b0caa828e7414b68f">&#9670;&nbsp;</a></span>ComputeInstanceTransformsAtTimes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool ComputeInstanceTransformsAtTimes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vt_array.html">VtArray</a>&lt; <a class="el" href="class_gf_matrix4d.html">GfMatrix4d</a> &gt;&gt; *&#160;</td>
          <td class="paramname"><em>xformsArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_usd_time_code.html">UsdTimeCode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_time_code.html">UsdTimeCode</a>&#160;</td>
          <td class="paramname"><em>baseTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_geom_point_instancer.html#aa184c49dc6b24efa4d160c1fe505a403">ProtoXformInclusion</a>&#160;</td>
          <td class="paramname"><em>doProtoXforms</em> = <code><a class="el" href="class_usd_geom_point_instancer.html#aa184c49dc6b24efa4d160c1fe505a403afddf3d32b5aaf5e37ad0caa2a5b2b8ff">IncludeProtoXform</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_usd_geom_point_instancer.html#aa2257e2db6d6aea4856489ceece508a8">MaskApplication</a>&#160;</td>
          <td class="paramname"><em>applyMask</em> = <code><a class="el" href="class_usd_geom_point_instancer.html#aa2257e2db6d6aea4856489ceece508a8a4b4edcf3676c20fc90a1367af05379d1">ApplyMask</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the per-instance transforms as in ComputeInstanceTransformsAtTime, but using multiple sample times. </p>
<p>An array of matrix arrays is returned where each matrix array contains the instance transforms for the corresponding time in <code>times</code> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">times</td><td>- A vector containing the UsdTimeCodes at which we want to sample. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8cd85f70313ba3118d2a7416d309d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cd85f70313ba3118d2a7416d309d4a">&#9670;&nbsp;</a></span>ComputeMaskAtTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API std::vector&lt;bool&gt; ComputeMaskAtTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_usd_time_code.html">UsdTimeCode</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VtInt64Array const *&#160;</td>
          <td class="paramname"><em>ids</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a presence mask to be applied to per-instance data arrays based on authored <em>inactiveIds</em>, <em>invisibleIds</em>, and <em>ids</em> . </p>
<p>If no <em>ids</em> attribute has been authored, then the values in <em>inactiveIds</em> and <em>invisibleIds</em> will be interpreted directly as indices of <em>protoIndices</em> .</p>
<p>If <code>ids</code> is non-NULL, it is assumed to be the id-mapping to apply, and must match the length of <em>protoIndices</em> at <code>time</code> . If NULL, we will call <a class="el" href="class_usd_geom_point_instancer.html#ab649953d4c84eae16d2b821bc3627b3a" title="Ids are optional; if authored, the ids array should be the same length as the protoIndices array,...">GetIdsAttr()</a>.Get(time)</p>
<dl class="section note"><dt>Note</dt><dd>If all "live" instances at <a class="el" href="class_usd_time_code.html" title="Represent a time value, which may be either numeric, holding a double value, or a sentinel value UsdT...">UsdTimeCode</a> <code>time</code> pass the mask, we will return an <b>empty</b> mask so that clients can trivially recognize the common "no masking" case.</dd></dl>
<p>The returned mask can be used with <a class="el" href="class_usd_geom_point_instancer.html#a4fd64ffb5f621575fcc9c89c17c9c04a" title="Contract dataArray in-place to contain only the elements whose index in mask is true.">ApplyMaskToArray()</a>, and will contain a <code>true</code> value for every element that should survive. </p>

</div>
</div>
<a id="ae13702eda2c800254bc40d3948420457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13702eda2c800254bc40d3948420457">&#9670;&nbsp;</a></span>CreateAccelerationsAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> CreateAccelerationsAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> const &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code><a class="el" href="class_vt_value.html">VtValue</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeSparsely</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_usd_geom_point_instancer.html#abf4df1035f2f759d5119392f94a73626" title="If authored, per-instance &#39;accelerations&#39; will be used with velocities to compute positions between s...">GetAccelerationsAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create. </p>
<p>If specified, author <code>defaultValue</code> as the attribute's default, sparsely (when it makes sense to do so) if <code>writeSparsely</code> is <code>true</code> - the default for <code>writeSparsely</code> is <code>false</code>. </p>

</div>
</div>
<a id="a26932e7a9f211578f436a14683ac58c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26932e7a9f211578f436a14683ac58c1">&#9670;&nbsp;</a></span>CreateAngularVelocitiesAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> CreateAngularVelocitiesAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> const &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code><a class="el" href="class_vt_value.html">VtValue</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeSparsely</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_usd_geom_point_instancer.html#af98bc3fe0a980a0fb0d5a67e6b4901f2" title="If authored, per-instance angular velocity vector to be used for interoplating orientations.">GetAngularVelocitiesAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create. </p>
<p>If specified, author <code>defaultValue</code> as the attribute's default, sparsely (when it makes sense to do so) if <code>writeSparsely</code> is <code>true</code> - the default for <code>writeSparsely</code> is <code>false</code>. </p>

</div>
</div>
<a id="a836153b8fed90436fea28a1ff0de5966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836153b8fed90436fea28a1ff0de5966">&#9670;&nbsp;</a></span>CreateIdsAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> CreateIdsAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> const &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code><a class="el" href="class_vt_value.html">VtValue</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeSparsely</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_usd_geom_point_instancer.html#ab649953d4c84eae16d2b821bc3627b3a" title="Ids are optional; if authored, the ids array should be the same length as the protoIndices array,...">GetIdsAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create. </p>
<p>If specified, author <code>defaultValue</code> as the attribute's default, sparsely (when it makes sense to do so) if <code>writeSparsely</code> is <code>true</code> - the default for <code>writeSparsely</code> is <code>false</code>. </p>

</div>
</div>
<a id="abab7826296b1bb8d647439f5bb6f5167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab7826296b1bb8d647439f5bb6f5167">&#9670;&nbsp;</a></span>CreateInvisibleIdsAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> CreateInvisibleIdsAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> const &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code><a class="el" href="class_vt_value.html">VtValue</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeSparsely</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_usd_geom_point_instancer.html#a4ccd01db405d601c5cc12645d1f9a8d3" title="A list of id&#39;s to make invisible at the evaluation time.">GetInvisibleIdsAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create. </p>
<p>If specified, author <code>defaultValue</code> as the attribute's default, sparsely (when it makes sense to do so) if <code>writeSparsely</code> is <code>true</code> - the default for <code>writeSparsely</code> is <code>false</code>. </p>

</div>
</div>
<a id="a8dc7993e9c906a2b4ad227140604be5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc7993e9c906a2b4ad227140604be5b">&#9670;&nbsp;</a></span>CreateOrientationsAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> CreateOrientationsAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> const &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code><a class="el" href="class_vt_value.html">VtValue</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeSparsely</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_usd_geom_point_instancer.html#ada5000a8b2f38c6d4b3ea550a91aa069" title="If authored, per-instance orientation of each instance about its prototype&#39;s origin,...">GetOrientationsAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create. </p>
<p>If specified, author <code>defaultValue</code> as the attribute's default, sparsely (when it makes sense to do so) if <code>writeSparsely</code> is <code>true</code> - the default for <code>writeSparsely</code> is <code>false</code>. </p>

</div>
</div>
<a id="a187eb8f0aeb00ec937c0516aec82dfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187eb8f0aeb00ec937c0516aec82dfe8">&#9670;&nbsp;</a></span>CreatePositionsAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> CreatePositionsAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> const &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code><a class="el" href="class_vt_value.html">VtValue</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeSparsely</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_usd_geom_point_instancer.html#a30684ce10025f54b6b9fdab13700ae99" title="Required property.">GetPositionsAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create. </p>
<p>If specified, author <code>defaultValue</code> as the attribute's default, sparsely (when it makes sense to do so) if <code>writeSparsely</code> is <code>true</code> - the default for <code>writeSparsely</code> is <code>false</code>. </p>

</div>
</div>
<a id="a87c07674a5ce95e00b87e1d4e70b047d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c07674a5ce95e00b87e1d4e70b047d">&#9670;&nbsp;</a></span>CreateProtoIndicesAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> CreateProtoIndicesAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> const &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code><a class="el" href="class_vt_value.html">VtValue</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeSparsely</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_usd_geom_point_instancer.html#a1f0a46b50806ce1922c5ebd03ad94bd6" title="Required property.">GetProtoIndicesAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create. </p>
<p>If specified, author <code>defaultValue</code> as the attribute's default, sparsely (when it makes sense to do so) if <code>writeSparsely</code> is <code>true</code> - the default for <code>writeSparsely</code> is <code>false</code>. </p>

</div>
</div>
<a id="afec51385816998f993b365e6a2266150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec51385816998f993b365e6a2266150">&#9670;&nbsp;</a></span>CreatePrototypesRel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_relationship.html">UsdRelationship</a> CreatePrototypesRel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_usd_geom_point_instancer.html#a612b93e2bca96a78c93967a20555bb3d" title="Required property.">GetPrototypesRel()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create. </p>

</div>
</div>
<a id="a4b02522ca738f4b1801f8a7a6b061240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b02522ca738f4b1801f8a7a6b061240">&#9670;&nbsp;</a></span>CreateScalesAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> CreateScalesAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> const &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code><a class="el" href="class_vt_value.html">VtValue</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeSparsely</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_usd_geom_point_instancer.html#a0b0e562b36e2413ba95616bd4eed98a5" title="If authored, per-instance scale to be applied to each instance, before any rotation is applied.">GetScalesAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create. </p>
<p>If specified, author <code>defaultValue</code> as the attribute's default, sparsely (when it makes sense to do so) if <code>writeSparsely</code> is <code>true</code> - the default for <code>writeSparsely</code> is <code>false</code>. </p>

</div>
</div>
<a id="aaf96c3a4bc0546725bc50c23067b7d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf96c3a4bc0546725bc50c23067b7d1a">&#9670;&nbsp;</a></span>CreateVelocitiesAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> CreateVelocitiesAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> const &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code><a class="el" href="class_vt_value.html">VtValue</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeSparsely</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_usd_geom_point_instancer.html#a2840a996c8a768ecea390147390dc222" title="If provided, per-instance &#39;velocities&#39; will be used to compute positions between samples for the &#39;pos...">GetVelocitiesAttr()</a>, and also <a class="el" href="_usd__page__common_idioms.html#Usd_Create_Or_Get_Property">Create vs Get Property Methods</a> for when to use Get vs Create. </p>
<p>If specified, author <code>defaultValue</code> as the attribute's default, sparsely (when it makes sense to do so) if <code>writeSparsely</code> is <code>true</code> - the default for <code>writeSparsely</code> is <code>false</code>. </p>

</div>
</div>
<a id="af62e7d7882ad88c1ed4f22328e91263c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62e7d7882ad88c1ed4f22328e91263c">&#9670;&nbsp;</a></span>DeactivateId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool DeactivateId </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that the instance identified by <code>id</code> is inactive over all time. </p>
<p>This deactivation is encoded sparsely, affecting no other instances.</p>
<p>A deactivated instance is guaranteed not to render if the renderer honors masking. </p>

</div>
</div>
<a id="a263554417f6a285d071fdfd85b725e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263554417f6a285d071fdfd85b725e23">&#9670;&nbsp;</a></span>DeactivateIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool DeactivateIds </td>
          <td>(</td>
          <td class="paramtype">VtInt64Array const &amp;&#160;</td>
          <td class="paramname"><em>ids</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that the instances identified by <code>ids</code> are inactive over all time. </p>
<p>This deactivation is encoded sparsely, affecting no other instances.</p>
<p>A deactivated instance is guaranteed not to render if the renderer honors masking. </p>

</div>
</div>
<a id="a9b13c0dce72dcf8af3f22df2bddd2f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b13c0dce72dcf8af3f22df2bddd2f5a">&#9670;&nbsp;</a></span>Define()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USDGEOM_API <a class="el" href="class_usd_geom_point_instancer.html">UsdGeomPointInstancer</a> Define </td>
          <td>(</td>
          <td class="paramtype">const UsdStagePtr &amp;&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to ensure a <em><a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a></em> adhering to this schema at <code>path</code> is defined (according to <a class="el" href="class_usd_prim.html#a87fbe0030c0fbb6307ee434664f1142f" title="Return true if this prim and all its ancestors have defining specifiers, false otherwise.">UsdPrim::IsDefined()</a>) on this stage. </p>
<p>If a prim adhering to this schema at <code>path</code> is already defined on this stage, return that prim. Otherwise author an <em><a class="el" href="class_sdf_prim_spec.html" title="Represents a prim description in an SdfLayer object.">SdfPrimSpec</a></em> with <em>specifier</em> == <em>SdfSpecifierDef</em> and this schema's prim type name for the prim at <code>path</code> at the current EditTarget. Author <em><a class="el" href="class_sdf_prim_spec.html" title="Represents a prim description in an SdfLayer object.">SdfPrimSpec</a></em> s with <code>specifier</code> == <em>SdfSpecifierDef</em> and empty typeName at the current EditTarget for any nonexistent, or existing but not <em>Defined</em> ancestors.</p>
<p>The given <em>path</em> must be an absolute prim path that does not contain any variant selections.</p>
<p>If it is impossible to author any of the necessary PrimSpecs, (for example, in case <em>path</em> cannot map to the current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a>'s namespace) issue an error and return an invalid <em><a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a></em>.</p>
<p>Note that this method may return a defined prim whose typeName does not specify this schema class, in case a stronger typeName opinion overrides the opinion at the current EditTarget. </p>

</div>
</div>
<a id="a8aecdc9be88ae26cc50c64756e37ce09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aecdc9be88ae26cc50c64756e37ce09">&#9670;&nbsp;</a></span>Get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USDGEOM_API <a class="el" href="class_usd_geom_point_instancer.html">UsdGeomPointInstancer</a> Get </td>
          <td>(</td>
          <td class="paramtype">const UsdStagePtr &amp;&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sdf_path.html">SdfPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <a class="el" href="class_usd_geom_point_instancer.html" title="Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters)...">UsdGeomPointInstancer</a> holding the prim adhering to this schema at <code>path</code> on <code>stage</code>. </p>
<p>If no prim exists at <code>path</code> on <code>stage</code>, or if the prim at that path does not adhere to this schema, return an invalid schema object. This is shorthand for the following:</p>
<div class="fragment"><div class="line"><a class="code" href="class_usd_geom_point_instancer.html#af3d9eb4de0568b41fb590380e0ebf73f">UsdGeomPointInstancer</a>(stage-&gt;GetPrimAtPath(path));</div></div><!-- fragment --> 
</div>
</div>
<a id="abf4df1035f2f759d5119392f94a73626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4df1035f2f759d5119392f94a73626">&#9670;&nbsp;</a></span>GetAccelerationsAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> GetAccelerationsAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If authored, per-instance 'accelerations' will be used with velocities to compute positions between samples for the 'positions' attribute rather than interpolating between neighboring 'positions' samples. </p>
<p>Acceleration is measured in position units per second-squared. To convert to position units per squared <a class="el" href="class_usd_time_code.html" title="Represent a time value, which may be either numeric, holding a double value, or a sentinel value UsdT...">UsdTimeCode</a>, divide by the square of <a class="el" href="class_usd_stage.html#a85092d7455ae894d50224e761dc6e840" title="Returns the stage&#39;s timeCodesPerSecond value.">UsdStage::GetTimeCodesPerSecond()</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone" colspan="2"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Declaration  </td><td class="markdownTableBodyNone"><code>vector3f[] accelerations</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">C++ Type  </td><td class="markdownTableBodyNone"><a class="el" href="class_vt_array.html">VtArray&lt;GfVec3f&gt;</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_usd__page__datatypes.html#Usd_Datatypes">Usd Type</a>  </td><td class="markdownTableBodyNone">SdfValueTypeNames-&gt;Vector3fArray   </td></tr>
</table>

</div>
</div>
<a id="af98bc3fe0a980a0fb0d5a67e6b4901f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98bc3fe0a980a0fb0d5a67e6b4901f2">&#9670;&nbsp;</a></span>GetAngularVelocitiesAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> GetAngularVelocitiesAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If authored, per-instance angular velocity vector to be used for interoplating orientations. </p>
<p>Angular velocities should be considered mandatory if both <em>protoIndices</em> and <em>orientations</em> are animated. Angular velocity is measured in <b>degrees</b> per second. To convert to degrees per <a class="el" href="class_usd_time_code.html" title="Represent a time value, which may be either numeric, holding a double value, or a sentinel value UsdT...">UsdTimeCode</a>, divide by <a class="el" href="class_usd_stage.html#a85092d7455ae894d50224e761dc6e840" title="Returns the stage&#39;s timeCodesPerSecond value.">UsdStage::GetTimeCodesPerSecond()</a>.</p>
<p>See also <a class="el" href="class_usd_geom_point_instancer.html#UsdGeomPointInstancer_transform">Computing an Instance Transform</a> .</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone" colspan="2"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Declaration  </td><td class="markdownTableBodyNone"><code>vector3f[] angularVelocities</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">C++ Type  </td><td class="markdownTableBodyNone"><a class="el" href="class_vt_array.html">VtArray&lt;GfVec3f&gt;</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_usd__page__datatypes.html#Usd_Datatypes">Usd Type</a>  </td><td class="markdownTableBodyNone">SdfValueTypeNames-&gt;Vector3fArray   </td></tr>
</table>

</div>
</div>
<a id="ab649953d4c84eae16d2b821bc3627b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab649953d4c84eae16d2b821bc3627b3a">&#9670;&nbsp;</a></span>GetIdsAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> GetIdsAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ids are optional; if authored, the ids array should be the same length as the <em>protoIndices</em> array, specifying (at each timeSample if instance identities are changing) the id of each instance. </p>
<p>The type is signed intentionally, so that clients can encode some binary state on Id'd instances without adding a separate primvar. See also <a class="el" href="class_usd_geom_point_instancer.html#UsdGeomPointInstancer_varyingTopo">Varying Instance Identity over Time</a></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone" colspan="2"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Declaration  </td><td class="markdownTableBodyNone"><code>int64[] ids</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">C++ Type  </td><td class="markdownTableBodyNone">VtArray&lt;int64_t&gt;   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_usd__page__datatypes.html#Usd_Datatypes">Usd Type</a>  </td><td class="markdownTableBodyNone">SdfValueTypeNames-&gt;Int64Array   </td></tr>
</table>

</div>
</div>
<a id="a94eab71913905f429534a527af9a7006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94eab71913905f429534a527af9a7006">&#9670;&nbsp;</a></span>GetInstanceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API size_t GetInstanceCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_usd_time_code.html">UsdTimeCode</a>&#160;</td>
          <td class="paramname"><em>timeCode</em> = <code><a class="el" href="class_usd_time_code.html#a8a2192045dc22e90fe08ef2d8d68f3b8">UsdTimeCode::Default</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of instances as defined by the size of the <em>protoIndices</em> array at <em>timeCode</em>. </p>
<p><dl class="section note"><dt>Note</dt><dd>For most code, this check will be performant. When using file formats where the cost of attribute reading is high and the time sampled array will be read into memory later, it may be better to explicitly read the value once and check the size of the array directly. </dd></dl>
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_usd_geom_point_instancer.html#a1f0a46b50806ce1922c5ebd03ad94bd6" title="Required property.">GetProtoIndicesAttr()</a> </dd></dl>

</div>
</div>
<a id="a4ccd01db405d601c5cc12645d1f9a8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccd01db405d601c5cc12645d1f9a8d3">&#9670;&nbsp;</a></span>GetInvisibleIdsAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> GetInvisibleIdsAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of id's to make invisible at the evaluation time. </p>
<p>See <a class="el" href="class_usd_geom_point_instancer.html#UsdGeomPointInstancer_invisibleIds">invisibleIds: Animatable Masking</a> .</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone" colspan="2"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Declaration  </td><td class="markdownTableBodyNone"><code>int64[] invisibleIds = []</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">C++ Type  </td><td class="markdownTableBodyNone">VtArray&lt;int64_t&gt;   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_usd__page__datatypes.html#Usd_Datatypes">Usd Type</a>  </td><td class="markdownTableBodyNone">SdfValueTypeNames-&gt;Int64Array   </td></tr>
</table>

</div>
</div>
<a id="ada5000a8b2f38c6d4b3ea550a91aa069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5000a8b2f38c6d4b3ea550a91aa069">&#9670;&nbsp;</a></span>GetOrientationsAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> GetOrientationsAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If authored, per-instance orientation of each instance about its prototype's origin, represented as a unit length quaternion, which allows us to encode it with sufficient precision in a compact <a class="el" href="class_gf_quath.html" title="Basic type: a quaternion, a complex number with a real coefficient and three imaginary coefficients,...">GfQuath</a>. </p>
<p>It is client's responsibility to ensure that authored quaternions are unit length; the convenience API below for authoring orientations from rotation matrices will ensure that quaternions are unit length, though it will not make any attempt to select the "better (for interpolation
with respect to neighboring samples)" of the two possible quaternions that encode the rotation.</p>
<p>See also <a class="el" href="class_usd_geom_point_instancer.html#UsdGeomPointInstancer_transform">Computing an Instance Transform</a> .</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone" colspan="2"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Declaration  </td><td class="markdownTableBodyNone"><code>quath[] orientations</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">C++ Type  </td><td class="markdownTableBodyNone">VtArray&lt;GfQuath&gt;   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_usd__page__datatypes.html#Usd_Datatypes">Usd Type</a>  </td><td class="markdownTableBodyNone">SdfValueTypeNames-&gt;QuathArray   </td></tr>
</table>

</div>
</div>
<a id="a30684ce10025f54b6b9fdab13700ae99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30684ce10025f54b6b9fdab13700ae99">&#9670;&nbsp;</a></span>GetPositionsAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> GetPositionsAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Required property</b>. </p>
<p>Per-instance position. See also <a class="el" href="class_usd_geom_point_instancer.html#UsdGeomPointInstancer_transform">Computing an Instance Transform</a> .</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone" colspan="2"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Declaration  </td><td class="markdownTableBodyNone"><code>point3f[] positions</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">C++ Type  </td><td class="markdownTableBodyNone"><a class="el" href="class_vt_array.html">VtArray&lt;GfVec3f&gt;</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_usd__page__datatypes.html#Usd_Datatypes">Usd Type</a>  </td><td class="markdownTableBodyNone">SdfValueTypeNames-&gt;Point3fArray   </td></tr>
</table>

</div>
</div>
<a id="a1f0a46b50806ce1922c5ebd03ad94bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0a46b50806ce1922c5ebd03ad94bd6">&#9670;&nbsp;</a></span>GetProtoIndicesAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> GetProtoIndicesAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Required property</b>. </p>
<p>Per-instance index into <em>prototypes</em> relationship that identifies what geometry should be drawn for each instance. <b>Topology attribute</b> - can be animated, but at a potential performance impact for streaming.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone" colspan="2"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Declaration  </td><td class="markdownTableBodyNone"><code>int[] protoIndices</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">C++ Type  </td><td class="markdownTableBodyNone">VtArray&lt;int&gt;   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_usd__page__datatypes.html#Usd_Datatypes">Usd Type</a>  </td><td class="markdownTableBodyNone">SdfValueTypeNames-&gt;IntArray   </td></tr>
</table>

</div>
</div>
<a id="a612b93e2bca96a78c93967a20555bb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612b93e2bca96a78c93967a20555bb3d">&#9670;&nbsp;</a></span>GetPrototypesRel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_relationship.html">UsdRelationship</a> GetPrototypesRel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Required property</b>. </p>
<p>Orders and targets the prototype root prims, which can be located anywhere in the scenegraph that is convenient, although we promote organizing prototypes as children of the PointInstancer. The position of a prototype in this relationship defines the value an instance would specify in the <em>protoIndices</em> attribute to instance that prototype. Since relationships are uniform, this property cannot be animated. </p>

</div>
</div>
<a id="a0b0e562b36e2413ba95616bd4eed98a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0e562b36e2413ba95616bd4eed98a5">&#9670;&nbsp;</a></span>GetScalesAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> GetScalesAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If authored, per-instance scale to be applied to each instance, before any rotation is applied. </p>
<p>See also <a class="el" href="class_usd_geom_point_instancer.html#UsdGeomPointInstancer_transform">Computing an Instance Transform</a> .</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone" colspan="2"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Declaration  </td><td class="markdownTableBodyNone"><code>float3[] scales</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">C++ Type  </td><td class="markdownTableBodyNone"><a class="el" href="class_vt_array.html">VtArray&lt;GfVec3f&gt;</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_usd__page__datatypes.html#Usd_Datatypes">Usd Type</a>  </td><td class="markdownTableBodyNone">SdfValueTypeNames-&gt;Float3Array   </td></tr>
</table>

</div>
</div>
<a id="ae40ae43320babff8a254a3a8107a255a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40ae43320babff8a254a3a8107a255a">&#9670;&nbsp;</a></span>GetSchemaAttributeNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static USDGEOM_API const <a class="el" href="token_8h.html#a9d94c69b8de3eb7202797d3c6d56db59">TfTokenVector</a>&amp; GetSchemaAttributeNames </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeInherited</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector of names of all pre-declared attributes for this schema class and all its ancestor classes. </p>
<p>Does not include attributes that may be authored by custom/extended methods of the schemas involved. </p>

</div>
</div>
<a id="a2840a996c8a768ecea390147390dc222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2840a996c8a768ecea390147390dc222">&#9670;&nbsp;</a></span>GetVelocitiesAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API <a class="el" href="class_usd_attribute.html">UsdAttribute</a> GetVelocitiesAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If provided, per-instance 'velocities' will be used to compute positions between samples for the 'positions' attribute, rather than interpolating between neighboring 'positions' samples. </p>
<p>Velocities should be considered mandatory if both <em>protoIndices</em> and <em>positions</em> are animated. Velocity is measured in position units per second, as per most simulation software. To convert to position units per <a class="el" href="class_usd_time_code.html" title="Represent a time value, which may be either numeric, holding a double value, or a sentinel value UsdT...">UsdTimeCode</a>, divide by <a class="el" href="class_usd_stage.html#a85092d7455ae894d50224e761dc6e840" title="Returns the stage&#39;s timeCodesPerSecond value.">UsdStage::GetTimeCodesPerSecond()</a>.</p>
<p>See also <a class="el" href="class_usd_geom_point_instancer.html#UsdGeomPointInstancer_transform">Computing an Instance Transform</a>, <a class="el" href="usd_geom_page_front.html#UsdGeom_VelocityInterpolation">Applying Timesampled Velocities to Geometry</a> .</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone" colspan="2"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Declaration  </td><td class="markdownTableBodyNone"><code>vector3f[] velocities</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">C++ Type  </td><td class="markdownTableBodyNone"><a class="el" href="class_vt_array.html">VtArray&lt;GfVec3f&gt;</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_usd__page__datatypes.html#Usd_Datatypes">Usd Type</a>  </td><td class="markdownTableBodyNone">SdfValueTypeNames-&gt;Vector3fArray   </td></tr>
</table>

</div>
</div>
<a id="a9cc2315ea6be2e129f1732e6d33e363f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc2315ea6be2e129f1732e6d33e363f">&#9670;&nbsp;</a></span>InvisId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool InvisId </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that the instance identified by <code>id</code> is invisible at <code>time</code>. </p>
<p>This will cause <em>invisibleIds</em> to first be broken down (keyed) at <code>time</code>, causing all animation in weaker layers that the current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> to be overridden. Has no effect on any timeSamples other than the one at <code>time</code>.</p>
<p>An invised instance is guaranteed not to render if the renderer honors masking. </p>

</div>
</div>
<a id="aa88b2c5d831432796b69d7b85bc39bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88b2c5d831432796b69d7b85bc39bd5">&#9670;&nbsp;</a></span>InvisIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool InvisIds </td>
          <td>(</td>
          <td class="paramtype">VtInt64Array const &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that the instances identified by <code>ids</code> are invisible at <code>time</code>. </p>
<p>This will cause <em>invisibleIds</em> to first be broken down (keyed) at <code>time</code>, causing all animation in weaker layers that the current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> to be overridden. Has no effect on any timeSamples other than the one at <code>time</code>.</p>
<p>An invised instance is guaranteed not to render if the renderer honors masking. </p>

</div>
</div>
<a id="a9a4d919761befd2ee076188f02419272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4d919761befd2ee076188f02419272">&#9670;&nbsp;</a></span>VisAllIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool VisAllIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that all instances are visible at <code>time</code>. </p>
<p>Operates by authoring an empty array at <code>time</code>.</p>
<p>This does not guarantee that the instances will be rendered, because each may still be "inactive" due to its id being present in the <em>inactivevIds</em> metadata (see <a class="el" href="class_usd_geom_point_instancer.html#a8c252eec2616b2d883a2db5b8b0f3d60" title="Ensure that the instance identified by id is active over all time.">ActivateId()</a>, <a class="el" href="class_usd_geom_point_instancer.html#af62e7d7882ad88c1ed4f22328e91263c" title="Ensure that the instance identified by id is inactive over all time.">DeactivateId()</a>) </p>

</div>
</div>
<a id="abf1ac95ca33821f69586590df694ee35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1ac95ca33821f69586590df694ee35">&#9670;&nbsp;</a></span>VisId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool VisId </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that the instance identified by <code>id</code> is visible at <code>time</code>. </p>
<p>This will cause <em>invisibleIds</em> to first be broken down (keyed) at <code>time</code>, causing all animation in weaker layers that the current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> to be overridden. Has no effect on any timeSamples other than the one at <code>time</code>. If the <em>invisibleIds</em> attribute is not authored or is blocked, this operation is a no-op.</p>
<p>This does not guarantee that the instance will be rendered, because it may still be "inactive" due to <code>id</code> being present in the <em>inactivevIds</em> metadata (see <a class="el" href="class_usd_geom_point_instancer.html#a8c252eec2616b2d883a2db5b8b0f3d60" title="Ensure that the instance identified by id is active over all time.">ActivateId()</a>, <a class="el" href="class_usd_geom_point_instancer.html#af62e7d7882ad88c1ed4f22328e91263c" title="Ensure that the instance identified by id is inactive over all time.">DeactivateId()</a>) </p>

</div>
</div>
<a id="a1233046a057a7befb515aaa1b5fee9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1233046a057a7befb515aaa1b5fee9c6">&#9670;&nbsp;</a></span>VisIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USDGEOM_API bool VisIds </td>
          <td>(</td>
          <td class="paramtype">VtInt64Array const &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_usd_time_code.html">UsdTimeCode</a> const &amp;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that the instances identified by <code>ids</code> are visible at <code>time</code>. </p>
<p>This will cause <em>invisibleIds</em> to first be broken down (keyed) at <code>time</code>, causing all animation in weaker layers that the current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> to be overridden. Has no effect on any timeSamples other than the one at <code>time</code>. If the <em>invisibleIds</em> attribute is not authored or is blocked, this operation is a no-op.</p>
<p>This does not guarantee that the instances will be rendered, because each may still be "inactive" due to <code>id</code> being present in the <em>inactivevIds</em> metadata (see <a class="el" href="class_usd_geom_point_instancer.html#a8c252eec2616b2d883a2db5b8b0f3d60" title="Ensure that the instance identified by id is active over all time.">ActivateId()</a>, <a class="el" href="class_usd_geom_point_instancer.html#af62e7d7882ad88c1ed4f22328e91263c" title="Ensure that the instance identified by id is inactive over all time.">DeactivateId()</a>) </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3e5fc43aea5aea4908c3ce980fdf8908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5fc43aea5aea4908c3ce980fdf8908">&#9670;&nbsp;</a></span>schemaKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741">UsdSchemaKind</a> schemaKind = <a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741aa6650141c3d230f8e4e51461e1d9e645">UsdSchemaKind::ConcreteTyped</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant representing what kind of schema this class is. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="common_8h.html#a64c9c016c495366a2ca7330d56c77741" title="An enum representing which kind of schema a given schema class belongs to.">UsdSchemaKind</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="point_instancer_8h_source.html#l00284">284</a> of file <a class="el" href="point_instancer_8h_source.html">pointInstancer.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pxr/usd/usdGeom/<a class="el" href="point_instancer_8h_source.html">pointInstancer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_usd_geom_point_instancer.html">UsdGeomPointInstancer</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:06 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>