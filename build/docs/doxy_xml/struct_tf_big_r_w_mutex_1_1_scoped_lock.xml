<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="struct_tf_big_r_w_mutex_1_1_scoped_lock" kind="struct" language="C++" prot="public">
    <compoundname>TfBigRWMutex::ScopedLock</compoundname>
    <includes refid="big_r_w_mutex_8h" local="no">bigRWMutex.h</includes>
      <sectiondef kind="public-static-attrib">
      <memberdef kind="variable" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a1d15fe29410c4ba47a0eb8c9e45d2573" prot="public" static="yes" mutable="no">
        <type>constexpr int</type>
        <definition>constexpr int NotAcquired</definition>
        <argsstring></argsstring>
        <name>NotAcquired</name>
        <initializer>= -1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="91" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="91" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a8d37a09d9e4ea1e72de9a79caa6c379a" prot="public" static="yes" mutable="no">
        <type>constexpr int</type>
        <definition>constexpr int WriteAcquired</definition>
        <argsstring></argsstring>
        <name>WriteAcquired</name>
        <initializer>= -2</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="92" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="92" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1abcf8680c7f70bbbeec30a7f6bd69718f" prot="private" static="no" mutable="no">
        <type><ref refid="class_tf_big_r_w_mutex" kindref="compound">TfBigRWMutex</ref> *</type>
        <definition>TfBigRWMutex* _mutex</definition>
        <argsstring></argsstring>
        <name>_mutex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="198" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="198" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a9bb763928c9a78bd220119bb042fabc7" prot="private" static="no" mutable="no">
        <type>int</type>
        <definition>int _acqState</definition>
        <argsstring></argsstring>
        <name>_acqState</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="199" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="199" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a50d2ce9d7129212e6976c88fa3a714ee" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>ScopedLock</definition>
        <argsstring>(TfBigRWMutex &amp;m, bool write=true)</argsstring>
        <name>ScopedLock</name>
        <param>
          <type><ref refid="class_tf_big_r_w_mutex" kindref="compound">TfBigRWMutex</ref> &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>write</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Construct a scoped lock for mutex <computeroutput>m</computeroutput> and acquire either a read or a write lock depending on <computeroutput>write</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="96" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="96" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a3150d0659fbe1506be0ce262cd7b1278" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>ScopedLock</definition>
        <argsstring>()</argsstring>
        <name>ScopedLock</name>
        <briefdescription>
<para>Construct a scoped lock not associated with a <computeroutput>mutex</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="103" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="103" bodyend="103"/>
      </memberdef>
      <memberdef kind="function" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1acc8f76dda0ec82b4120a2255b8ce74b7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>~ScopedLock</definition>
        <argsstring>()</argsstring>
        <name>~ScopedLock</name>
        <briefdescription>
<para>If this scoped lock is acquired for either read or write, <ref refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a94c93747c8daa99d65c2a04c6be0748c" kindref="member">Release()</ref> it. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="107" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="107" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1ae053ea155f9eaa1a1ab2222d22424384" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Acquire</definition>
        <argsstring>(TfBigRWMutex &amp;m, bool write=true)</argsstring>
        <name>Acquire</name>
        <param>
          <type><ref refid="class_tf_big_r_w_mutex" kindref="compound">TfBigRWMutex</ref> &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>write</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>If the current scoped lock is acquired, <ref refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a94c93747c8daa99d65c2a04c6be0748c" kindref="member">Release()</ref> it, then associate this lock with <computeroutput>m</computeroutput> and acquire either a read or a write lock, depending on <computeroutput>write</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="114" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="114" bodyend="118"/>
      </memberdef>
      <memberdef kind="function" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a2b66e8e54ed47336076e5c23b0ef22c0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Acquire</definition>
        <argsstring>(bool write=true)</argsstring>
        <name>Acquire</name>
        <param>
          <type>bool</type>
          <declname>write</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Acquire either a read or write lock on this lock&apos;s associated mutex depending on <computeroutput>write</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>This lock must be associated with a mutex (typically by construction or by a call to <ref refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1ae053ea155f9eaa1a1ab2222d22424384" kindref="member">Acquire()</ref> that takes a mutex). This lock must not already be acquired when calling <ref refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1ae053ea155f9eaa1a1ab2222d22424384" kindref="member">Acquire()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="125" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="125" bodyend="132"/>
      </memberdef>
      <memberdef kind="function" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a94c93747c8daa99d65c2a04c6be0748c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Release</definition>
        <argsstring>()</argsstring>
        <name>Release</name>
        <briefdescription>
<para>Release the currently required lock on the associated mutex. </para>
        </briefdescription>
        <detaileddescription>
<para>If this lock is not currently acquired, silently do nothing. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="136" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="136" bodyend="147"/>
      </memberdef>
      <memberdef kind="function" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1aea82059734813662236ac5c264a87bbd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void AcquireRead</definition>
        <argsstring>()</argsstring>
        <name>AcquireRead</name>
        <briefdescription>
<para>Acquire a read lock on this lock&apos;s associated mutex. </para>
        </briefdescription>
        <detaileddescription>
<para>This lock must not already be acquired when calling <computeroutput><ref refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1aea82059734813662236ac5c264a87bbd" kindref="member">AcquireRead()</ref></computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="151" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="151" bodyend="154"/>
      </memberdef>
      <memberdef kind="function" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1ae26cf2a0b6c906a79d7afc652ec6be24" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void AcquireWrite</definition>
        <argsstring>()</argsstring>
        <name>AcquireWrite</name>
        <briefdescription>
<para>Acquire a write lock on this lock&apos;s associated mutex. </para>
        </briefdescription>
        <detaileddescription>
<para>This lock must not already be acquired when calling <computeroutput><ref refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1ae26cf2a0b6c906a79d7afc652ec6be24" kindref="member">AcquireWrite()</ref></computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="158" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="158" bodyend="162"/>
      </memberdef>
      <memberdef kind="function" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a042b2ad177df032a8a617c043ac8626d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool UpgradeToWriter</definition>
        <argsstring>()</argsstring>
        <name>UpgradeToWriter</name>
        <briefdescription>
<para>Change this lock&apos;s acquisition state from a read lock to a write lock. </para>
        </briefdescription>
        <detaileddescription>
<para>This lock must already be acquired for reading. For consistency with tbb, this function returns a bool indicating whether the upgrade was done atomically, without releasing the read-lock. However the current implementation always releases the read lock so this function always returns false. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="170" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="170" bodyend="175"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1adabf24011352965b26550703f41eb1a5" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void _ReleaseRead</definition>
        <argsstring>()</argsstring>
        <name>_ReleaseRead</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="179" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="179" bodyend="183"/>
      </memberdef>
      <memberdef kind="function" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1ab212ee067722bb714b87e2a3d59a51b9" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void _ReleaseWrite</definition>
        <argsstring>()</argsstring>
        <name>_ReleaseWrite</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="185" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="185" bodyend="189"/>
      </memberdef>
      <memberdef kind="function" id="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a737fe15c615e6756b68d2de9610beba1" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int _GetSeed</definition>
        <argsstring>() const</argsstring>
        <name>_GetSeed</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/bigRWMutex.h" line="193" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="193" bodyend="196"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Scoped lock utility class. </para>
    </briefdescription>
    <detaileddescription>
<para>API modeled after tbb::spin_rw_mutex::scoped_lock. </para>
    </detaileddescription>
    <location file="pxr/base/tf/bigRWMutex.h" line="86" column="1" bodyfile="pxr/base/tf/bigRWMutex.h" bodystart="86" bodyend="202"/>
    <listofallmembers>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a9bb763928c9a78bd220119bb042fabc7" prot="private" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>_acqState</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a737fe15c615e6756b68d2de9610beba1" prot="private" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>_GetSeed</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1abcf8680c7f70bbbeec30a7f6bd69718f" prot="private" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>_mutex</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1adabf24011352965b26550703f41eb1a5" prot="private" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>_ReleaseRead</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1ab212ee067722bb714b87e2a3d59a51b9" prot="private" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>_ReleaseWrite</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1ae053ea155f9eaa1a1ab2222d22424384" prot="public" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>Acquire</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a2b66e8e54ed47336076e5c23b0ef22c0" prot="public" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>Acquire</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1aea82059734813662236ac5c264a87bbd" prot="public" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>AcquireRead</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1ae26cf2a0b6c906a79d7afc652ec6be24" prot="public" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>AcquireWrite</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a1d15fe29410c4ba47a0eb8c9e45d2573" prot="public" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>NotAcquired</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a94c93747c8daa99d65c2a04c6be0748c" prot="public" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>Release</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a50d2ce9d7129212e6976c88fa3a714ee" prot="public" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>ScopedLock</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a3150d0659fbe1506be0ce262cd7b1278" prot="public" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>ScopedLock</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a042b2ad177df032a8a617c043ac8626d" prot="public" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>UpgradeToWriter</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1a8d37a09d9e4ea1e72de9a79caa6c379a" prot="public" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>WriteAcquired</name></member>
      <member refid="struct_tf_big_r_w_mutex_1_1_scoped_lock_1acc8f76dda0ec82b4120a2255b8ce74b7" prot="public" virt="non-virtual"><scope>TfBigRWMutex::ScopedLock</scope><name>~ScopedLock</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
