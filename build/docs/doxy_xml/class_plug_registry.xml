<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="class_plug_registry" kind="class" language="C++" prot="public">
    <compoundname>PlugRegistry</compoundname>
    <basecompoundref refid="class_tf_weak_base" prot="public" virt="non-virtual">TfWeakBase</basecompoundref>
    <includes refid="base_2plug_2registry_8h" local="no">registry.h</includes>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="class_plug_registry_1ab096e6a24e35ffd8c12719cb632570b7" prot="public" static="no">
        <type><ref refid="class_plug_registry" kindref="compound">PlugRegistry</ref></type>
        <definition>typedef PlugRegistry This</definition>
        <argsstring></argsstring>
        <name>This</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="340" column="1" bodyfile="pxr/base/plug/registry.h" bodystart="340" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="class_plug_registry_1adea5a2717c8af13dadc9919e197ffe5b" prot="public" static="no">
        <type>std::vector&lt; <ref refid="class_tf_type" kindref="compound">TfType</ref> &gt;</type>
        <definition>typedef std::vector&lt;TfType&gt; TypeVector</definition>
        <argsstring></argsstring>
        <name>TypeVector</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="341" column="1" bodyfile="pxr/base/plug/registry.h" bodystart="341" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="class_plug_registry_1a610a5b8b8da196db90eb4d99d542a4f6" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class TfSingleton&lt; PlugRegistry &gt;</definition>
        <argsstring></argsstring>
        <name>TfSingleton&lt; PlugRegistry &gt;</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="473" column="1" bodyfile="pxr/base/plug/registry.h" bodystart="475" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="class_plug_registry_1a4bcd707c468bf0fb07ddb3e2d6a58367" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class PlugPlugin</definition>
        <argsstring></argsstring>
        <name>PlugPlugin</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="476" column="1" bodyfile="pxr/base/plug/registry.h" bodystart="476" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_plug_registry_1a090485e372a2812b6b7e311d3dac60ab" prot="private" static="no" mutable="no">
        <type>TfHashSet&lt; std::string, <ref refid="class_tf_hash" kindref="compound">TfHash</ref> &gt;</type>
        <definition>TfHashSet&lt;std::string, TfHash&gt; _registeredPluginPaths</definition>
        <argsstring></argsstring>
        <name>_registeredPluginPaths</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="479" column="1" bodyfile="pxr/base/plug/registry.h" bodystart="479" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_plug_registry_1a3f0b4c278cb19f9c2b2dbdb065f51e14" prot="private" static="no" mutable="no">
        <type>std::mutex</type>
        <definition>std::mutex _mutex</definition>
        <argsstring></argsstring>
        <name>_mutex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="481" column="1" bodyfile="pxr/base/plug/registry.h" bodystart="481" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="class_plug_registry_1a2fdd5faaeea81f1e8ce7b58652b6b2b4" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>PlugRegistry</definition>
        <argsstring>(PlugRegistry const &amp;)=delete</argsstring>
        <name>PlugRegistry</name>
        <param>
          <type><ref refid="class_plug_registry" kindref="compound">PlugRegistry</ref> const &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="337" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1acd30f35dbb2464285d1927b96cbe8717" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="class_plug_registry" kindref="compound">PlugRegistry</ref> &amp;</type>
        <definition>PlugRegistry&amp; operator=</definition>
        <argsstring>(PlugRegistry const &amp;)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="class_plug_registry" kindref="compound">PlugRegistry</ref> const &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="338" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1a37768e08eee844e839a92120a9addf4b" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_LOCAL</type>
        <definition>PLUG_LOCAL PlugRegistry</definition>
        <argsstring>()</argsstring>
        <name>PlugRegistry</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="458" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1af166bc55fe12ed1f397a7c7b9002856f" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_LOCAL PlugPluginPtrVector</type>
        <definition>PLUG_LOCAL PlugPluginPtrVector _RegisterPlugins</definition>
        <argsstring>(const std::vector&lt; std::string &gt; &amp;pathsToPlugInfo, bool pathsAreOrdered)</argsstring>
        <name>_RegisterPlugins</name>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>pathsToPlugInfo</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>pathsAreOrdered</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="465" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1ab4f01e7936893266f6b9bab5598e706d" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ConcurrentVector</type>
          </param>
        </templateparamlist>
        <type>PLUG_LOCAL void</type>
        <definition>PLUG_LOCAL void _RegisterPlugin</definition>
        <argsstring>(const Plug_RegistrationMetadata &amp;, ConcurrentVector *newPlugins)</argsstring>
        <name>_RegisterPlugin</name>
        <param>
          <type>const Plug_RegistrationMetadata &amp;</type>
        </param>
        <param>
          <type>ConcurrentVector *</type>
          <declname>newPlugins</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="470" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1adbc75cd2d33d9c3d2167ce1bc0c983fb" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_LOCAL bool</type>
        <definition>PLUG_LOCAL bool _InsertRegisteredPluginPath</definition>
        <argsstring>(const std::string &amp;path)</argsstring>
        <name>_InsertRegisteredPluginPath</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>path</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="473" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="class_plug_registry_1a8b287622f64269e7f9edd1410436d805" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_API <ref refid="class_plug_registry" kindref="compound">PlugRegistry</ref> &amp;</type>
        <definition>static PLUG_API PlugRegistry&amp; GetInstance</definition>
        <argsstring>()</argsstring>
        <name>GetInstance</name>
        <briefdescription>
<para>Returns the singleton <computeroutput><ref refid="class_plug_registry" kindref="compound">PlugRegistry</ref></computeroutput> instance. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="345" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1ad4b3d4cb0992361d63ea170161fc6171" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_API <ref refid="class_tf_type" kindref="compound">TfType</ref></type>
        <definition>static PLUG_API TfType FindTypeByName</definition>
        <argsstring>(std::string const &amp;typeName)</argsstring>
        <name>FindTypeByName</name>
        <param>
          <type>std::string const &amp;</type>
          <declname>typeName</declname>
        </param>
        <briefdescription>
<para>Retrieve the <computeroutput><ref refid="class_tf_type" kindref="compound">TfType</ref></computeroutput> corresponding to the given <computeroutput>name</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>See the documentation for <computeroutput><ref refid="class_tf_type_1a73035766205949ad12cc23ebf622e07e" kindref="member">TfType::FindByName</ref></computeroutput> for more information. Use this function if you expect that <computeroutput>name</computeroutput> may name a type provided by a plugin. Calling this function will incur plugin discovery (but not loading) if plugin discovery has not yet occurred.</para>
<para>Note that additional plugins may be registered during program runtime. <simplesect kind="see"><para><ref refid="plug_page_front_1Plug_Discovery" kindref="member">Plug-In Discovery &amp; Registration</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="367" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1ab8d9978a85af6f5020d5f07a8ba644cf" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_API <ref refid="class_tf_type" kindref="compound">TfType</ref></type>
        <definition>static PLUG_API TfType FindDerivedTypeByName</definition>
        <argsstring>(TfType base, std::string const &amp;typeName)</argsstring>
        <name>FindDerivedTypeByName</name>
        <param>
          <type><ref refid="class_tf_type" kindref="compound">TfType</ref></type>
          <declname>base</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>typeName</declname>
        </param>
        <briefdescription>
<para>Retrieve the <computeroutput><ref refid="class_tf_type" kindref="compound">TfType</ref></computeroutput> that derives from <computeroutput>base</computeroutput> and has the given alias or type name <computeroutput>typeName</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>See the documentation for <computeroutput><ref refid="class_tf_type_1ac2acc8a814d948d5444aba8852db5bcf" kindref="member">TfType::FindDerivedByName</ref></computeroutput> for more information. Use this function if you expect that the derived type may be provided by a plugin. Calling this function will incur plugin discovery (but not loading) if plugin discovery has not yet occurred.</para>
<para>Note that additional plugins may be registered during program runtime. <simplesect kind="see"><para><ref refid="plug_page_front_1Plug_Discovery" kindref="member">Plug-In Discovery &amp; Registration</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="380" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1ad656572db5fa6cb4d0a4b7ab17b3880f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Base</type>
          </param>
        </templateparamlist>
        <type><ref refid="class_tf_type" kindref="compound">TfType</ref></type>
        <definition>static TfType FindDerivedTypeByName</definition>
        <argsstring>(std::string const &amp;typeName)</argsstring>
        <name>FindDerivedTypeByName</name>
        <param>
          <type>std::string const &amp;</type>
          <declname>typeName</declname>
        </param>
        <briefdescription>
<para>Retrieve the <computeroutput><ref refid="class_tf_type" kindref="compound">TfType</ref></computeroutput> that derives from <computeroutput>Base</computeroutput> and has the given alias or type name <computeroutput>typeName</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>See the documentation for <computeroutput><ref refid="class_tf_type_1ac2acc8a814d948d5444aba8852db5bcf" kindref="member">TfType::FindDerivedByName</ref></computeroutput> for more information. Use this function if you expect that the derived type may be provided by a plugin. Calling this function will incur plugin discovery (but not loading) if plugin discovery has not yet occurred.</para>
<para>Note that additional plugins may be registered during program runtime. <simplesect kind="see"><para><ref refid="plug_page_front_1Plug_Discovery" kindref="member">Plug-In Discovery &amp; Registration</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="393" column="1" bodyfile="pxr/base/plug/registry.h" bodystart="393" bodyend="395"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1a491223b1f382752c136b50925cbc6d07" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_API std::vector&lt; <ref refid="class_tf_type" kindref="compound">TfType</ref> &gt;</type>
        <definition>static PLUG_API std::vector&lt;TfType&gt; GetDirectlyDerivedTypes</definition>
        <argsstring>(TfType base)</argsstring>
        <name>GetDirectlyDerivedTypes</name>
        <param>
          <type><ref refid="class_tf_type" kindref="compound">TfType</ref></type>
          <declname>base</declname>
        </param>
        <briefdescription>
<para>Return a vector of types derived directly from <emphasis>base</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>Use this function if you expect that plugins may provide types derived from <emphasis>base</emphasis>. Otherwise, use <emphasis><ref refid="class_tf_type_1aa37b02659aa00a6f6f098acd1bff3a41" kindref="member">TfType::GetDirectlyDerivedTypes</ref></emphasis>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="403" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1af859ac657fb599ad71583621d0cf805b" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_API void</type>
        <definition>static PLUG_API void GetAllDerivedTypes</definition>
        <argsstring>(TfType base, std::set&lt; TfType &gt; *result)</argsstring>
        <name>GetAllDerivedTypes</name>
        <param>
          <type><ref refid="class_tf_type" kindref="compound">TfType</ref></type>
          <declname>base</declname>
        </param>
        <param>
          <type>std::set&lt; <ref refid="class_tf_type" kindref="compound">TfType</ref> &gt; *</type>
          <declname>result</declname>
        </param>
        <briefdescription>
<para>Return the set of all types derived (directly or indirectly) from <emphasis>base</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>Use this function if you expect that plugins may provide types derived from <emphasis>base</emphasis>. Otherwise, use <emphasis><ref refid="class_tf_type_1aa596041c67273d15501bef32540094fd" kindref="member">TfType::GetAllDerivedTypes</ref></emphasis>.</para>
<para>Note that additional plugins may be registered during program runtime. <simplesect kind="see"><para><ref refid="plug_page_front_1Plug_Discovery" kindref="member">Plug-In Discovery &amp; Registration</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="413" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1a07bd4722b659ca5c2ee2dd93ec79db67" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Base</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void GetAllDerivedTypes</definition>
        <argsstring>(std::set&lt; TfType &gt; *result)</argsstring>
        <name>GetAllDerivedTypes</name>
        <param>
          <type>std::set&lt; <ref refid="class_tf_type" kindref="compound">TfType</ref> &gt; *</type>
          <declname>result</declname>
        </param>
        <briefdescription>
<para>Return the set of all types derived (directly or indirectly) from <emphasis>Base</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>Use this function if you expect that plugins may provide types derived from <emphasis>base</emphasis>. Otherwise, use <emphasis><ref refid="class_tf_type_1aa596041c67273d15501bef32540094fd" kindref="member">TfType::GetAllDerivedTypes</ref></emphasis>.</para>
<para>Note that additional plugins may be registered during program runtime. <simplesect kind="see"><para><ref refid="plug_page_front_1Plug_Discovery" kindref="member">Plug-In Discovery &amp; Registration</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="423" column="1" bodyfile="pxr/base/plug/registry.h" bodystart="423" bodyend="425"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="class_plug_registry_1ada54bcdd334de360eddab430894dd5ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_API PlugPluginPtrVector</type>
        <definition>PLUG_API PlugPluginPtrVector RegisterPlugins</definition>
        <argsstring>(const std::string &amp;pathToPlugInfo)</argsstring>
        <name>RegisterPlugins</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>pathToPlugInfo</declname>
        </param>
        <briefdescription>
<para>Registers all plug-ins discovered at <emphasis>pathToPlugInfo</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>Sends <ref refid="class_plug_notice_1_1_did_register_plugins" kindref="compound">PlugNotice::DidRegisterPlugins</ref> with any newly registered plugins. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="350" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1a43fe0749d24f0dd2a909a6abf2d427f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_API PlugPluginPtrVector</type>
        <definition>PLUG_API PlugPluginPtrVector RegisterPlugins</definition>
        <argsstring>(const std::vector&lt; std::string &gt; &amp;pathsToPlugInfo)</argsstring>
        <name>RegisterPlugins</name>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>pathsToPlugInfo</declname>
        </param>
        <briefdescription>
<para>Registers all plug-ins discovered in any of <emphasis>pathsToPlugInfo</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>Sends <ref refid="class_plug_notice_1_1_did_register_plugins" kindref="compound">PlugNotice::DidRegisterPlugins</ref> with any newly registered plugins. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="356" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1a4c5dfc1c3b55017173c9df93b091424c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_API PlugPluginPtr</type>
        <definition>PLUG_API PlugPluginPtr GetPluginForType</definition>
        <argsstring>(TfType t) const</argsstring>
        <name>GetPluginForType</name>
        <param>
          <type><ref refid="class_tf_type" kindref="compound">TfType</ref></type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Returns the plug-in for the given type, or a null pointer if there is no registered plug-in. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="430" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1aa395fd445592f25012f9406b155431d7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_API PlugPluginPtrVector</type>
        <definition>PLUG_API PlugPluginPtrVector GetAllPlugins</definition>
        <argsstring>() const</argsstring>
        <name>GetAllPlugins</name>
        <briefdescription>
<para>Returns all registered plug-ins. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that additional plugins may be registered during program runtime. <simplesect kind="see"><para><ref refid="plug_page_front_1Plug_Discovery" kindref="member">Plug-In Discovery &amp; Registration</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="435" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1abab64fbe6f5a8d113e4f31a3bde0959a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_API PlugPluginPtr</type>
        <definition>PLUG_API PlugPluginPtr GetPluginWithName</definition>
        <argsstring>(const std::string &amp;name) const</argsstring>
        <name>GetPluginWithName</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Returns a plugin with the specified library name. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that additional plugins may be registered during program runtime. <simplesect kind="see"><para><ref refid="plug_page_front_1Plug_Discovery" kindref="member">Plug-In Discovery &amp; Registration</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="441" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1a545f23185a7f34a760b125daa5a6698a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_API std::string</type>
        <definition>PLUG_API std::string GetStringFromPluginMetaData</definition>
        <argsstring>(TfType type, const std::string &amp;key) const</argsstring>
        <name>GetStringFromPluginMetaData</name>
        <param>
          <type><ref refid="class_tf_type" kindref="compound">TfType</ref></type>
          <declname>type</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>Looks for a string associated with <emphasis>type</emphasis> and <emphasis>key</emphasis> and returns it, or an empty string if <emphasis>type</emphasis> or <emphasis>key</emphasis> are not found. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="446" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_registry_1a51a448ab0535968b4b3f1ef497322398" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>PLUG_API <ref refid="class_js_value" kindref="compound">JsValue</ref></type>
        <definition>PLUG_API JsValue GetDataFromPluginMetaData</definition>
        <argsstring>(TfType type, const std::string &amp;key) const</argsstring>
        <name>GetDataFromPluginMetaData</name>
        <param>
          <type><ref refid="class_tf_type" kindref="compound">TfType</ref></type>
          <declname>type</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>key</declname>
        </param>
        <briefdescription>
<para>Looks for a <ref refid="class_js_value" kindref="compound">JsValue</ref> associated with <emphasis>type</emphasis> and <emphasis>key</emphasis> and returns it, or a null <ref refid="class_js_value" kindref="compound">JsValue</ref> if <emphasis>type</emphasis> or <emphasis>key</emphasis> are not found. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/registry.h" line="452" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Defines an interface for registering plugins. </para>
    </briefdescription>
    <detaileddescription>
<para><ref refid="class_plug_registry" kindref="compound">PlugRegistry</ref> maintains a registry of plug-ins known to the system and provides an interface for base classes to load any plug-ins required to instantiate a subclass of a given type.</para>
<para><heading level="2">Defining a Base Class API</heading>
</para>
<para>In order to use this facility you will generally provide a library which defines the API for a plug-in base class. This API will be sufficient for the application or framework to make use of custom subclasses that will be written by plug-in developers.</para>
<para>For example, if you have an image processing application, you might want to support plug-ins that implement image filters. You can define an abstract base class for image filters that declares the API your application will require image filters to implement; perhaps something simple like <ref refid="class_plug_registry_1plug_cppcode_PlugRegistry1" kindref="member">C++ Code Example 1</ref> (Doxygen only).</para>
<para>People writing custom filters would write a subclass of ImageFilter that overrides the two methods, implementing their own special filtering behavior.</para>
<sect1 id="class_plug_registry_1plug_EnablingPlugins">
<title>Enabling Plug-in Loading for the Base Class</title>
<para>In order for ImageFilter to be able to load plug-ins that implement these custom subclasses, it must be registered with the <ref refid="class_tf_type" kindref="compound">TfType</ref> system.</para>
<para>The ImageFilter base class, as was mentioned earlier, should be made available in a library that the application links with. This is done so that plug-ins that want to provide ImageFilters can also link with the library allowing them to subclass ImageFilter.</para>
</sect1>
<sect1 id="class_plug_registry_1plug_RegisteringPlugins">
<title>Registering Plug-ins</title>
<para>A plug-in developer can now write plug-ins with ImageFilter subclasses. Plug-ins can be implemented either as native dynamic libraries (either regular dynamic libraries or framework bundles) or as Python modules.</para>
<para>Plug-ins must be registered with the registry. All plugins are registered via <ref refid="class_plug_registry_1ada54bcdd334de360eddab430894dd5ac" kindref="member">RegisterPlugins()</ref>. Plug-in Python modules must be directly importable (in other words they must be able to be found in Python&apos;s module path.) Plugins are registered by providing a path or paths to JSON files that describe the location, structure and contents of the plugin. The standard name for these files in plugInfo.json.</para>
<para>Typically, the application that hosts plug-ins will locate and register plug-ins at startup.</para>
<para>The plug-in facility is lazy. It does not dynamically load code from plug-in bundles until that code is required.</para>
</sect1>
<sect1 id="class_plug_registry_1plug_plugInfo">
<title>plugInfo.json</title>
<para>A plugInfo.json file has the following structure:</para>
<para><programlisting><codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#<sp/>Comments<sp/>are<sp/>allowed<sp/>and<sp/>indicated<sp/>by<sp/>a<sp/>hash<sp/>at<sp/>the<sp/>start<sp/>of<sp/>a</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#<sp/>line<sp/>or<sp/>after<sp/>spaces<sp/>and<sp/>tabs.<sp/><sp/>They<sp/>continue<sp/>to<sp/>the<sp/>end<sp/>of<sp/>line.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#<sp/>Blank<sp/>lines<sp/>are<sp/>okay,<sp/>too.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#<sp/>This<sp/>is<sp/>optional.<sp/><sp/>It<sp/>may<sp/>contain<sp/>any<sp/>number<sp/>of<sp/>strings.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#<sp/><sp/><sp/>Paths<sp/>may<sp/>be<sp/>absolute<sp/>or<sp/>relative.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#<sp/><sp/><sp/>Paths<sp/>ending<sp/>with<sp/>slash<sp/>have<sp/>plugInfo.json<sp/>appended<sp/>automatically.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#<sp/><sp/><sp/>&apos;*&apos;<sp/>may<sp/>be<sp/>used<sp/>anywhere<sp/>to<sp/>match<sp/>any<sp/>character<sp/>except<sp/>slash.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#<sp/><sp/><sp/>&apos;**&apos;<sp/>may<sp/>be<sp/>used<sp/>anywhere<sp/>to<sp/>match<sp/>any<sp/>character<sp/>including<sp/>slash.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;Includes&quot;:<sp/>[</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;/absolute/path/to/plugInfo.json&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;/absolute/path/to/custom.filename&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;/absolute/path/to/directory/with/plugInfo/&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;relative/path/to/plugInfo.json&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;relative/path/to/directory/with/plugInfo/&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;glob*/pa*th/*to*/*/plugInfo.json&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;recursive/pa**th/**/&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>],</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#<sp/>This<sp/>is<sp/>optional.<sp/><sp/>It<sp/>may<sp/>contain<sp/>any<sp/>number<sp/>of<sp/>objects.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;Plugins&quot;:<sp/>[</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>Type<sp/>is<sp/>required<sp/>and<sp/>may<sp/>be<sp/>&quot;library&quot;,<sp/>&quot;python&quot;<sp/>or<sp/>&quot;resource&quot;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;Type&quot;:<sp/>&quot;library&quot;,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>Name<sp/>is<sp/>required.<sp/><sp/>It<sp/>should<sp/>be<sp/>the<sp/>Python<sp/>module<sp/>name,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>the<sp/>shared<sp/>library<sp/>name,<sp/>or<sp/>a<sp/>unique<sp/>resource<sp/>name.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;Name&quot;:<sp/>&quot;myplugin&quot;,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>Root<sp/>is<sp/>optional.<sp/><sp/>It<sp/>defaults<sp/>to<sp/>&quot;.&quot;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>This<sp/>gives<sp/>the<sp/>path<sp/>to<sp/>the<sp/>plugin<sp/>as<sp/>a<sp/>whole<sp/>if<sp/>the<sp/>plugin</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>has<sp/>substructure.<sp/><sp/>For<sp/>Python<sp/>it<sp/>should<sp/>be<sp/>the<sp/>directory</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>with<sp/>the<sp/>__init__.py<sp/>file.<sp/><sp/>The<sp/>path<sp/>is<sp/>usually<sp/>relative.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;Root&quot;:<sp/>&quot;.&quot;,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>LibraryPath<sp/>is<sp/>required<sp/>by<sp/>Type<sp/>&quot;library&quot;<sp/>and<sp/>unused</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>otherwise.<sp/><sp/>It<sp/>gives<sp/>the<sp/>path<sp/>to<sp/>the<sp/>shared<sp/>library</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>object,<sp/>either<sp/>absolute<sp/>or<sp/>relative<sp/>to<sp/>Root.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;LibraryPath&quot;:<sp/>&quot;libmyplugin.so&quot;,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>ResourcePath<sp/>is<sp/>option.<sp/><sp/>It<sp/>defaults<sp/>to<sp/>&quot;.&quot;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>This<sp/>gives<sp/>the<sp/>path<sp/>to<sp/>the<sp/>plugin&apos;s<sp/>resources<sp/>directory.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>The<sp/>path<sp/>is<sp/>either<sp/>absolute<sp/>or<sp/>relative<sp/>to<sp/>Root.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;ResourcePath&quot;:<sp/>&quot;resources&quot;,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>Info<sp/>is<sp/>required.<sp/><sp/>It&apos;s<sp/>described<sp/>below.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;Info&quot;:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>Plugin<sp/>contents.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>]</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>As a special case, if a plugInfo.json contains an object that doesn&apos;t have either the &quot;Includes&quot; or &quot;Plugins&quot; keys then it&apos;s as if the object was in a &quot;Plugins&quot; array.</para>
</sect1>
<sect1 id="class_plug_registry_1plug_Advertising">
<title>Advertising a Plug-in&apos;s Contents</title>
<para>Once the plug-ins are registered, the plug-in facility must also be able to tell what they contain. Specifically, it must be able to find out what subclasses of what plug-in base classes each plug-in contains. Plug-ins must advertise this information through their plugInfo.json file in the &quot;Info&quot; key. In the &quot;Info&quot; object there should be a key &quot;Types&quot; holding an object.</para>
<para>This &quot;Types&quot; object&apos;s keys are names of subclasses and its values are yet more objects (the subclass meta-data objects). The meta-data objects can contain arbitrary key-value pairs. The plug-in mechanism will look for a meta-data key called &quot;displayName&quot; whose value should be the display name of the subclass. The plug-in mechanism will look for a meta-data key called &quot;bases&quot; whose value should be an array of base class type names.</para>
<para>For example, a bundle that contains a subclass of ImageFilter might have a plugInfo.json that looks like the following example.</para>
<para><programlisting><codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;Types&quot;:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;MyCustomCoolFilter&quot;<sp/>:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;bases&quot;:<sp/>[&quot;ImageFilter&quot;],</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;displayName&quot;:<sp/>&quot;Add<sp/>Coolness<sp/>to<sp/>Image&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>other<sp/>arbitrary<sp/>metadata<sp/>for<sp/>MyCustomCoolFilter<sp/>here</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>What this says is that the plug-in contains a type called MyCustomCoolFilter which has a base class ImageFilter and that this subclass should be called &quot;Add Coolness to Image&quot; in user-visible contexts.</para>
<para>In addition to the &quot;displayName&quot; meta-data key which is actually known to the plug-in facility, you may put whatever other information you want into a class&apos; meta-data dictionary. If your plug-in base class wants to define custom keys that it requires all subclasses to provide, you can do that. Or, if a plug-in writer wants to define their own keys that their code will look for at runtime, that is OK as well.</para>
</sect1>
<sect1 id="class_plug_registry_1plug_subClasses">
<title>Working with Subclasses of a Plug-in Base Class</title>
<para>Most code with uses types defined in plug-ins doesn&apos;t deal with the Plug API directly. Instead, the <ref refid="class_tf_type" kindref="compound">TfType</ref> interface is used to lookup types and to manufacture instances. The <ref refid="class_tf_type" kindref="compound">TfType</ref> interface will take care to load any required plugins.</para>
<para>To wrap up our example, the application that wants to actually use ImageFilter plug-ins would probably do a couple of things. First, it would get a list of available ImageFilters to present to the user. This could be accomplished as shown in <ref refid="class_plug_registry_1plug_cppcode_PlugRegistry2" kindref="member">Python Code Example 2</ref> (Doxygen only).</para>
<para>Then, when the user picks a filter from the list, it would manufacture and instance of the filter as shown in <ref refid="class_plug_registry_1plug_cppcode_PlugRegistry3" kindref="member">Python Code Example 3</ref> (Doxygen only).</para>
<para>As was mentioned earlier, this plug-in facility tries to be as lazy as possible about loading the code associated with plug-ins. To that end, loading of a plugin will be deferred until an instance of a type is manufactured which requires the plugin.</para>
</sect1>
<sect1 id="class_plug_registry_1plug_MultipleSubclasses">
<title>Multiple Subclasses of Multiple Plug-in Base Classes</title>
<para>It is possible for a bundle to implement multiple subclasses for a plug-in base class if desired. If you want to package half a dozen ImageFilter subclasses in one bundle, that will work fine. All must be declared in the plugInfo.json.</para>
<para>It is possible for there to be multiple classes in your application or framework that are plug-in base classes. Plug-ins that implement subclasses of any of these base classes can all coexist. And, it is possible to have subclasses of multiple plug-in base classes in the same bundle.</para>
<para>When putting multiple subclasses (of the same or different base classes) in a bundle, keep in mind that dynamic loading happens for the whole bundle the first time any subclass is needed, the whole bundle will be loaded. But this is generally not a big concern.</para>
<para>For example, say the example application also has a plug-in base class &quot;ImageCodec&quot; that allows people to add support for reading and writing other image formats. Imagine that you want to supply a plug-in that has two codecs and a filter all in a single plug-in. Your plugInfo.json &quot;Info&quot; object might look something like this example.</para>
<para><programlisting><codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;Types&quot;:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;MyTIFFCodec&quot;:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;bases&quot;:<sp/>[&quot;ImageCodec&quot;],</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;displayName&quot;:<sp/>&quot;TIFF<sp/>Image&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;MyJPEGCodec&quot;:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;bases&quot;:<sp/>[&quot;ImageCodec&quot;],</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;displayName&quot;:<sp/>&quot;JPEG<sp/>Image&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;MyCustomCoolFilter&quot;<sp/>:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;bases&quot;:<sp/>[&quot;ImageFilter&quot;],</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;displayName&quot;:<sp/>&quot;Add<sp/>Coolness<sp/>to<sp/>Image&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="class_plug_registry_1plug_Dependencies">
<title>Dependencies on Other Plug-ins</title>
<para>If you write a plug-in that has dependencies on another plug-in that you cannot (or do not want to) link against statically, you can declare the dependencies in your plug-in&apos;s plugInfo.json . A plug-in declares dependencies on other classes with a PluginDependencies key whose value is a dictionary. The keys of the dictionary are plug-in base class names and the values are arrays of subclass names.</para>
<para>The following example contains an example of a plug-in that depends on two classes from the plug-in in the previous example.</para>
<para><programlisting><codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;Types&quot;:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;UltraCoolFilter&quot;:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;bases&quot;:<sp/>[&quot;MyCustomCoolFilter&quot;],</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;displayName&quot;:<sp/>&quot;Add<sp/>Unbelievable<sp/>Coolness<sp/>to<sp/>Image&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#<sp/>A<sp/>subclass<sp/>of<sp/>MyCustomCoolFilter<sp/>that<sp/>also<sp/>uses<sp/>MyTIFFCodec</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;PluginDependencies&quot;:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;ImageFilter&quot;:<sp/>[&quot;MyCustomCoolFilter&quot;],</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;ImageCodec&quot;:<sp/>[&quot;MyTIFFCodec&quot;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The ImageFilter provided by the plug-in in this example depends on the other ImageFilter MyCoolImageFilter and the ImageCodec MyTIFFCodec. Before loading this plug-in, the plug-in facility will ensure that those two classes are present, loading the plug-in that contains them if needed.</para>
</sect1>
<sect1 id="class_plug_registry_1plug_cppcode_PlugRegistry1">
<title>C++ Code Example 1</title>
<para><programlisting><codeline><highlight class="normal">//<sp/>Declare<sp/>a<sp/>base<sp/>class<sp/>interface</highlight></codeline>
<codeline><highlight class="normal">class<sp/>ImageFilter<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>virtual<sp/>bool<sp/>CanFilterImage(const<sp/>ImagePtr<sp/>&amp;<sp/>inputImage)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>virtual<sp/>ImagePtr<sp/>FilterImage(const<sp/>ImagePtr<sp/>&amp;<sp/>inputImage)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="class_plug_registry_1plug_cppcode_PlugRegistry2">
<title>Python Code Example 2</title>
<para><programlisting><codeline><highlight class="normal">#<sp/>Get<sp/>the<sp/>names<sp/>of<sp/>derived<sp/>types</highlight></codeline>
<codeline><highlight class="normal">baseType<sp/>=<sp/>Tf.Type.Find(ImageFilter)</highlight></codeline>
<codeline><highlight class="normal">if<sp/>baseType:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>derivedTypes<sp/>=<sp/>baseType.GetAllDerived()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>derivedTypeNames<sp/>=<sp/>[<sp/>derived.typeName<sp/>for<sp/>derived<sp/>in<sp/>derivedTypes<sp/>]</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="class_plug_registry_1plug_cppcode_PlugRegistry3">
<title>Python Code Example 3</title>
<para><programlisting><codeline><highlight class="normal">#<sp/>Manufacture<sp/>an<sp/>instance<sp/>of<sp/>a<sp/>derived<sp/>type</highlight></codeline>
<codeline><highlight class="normal">imageFilterType<sp/>=<sp/>Tf.Type.Find(ImageFilter)</highlight></codeline>
<codeline><highlight class="normal">myFilterType<sp/>=<sp/>Tf.Type.FindByName(&apos;UltraCoolImageFilter&apos;)</highlight></codeline>
<codeline><highlight class="normal">if<sp/>myFilterType<sp/>and<sp/>myFilterType.IsA(imageFilterType):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>myFilter<sp/>=<sp/>myFilterType.Manufacture()</highlight></codeline>
</programlisting> </para>
</sect1>
    </detaileddescription>
    <inheritancegraph>
      <node id="4805">
        <label>PlugRegistry</label>
        <link refid="class_plug_registry"/>
        <childnode refid="4806" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4806">
        <label>TfWeakBase</label>
        <link refid="class_tf_weak_base"/>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="4807">
        <label>PlugRegistry</label>
        <link refid="class_plug_registry"/>
        <childnode refid="4808" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4808">
        <label>TfWeakBase</label>
        <link refid="class_tf_weak_base"/>
      </node>
    </collaborationgraph>
    <location file="pxr/base/plug/registry.h" line="336" column="1" bodyfile="pxr/base/plug/registry.h" bodystart="336" bodyend="482"/>
    <listofallmembers>
      <member refid="class_tf_weak_base_1a01aa4c4b93df067f2ec9b9e5fa4c35b3" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>__GetTfWeakBase__</name></member>
      <member refid="class_tf_weak_base_1a6a5533162e8efab1be47acd6ccd5254c" prot="protected" virt="non-virtual"><scope>PlugRegistry</scope><name>_HasRemnant</name></member>
      <member refid="class_plug_registry_1adbc75cd2d33d9c3d2167ce1bc0c983fb" prot="private" virt="non-virtual"><scope>PlugRegistry</scope><name>_InsertRegisteredPluginPath</name></member>
      <member refid="class_plug_registry_1a3f0b4c278cb19f9c2b2dbdb065f51e14" prot="private" virt="non-virtual"><scope>PlugRegistry</scope><name>_mutex</name></member>
      <member refid="class_tf_weak_base_1a95139d2f4d04eb706664a4f47eb93918" prot="protected" virt="non-virtual"><scope>PlugRegistry</scope><name>_Register</name></member>
      <member refid="class_tf_weak_base_1ac1312732482c8a286522f703f2cf90d1" prot="protected" virt="non-virtual"><scope>PlugRegistry</scope><name>_Register</name></member>
      <member refid="class_plug_registry_1a090485e372a2812b6b7e311d3dac60ab" prot="private" virt="non-virtual"><scope>PlugRegistry</scope><name>_registeredPluginPaths</name></member>
      <member refid="class_plug_registry_1ab4f01e7936893266f6b9bab5598e706d" prot="private" virt="non-virtual"><scope>PlugRegistry</scope><name>_RegisterPlugin</name></member>
      <member refid="class_plug_registry_1af166bc55fe12ed1f397a7c7b9002856f" prot="private" virt="non-virtual"><scope>PlugRegistry</scope><name>_RegisterPlugins</name></member>
      <member refid="class_tf_weak_base_1a16f1e27cc0c7c606ffb397b7d970ed10" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>EnableNotification2</name></member>
      <member refid="class_plug_registry_1ab8d9978a85af6f5020d5f07a8ba644cf" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>FindDerivedTypeByName</name></member>
      <member refid="class_plug_registry_1ad656572db5fa6cb4d0a4b7ab17b3880f" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>FindDerivedTypeByName</name></member>
      <member refid="class_plug_registry_1ad4b3d4cb0992361d63ea170161fc6171" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>FindTypeByName</name></member>
      <member refid="class_plug_registry_1af859ac657fb599ad71583621d0cf805b" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>GetAllDerivedTypes</name></member>
      <member refid="class_plug_registry_1a07bd4722b659ca5c2ee2dd93ec79db67" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>GetAllDerivedTypes</name></member>
      <member refid="class_plug_registry_1aa395fd445592f25012f9406b155431d7" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>GetAllPlugins</name></member>
      <member refid="class_plug_registry_1a51a448ab0535968b4b3f1ef497322398" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>GetDataFromPluginMetaData</name></member>
      <member refid="class_plug_registry_1a491223b1f382752c136b50925cbc6d07" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>GetDirectlyDerivedTypes</name></member>
      <member refid="class_plug_registry_1a8b287622f64269e7f9edd1410436d805" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>GetInstance</name></member>
      <member refid="class_plug_registry_1a4c5dfc1c3b55017173c9df93b091424c" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>GetPluginForType</name></member>
      <member refid="class_plug_registry_1abab64fbe6f5a8d113e4f31a3bde0959a" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>GetPluginWithName</name></member>
      <member refid="class_plug_registry_1a545f23185a7f34a760b125daa5a6698a" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>GetStringFromPluginMetaData</name></member>
      <member refid="class_tf_weak_base_1a3241c32a82fbed0716a77049f6134e1e" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>GetUniqueIdentifier</name></member>
      <member refid="class_plug_registry_1acd30f35dbb2464285d1927b96cbe8717" prot="private" virt="non-virtual"><scope>PlugRegistry</scope><name>operator=</name></member>
      <member refid="class_tf_weak_base_1af890ac314073e903458bf6b2397566b5" prot="public" virt="non-virtual" ambiguityscope="TfWeakBase::"><scope>PlugRegistry</scope><name>operator=</name></member>
      <member refid="class_plug_registry_1a4bcd707c468bf0fb07ddb3e2d6a58367" prot="private" virt="non-virtual"><scope>PlugRegistry</scope><name>PlugPlugin</name></member>
      <member refid="class_plug_registry_1a2fdd5faaeea81f1e8ce7b58652b6b2b4" prot="private" virt="non-virtual"><scope>PlugRegistry</scope><name>PlugRegistry</name></member>
      <member refid="class_plug_registry_1a37768e08eee844e839a92120a9addf4b" prot="private" virt="non-virtual"><scope>PlugRegistry</scope><name>PlugRegistry</name></member>
      <member refid="class_plug_registry_1ada54bcdd334de360eddab430894dd5ac" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>RegisterPlugins</name></member>
      <member refid="class_plug_registry_1a43fe0749d24f0dd2a909a6abf2d427f9" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>RegisterPlugins</name></member>
      <member refid="class_plug_registry_1a610a5b8b8da196db90eb4d99d542a4f6" prot="private" virt="non-virtual"><scope>PlugRegistry</scope><name>TfSingleton&lt; PlugRegistry &gt;</name></member>
      <member refid="class_tf_weak_base_1a6e4abdd663654f8c8019702a464de8d6" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>TfWeakBase</name></member>
      <member refid="class_tf_weak_base_1affc4c00d0bbfdfe4f9e6a8b2e81be368" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>TfWeakBase</name></member>
      <member refid="class_plug_registry_1ab096e6a24e35ffd8c12719cb632570b7" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>This</name></member>
      <member refid="class_plug_registry_1adea5a2717c8af13dadc9919e197ffe5b" prot="public" virt="non-virtual"><scope>PlugRegistry</scope><name>TypeVector</name></member>
      <member refid="class_tf_weak_base_1a778020f525b66def8a284c6f020592c2" prot="protected" virt="non-virtual"><scope>PlugRegistry</scope><name>~TfWeakBase</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
