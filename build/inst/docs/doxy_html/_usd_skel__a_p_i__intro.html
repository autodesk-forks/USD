<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: API Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_usd_skel__a_p_i__intro.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">API Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page gives a brief introduction to using the UsdSkel API to read skel data encoded in USD.</p>
<h1><a class="anchor" id="UsdSkel_API_SkeletonQuery"></a>
Querying Skeleton Structure And Animation</h1>
<p>Given a scene that contains a <a class="el" href="class_usd_skel_skeleton.html" title="Describes a skeleton.">UsdSkelSkeleton</a>, a consuming application is free to access that primitive and reason about its structure on its own, if it chooses to do so. But UsdSkel also provides a more convenient API for querying data on a Skeleton: <a class="el" href="class_usd_skel_skeleton_query.html" title="Primary interface to reading bound skeleton data.">UsdSkelSkeletonQuery</a>. A <a class="el" href="class_usd_skel_skeleton_query.html" title="Primary interface to reading bound skeleton data.">UsdSkelSkeletonQuery</a> is created through a <a class="el" href="class_usd_skel_cache.html" title="Thread-safe cache for accessing query objects for evaluating skeletal data.">UsdSkelCache</a>, using a <a class="el" href="class_usd_skel_skeleton.html" title="Describes a skeleton.">UsdSkelSkeleton</a> primitive, as in the following example:</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><a class="code" href="class_usd_skel_cache.html">UsdSkelCache</a> skelCache;</div><div class="line"><a class="code" href="class_usd_skel_skeleton.html">UsdSkelSkeleton</a> skel = <a class="code" href="class_usd_skel_skeleton.html">UsdSkelSkeleton</a>.<a class="code" href="class_usd_skel_skeleton.html#a2f6dddaf7a197b14f9834af074445889">Get</a>((stage, <a class="code" href="class_sdf_path.html">SdfPath</a>(<span class="stringliteral">&quot;/Path/To/Skel&quot;</span>)));</div><div class="line"><a class="code" href="class_usd_skel_skeleton_query.html">UsdSkelSkeletonQuery</a> skelQuery = skelCache.<a class="code" href="class_usd_skel_cache.html#aaef141286813bfeb6998a8f0ac08b43b">GetSkelQuery</a>(skel);</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">skelCache = UsdSkel.Cache()</div><div class="line">skel = <a class="code" href="class_usd_skel_skeleton.html#a2f6dddaf7a197b14f9834af074445889">UsdSkelSkeleton.Get</a>(stage, <span class="stringliteral">&quot;/Path/To/Skel&quot;</span>);</div><div class="line">skelQuery = skelCache.GetSkelQuery(skel)</div></div><!-- fragment --></li>
</ul>
<p>As with other cache structures in Usd &ndash; <a class="el" href="class_usd_geom_xform_cache.html" title="A caching mechanism for transform matrices.">UsdGeomXformCache</a>, <a class="el" href="class_usd_geom_b_box_cache.html" title="Caches bounds by recursively computing and aggregating bounds of children in world space and aggregat...">UsdGeomBBoxCache</a>, etc. &ndash; the <a class="el" href="class_usd_skel_cache.html" title="Thread-safe cache for accessing query objects for evaluating skeletal data.">UsdSkelCache</a> that was constructed here is meant to be a persistent cache. The cache is thread-safe, and can be re-used for any numbers of primitives. When reading a USD file, it is best to create a single <a class="el" href="class_usd_skel_cache.html" title="Thread-safe cache for accessing query objects for evaluating skeletal data.">UsdSkelCache</a> to reuse for each new <a class="el" href="class_usd_skel_skeleton.html" title="Describes a skeleton.">UsdSkelSkeleton</a> that is encountered.</p>
<p>A <a class="el" href="class_usd_skel_skeleton_query.html" title="Primary interface to reading bound skeleton data.">UsdSkelSkeletonQuery</a> provides convenience methods for extracting joint transforms, in a variety of spaces.</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><span class="comment">// Local-space joint transforms</span></div><div class="line">VtMatrix4dArray localSpaceXforms;</div><div class="line">skelQuery.<a class="code" href="class_usd_skel_skeleton_query.html#a64035a9d2af1f6e3efe4ea06707beb30">ComputeJointLocalTransforms</a>(&amp;localSpaceXforms, time);</div><div class="line"></div><div class="line"><span class="comment">// Joint transforms in the space of the Skeleton.</span></div><div class="line">VtMatrix4dArray skelSpaceXforms;</div><div class="line">skelQuery.<a class="code" href="class_usd_skel_skeleton_query.html#a8655e2695cc5196046fb9ecba497a6a3">ComputeJointSkelTransforms</a>(&amp;skelSpaceXforms, time);</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line"><span class="comment"># Local-space joint transforms</span></div><div class="line">localSpaceXforms = skelQuery.ComputeJointLocalTransforms(time)</div><div class="line"></div><div class="line"><span class="comment"># Joint transforms in the space of the Skeleton.</span></div><div class="line">skelSpaceXforms = skelQuery.ComputeJointSkelTransforms(time)</div></div><!-- fragment --></li>
</ul>
<p>Note that this allows the animated transforms of a Skeleton to be extracted without having to deal with some of the more complicated aspects of the Skeleton encoding, such as the inheritance of the <em>skel:animationSource</em> relationship.</p>
<h2><a class="anchor" id="UsdSkel_API_JointPathsAndNames"></a>
Joint Paths and Names</h2>
<p>Each joint in a Skeleton is identified by a token, which represents the path to a joint in a hierarchy. For example:</p>
<div class="fragment"><div class="line">def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {</div><div class="line">    uniform token[] joints = [</div><div class="line">        <span class="stringliteral">&quot;Shoulder&quot;</span>, <span class="stringliteral">&quot;Shoulder/Elbow&quot;</span>, <span class="stringliteral">&quot;Shoulder/Elbow/Hand&quot;</span></div><div class="line">    ]</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>Each of these tokens can be converted to an <em><a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a></em>, after which the <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> methods can be used to extract different components of the path. For instance, to extract just the <em>name</em> component of each path (<code>Shoulder/Elbow</code> -&gt; <code>Elbow</code>), do the following:</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; skelQuery.<a class="code" href="class_usd_skel_skeleton_query.html#aab38abf001974901d97c0d9e07006262">GetJointOrder</a>().size(); ++i) {</div><div class="line">    <a class="code" href="class_sdf_path.html">SdfPath</a> jointPath(skelQuery.<a class="code" href="class_usd_skel_skeleton_query.html#aab38abf001974901d97c0d9e07006262">GetJointOrder</a>()[i]);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Name of joint &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; is &quot;</span></div><div class="line">              &lt;&lt; jointPath.<a class="code" href="class_sdf_path.html#a204344d110d2bb74928f43d2c1fe0047">GetName</a>() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line"><span class="keywordflow">for</span> i,jointToken <span class="keywordflow">in</span> enumerate(skelQuery.GetJointOrder()):</div><div class="line">    jointPath = Sdf.Path(jointToken)</div><div class="line">    <span class="keywordflow">print</span> <span class="stringliteral">&quot;Name of joint&quot;</span>, i, <span class="stringliteral">&quot;is&quot;</span>, jointPath.name</div></div><!-- fragment --></li>
</ul>
<p>For the schema example above, this code will print:</p>
<pre class="fragment">Name of joint 0 is Shoulder
Name of joint 1 is Elbow
Name of joint 2 is Hand
</pre><p>It should be noted that, if extracting the <em>name</em> of a joint in this manner, joint names are not guaranteed to be unique. For example, suppose a Skeleton has two arms. That may be encoded as:</p>
<div class="fragment"><div class="line">def Skeleton <span class="stringliteral">&quot;Skel&quot;</span> {</div><div class="line">    uniform token[] joints = [</div><div class="line">        <span class="stringliteral">&quot;LeftShoulder&quot;</span>, <span class="stringliteral">&quot;LeftShoulder/Elbow&quot;</span>, <span class="stringliteral">&quot;LeftShoulder/Elbow/Hand&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;RighShoulder&quot;</span>, <span class="stringliteral">&quot;RightShoulder/Elbow&quot;</span>, <span class="stringliteral">&quot;RightShoulder/Elbow/Hand&quot;</span></div><div class="line">    ]</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>Although the <em>path</em> of every joint is unique, there is no guarantee over the uniqueness of the <em>name</em>. This is true of primitives in USD in general: Names need not be globally unique, but rather only need to be unique amongst their sibling primitives.</p>
<h2><a class="anchor" id="UsdSkel_API_JointHierarchy"></a>
Querying the Joint Hierarchy</h2>
<p>The structure of the joint hierarchy itself can also be queried through the <a class="el" href="class_usd_skel_skeleton_query.html" title="Primary interface to reading bound skeleton data.">UsdSkelSkeletonQuery</a>. For example, suppose that in an application, every joint is described as a <em>Joint</em> object, which has a pointer to its parent <em>Joint</em>. Code for creating a <em>Joint</em> object for every joint in a Skeleton might look something like the following:</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><span class="comment">// The ordered set of Joint objects of an imaginary application.</span></div><div class="line">std::vector&lt;Joint&gt; joints;</div><div class="line"></div><div class="line"><span class="comment">// GetTopology() returns a UsdSkelTopology object, which describes</span></div><div class="line"><span class="comment">// the parent&lt;-&gt;child relationships. It also gives the number of joints.</span></div><div class="line"><span class="keywordtype">size_t</span> numJoints = skelQuery.<a class="code" href="class_usd_skel_skeleton_query.html#a0da8b34f1a4041f64579cdcc6547a042">GetTopology</a>().GetNumJoints();</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numJoints; ++i) {</div><div class="line">    std::string name = <a class="code" href="class_sdf_path.html">SdfPath</a>(skelQuery.<a class="code" href="class_usd_skel_skeleton_query.html#aab38abf001974901d97c0d9e07006262">GetJointOrder</a>()[i]).GetName();</div><div class="line">    <span class="keywordtype">int</span> parent = skelQuery.<a class="code" href="class_usd_skel_skeleton_query.html#a0da8b34f1a4041f64579cdcc6547a042">GetTopology</a>().<a class="code" href="class_usd_skel_topology.html#a779e634a4070d93af1e4b82bfe6c9149">GetParent</a>(i);</div><div class="line">    <span class="keywordflow">if</span> (parent &gt;= 0) {</div><div class="line">        Joint parentJoint = joints[parent];</div><div class="line">        joints.push_back(Joint(name, parentJoint));</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">// Root joint</span></div><div class="line">        joints.push_back(Joint(name));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line"><span class="comment"># The ordered set of Joint objects of an imaginary application.</span></div><div class="line">joints = []</div><div class="line"></div><div class="line"><span class="comment"># GetTopology() returns a UsdSkel.Topology object, which describes</span></div><div class="line"><span class="comment"># the parent&lt;-&gt;child relationships. It also gives the number of joints.</span></div><div class="line">numJoints = len(skelQuery.GetTopology())</div><div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(numJoints):</div><div class="line">    name = Sdf.Path(skelQuery.GetJointOrder()[i]).name</div><div class="line">    parent = skelQuery.GetTopology().GetParent(i)</div><div class="line">    <span class="keywordflow">if</span> parent &gt;= 0:</div><div class="line">        parentJoint = joints[parent]</div><div class="line">        joints.append(Joint(name, parentJoint))</div><div class="line">    <span class="keywordflow">else</span>:</div><div class="line">        joints.append(Joint(name))</div></div><!-- fragment --></li>
</ul>
<p>In the above code snippet, indexing into the <em>joints</em> array with the parent index of a joint might appear unsafe, since it might not be clear whether or not the parent joint had been constructed yet. However, it is a schema <b>requirement</b> that the set of joints is ordered, with parent joints coming before child joints. That is, linearly iterating through the ordered set of joints on a Skeleton must always describe a top-down hierarchy traversal. When a <a class="el" href="class_usd_skel_skeleton_query.html" title="Primary interface to reading bound skeleton data.">UsdSkelSkeletonQuery</a> is constructed, its topology is validated, and the resulting query object is only valid if that topology check passes. So given a valid <a class="el" href="class_usd_skel_skeleton_query.html" title="Primary interface to reading bound skeleton data.">UsdSkelSkeletonQuery</a>, the above code snippet will be safe.</p>
<p>To further expand on that point, the <em>topology</em> of a Skeleton may be directly validated as follows:</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><a class="code" href="class_usd_skel_skeleton.html">UsdSkelSkeleton</a> skel(skelPrim);</div><div class="line">VtTokenArray joints;</div><div class="line"><span class="keywordflow">if</span> (skel.<a class="code" href="class_usd_skel_skeleton.html#aa6bf8297f4aae6de9fbf1b784c524d30">GetJointsAttr</a>().<a class="code" href="class_usd_attribute.html#a9d41bc223be86408ba7d7f74df7c35a9">Get</a>(&amp;joints)) {</div><div class="line">    <a class="code" href="class_usd_skel_topology.html">UsdSkelTopology</a> topology(joints);</div><div class="line">    std::string whyNot;</div><div class="line">    <span class="keywordtype">bool</span> valid = topology.Validate(&amp;whyNot);</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">skel = UsdSkel.Skeleton(skelPrim)</div><div class="line">joints = skel.GetJointsAttr().Get(joints)</div><div class="line"><span class="keywordflow">if</span> joints:</div><div class="line">   topology = UsdSkel.Topology(joints)</div><div class="line">   valid,whyNot = topology.Validate()</div></div><!-- fragment --></li>
</ul>
<p>But again, if data is being queried through a <a class="el" href="class_usd_skel_skeleton_query.html" title="Primary interface to reading bound skeleton data.">UsdSkelSkeletonQuery</a>, this validation occurs <em>automatically</em>.</p>
<h1><a class="anchor" id="UsdSkel_API_SkeletonBindings"></a>
Skeleton Bindings</h1>
<p>Before applying skinning to primitives, we need to first identify which primitives are skinnable, and which Skeleton affects them. It is also desired that this discovery process helps facilitate data sharing. For instance, suppose a model consists of 1000 individual meshes. In order to skin those meshes on a GPU, we would need to first compute appropriate skinning transforms to upload to the GPU. It would be awfully inefficient to do that for each individual mesh &ndash; I.e., to perform redundant computations, and upload the same set of transforms for each mesh.</p>
<p>The following snippet demonstrates how this can be addressed efficiently through UsdSkel. We will show the complete code first, before describing the individual parts in more detail:</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><a class="code" href="class_usd_skel_cache.html">UsdSkelCache</a> skelCache;</div><div class="line"></div><div class="line"><span class="comment">// Traverse through the prims on the stage to find where we might</span></div><div class="line"><span class="comment">// have prims to skin.</span></div><div class="line"><span class="keyword">auto</span> it = stage-&gt;Traverse();</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="class_usd_prim.html">UsdPrim</a>&amp; prim : it) {</div><div class="line">    <span class="keywordflow">if</span> (prim.IsA&lt;<a class="code" href="class_usd_skel_root.html">UsdSkelRoot</a>&gt;()) {</div><div class="line">        it.PruneChilren();</div><div class="line"></div><div class="line">        <a class="code" href="class_usd_skel_root.html">UsdSkelRoot</a> skelRoot(prim);</div><div class="line">        skelCache.<a class="code" href="class_usd_skel_cache.html#abe0fe7ed06f122fda9ffd7924c231d3f">Populate</a>(skelRoot, <a class="code" href="prim_flags_8h.html#a0d604565b22c13d66365b04be5a8da12">UsdTraverseInstanceProxies</a>()));</div><div class="line"></div><div class="line">        std::vector&lt;UsdSkelBinding&gt; bindings;</div><div class="line">        skelCache.<a class="code" href="class_usd_skel_cache.html#a4637404879063e53d1c0187b2d336d06">ComputeSkelBindings</a>(skelRoot, &amp;bindings,</div><div class="line">                                      <a class="code" href="prim_flags_8h.html#a0d604565b22c13d66365b04be5a8da12">UsdTraverseInstanceProxies</a>());</div><div class="line"></div><div class="line">        <span class="comment">// Iterate over the bindings related to this SkelRoot</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="class_usd_skel_binding.html">UsdSkelBinding</a>&amp; binding : bindings) {</div><div class="line">            <span class="comment">// Get the Skeleton for this binding.</span></div><div class="line">            UsdSkelQuery skelQuery =</div><div class="line">                skelCache.<a class="code" href="class_usd_skel_cache.html#aaef141286813bfeb6998a8f0ac08b43b">GetSkelQuery</a>(binding.GetSkeleton());</div><div class="line"></div><div class="line">            VtMatrix4dArray skinningXforms;</div><div class="line">            <span class="keywordflow">if</span> (skelQuery.ComputeSkinningTransforms(&amp;skinningXforms, time)) {</div><div class="line"></div><div class="line">                <span class="comment">// Iterate over the prims that are skinned by this Skeleton.</span></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="class_usd_skel_skinning_query.html">UsdSkelSkinningQuery</a>&amp; skinningQuery :</div><div class="line">                     binding.GetSkinningTargets()) {</div><div class="line">                     </div><div class="line">                   <span class="keyword">const</span> <a class="code" href="class_usd_prim.html">UsdPrim</a>&amp; primToSkin = skinningQuery.<a class="code" href="class_usd_object.html#a4ba10e023e7f3f3c93131bc7fc3146b7">GetPrim</a>();</div><div class="line">                   <span class="comment">// Process prim / apply skinning</span></div><div class="line">                }</div><div class="line">            }</div><div class="line">       }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">skelCache = UsdSkel.Cache()</div><div class="line"></div><div class="line"><span class="comment"># Traverse through the prims on the stage to find where we might</span></div><div class="line"><span class="comment"># have prims to skin.</span></div><div class="line">it = iter(stage.Traverse())</div><div class="line"><span class="keywordflow">for</span> prim <span class="keywordflow">in</span> it:</div><div class="line">    <span class="keywordflow">if</span> prim.IsA(UsdSkel.Root):</div><div class="line">        it.PruneChildren()</div><div class="line">        </div><div class="line">        skelRoot = UsdSkel.Root(prim)</div><div class="line">        skelCache.Populate(skelRoot, Usd.TraverseInstanceProxies()))</div><div class="line">        </div><div class="line">        bindings = skelCache.ComputeSkelBindings(</div><div class="line">            skelRoot, Usd.TraverseInstanceProxies())</div><div class="line"></div><div class="line">        <span class="comment"># Iterate over the bindings related to this SkelRoot</span></div><div class="line">        <span class="keywordflow">for</span> binding <span class="keywordflow">in</span> bindings:</div><div class="line">            <span class="comment"># Get the Skeleton for this binding.</span></div><div class="line">            skelQuery = skelCache.GetSkelQuery(binding.GetSkeleton())</div><div class="line"></div><div class="line">            skinningXforms = skelQuery.ComputeSkinningTransforms(time)</div><div class="line">            <span class="keywordflow">if</span> skinningXforms:</div><div class="line"></div><div class="line">               <span class="comment"># Iterate over the prims that are skinned by this Skeleton.   </span></div><div class="line">               <span class="keywordflow">for</span> skinningQuery <span class="keywordflow">in</span> binding.GetSkinningTargets():</div><div class="line">                   primToSkin = skinningQuery.GetPrim()</div><div class="line">                   <span class="comment"># Process prim / apply skinning</span></div></div><!-- fragment --></li>
</ul>
<p>The first part of this should be familiar:</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><a class="code" href="class_usd_skel_cache.html">UsdSkelCache</a> skelCache;</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">skelCache = UsdSkel.Cache()</div></div><!-- fragment --></li>
</ul>
<p>When accessing a <a class="el" href="class_usd_skel_skeleton_query.html" title="Primary interface to reading bound skeleton data.">UsdSkelSkeletonQuery</a> for a Skeleton, we constructed a <a class="el" href="class_usd_skel_cache.html" title="Thread-safe cache for accessing query objects for evaluating skeletal data.">UsdSkelCache</a>. Again, in a context where data is being read from USD, this cache is intended to persist and be reused across multiple prims (or multiple stages, for that matter). This code example actually makes for a good example of how the cache can be shared across multiple primitives.</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><span class="keyword">auto</span> it = stage-&gt;Traverse();</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="class_usd_prim.html">UsdPrim</a>&amp; prim : it) {</div><div class="line">    <span class="keywordflow">if</span> (prim.IsA&lt;<a class="code" href="class_usd_skel_root.html">UsdSkelRoot</a>&gt;()) {</div><div class="line">        it.PruneChilren();</div><div class="line">        ...</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">it = iter(stage.Traverse())</div><div class="line"><span class="keywordflow">for</span> prim <span class="keywordflow">in</span> it:</div><div class="line">    <span class="keywordflow">if</span> prim.IsA(UsdSkel.Root):</div><div class="line">        it.PruneChildren()</div><div class="line">        ...</div></div><!-- fragment --></li>
</ul>
<p>Here, we traverse through the primitives on the stage. When we encounter a <a class="el" href="class_usd_skel_root.html" title="Boundable prim type used to identify a scope beneath which skeletally-posed primitives are defined.">UsdSkelRoot</a> primitive, we know that we have discovered a branch of the scene graph that <em>might</em> contain skeletally-posed models.</p>
<p>Being able to identify subsets of the scene graph that contain skeletal characters is part of the motivation behind the existence of SkelRoot primitives. It is common in IO contexts to use the SkelRoot as a point for dispatching common computations needed when translating Skeletons.</p>
<p>Both when calling Populate() as well as when computing bindings, a predicate is passed that enables traversal of instances. This code is assuming that it is reasonably to process instanced, skinned primitives. If that is not the case, we could instead pass UsdPrimDefaultPredicate.</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><a class="code" href="class_usd_skel_root.html">UsdSkelRoot</a> skelRoot(prim);</div><div class="line">skelCache.<a class="code" href="class_usd_skel_cache.html#abe0fe7ed06f122fda9ffd7924c231d3f">Populate</a>(skelRoot, <a class="code" href="prim_flags_8h.html#a0d604565b22c13d66365b04be5a8da12">UsdTraverseInstanceProxies</a>());</div><div class="line"></div><div class="line">std::vector&lt;UsdSkelBinding&gt; bindings;</div><div class="line">skelCache.<a class="code" href="class_usd_skel_cache.html#a4637404879063e53d1c0187b2d336d06">ComputeSkelBindings</a>(skelRoot, &amp;bindings,</div><div class="line">                              <a class="code" href="prim_flags_8h.html#a0d604565b22c13d66365b04be5a8da12">UsdTraverseInstanceProxies</a>());</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">skelRoot = UsdSkel.Root(prim)</div><div class="line">skelCache.Populate(skelRoot, Usd.TraverseInstanceProxies())</div><div class="line"></div><div class="line">bindings = skelCache.ComputeSkelBindings(</div><div class="line">    skelRoot, Usd.TraverseInstanceProxies())</div></div><!-- fragment --></li>
</ul>
<p>A <a class="el" href="class_usd_skel_binding.html" title="Helper object that describes the binding of a skeleton to a set of skinnable objects.">UsdSkelBinding</a> object is a simply a mapping of some Skeleton to a set of skinnable primitives. We can compute those mappings by way of the <a class="el" href="class_usd_skel_cache.html" title="Thread-safe cache for accessing query objects for evaluating skeletal data.">UsdSkelCache</a>, but must first <code>Populate()</code> that section of the scene graph on the cache.</p>
<p>What we gain from using this API is that the <a class="el" href="class_usd_skel_cache.html" title="Thread-safe cache for accessing query objects for evaluating skeletal data.">UsdSkelCache</a> is doing all the work of properly resolving inherited binding properties for us, allowing us to get at the question we're really interested: What prims are we skinning, and with which Skeletons?</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="class_usd_skel_binding.html">UsdSkelBinding</a>&amp; binding : bindings) {</div><div class="line">    <span class="comment">// Get the Skeleton for this binding.</span></div><div class="line">    UsdSkelQuery skelQuery =</div><div class="line">        skelCache.<a class="code" href="class_usd_skel_cache.html#aaef141286813bfeb6998a8f0ac08b43b">GetSkelQuery</a>(binding.GetSkeleton());</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line"><span class="comment"># Iterate over the bindings related to this SkelRoot</span></div><div class="line"><span class="keywordflow">for</span> binding <span class="keywordflow">in</span> bindings:</div><div class="line">    <span class="comment"># Get the Skeleton for this binding.</span></div><div class="line">    skelQuery = skelCache.GetSkelQuery(binding.GetSkeleton())</div><div class="line">    ...</div></div><!-- fragment --></li>
</ul>
<p>There could be any number of Skeletons beneath a SkelRoot. There will be a <a class="el" href="class_usd_skel_binding.html" title="Helper object that describes the binding of a skeleton to a set of skinnable objects.">UsdSkelBinding</a> associated with each uniquely bound Skeleton. So we must iterate over all of them.</p>
<p>The binding holds a reference to the Skeleton. As we saw earlier, we can extract a <a class="el" href="class_usd_skel_skeleton_query.html" title="Primary interface to reading bound skeleton data.">UsdSkelSkeletonQuery</a> from the <a class="el" href="class_usd_skel_cache.html" title="Thread-safe cache for accessing query objects for evaluating skeletal data.">UsdSkelCache</a> using that Skeleton, which provides a more convenient API for extracting data from the Skeleton.</p>
<ul>
<li>C++: <div class="fragment"><div class="line">VtMatrix4dArray skinningXforms;</div><div class="line"><span class="keywordflow">if</span> (skelQuery.ComputeSkinningTransforms(&amp;skinningXforms, time)) {</div><div class="line">   ...</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">skinningXforms = skelQuery.ComputeSkinningTransforms(time)</div><div class="line"><span class="keywordflow">if</span> skinningXforms:</div><div class="line">   ...</div></div><!-- fragment --></li>
</ul>
<p>The skinning transforms have been included at this point only as an example, to emphasize the point that this serves as a common code site at which properties related to a Skeleton can be computed, which are subsequently shared across all of the primitives that are skinned by that Skeleton.</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><span class="comment">// Iterate over the prims that are skinned by this Skeleton.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="class_usd_skel_skinning_query.html">UsdSkelSkinningQuery</a>&amp; skinningQuery :</div><div class="line">     binding.GetSkinningTargets()) {</div><div class="line">     </div><div class="line">   <span class="keyword">const</span> <a class="code" href="class_usd_prim.html">UsdPrim</a>&amp; primToSkin = skinningQuery.<a class="code" href="class_usd_object.html#a4ba10e023e7f3f3c93131bc7fc3146b7">GetPrim</a>();</div><div class="line"></div><div class="line">   ...</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line"><span class="comment"># Iterate over the prims that are skinned by this Skeleton.   </span></div><div class="line"><span class="keywordflow">for</span> skinningQuery <span class="keywordflow">in</span> binding.GetSkinningTargets():</div><div class="line"></div><div class="line">    primToSkin = skinningQuery.GetPrim()</div><div class="line">    ...</div></div><!-- fragment --></li>
</ul>
<p>At this point, we have a Skeleton &ndash; or better yet, a <a class="el" href="class_usd_skel_skeleton_query.html" title="Primary interface to reading bound skeleton data.">UsdSkelSkeletonQuery</a> &ndash; and can traverse over the 'skinning targets', which are the set of primitives that are skinned by that Skeleton.</p>
<p>The set of skinned primitives are returned as <a class="el" href="class_usd_skel_skinning_query.html" title="Object used for querying resolved bindings for skinning.">UsdSkelSkinningQuery</a> objects. Just as <a class="el" href="class_usd_skel_skeleton_query.html" title="Primary interface to reading bound skeleton data.">UsdSkelSkeletonQuery</a> objects provide convenient API for querying data related to a Skeleton, a <a class="el" href="class_usd_skel_skinning_query.html" title="Object used for querying resolved bindings for skinning.">UsdSkelSkinningQuery</a> provides convenient API for reading data related to primitives that are skinned, such as joint influences. See the <a class="el" href="_usd_skel__a_p_i__intro.html#UsdSkel_API_SkinningQuery">skinning query</a> section for more information.</p>
<h2><a class="anchor" id="UsdSkel_API_DiscoveringBindings"></a>
Discovering Bindings On Skinnable Primitives</h2>
<p>In the <a class="el" href="_usd_skel__a_p_i__intro.html#UsdSkel_API_SkeletonBindings">Skeleton Bindings</a> section, we explored a top-down traversal of a stage, which allowed us to efficiently associate a Skeleton with multiple prims that are affected by that Skeleton. Sometimes, such top-down traversal patterns are not possible, and we need to discover bindings the other way around: That is, given a primitive, discover the Skeleton that affects it, and begin computing data required to skin it.</p>
<p>As with the previous section, we will start with a complete coding example, before breaking down the individual parts.</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><a class="code" href="class_usd_skel_cache.html">UsdSkelCache</a> skelCache;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_usd_skel_root.html">UsdSkelRoot</a> skelRoot = <a class="code" href="class_usd_skel_root.html#abae051db9db8423b62b5f4e86cdc2ee5">UsdSkelRoot::Find</a>(prim)) {</div><div class="line">   skelCache.<a class="code" href="class_usd_skel_cache.html#abe0fe7ed06f122fda9ffd7924c231d3f">Populate</a>(skelRoot, <a class="code" href="prim_flags_8h.html#a0d604565b22c13d66365b04be5a8da12">UsdTraverseInstanceProxies</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="class_usd_skel_skinning_query.html">UsdSkelSkinningQuery</a> skinningQuery = skelCache.<a class="code" href="class_usd_skel_cache.html#a182cd014ee50683dc1774e1b2a1d0db1">GetSkinningQuery</a>(prim)) {</div><div class="line"></div><div class="line">        <span class="comment">// Find the Skeleton that should affect this prim.</span></div><div class="line">        <a class="code" href="class_usd_skel_skeleton.html">UsdSkelSkeleton</a> skel = <a class="code" href="class_usd_skel_binding_a_p_i.html">UsdSkelBindingAPI</a>(prim).<a class="code" href="class_usd_skel_binding_a_p_i.html#a781a5a151d35fd6f9f1773f5755d261d">GetInheritedSkeleton</a>();</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="class_usd_skel_skeleton_query.html">UsdSkelSkeletonQuery</a> skelQuery = skelCache.<a class="code" href="class_usd_skel_cache.html#aaef141286813bfeb6998a8f0ac08b43b">GetSkelQuery</a>(skel)) {</div><div class="line">            <span class="comment">// Apply skinning?</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">skelCache = UsdSkel.Cache()</div><div class="line"></div><div class="line">skelRoot = UsdSkel.Root.Find(prim)</div><div class="line"><span class="keywordflow">if</span> skelRoot:</div><div class="line">   skelCache.Populate(skelRoot, Usd.TraverseInstanceProxies())</div><div class="line"></div><div class="line">    skinningQuery = skelCache.GetSkinningQuery(prim)</div><div class="line">    <span class="keywordflow">if</span> skinningQuery:</div><div class="line"></div><div class="line">        <span class="comment"># Find the Skeleton that should affect this prim.</span></div><div class="line">        skel = UsdSkel.BindingAPI(prim).GetInheritedSkeleton()</div><div class="line">        skelQuery = skelCache.GetSkelQuery(skel);</div><div class="line">        <span class="keywordflow">if</span> skelQuery:</div><div class="line">            <span class="comment"># Apply skinning?</span></div></div><!-- fragment --></li>
</ul>
<p>Once more, the first line should seem familiar:</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><a class="code" href="class_usd_skel_cache.html">UsdSkelCache</a> skelCache;</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">skelCache = UsdSkel.Cache()</div></div><!-- fragment --></li>
</ul>
<p>As with previous examples, we utilize a <a class="el" href="class_usd_skel_cache.html" title="Thread-safe cache for accessing query objects for evaluating skeletal data.">UsdSkelCache</a>. Again, we emphasize that such caches should persist, and be shared across multiple prims.</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_usd_skel_root.html">UsdSkelRoot</a> skelRoot = <a class="code" href="class_usd_skel_root.html#abae051db9db8423b62b5f4e86cdc2ee5">UsdSkelRoot::Find</a>(prim)) {</div><div class="line">   skelCache.<a class="code" href="class_usd_skel_cache.html#abe0fe7ed06f122fda9ffd7924c231d3f">Populate</a>(skelRoot, <a class="code" href="prim_flags_8h.html#a0d604565b22c13d66365b04be5a8da12">UsdTraverseInstanceProxies</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="class_usd_skel_skinning_query.html">UsdSkelSkinningQuery</a> skinningQuery = skelCache.<a class="code" href="class_usd_skel_cache.html#a182cd014ee50683dc1774e1b2a1d0db1">GetSkinningQuery</a>(prim)) {</div><div class="line">       ...</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">skelRoot = UsdSkel.Root.Find(prim)</div><div class="line"><span class="keywordflow">if</span> skelRoot:</div><div class="line">   skelCache.Populate(skelRoot, Usd.TraverseInstanceProxies())</div><div class="line"></div><div class="line">    skinningQuery = skelCache.GetSkinningQuery(prim)</div><div class="line">    <span class="keywordflow">if</span> skinningQuery:</div><div class="line">       ...</div></div><!-- fragment --></li>
</ul>
<p>We want to be able to extract a <a class="el" href="class_usd_skel_skinning_query.html" title="Object used for querying resolved bindings for skinning.">UsdSkelSkinningQuery</a>, which provides useful utilities for working with skinnable primitives. As with <a class="el" href="class_usd_skel_skeleton_query.html" title="Primary interface to reading bound skeleton data.">UsdSkelSkeletonQuery</a> objects, skinning queries are accessed through the <a class="el" href="class_usd_skel_cache.html" title="Thread-safe cache for accessing query objects for evaluating skeletal data.">UsdSkelCache</a>. But before they are accessed, we need to <code>Populate()</code> the <a class="el" href="class_usd_skel_cache.html" title="Thread-safe cache for accessing query objects for evaluating skeletal data.">UsdSkelCache</a> with the section of the scene graph that contains the skinnable primitive. Cache population causes the cache to be pre-populated with information about inherited bindings, which is necessary when accessing skinning queries. All prims which have authored UsdSkel attributes must also have the SkelBindingAPI schema applied at time of cache population.</p>
<p>Passing the predicate produced by <a class="el" href="prim_flags_8h.html#a0d604565b22c13d66365b04be5a8da12" title="This function is used to allow the prim traversal functions listed under Prim predicate flags to trav...">UsdTraverseInstanceProxies()</a> ensures that instanced, skinnable prims are populated on the cache. If there is no need to consider instanced primitives, then a predicate that does not traverse instance proxies &ndash; such as UsdPrimDefaultPredicate &ndash; may be used instead.</p>
<p>The SkelRoot that encapsulates a primitive can be found using <a class="el" href="class_usd_skel_root.html#abae051db9db8423b62b5f4e86cdc2ee5" title="Returns the skel root at or above prim, or an invalid schema object.">UsdSkelRoot::Find</a>. If no SkelRoot is found, that means that the primitive is not encapsulated within a SkelRoot, and so any properties on the prim related to skinning should be ignored.</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_usd_skel_skinning_query.html">UsdSkelSkinningQuery</a> skinningQuery = skelCache.<a class="code" href="class_usd_skel_cache.html#a182cd014ee50683dc1774e1b2a1d0db1">GetSkinningQuery</a>(prim)) {</div><div class="line">   ...</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">skinningQuery = skelCache.GetSkinningQuery(prim)</div><div class="line"><span class="keywordflow">if</span> skinningQuery:</div><div class="line">   ...</div></div><!-- fragment --></li>
</ul>
<p>Having found a SkelRoot and populated the <a class="el" href="class_usd_skel_cache.html" title="Thread-safe cache for accessing query objects for evaluating skeletal data.">UsdSkelCache</a>, we can access a <a class="el" href="class_usd_skel_skinning_query.html" title="Object used for querying resolved bindings for skinning.">UsdSkelSkinningQuery</a> object for the primitive that is being skinned. If the resulting <a class="el" href="class_usd_skel_skinning_query.html" title="Object used for querying resolved bindings for skinning.">UsdSkelSkinningQuery</a> is invalid, that means that either the primitive is not considered to be skinnable, or the skinning properties are malformed in some way. If the latter, appropriate warning messages will have been posted.</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><span class="comment">// Find the Skeleton that should affect this prim.</span></div><div class="line"><a class="code" href="class_usd_skel_skeleton.html">UsdSkelSkeleton</a> skel = <a class="code" href="class_usd_skel_binding_a_p_i.html">UsdSkelBindingAPI</a>(prim).<a class="code" href="class_usd_skel_binding_a_p_i.html#a781a5a151d35fd6f9f1773f5755d261d">GetInheritedSkeleton</a>();</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_usd_skel_skeleton_query.html">UsdSkelSkeletonQuery</a> skelQuery = skelCache.<a class="code" href="class_usd_skel_cache.html#aaef141286813bfeb6998a8f0ac08b43b">GetSkelQuery</a>(skel)) {</div><div class="line">    <span class="comment">// Apply skinning?</span></div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line"><span class="comment"># Find the Skeleton that should affect this prim.</span></div><div class="line">skel = UsdSkel.BindingAPI(prim).GetInheritedSkeleton()</div><div class="line">skelQuery = skelCache.GetSkelQuery(skel);</div><div class="line"><span class="keywordflow">if</span> skelQuery:</div><div class="line">    <span class="comment"># Apply skinning?</span></div></div><!-- fragment --></li>
</ul>
<p>If we've acquired a valid <a class="el" href="class_usd_skel_skinning_query.html" title="Object used for querying resolved bindings for skinning.">UsdSkelSkinningQuery</a>, we know that a primitive is a valid candidate for skinning. The next logical step might be to determine which Skeleton affects skinning. <a class="el" href="class_usd_skel_binding_a_p_i.html#a781a5a151d35fd6f9f1773f5755d261d" title="Returns the skeleton bound at this prim, or one of its ancestors.">UsdSkelBindingAPI::GetInheritedSkeleton</a> can be used to discover the bound Skeleton, based on the inherited <em>skel:skeleton</em> binding properties. As before, once we have a Skeleton, we can get access to a <a class="el" href="class_usd_skel_skeleton_query.html" title="Primary interface to reading bound skeleton data.">UsdSkelSkeletonQuery</a> to assist value extraction.</p>
<h2><a class="anchor" id="UsdSkel_API_SkinningQuery"></a>
UsdSkelSkinningQuery: Extracting joint influences</h2>
<p>Coding examples from the previous sections demonstrated how to find skinnable primitives and gain access to a <a class="el" href="class_usd_skel_skinning_query.html" title="Object used for querying resolved bindings for skinning.">UsdSkelSkinningQuery</a> object for a skinnable primitive. Here we briefly demonstrate some of the basic queries that can be used to extract joint influences from skinning queries:</p>
<ul>
<li>C++: <div class="fragment"><div class="line">VtIntArray jointIndices;</div><div class="line">VtFloatArray jointWeights;</div><div class="line">skinningQuery.ComputeJointInfluences(&amp;jointIndices, &amp;jointWeights);</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">influences = skinningQuery.ComputeJointInfluences()</div><div class="line"><span class="keywordflow">if</span> influences:</div><div class="line">    jointIndices,jointWeights = influences</div></div><!-- fragment --></li>
</ul>
<p>Use <a class="el" href="class_usd_skel_skinning_query.html#a55b3d590dfab71d7d108f09d138d3351" title="Returns true if the held prim has the same joint influences across all points, or false otherwise.">UsdSkelSkinningQuery::IsRigidlyDeformed</a> to determine whether or not these arrays represent rigid influences, or varying (per-point) influences.</p>
<p>If the skinnable primitive is <em>not</em> rigidly deforming, then these arrays store a fixed number of influences per point. The full set of influences for the first point come first, followed by the influences for the second point, and so forth. <a class="el" href="class_usd_skel_skinning_query.html#ae9c6fae1e6724c31e15f04295da5e976" title="Convenience method for computing joint influence, where constant influences are expanded to hold valu...">UsdSkelSkinningQuery::ComputeVaryingJointInfluences</a></p>
<p>returns the number of influences that map to each point.</p>
<p>If the skinnable primitive is rigidly deforming, then all of the resulting influences apply to <em>every point</em>. Such a deformation can also be applied by altering a primitive's transform &ndash; hence, a rigid deformation. It is up to the client to determine how to deal with rigid influences.</p>
<p>Not all applications are capable of dealing with rigid transformations. If that's the case, <a class="el" href="class_usd_skel_skinning_query.html#ae9c6fae1e6724c31e15f04295da5e976" title="Convenience method for computing joint influence, where constant influences are expanded to hold valu...">UsdSkelSkinningQuery::ComputeVaryingJointInfluences</a> can be used instead:</p>
<ul>
<li>C++: <div class="fragment"><div class="line">VtIntArray jointIndices;</div><div class="line">VtFloatArray jointWeights;</div><div class="line">skinningQuery.ComputeVaryingJointInfluences(</div><div class="line">    numPoints, &amp;jointIndices, &amp;jointWeights);</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">influences = skinningQuery.ComputeVaryingJointInfluences(numPoints)</div><div class="line"><span class="keywordflow">if</span> influences:</div><div class="line">    jointIndices,jointWeights = influences</div></div><!-- fragment --></li>
</ul>
<p>When calling <a class="el" href="class_usd_skel_skinning_query.html#ae9c6fae1e6724c31e15f04295da5e976" title="Convenience method for computing joint influence, where constant influences are expanded to hold valu...">UsdSkelSkinningQuery::ComputeVaryingJointInfluences</a>, rigid influences are automatically expanded out to define per-point influences.</p>
<p>Another restriction encountered in some applications is that they have a limit on the number of influences that may be specified per point. We do not feel that it is appropriate to enforce such application-specific limitations on the storage encoding, so UsdSkel defines no limit on the number of influences.</p>
<p>However, UsdSkel does provide utility methods to allow influence arrays to be resized, which such applications may use:</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><span class="keywordtype">int</span> numInfluencesPerComponent = skinningQuery.GetNumInfluencesPerComponent();</div><div class="line"><span class="keywordflow">if</span> (numInfluencesPerComponent &gt; 4) {</div><div class="line">   <a class="code" href="group___usd_skel___joint_influence_utils.html#ga062c9743f1bfb73b8274098c3349c4ef">UsdSkelResizeInfluences</a>(&amp;jointIndices, numInfluencesPerComponent, 4);</div><div class="line">   <a class="code" href="group___usd_skel___joint_influence_utils.html#ga062c9743f1bfb73b8274098c3349c4ef">UsdSkelResizeInfluences</a>(&amp;jointWeights, numInfluencesPerComponent, 4);</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">numInfluencesPerComponent = skinningQuery.GetNumInfluencesPerComponent()</div><div class="line"><span class="keywordflow">if</span> numInfluencesPerComponent &gt; 4:</div><div class="line">   UsdSkel.ResizeInfluences(jointIndices, numInfluencesPerComponent, 4);</div><div class="line">   UsdSkel.ResizeInfluences(jointWeights, numInfluencesPerComponent, 4);</div></div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="UsdSkel_API_BakeSkinning"></a>
Testing Skinning with UsdSkelBakeSkinning</h1>
<p>UsdSkel provides a UsdSkelBakeSkinning method that bakes the results of skinning directly into points and transforms, effectively converting skeletally posed primitives into normal geometry caches, with no special skeletal behaviors.</p>
<p>UsdSkelBakeSkinning is intended both to serve as a reference implementation for skinning, and to help facilitate testing. </p><dl class="section warning"><dt>Warning</dt><dd>UsdSkelBakeSkinning is intended for testing and debugging, and emphasizes correctness over performance. It should not be used in performance-sensitive contexts.</dd></dl>
<p>Skinning can be baked on a stage as follows:</p>
<ul>
<li>C++: <div class="fragment"><div class="line">UsdSkelBakeSkinning(stage-&gt;Traverse());</div><div class="line">stage-&gt;Save();</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">UsdSkel.BakeSkinning(stage.Traverse());</div><div class="line">stage.Save();</div></div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="UsdSkel_API_WritingSkels"></a>
Writing Skeletons</h1>
<p>The following code demonstrates the full USD/UsdSkel API, showing how an animated Skeleton might be authored by a DCC application. It is not meant to be a definitive example on the <em>right</em> way to author a Skeleton, but merely serves as a simple example to start from.</p>
<p>For simplicity, this example focuses solely on encoding a Skeleton, and does not including bindings for skinnable primitives.</p>
<p>As with previous examples, we begin with complete code, and then break it down into its component parts.</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><span class="keywordtype">bool</span></div><div class="line">WriteAnimatedSkel(</div><div class="line">    <span class="keyword">const</span> UsdStagePtr&amp; stage,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="class_sdf_path.html">SdfPath</a>&amp; skelPath,</div><div class="line">    <span class="keyword">const</span> SdfPathVector&amp; jointPaths,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;GfMatrix4d&gt;&amp; rootTransformsPerFrame,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;VtMatrix4dArray&gt;&amp; jointWorldSpaceTransformsPerFrame,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;UsdTimeCode&gt;&amp; times,</div><div class="line">    <span class="keyword">const</span> VtMatrix4dArray&amp; bindTransforms,</div><div class="line">    <span class="keyword">const</span> VtMatrix4dArray* restTransforms=<span class="keyword">nullptr</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (rootTransformsPerFrame.size() != times.size())</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">if</span> (jointWorldSpaceTransformsPerFrame.size() != times.size())</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">if</span> (bindTransforms.size() != jointPaths.size())</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <a class="code" href="class_usd_skel_skeleton.html">UsdSkelSkeleton</a> skel = <a class="code" href="class_usd_skel_skeleton.html#a24c1eea74c3316635f1105a4b76f1315">UsdSkelSkeleton::Define</a>(stage, skelPath);</div><div class="line">    <span class="keywordflow">if</span> (!skel) {</div><div class="line">        <a class="code" href="group__group__tf___diagnostic.html#gaba2e638edaae9e9c6e5180e020f12ccf">TF_WARN</a>(<span class="stringliteral">&quot;Failed creating a Skeleton prim at &lt;%s&gt;.&quot;</span>, skelPath.<a class="code" href="class_sdf_path.html#a31225e07892b847e3e98473f7f04dbf4">GetText</a>());</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> numJoints = jointPaths.size();</div><div class="line"></div><div class="line">    <a class="code" href="class_usd_skel_topology.html">UsdSkelTopology</a> topo(jointPaths);</div><div class="line">    std::string reason;</div><div class="line">    <span class="keywordflow">if</span> (!topo.Validate(&amp;reason)) {</div><div class="line">        <a class="code" href="group__group__tf___diagnostic.html#gaba2e638edaae9e9c6e5180e020f12ccf">TF_WARN</a>(<span class="stringliteral">&quot;Invalid topology: %s&quot;</span>, reason.c_str());</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    VtTokenArray jointTokens(numJoints);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; jointPaths.size(); ++i) {</div><div class="line">        jointTokens[i] = <a class="code" href="class_tf_token.html">TfToken</a>(jointPaths[i].GetString());</div><div class="line">    }</div><div class="line">    skel.<a class="code" href="class_usd_skel_skeleton.html#aa6bf8297f4aae6de9fbf1b784c524d30">GetJointsAttr</a>().<a class="code" href="class_usd_attribute.html#a7fd0957eecddb7cfcd222cccd51e23e6">Set</a>(jointTokens);</div><div class="line"></div><div class="line">    skel.<a class="code" href="class_usd_skel_skeleton.html#a0762be4742010c4943912c4c428624dc">GetBindTransformsAttr</a>().<a class="code" href="class_usd_attribute.html#a7fd0957eecddb7cfcd222cccd51e23e6">Set</a>(bindTransforms);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (restTransforms &amp;&amp; restTransforms-&gt;size() == numJoints) {</div><div class="line">        skel.<a class="code" href="class_usd_skel_skeleton.html#af1fb07ad318db8d810a3afd7925b31ee">GetRestTransformsAttr</a>().<a class="code" href="class_usd_attribute.html#a7fd0957eecddb7cfcd222cccd51e23e6">Set</a>(*restTransforms);</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="class_usd_attribute.html">UsdAttribute</a> rootTransformAttr = skel.<a class="code" href="class_usd_geom_xformable.html#a97e5c56a739490600e4e7e37b3953a08">MakeMatrixXform</a>();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; times.size(); ++i) {</div><div class="line">        rootTransformAttr.<a class="code" href="class_usd_attribute.html#a7fd0957eecddb7cfcd222cccd51e23e6">Set</a>(rootTransformsPerFrame[i], times[i]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="class_usd_skel_animation.html">UsdSkelAnimation</a> anim = <a class="code" href="class_usd_skel_animation.html#a81230ba662e765774cc2a956c1820c95">UsdSkelAnimation::Define</a>(</div><div class="line">        stage, skelPath.<a class="code" href="class_sdf_path.html#ab38c801f846f5eda9934f7306a0ba229">AppendChild</a>(<a class="code" href="class_tf_token.html">TfToken</a>(<span class="stringliteral">&quot;Anim&quot;</span>)));</div><div class="line"></div><div class="line">    <a class="code" href="class_usd_skel_binding_a_p_i.html">UsdSkelBindingAPI</a> binding = <a class="code" href="class_usd_skel_binding_a_p_i.html#a82e008f7c638888bea48d2e6f5172fdb">UsdSkelBindingAPI::Apply</a>(skel.<a class="code" href="class_usd_schema_base.html#a4ba10e023e7f3f3c93131bc7fc3146b7">GetPrim</a>());</div><div class="line">    binding.<a class="code" href="class_usd_skel_binding_a_p_i.html#a3a26d9df3fddd642e023779fe355b113">CreateSkeletonRel</a>().<a class="code" href="class_usd_relationship.html#a459108ba8902c4bf7ba4dbe55b9f3416">SetTargets</a>(</div><div class="line">        SdfPathVector({anim.<a class="code" href="class_usd_schema_base.html#a4ba10e023e7f3f3c93131bc7fc3146b7">GetPrim</a>().<a class="code" href="class_usd_object.html#a936bfb1e341cc81184c64af44763c433">GetPath</a>()}));</div><div class="line"></div><div class="line">    anim.<a class="code" href="class_usd_skel_animation.html#aa6bf8297f4aae6de9fbf1b784c524d30">GetJointsAttr</a>().<a class="code" href="class_usd_attribute.html#a7fd0957eecddb7cfcd222cccd51e23e6">Set</a>(jointTokens);</div><div class="line">    </div><div class="line">    <span class="comment">// Set root transforms and joint transforms per frame.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; times.size(); ++i) {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_gf_matrix4d.html">GfMatrix4d</a>&amp; rootTransform = rootTransformsPerFrame[i];</div><div class="line">        <span class="keyword">const</span> VtMatrix4dArray&amp; jointWorldSpaceTransforms =</div><div class="line">            jointWorldSpaceTransformsPerFrame[i];</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (jointWorldSpaceTransforms.size() == numJoints) {</div><div class="line">            </div><div class="line">            VtMatrix4dArray jointLocalSpaceTransforms;</div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="group___usd_skel___joint_transform_utils.html#ga3864a18b6185a003ab1ee0f004cf5735">UsdSkelComputeJointLocalTransforms</a>(</div><div class="line">                    topo, jointWorldSpaceTransforms,</div><div class="line">                    &amp;jointLocalSpaceTransforms,</div><div class="line">                    &amp;rootTransform)) {</div><div class="line"></div><div class="line">                anim.<a class="code" href="class_usd_skel_animation.html#a0bdf0f733d58eefc30787a0721e1c889">SetTransforms</a>(jointLocalSpaceTransforms, times[i]);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Don&#39;t forget to call Save() on the stage!</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line"><span class="keyword">def </span>WriteAnimatedSkel(stage, skelPath, jointPaths,</div><div class="line">                      rootTransformsPerFrame,</div><div class="line">                      jointWorldSpaceTransformsPerFrame,</div><div class="line">                      times, bindTransforms, restTransforms=None):</div><div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(rootTransformsPerFrame) == len(times):</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(jointWorldSpaceTransformsPerFrame) == len(times):</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(bindTransforms) == len(jointPaths):</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">    skel = UsdSkel.Skeleton.Define(stage, skelPath)</div><div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> skel:</div><div class="line">        Tf.Warn(<span class="stringliteral">&quot;Failed defining a Skeleton at &lt;%s&gt;.&quot;</span>, skelPath)</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">    numJoints = len(jointPaths)</div><div class="line"></div><div class="line">    topo = UsdSkel.Topology(jointPaths)</div><div class="line">    valid,whyNot = topo.Validate()</div><div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> valid:</div><div class="line">        Tf.Warn(<span class="stringliteral">&quot;Invalid topology: %s&quot;</span>%reason)</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">    jointTokens = Vt.TokenArray([jointPath.pathString <span class="keywordflow">for</span> jointPath <span class="keywordflow">in</span> jointPaths])</div><div class="line">    skel.GetJointsAttr().Set(jointTokens)</div><div class="line"></div><div class="line">    skel.GetBindTransformsAttr().Set(bindTransforms)</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> restTransforms <span class="keywordflow">and</span> len(restTransforms) == numJoints:</div><div class="line">        skel.GetRestTransformsAttr().Set(restTransforms)</div><div class="line"></div><div class="line">    rootTransformAttr = skel.MakeMatrixXform()</div><div class="line">    <span class="keywordflow">for</span> i,time <span class="keywordflow">in</span> enumerate(times):</div><div class="line">        rootTransformAttr.Set(rootTransformsPerFrame[i], time)</div><div class="line"></div><div class="line">    anim = UsdSkel.Animation.Define(stage, skelPath.AppendChild(<span class="stringliteral">&quot;Anim&quot;</span>))</div><div class="line"></div><div class="line">    binding = UsdSkel.BindingAPI.Apply(skel.GetPrim())</div><div class="line">    binding.CreateSkeletonRel().SetTargets([anim.GetPrim().GetPath()])</div><div class="line"></div><div class="line">    anim.GetJointsAttr().Set(jointTokens)</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> i,time <span class="keywordflow">in</span> enumerate(times):</div><div class="line">        rootTransform = rootTransformsPerFrame[i]</div><div class="line">        jointWorldSpaceTransforms = jointWorldSpaceTransformsPerFrame[i]</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> len(jointWorldSpaceTransforms) == numJoints:</div><div class="line">            </div><div class="line">            jointLocalSpaceTransforms =\</div><div class="line">                UsdSkel.ComputeJointLocalTransforms(</div><div class="line">                    topo, jointWorldSpaceTransforms, rootTransform)</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> jointLocalSpaceTransforms:</div><div class="line">                anim.SetTransforms(jointLocalSpaceTransforms, time)</div><div class="line"></div><div class="line">    <span class="comment"># Don&#39;t forget to call Save() on the stage!</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">True</span></div></div><!-- fragment --></li>
<li>C++: <div class="fragment"><div class="line"><span class="keywordflow">if</span> (rootTransformsPerFrame.size() != times.size())</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="keywordflow">if</span> (jointWorldSpaceTransformsPerFrame.size() != times.size())</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="keywordflow">if</span> (bindTransforms.size() != jointPaths.size())</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line"><span class="keywordflow">if</span> <span class="keywordflow">not</span> len(rootTransformsPerFrame) == len(times):</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">False</span></div><div class="line"><span class="keywordflow">if</span> <span class="keywordflow">not</span> len(jointWorldSpaceTransformsPerFrame) == len(times):</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">False</span></div><div class="line"><span class="keywordflow">if</span> <span class="keywordflow">not</span> len(bindTransforms) == len(jointPaths):</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">False</span></div></div><!-- fragment --></li>
</ul>
<p>For this method, we expect <em>rootTransformsPerFrame</em> to be an array holding a <a class="el" href="class_gf_matrix4d.html" title="Stores a 4x4 matrix of double elements.">GfMatrix4d</a> for each time in <em>times</em>. Similarly, <em>jointWorldSpaceTransformsPerFrame</em> holds a VtMatrix4dArray for each time in <em>times</em>, providing the full set of joint transforms for the corresponding time. Finally, the <em>jointPaths</em> input is an array of <a class="el" href="class_sdf_path.html" title="A path value used to locate objects in layers or scenegraphs.">SdfPath</a> objects giving the path of each joint, and establishing the <a class="el" href="_usd_skel__schemas.html#UsdSkel_JointOrder">Joint Order</a> of the skeleton. The required bindTransforms array must be the same size.</p>
<p>A more complete implementation would provide useful warning messages, rather than simply returning <em>false</em>.</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><a class="code" href="class_usd_skel_skeleton.html">UsdSkelSkeleton</a> skel = <a class="code" href="class_usd_skel_skeleton.html#a24c1eea74c3316635f1105a4b76f1315">UsdSkelSkeleton::Define</a>(stage, skelPath);</div><div class="line"><span class="keywordflow">if</span> (!skel) {</div><div class="line">    <a class="code" href="group__group__tf___diagnostic.html#gaba2e638edaae9e9c6e5180e020f12ccf">TF_WARN</a>(<span class="stringliteral">&quot;Failed creating a Skeleton prim at &lt;%s&gt;.&quot;</span>, skelPath.<a class="code" href="class_sdf_path.html#a31225e07892b847e3e98473f7f04dbf4">GetText</a>());</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">skel = UsdSkel.Skeleton.Define(stage, skelPath)</div><div class="line"><span class="keywordflow">if</span> <span class="keywordflow">not</span> skel:</div><div class="line">    Tf.Warn(<span class="stringliteral">&quot;Failed defining a Skeleton at &lt;%s&gt;.&quot;</span>, skelPath)</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">False</span></div></div><!-- fragment --></li>
</ul>
<p>We start by defining a Skeleton primitive on the stage at the given path. It is good practice to check that the resulting prim is valid. Some reasons why we may be unable to create the prim include:</p><ul>
<li>The provided <em>skelPath</em> is not a valid, absolute prim path.</li>
<li>An ancestor of the prim at <em>skelPath</em> is already inactive on the stage. It is not possible to acquire a <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> for a descendant of an inactive prim.</li>
</ul>
<p>A more complete implementation would likely at least validate that the <em>skelPath</em> is not invalid.</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><a class="code" href="class_usd_skel_topology.html">UsdSkelTopology</a> topo(jointPaths);</div><div class="line">std::string reason;</div><div class="line"><span class="keywordflow">if</span> (!topo.Validate(&amp;reason)) {</div><div class="line">    <a class="code" href="group__group__tf___diagnostic.html#gaba2e638edaae9e9c6e5180e020f12ccf">TF_WARN</a>(<span class="stringliteral">&quot;Invalid topology: %s&quot;</span>, reason.c_str());</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">topo = UsdSkel.Topology(jointPaths)</div><div class="line">valid,whyNot = topo.Validate()</div><div class="line"><span class="keywordflow">if</span> <span class="keywordflow">not</span> valid:</div><div class="line">    Tf.Warn(<span class="stringliteral">&quot;Invalid topology: %s&quot;</span>%reason)</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">False</span></div></div><!-- fragment --></li>
</ul>
<p>The input <em>jointPaths</em> specify the topology of the Skeleton. We construct a <a class="el" href="class_usd_skel_topology.html" title="Object holding information describing skeleton topology.">UsdSkelTopology</a> object at this point primarily for use in subsequent transform computations. But this is also a good point to verify that our topology is valid.</p>
<ul>
<li>C++: <div class="fragment"><div class="line">VtTokenArray jointTokens(numJoints);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; jointPaths.size(); ++i) {</div><div class="line">    jointTokens[i] = <a class="code" href="class_tf_token.html">TfToken</a>(jointPaths[i].GetString());</div><div class="line">}</div><div class="line">skel.<a class="code" href="class_usd_skel_skeleton.html#aa6bf8297f4aae6de9fbf1b784c524d30">GetJointsAttr</a>().<a class="code" href="class_usd_attribute.html#a7fd0957eecddb7cfcd222cccd51e23e6">Set</a>(jointTokens);</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">jointTokens = Vt.TokenArray([jointPath.pathString <span class="keywordflow">for</span> jointPath <span class="keywordflow">in</span> jointPaths])</div><div class="line">skel.GetJointsAttr().Set(jointTokens)</div></div><!-- fragment --></li>
</ul>
<p>The actual joint topology is stored on the Skeleton primitive as an array of tokens (VtTokenArray). We convert the input paths to tokens, and write the result to the Skeleton.</p>
<ul>
<li>C++: <div class="fragment"><div class="line">skel.<a class="code" href="class_usd_skel_skeleton.html#a0762be4742010c4943912c4c428624dc">GetBindTransformsAttr</a>().<a class="code" href="class_usd_attribute.html#a7fd0957eecddb7cfcd222cccd51e23e6">Set</a>(bindTransforms);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (restTransforms &amp;&amp; restTransforms-&gt;size() == numJoints) {</div><div class="line">    skel.<a class="code" href="class_usd_skel_skeleton.html#af1fb07ad318db8d810a3afd7925b31ee">GetRestTransformsAttr</a>().<a class="code" href="class_usd_attribute.html#a7fd0957eecddb7cfcd222cccd51e23e6">Set</a>(*restTransforms);</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">skel.GetBindTransformsAttr().Set(bindTransforms)</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> restTransforms <span class="keywordflow">and</span> len(restTransforms) == numJoints:</div><div class="line">    skel.GetRestTransformsAttr().Set(restTransforms)</div></div><!-- fragment --></li>
</ul>
<p>Here we author the <em>bindTransforms</em> property of the Skeleton. The <em>restTransforms</em> property has been treated as optional. But if <em>restTransforms</em> are not authored, then a <a class="el" href="class_usd_skel_animation.html" title="Describes a skel animation, where joint animation is stored in a vectorized form.">UsdSkelAnimation</a> must be bound to the Skeleton (which we will do shortly), and that animation must include the full set of joints. See <a class="el" href="_usd_skel__schemas.html#UsdSkel_BindingAPI_Skeletons">BindingAPI: Binding Skeletons</a> for more information on binding animations.</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><a class="code" href="class_usd_attribute.html">UsdAttribute</a> rootTransformAttr = skel.<a class="code" href="class_usd_geom_xformable.html#a97e5c56a739490600e4e7e37b3953a08">MakeMatrixXform</a>();</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; times.size(); ++i) {</div><div class="line">    rootTransformAttr.<a class="code" href="class_usd_attribute.html#a7fd0957eecddb7cfcd222cccd51e23e6">Set</a>(rootTransformsPerFrame[i], times[i]);</div><div class="line">}</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">rootTransformAttr = skel.MakeMatrixXform()</div><div class="line"><span class="keywordflow">for</span> i,time <span class="keywordflow">in</span> enumerate(times):</div><div class="line">    rootTransformAttr.Set(rootTransformsPerFrame[i], time)</div></div><!-- fragment --></li>
</ul>
<p>This demonstrates use of <a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable</a> API (a base class of <a class="el" href="class_usd_skel_skeleton.html" title="Describes a skeleton.">UsdSkelSkeleton</a>) for applying transforms on primitives. For this example, the root transform has been written out directly on the Skeleton. In actual production cases, it is not uncommon for the full root transform to instead be set on an ancestor of the Skeleton.</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><a class="code" href="class_usd_skel_animation.html">UsdSkelAnimation</a> anim = <a class="code" href="class_usd_skel_animation.html#a81230ba662e765774cc2a956c1820c95">UsdSkelAnimation::Define</a>(</div><div class="line">    stage, skelPath.<a class="code" href="class_sdf_path.html#ab38c801f846f5eda9934f7306a0ba229">AppendChild</a>(<a class="code" href="class_tf_token.html">TfToken</a>(<span class="stringliteral">&quot;Anim&quot;</span>)));</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">anim = UsdSkel.Animation.Define(stage, skelPath.AppendChild(<span class="stringliteral">&quot;Anim&quot;</span>))</div></div><!-- fragment --></li>
</ul>
<p>For reasons that are covered in-depth <a class="el" href="_usd_skel__schemas.html#UsdSkel_SkelAnimation">elsewhere</a>, a Skeleton's joint animations are encoded on a separate primitive.</p>
<p>Note that <em>where</em> on the stage we choose to place the <a class="el" href="class_usd_skel_animation.html" title="Describes a skel animation, where joint animation is stored in a vectorized form.">UsdSkelAnimation</a> primitive really only starts to matter when using <a class="el" href="_usd_skel__instancing.html">instancing.</a> In the simple case of encoding a small number of skeletons, adding the animation as a child of the Skeleton, as above, is the most straight-forward approach. But when defining skeletons that take advantage of instancing, a SkelAnimation will not be a descendant of the Skeleton.</p>
<ul>
<li>C++: <div class="fragment"><div class="line"><a class="code" href="class_usd_skel_binding_a_p_i.html">UsdSkelBindingAPI</a> binding = <a class="code" href="class_usd_skel_binding_a_p_i.html#a82e008f7c638888bea48d2e6f5172fdb">UsdSkelBindingAPI::Apply</a>(skel.<a class="code" href="class_usd_schema_base.html#a4ba10e023e7f3f3c93131bc7fc3146b7">GetPrim</a>());</div><div class="line">binding.<a class="code" href="class_usd_skel_binding_a_p_i.html#a3a26d9df3fddd642e023779fe355b113">CreateSkeletonRel</a>().<a class="code" href="class_usd_relationship.html#a459108ba8902c4bf7ba4dbe55b9f3416">SetTargets</a>(</div><div class="line">    SdfPathVector({anim.<a class="code" href="class_usd_schema_base.html#a4ba10e023e7f3f3c93131bc7fc3146b7">GetPrim</a>().<a class="code" href="class_usd_object.html#a936bfb1e341cc81184c64af44763c433">GetPath</a>()}));</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">binding = UsdSkel.BindingAPI.Apply(skel.GetPrim())</div><div class="line">binding.CreateSkeletonRel().SetTargets([anim.GetPrim().GetPath()])</div></div><!-- fragment --></li>
</ul>
<p>Here we apply the <a class="el" href="class_usd_skel_binding_a_p_i.html" title="Provides API for authoring and extracting all the skinning-related data that lives in the &quot;geometry h...">UsdSkelBindingAPI</a> to the Skeleton, and use it to bind the animation directly to the Skeleton. In more complex <a class="el" href="_usd_skel__instancing.html">instancing</a> scenarios, we might instead choose to bind the animation to an ancestor of the Skeleton.</p>
<ul>
<li>C++: <div class="fragment"><div class="line">anim.<a class="code" href="class_usd_skel_animation.html#aa6bf8297f4aae6de9fbf1b784c524d30">GetJointsAttr</a>().<a class="code" href="class_usd_attribute.html#a7fd0957eecddb7cfcd222cccd51e23e6">Set</a>(jointTokens);</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">anim.GetJointsAttr().Set(jointTokens)</div></div><!-- fragment --></li>
</ul>
<p>Previously, we stored <em>jointTokens</em> on the Skeleton, to encode topology. When creating a <a class="el" href="class_usd_skel_animation.html" title="Describes a skel animation, where joint animation is stored in a vectorized form.">UsdSkelAnimation</a>, we need to once again store the joint tokens. The <em>jointTokens</em> set on the animation define the <a class="el" href="_usd_skel__schemas.html#UsdSkel_JointOrder">Joint Order</a> of the animation. In this case, the joint order of the animation is identical to that of the Skeleton, but note that that need not be the case (for example, if the Skeleton includes joints for fingers, our animation could exclude the fingers).</p>
<ul>
<li>C++: <div class="fragment"><div class="line">VtMatrix4dArray jointLocalSpaceTransforms;</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group___usd_skel___joint_transform_utils.html#ga3864a18b6185a003ab1ee0f004cf5735">UsdSkelComputeJointLocalTransforms</a>(</div><div class="line">        topo, jointWorldSpaceTransforms,</div><div class="line">        &amp;jointLocalSpaceTransforms,</div><div class="line">        &amp;rootTransform)) {</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">jointLocalSpaceTransforms =\</div><div class="line">    UsdSkel.ComputeJointLocalTransforms(</div><div class="line">        topo, jointWorldSpaceTransforms,</div><div class="line">        rootTransform)</div></div><!-- fragment --></li>
</ul>
<p>This method has been written to allow joint transforms to be provided in world space, because it is often easier for applications to reliably translate world space transform, rather than local transforms &ndash; for example, because an application may need to skip intermediate joints, or because an application may have weird transform inheritance rules (oddities abound related to inheritance of <em>scale</em>!). Previously we created a <a class="el" href="class_usd_skel_topology.html" title="Object holding information describing skeleton topology.">UsdSkelTopology</a> object, primarily so that it can be used at this point to convert world space joint transforms into local space, as required by the <a class="el" href="class_usd_skel_animation.html" title="Describes a skel animation, where joint animation is stored in a vectorized form.">UsdSkelAnimation</a> schema.</p>
<p>Of course, if it is easy for an application to provide transforms directly in local space, this conversion would be unnecessary.</p>
<ul>
<li>C++: <div class="fragment"><div class="line">anim.<a class="code" href="class_usd_skel_animation.html#a0bdf0f733d58eefc30787a0721e1c889">SetTransforms</a>(jointLocalSpaceTransforms, times[i]);</div></div><!-- fragment --></li>
<li>Python: <div class="fragment"><div class="line">anim.SetTransforms(jointLocalSpaceTransforms, time)</div></div><!-- fragment --></li>
</ul>
<p>Finally, we write joint transforms on the <a class="el" href="class_usd_skel_animation.html" title="Describes a skel animation, where joint animation is stored in a vectorized form.">UsdSkelAnimation</a> primitive. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="usd_skel_page_front.html">UsdSkel : USD Skeleton Schema and API</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:57 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>