<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="class_plug_static_interface" kind="class" language="C++" prot="public">
    <compoundname>PlugStaticInterface</compoundname>
    <basecompoundref prot="private" virt="non-virtual">Plug_StaticInterfaceBase</basecompoundref>
    <includes refid="static_interface_8h" local="no">staticInterface.h</includes>
    <templateparamlist>
      <param>
        <type>class</type>
        <declname>Interface</declname>
        <defname>Interface</defname>
      </param>
    </templateparamlist>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="class_plug_static_interface_1a9447beb316df5f846ab75c975cc0d892" prot="public" static="no">
        <type><ref refid="class_plug_static_interface" kindref="compound">PlugStaticInterface</ref>&lt; Interface &gt;</type>
        <definition>typedef PlugStaticInterface&lt;Interface&gt; This</definition>
        <argsstring></argsstring>
        <name>This</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/staticInterface.h" line="165" column="1" bodyfile="pxr/base/plug/staticInterface.h" bodystart="163" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="class_plug_static_interface_1a10c79bb09aeb8efbd9b01ee1fbde0061" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>operator UnspecifiedBoolType</definition>
        <argsstring>() const</argsstring>
        <name>operator UnspecifiedBoolType</name>
        <briefdescription>
<para>Load and instantiate then return <computeroutput>true</computeroutput> if the interface is valid, <computeroutput>false</computeroutput> otherwise. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/staticInterface.h" line="171" column="1" bodyfile="pxr/base/plug/staticInterface.h" bodystart="171" bodyend="174"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_static_interface_1a61efd4196a96540ee018fee8791f3f10" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool operator!</definition>
        <argsstring>() const</argsstring>
        <name>operator!</name>
        <briefdescription>
<para>Load and instantiate then return <computeroutput>false</computeroutput> if the interface is valid, <computeroutput>true</computeroutput> otherwise. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/staticInterface.h" line="178" column="1" bodyfile="pxr/base/plug/staticInterface.h" bodystart="178" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_static_interface_1a879c94053b6c62e0bfeac35bf9e79aa7" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>Interface *</type>
        <definition>Interface* Get</definition>
        <argsstring>() const</argsstring>
        <name>Get</name>
        <briefdescription>
<para>Returns the interface pointer, loading the plugin if necessary. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns <computeroutput>nullptr</computeroutput> if the interface could not be initialized. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/staticInterface.h" line="185" column="1" bodyfile="pxr/base/plug/staticInterface.h" bodystart="185" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_static_interface_1abf09871ff9a3b15d91f2c6b915f8b209" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>Interface *</type>
        <definition>Interface* operator-&gt;</definition>
        <argsstring>() const</argsstring>
        <name>operator-&gt;</name>
        <briefdescription>
<para>Returns the interface pointer, loading the plugin if necessary. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns <computeroutput>nullptr</computeroutput> if the interface could not be initialized. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/staticInterface.h" line="192" column="1" bodyfile="pxr/base/plug/staticInterface.h" bodystart="192" bodyend="195"/>
      </memberdef>
      <memberdef kind="function" id="class_plug_static_interface_1aa3aab5da55173e85a7802a503bc79b4b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>Interface &amp;</type>
        <definition>Interface&amp; operator *</definition>
        <argsstring>() const</argsstring>
        <name>operator *</name>
        <briefdescription>
<para>Returns the interface pointer as a reference, loading the plugin if necessary. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns <computeroutput>nullptr</computeroutput> if the interface could not be initialized. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/staticInterface.h" line="200" column="1" bodyfile="pxr/base/plug/staticInterface.h" bodystart="200" bodyend="203"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="class_plug_static_interface_1a5ec61bf6165230aea9405178d5d2df87" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>Interface *</type>
        <definition>Interface* _GetPtr</definition>
        <argsstring>() const</argsstring>
        <name>_GetPtr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/plug/staticInterface.h" line="206" column="1" bodyfile="pxr/base/plug/staticInterface.h" bodystart="206" bodyend="215"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Provides access to an interface into a plugin. </para>
    </briefdescription>
    <detaileddescription>
<para>A plugin can provide one or more interface types through which clients can access the plugin&apos;s full functionality without needing to link against the plugin (if you had to link against it, it wouldn&apos;t be a plugin). This is a convenience; you can achieve the same effect with <ref refid="class_tf_type_1a11f5ea108b10ee71f163a847bc494d33" kindref="member">TfType::GetFactory()</ref>.</para>
<para>Typical usage is: <programlisting><codeline><highlight class="normal">#include<sp/>&quot;path/to/SomePlugin.h&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;pxr/base/plug/staticInterface.h&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">static<sp/>PlugStaticInterface&lt;SomePluginInterface&gt;<sp/>ptr;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>MyFunction()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ptr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Plugin<sp/>is<sp/>available.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ptr-&gt;MakePluginDoSomething();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Plugin<sp/>is<sp/>not<sp/>available.<sp/><sp/>(An<sp/>error<sp/>will<sp/>have<sp/>been<sp/>reported</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>the<sp/>first<sp/>time<sp/>through.)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The interface must be defined correctly. In particular, it must have</para>
<para><itemizedlist>
<listitem><para>no data members (static or otherwise), </para>
</listitem>
<listitem><para>no static member functions, </para>
</listitem>
<listitem><para>no non-virtual member functions, </para>
</listitem>
<listitem><para>only pure virtual member functions, </para>
</listitem>
<listitem><para>no constructors except an inline protected default that does nothing (or no constructors at all,) </para>
</listitem>
<listitem><para>a virtual destructor as the first member that <emphasis>must</emphasis> be defined <emphasis>inline</emphasis> with an empty body even though inline virtual destructors are contrary to conventional practice.</para>
</listitem>
</itemizedlist>
The last requirement causes the compiler to emit a copy of the interface typeinfo into clients of the interface. This typeinfo is required by <ref refid="class_plug_static_interface" kindref="compound">PlugStaticInterface</ref> internals to perform the appropriate plugin metadata search for the interface type. Note that due to limitations in the GCC C++ ABI an inline virtual destructor may prevent dynamic_cast&lt;&gt; and typeid() from working correctly; do not use those on the interface type.</para>
<para>For example:</para>
<para><programlisting><codeline><highlight class="normal">class<sp/>SomePluginInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>~SomePluginInterface()<sp/>{<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>bool<sp/>MakePluginDoSomething()<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">protected:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SomePluginInterface()<sp/>{<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting> Note that interface types do not share a common base class.</para>
<para>For the plugin to work, there must be a concrete implementation of the interface type, the interface type must be in plugInfo file, and the interface type must be registered with <ref refid="class_tf_type" kindref="compound">TfType</ref> using <computeroutput>PLUG_REGISTER_INTERFACE_SINGLETON_TYPE:</computeroutput> <programlisting><codeline><highlight class="normal">#include<sp/>&quot;path/to/SomePlugin.h&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;pxr/base/plug/interfaceFactory.h&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;iostream&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>SomePluginImplementation<sp/>:<sp/>public<sp/>SomePluginInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>bool<sp/>MakePluginDoSomething()<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;Plugin<sp/>did<sp/>something&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">PLUG_REGISTER_INTERFACE_SINGLETON_TYPE(SomePluginInterface,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SomePluginImplementation)</highlight></codeline>
</programlisting> This causes TfType::Find&lt;SomePluginInterface&gt;::Manufacture() to return a pointer to a singleton instance of SomePluginImplementation.</para>
<para>Note that only SomePluginInterface needs to be registered in the plugInfo file and with <ref refid="class_tf_type" kindref="compound">TfType</ref>; other types provided by the plugin need only be defined in SomePlugin.h. In addition, SomePluginInterface can provide access to free functions in SomePlugin; clients would otherwise have to use <computeroutput>dlsym()</computeroutput> to access free functions in the plugin.</para>
<para>Warning: the <computeroutput><ref refid="class_plug_static_interface" kindref="compound">PlugStaticInterface</ref></computeroutput> construct relies upon zero-initialization of global data: therefore, you can only use this structure for static data member of classes, variables declared at file-scope, or variables declared static within a function. Do <emphasis>not</emphasis> declare a <computeroutput><ref refid="class_plug_static_interface" kindref="compound">PlugStaticInterface</ref></computeroutput> object as a local variable, as a member of a class or structure, or as a function parameter. </para>
    </detaileddescription>
    <location file="pxr/base/plug/staticInterface.h" line="160" column="1" bodyfile="pxr/base/plug/staticInterface.h" bodystart="160" bodyend="216"/>
    <listofallmembers>
      <member refid="class_plug_static_interface_1a5ec61bf6165230aea9405178d5d2df87" prot="private" virt="non-virtual"><scope>PlugStaticInterface</scope><name>_GetPtr</name></member>
      <member refid="class_plug_static_interface_1a879c94053b6c62e0bfeac35bf9e79aa7" prot="public" virt="non-virtual"><scope>PlugStaticInterface</scope><name>Get</name></member>
      <member refid="class_plug_static_interface_1aa3aab5da55173e85a7802a503bc79b4b" prot="public" virt="non-virtual"><scope>PlugStaticInterface</scope><name>operator *</name></member>
      <member refid="class_plug_static_interface_1a10c79bb09aeb8efbd9b01ee1fbde0061" prot="public" virt="non-virtual"><scope>PlugStaticInterface</scope><name>operator UnspecifiedBoolType</name></member>
      <member refid="class_plug_static_interface_1a61efd4196a96540ee018fee8791f3f10" prot="public" virt="non-virtual"><scope>PlugStaticInterface</scope><name>operator!</name></member>
      <member refid="class_plug_static_interface_1abf09871ff9a3b15d91f2c6b915f8b209" prot="public" virt="non-virtual"><scope>PlugStaticInterface</scope><name>operator-&gt;</name></member>
      <member refid="class_plug_static_interface_1a9447beb316df5f846ab75c975cc0d892" prot="public" virt="non-virtual"><scope>PlugStaticInterface</scope><name>This</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
