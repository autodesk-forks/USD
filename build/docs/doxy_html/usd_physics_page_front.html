<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: UsdPhysics : USD Physics Schema</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('usd_physics_page_front.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">UsdPhysics : USD Physics Schema </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#usdPhysics_purpose_and_scope">Purpose and Scope</a></li>
<li class="level1"><a href="#usdPhysics_overall_design">Overall Design Concerns</a><ul><li class="level2"><a href="#usdPhysics_rigid_body">Rigid Body Simulation Primer</a></li>
<li class="level2"><a href="#usdPhysics_usd_implementation">USD Implementation</a><ul><li class="level3"><a href="#usdPhysics_disambiguation">Disambiguation</a></li>
<li class="level3"><a href="#usdPhysics_fundamental_editing">Fundamental Editing Capabilities</a></li>
<li class="level3"><a href="#usdPhysics_physics_scenes">Physics Scenes</a></li>
<li class="level3"><a href="#usdPhysics_types">Types</a></li>
<li class="level3"><a href="#usdPhysics_units">Units</a></li>
<li class="level3"><a href="#usdPhysics_default_values">Default Values</a></li>
<li class="level3"><a href="#usdPhysics_rigid_bodies">Rigid Bodies</a></li>
<li class="level3"><a href="#usdPhysics_interaction_with_usd">Interaction with the USD hierarchy</a></li>
<li class="level3"><a href="#usdPhysics_rb_sleep">Sleep</a></li>
<li class="level3"><a href="#usdPhysics_kinematic_bodies">Kinematic Bodies</a></li>
<li class="level3"><a href="#usdPhysics_animation_of_attributes">Animation of Attributes</a></li>
<li class="level3"><a href="#usdPhysics_body_mass_properties">Body Mass Properties</a></li>
<li class="level3"><a href="#usdPhysics_collision_shapes">Collision Shapes</a></li>
<li class="level3"><a href="#usdPhysics_mesh_into_shapes">Turning Meshes into Shapes</a></li>
<li class="level3"><a href="#usdPhysics_physics_materials">Physics Materials</a></li>
<li class="level3"><a href="#usdPhysics_plane_shapes">Plane Shapes</a></li>
<li class="level3"><a href="#usdPhysics_collision_filtering">Collision Filtering</a></li>
<li class="level3"><a href="#usdPhysics_pairwise_filtering">Pairwise Filtering</a></li>
<li class="level3"><a href="#usdPhysics_joints">Joints</a></li>
<li class="level3"><a href="#usdPhysics_joint_reference_frames">Joint Reference Frames</a></li>
<li class="level3"><a href="#usdPhysics_jointed_bodies">Jointed Bodies</a></li>
<li class="level3"><a href="#usdPhysics_joint_collision_filtering">Joint Collision Filtering</a></li>
<li class="level3"><a href="#usdPhysics_breaking_disabling_joints">Breaking and Disabling Joints</a></li>
<li class="level3"><a href="#usdPhysics_joint_subtypes">Joint Subtypes</a></li>
<li class="level3"><a href="#usdPhysics_limits_drives">Joint Limits and Drives</a></li>
<li class="level3"><a href="#usdPhysics_articulations">Articulations</a></li>
</ul>
</li>
<li class="level2"><a href="#usdPhysics_examples">Examples</a><ul><li class="level3"><a href="#usdPhysics_box_on_box">Box on Box</a></li>
<li class="level3"><a href="#usdPhysics_box_on_quad">Box on Quad</a></li>
<li class="level3"><a href="#usdPhysics_spheres_with_material">Spheres with Materials</a></li>
<li class="level3"><a href="#usdPhysics_group_filtering">Group Filtering</a></li>
<li class="level3"><a href="#usdPhysics_pair_filtering">Pair Filtering</a></li>
<li class="level3"><a href="#usdPhysics_joint_example">Joint</a></li>
<li class="level3"><a href="#usdPhysics_distance_joint_example">Distance Joint</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><b>UsdPhysics</b> defines the physics-related prim and property schemas that together form a physics simulation representation.</p>
<p><b>Rigid Body Physics in USD Overview.</b></p>
<h1><a class="anchor" id="usdPhysics_purpose_and_scope"></a>
Purpose and Scope</h1>
<p>While at its launch USD was primarily targeted at film and VFX pipelines, it has been adopted into many other spaces and applications, including the authoring, interchange, and delivery of interactive 3D graphics content. Computer games and 3D web applications are examples of new domains for the integration of this content. In these consumer-facing applications, real-time physics allows realistic user interaction with virtual objects. In professional and academic applications, there are a number of use cases for real-time physics in areas such as mechanical engineering, architecture, artificial intelligence and robotics where vehicles or robots are designed, tested and trained in simulation. This schema extends USD to represent the real-time physics data required to enable these applications.</p>
<p>The realm of simulation is broad. This schema is intended as a baseline initial extension to USD that enables the minimum set of common concepts required to represent rigid body physics. Future iterations and extensions will incrementally add capabilities as needs are identified.</p>
<h1><a class="anchor" id="usdPhysics_overall_design"></a>
Overall Design Concerns</h1>
<p>The initial usdPhysics schema concerns rigid body simulations. Rigid body simulations are the most broadly applicable category we could identify, with common and long standing uses across all disciplines described above.</p>
<h2><a class="anchor" id="usdPhysics_rigid_body"></a>
Rigid Body Simulation Primer</h2>
<p>Rigid body simulators take as input a list of rigid bodies and a list of constraints. Given the state, or the state history of the bodies at a specific time, they compute the updated state of the bodies a moment in time later, with the general desire being that the bodies' movement while constrained by the constraints obeys the laws of physics. One can invoke a sequence of such simulation updates to generate an animation.</p>
<p>A rigid body can be described by its pose (position and orientation in a well defined frame of reference), as well as its mass distribution (specified by a center of mass position, total mass, and an inertia tensor). The body will also have a velocity (linear and angular vectors). Pose and velocity are both inputs and outputs of the simulation update.</p>
<p>Constraints describe physical limits between bodies. They can take many forms, but fall primarily into two categories:</p>
<ul>
<li><b>Explicit constraints</b>, often called joints, which create a fixed spatial relationship between two rigid bodies. One example is a requirement that one body never rotate relative to the other body, even if relative translation is possible.</li>
</ul>
<ul>
<li><b>Implicit constraints</b>, most commonly contacts, which are generally created 'behind the scenes' by the simulator to ensure that e.g. solid objects do not pass through each other. For the simulator to derive these constraints, each body must be provided with a collision representation (called 'collision shape' or 'collider') and physical material properties.</li>
</ul>
<p>Simulations often share a set of global parameters that influence the simulation of all bodies. It is generally possible to simultaneously create multiple simulations, each with their own set of parameter settings.</p>
<h2><a class="anchor" id="usdPhysics_usd_implementation"></a>
USD Implementation</h2>
<h3><a class="anchor" id="usdPhysics_disambiguation"></a>
Disambiguation</h3>
<p>First, it is clear that some terminology commonly used by the physics simulation community, such as 'scene', 'joint', and 'material' have different meanings than in VFX, and are already in use in other contexts by USD, so all of the usdPhysics schema classes are prefixed with 'Physics' and make use of namespacing to avoid any ambiguity.</p>
<h3><a class="anchor" id="usdPhysics_fundamental_editing"></a>
Fundamental Editing Capabilities</h3>
<p>A primary assumption in designing this schema was that one of the most common use cases will be to add physics behavior to existing USD content. Furthermore, the conventional wisdom was that to maximize the performance of USD implementations, it is best to avoid inflating the number of USD objects in a scene. Accordingly, the best approach is to attach new API schemas that contain physics attributes to existing USD objects whenever this makes sense. In rare cases there is no object already available to which simulation attributes can be attached in a rational manner, and in these cases, usdPhysics makes use of new USD IsA schemas.</p>
<p>It is vital that any operation to add physics can also be undone, which can be accomplished in most cases using <a class="el" href="class_usd_prim.html#aab70d4fa20d53a6675734205ded2da22" title="Removes a single-apply API schema with the given C++ type SchemaType from this prim in the current ed...">UsdPrim::RemoveAPI()</a>.</p>
<p>Similarly, in editor use cases it is a common capability to temporarily be able to mute/disable properties, without deleting them outright. Removing an API will make it be no longer "present", but all data authored to that API still remains. USD allows entire objects to deactivate via an active flag, but it can not be animated over time - which cannot be done with just RemoveAPI(). For a few cases where animating mute behavior is a really common use case, we have defined a boolean enable attribute. (Note that we initially wanted to have the enable flag in a base class for the classes that need it, but this creates problems when multiple enableable APIs are applied to an object. In this case USD only creates a single shared enable flag, which is not what we want.)</p>
<h3><a class="anchor" id="usdPhysics_physics_scenes"></a>
Physics Scenes</h3>
<p>A primary requirement is that multiple independent physics simulations can be described within a single USD stage. We found the best way to do this is to create a <a class="el" href="class_usd_physics_scene.html" title="General physics simulation properties, required for simulation.">UsdPhysicsScene</a> class. It was proposed to use the USD layers concept to partition physics into separate scenes, but the dominant layering idioms are workflow oriented, as opposed to primitive organization. It makes sense to leave those operational principles to a a studio's data design, rather than overload the concept for simulations. In case there are multiple scenes in a stage, bodies are assigned to specific scenes using a rel from body to scene. If there is only one unique scene, an explicit rel is unnecessary, and bodies are assumed to be associated with the singleton scene. It is not possible to put a single body into multiple scenes, as data races could occur, and it would be impossible to resolve the correct state of body given conflicting simulation.</p>
<p>Scenes can define a gravity vector attribute which accelerates all contained bodies appropriately. Gravity is provided as a separate direction vector and magnitude. This allows for the independent specification of default direction (which is opposite the stage up axis), and default magnitude (earth gravity).</p>
<h3><a class="anchor" id="usdPhysics_types"></a>
Types</h3>
<p>USD differentiates between base and role value types. We tried to use the available role types whenever applicable. For example, a velocity is a vector3f rather than a float3.</p>
<p>We chose to use single rather than double precision floats as widely available real time physics simulation software universally use single precision types for best performance, and the use of double or extended precision is only warranted for positions in extremely large spaces, which is already accommodated through the use of USD's built-in <a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable</a> type.</p>
<h3><a class="anchor" id="usdPhysics_units"></a>
Units</h3>
<p>In terms of units, physics makes use of USD's established concepts of distance and time, and also adds the concept of mass. All of the physical quantities we use can be decomposed into a product of these three basic types. USD does not in general prescribe units for distance and time. It however has the concept of metersPerUnit (<a class="el" href="struct_usd_geom_tokens_type.html#abb367d764f195f37437cf61190f8260b">UsdGeomTokensType::metersPerUnit</a>) and timeCodesPerSecond (<a class="el" href="class_usd_stage.html#a61c421fcf601c28f2efc5597b8058e22" title="Sets the stage&#39;s timeCodesPerSecond value.">UsdStage::SetTimeCodesPerSecond()</a>) metadata which makes it possible to scale content authored at different scales correctly relative to each other when bringing them into a shared scene. However, the class <a class="el" href="class_usd_geom_point_instancer.html" title="Encodes vectorized instancing of multiple, potentially animated, prototypes (object/instance masters)...">UsdGeomPointInstancer</a> stores velocity and angular velocity attributes that are specified in units per second and degrees per second, respectively. This indicates a particular preference for degrees and seconds in USD, and we wish to stay consistent with this. This physics extension therefore adopts degrees as the standard angular unit, seconds as the standard time unit, and continues to respect arbitrary units for distance. Additionally we adopt arbitrary mass units and add a kilogramsPerUnit (<a class="el" href="struct_usd_physics_tokens_type.html#a24c37003b1414e39167b1132f765dfec">UsdPhysicsTokensType::kilogramsPerUnit</a>) metadata which remains consistent with scaling conversions into the International System of Units.</p>
<p>In the schema we indicate the units for each specified quantity as an expression using the terms 'distance', 'degrees', 'mass' and 'seconds' as defined above. A USD stage can be composed by referencing a number of USD files that may each have differing units; however, the specification of unit is per-stage**, so correctives must be applied to referenced data to bring it into the units of the referencing stage, as part of the act of adding the reference. In the case of linear units, given the hierarchical nature of both references and composition of transformations in a scenegraph, it is possible to "correct" for differing units by applying a scale transformation on the prim where the reference is added. However, for a change of mass units, no such easy corrective is possible; instead, each measurement must be adjusted in an overriding opinion.</p>
<p>Similarly, any simulation outputs can be converted back into their original units before being written back to USD.</p>
<p>A few metric helper APIs (<a class="el" href="usd_physics_2metrics_8h.html#a63ba908d086f1124ede1061c390c2e15">UsdPhysicsGetStageKilogramsPerUnit()</a>, <a class="el" href="usd_physics_2metrics_8h.html#a1a8f0d08d433f5e0cab9e07982b592ce">UsdPhysicsStageHasAuthoredKilogramsPerUnit()</a>, <a class="el" href="usd_physics_2metrics_8h.html#a7e2ade44ed9ee0214aafa30e48044a90">UsdPhysicsSetStageKilogramsPerUnit()</a>, <a class="el" href="usd_physics_2metrics_8h.html#a02be613a54c2a8d537c861a42a3ba474">UsdPhysicsMassUnitsAre()</a>) are provided to access and set the stage level kilogramsPerUnit metadata.</p>
<h3><a class="anchor" id="usdPhysics_default_values"></a>
Default Values</h3>
<p>For some attributes in these schemas we desire the ability to signal that we want the simulator to supply a reasonable default value, whatever that may be for the particular simulator. Since USD prefers for all schema attributes to provide "fallback" (i.e. default) values, we specify default values for these attributes explicitly, typically with sentinel values that lie outside of the legal range of values for each particular attribute. For example, if an attribute is normally required to be non-negative, we use -1.0 to request a certain default behavior. Sometimes the attribute can use the entire floating point range, in which case we reserve what is effectively +/- infinity at the edges of this range as sentinels. We will use the floating point 'inf' literal which USD supports in files and schemas to denote this. We document such default sentinel behavior on a case by case basis in the schema.</p>
<h3><a class="anchor" id="usdPhysics_rigid_bodies"></a>
Rigid Bodies</h3>
<p>We represent physics rigid bodies using the <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a>, which can be applied to any <a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable</a>. <a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable</a> is the suitable base class as it provides a placement in space via the xform which is also a fundamental property of physics bodies.</p>
<p>Rigid bodies have linear and angular velocity attributes that are specified in local space, to be consistent with velocities in point instancers and a prim's xform.</p>
<p>Bodies can specify a simulationOwner scene rel for the aforementioned multi-scene simulation scenario.</p>
<h3><a class="anchor" id="usdPhysics_interaction_with_usd"></a>
Interaction with the USD hierarchy</h3>
<p>If a prim in a USD scene graph hierarchy is marked with <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a>, the behavior is such that with <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a>, all chidlren of the marked prim are assumed to be part of this rigid body, and move rigidly along with the body. This is consistent with the common behavior one expects during hand-animation of a sub-tree. If aggregate properties of the entire rigid body must be computed, such as total mass or the entirety of its collision volume, then the contents of the entire subtree are considered.</p>
<p>Note that it is of course permitted to change/animate the transforms in such a sub-tree, in which case any derived quantities in the physics engine such as center of mass or relative shape poses will be updated. Such animation will however not generate momentum. For example, rapidly animating rigid portions of Luxo Jr. will not cause the lamp to jump, since to compute such behavior we would need to capture the relative masses of multiple independent portions of the lamp, which is not possible if the whole is treated as a single rigid assembly. The correct approach would be to model each of the rigid portions of the lamp as independent rigid bodies, and connect these with joints, which we will discuss later.</p>
<p>It is not possible to have nested bodies. PhysicsRigidBodyAPIs applied to anything in the subtree under a prim that already has a <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a> are ignored. An exception is if a prim has an resetXformStack op. In this case it ignores rigid body parenting, and a rigid body API can then be used to make it dynamic.</p>
<h3><a class="anchor" id="usdPhysics_rb_sleep"></a>
Sleep</h3>
<p>Large terrestrial simulations have the common property that all objects will eventually fall to the ground and come to rest. It is common for rigid body simulation software to have a notion of 'sleeping' such bodies to improve performance. This means that interactions cease to be updated when an equilibrium state is reached, and start to be updated again once the equilibrium state has somehow been disturbed. It is also possible to start off simulations in a sleeping state. We provide <a class="el" href="struct_usd_physics_tokens_type.html#a661e1647f4571f1d5f741917848fac0c" title="&quot;physics:startsAsleep&quot;">UsdPhysicsTokensType::physicsStartsAsleep</a> to support this. We have considered exposing the runtime sleep state of each body in the simulation so that it would be visible to USD when the simulation deactivated a body, and to let USD force a body to sleep during simulation. We decided against this since the precise deactivation rules are an implementation detail that can vary significantly between simulations, so we prefer to keep this as a hidden implementation detail for the time being.</p>
<h3><a class="anchor" id="usdPhysics_kinematic_bodies"></a>
Kinematic Bodies</h3>
<p>In games and VFX it is often desirable to have an animator take full control over a body, even as it interacts with other physics driven bodies. We call such bodies 'kinematic'. Kinematic bodies still 'pull on' joints and 'push on' touching rigid bodies, but their xform is only read, but not written, by the physics simulator, letting the animation system write their xforms. We support such bodies using the <a class="el" href="struct_usd_physics_tokens_type.html#a480125ca509f610a9cd2de8540ec0795" title="&quot;physics:kinematicEnabled&quot;">UsdPhysicsTokensType::physicsKinematicEnabled</a> attribute. Kinematic bodies are not exactly the same thing as an animated static body with a collider: The simulation infers a continuous velocity for the kinematic body from the keyframing, and this velocity will be imparted to dynamic bodies during collisions.</p>
<h3><a class="anchor" id="usdPhysics_animation_of_attributes"></a>
Animation of Attributes</h3>
<p>We worked with the assumption that every attribute on every class that is not explicitly marked with "uniform" can be animated. Obviously erratic changing of some parameters could make some simulations explode in practice, we believe this is highly implementation dependent and not a reason to generally forbid attribute animation.</p>
<h3><a class="anchor" id="usdPhysics_body_mass_properties"></a>
Body Mass Properties</h3>
<p>We opted to decouple mass properties from <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a> and place them in a separate <a class="el" href="class_usd_physics_mass_a_p_i.html" title="Defines explicit mass properties (mass, density, inertia etc.).">UsdPhysicsMassAPI</a>. <a class="el" href="class_usd_physics_mass_a_p_i.html" title="Defines explicit mass properties (mass, density, inertia etc.).">UsdPhysicsMassAPI</a> is not required in cases where the mass properties of an object can be derived from collision geometry (discussed further down in this document) and the <a class="el" href="class_usd_physics_material_a_p_i.html" title="Adds simulation material properties to a Material.">UsdPhysicsMaterialAPI</a>. Most commonly, <a class="el" href="class_usd_physics_mass_a_p_i.html" title="Defines explicit mass properties (mass, density, inertia etc.).">UsdPhysicsMassAPI</a> is applied in addition to <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a>.</p>
<p>Unlike <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a>, it is also possible to apply <a class="el" href="class_usd_physics_mass_a_p_i.html" title="Defines explicit mass properties (mass, density, inertia etc.).">UsdPhysicsMassAPI</a> multiple times in a USD scene graph subtree, in order to make it possible to accumulate the mass of rigid components.</p>
<p>The mass of an object may be specified in multiple ways, and several conflicting settings are resolved using a precedence system that will initially seem rather complex yet but is actually intuitive and practical:</p>
<ul>
<li>Parents' explicit total masses override any mass properties specified further down in the subtree.</li>
</ul>
<ul>
<li>Density has lower precedence than mass, so explicit mass always overrides implicit mass that can be computed from volume and density.</li>
</ul>
<ul>
<li>A density in a child overrides a density specified in a parent for all of the subtree under the child.</li>
</ul>
<ul>
<li>A density specified via <a class="el" href="class_usd_physics_mass_a_p_i.html" title="Defines explicit mass properties (mass, density, inertia etc.).">UsdPhysicsMassAPI</a>, even if it is inherited from a prim higher in the tree, overrides any density specified via a material (see <a class="el" href="class_usd_physics_material_a_p_i.html" title="Adds simulation material properties to a Material.">UsdPhysicsMaterialAPI</a> later in this document).</li>
</ul>
<ul>
<li>Implicit mass at any prim is the computed volume of collision geometry at that prim times the locally effective density, plus the implicit masses of all children in the subtree.</li>
</ul>
<ul>
<li>Density is assumed to be 1000.0 kg/m3 (approximately the density of water) for volume computation when no other density is specified locally, or in bound materials either locally or higher up in the tree, and this value is converted into the collider's native units prior to being used for mass computation.</li>
</ul>
<ul>
<li>Mass is assumed to be 1.0 in the mass units used when none is provided explicitly, and there are no collision volumes to derive from.</li>
</ul>
<p>Implementing this rule set is potentially nontrivial, but it's important to get right. We plan to make the pseudocode of a mass computation system available that relies on the underlying physics system to compute the volume of collision geometry.</p>
<h3><a class="anchor" id="usdPhysics_collision_shapes"></a>
Collision Shapes</h3>
<p>Our design for collision shapes defines a <a class="el" href="class_usd_physics_collision_a_p_i.html" title="Applies collision attributes to a UsdGeomXformable prim.">UsdPhysicsCollisionAPI</a> that may be attached to objects of type <a class="el" href="class_usd_geom_gprim.html" title="Base class for all geometric primitives.">UsdGeomGprim</a> representing graphics geometry. Specifically, we suggest the support of <a class="el" href="class_usd_geom_capsule.html" title="Defines a primitive capsule, i.e.">UsdGeomCapsule</a>, <a class="el" href="class_usd_geom_cone.html" title="Defines a primitive cone, centered at the origin, whose spine is along the specified axis,...">UsdGeomCone</a>, <a class="el" href="class_usd_geom_cube.html" title="Defines a primitive rectilinear cube centered at the origin.">UsdGeomCube</a>, <a class="el" href="class_usd_geom_cylinder.html" title="Defines a primitive cylinder with closed ends, centered at the origin, whose spine is along the speci...">UsdGeomCylinder</a>, <a class="el" href="class_usd_geom_sphere.html" title="Defines a primitive sphere centered at the origin.">UsdGeomSphere</a> and <a class="el" href="class_usd_geom_mesh.html" title="Encodes a mesh with optional subdivision properties and features.">UsdGeomMesh</a>, though the precise set of supported geoms might be implementation specific. Note also that some implementations might support some of these shapes using potentially faceted convex approximations.</p>
<p>As we have alluded to earlier, a subtree under a <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a> prim may contain multiple collision shape prims (or 'colliders') that are required to resolve the motion of the body as it touches other bodies. For example, a teapot is a single rigid body (the top level prim is marked with <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a>), but it may be composed of multiple Mesh and other Geoms at and under this prim. Each of these parts can gain a <a class="el" href="class_usd_physics_collision_a_p_i.html" title="Applies collision attributes to a UsdGeomXformable prim.">UsdPhysicsCollisionAPI</a> which instructs the system to make this shape's geom into a collider for the purposes of physics simulation.</p>
<p>It is also possible to have PhysicsCollisionAPIs on prims that are not under a <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a>. These are treated as static colliders &ndash; shapes that are not moved by physics, but they can still collide with bodies, at which point they are interpreted as having zero velocity and infinite mass. Since static colliders do not have a corresponding <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a>, in this case it is possible for the <a class="el" href="class_usd_physics_collision_a_p_i.html" title="Applies collision attributes to a UsdGeomXformable prim.">UsdPhysicsCollisionAPI</a> <b>itself</b> to specify a simulationOwner scene. For any collider that <b>is</b> associated with a <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a>, the collider's simulation owner attribute is ignored.</p>
<p>According to USD rules, <a class="el" href="class_usd_geom_gprim.html" title="Base class for all geometric primitives.">UsdGeomGprim(s)</a> must generally be leaf prims, and because <a class="el" href="class_usd_physics_collision_a_p_i.html" title="Applies collision attributes to a UsdGeomXformable prim.">UsdPhysicsCollisionAPI</a> can only be applied to <a class="el" href="class_usd_geom_gprim.html" title="Base class for all geometric primitives.">UsdGeomGprim</a>, it means that there is no opportunity to inherit <a class="el" href="class_usd_physics_collision_a_p_i.html" title="Applies collision attributes to a UsdGeomXformable prim.">UsdPhysicsCollisionAPI</a> attributes down the scene graph. If a mesh is composed of submeshes, all of the submeshes are considered to be part of the collider.</p>
<p>The current design has the drawback that it is not possible to add multiple colliders to a single geom object directly. To add multiple colliders one must create a parent Xform (which receives the <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a>), and then add the original geom as a child, and add any additional colliders as additional children. This is a bit more invasive than we would prefer, but the only alternative would be to make colliders Is-A schemas rather than APIs, which there was a desire to avoid to prevent the number of USD objects from increasing a great deal.</p>
<h3><a class="anchor" id="usdPhysics_mesh_into_shapes"></a>
Turning Meshes into Shapes</h3>
<p>Simple USD Prims like Sphere, Cylinder, Cube, Cone and Capsule can be used for physics simulation directly with the simple addition of a <a class="el" href="class_usd_physics_collision_a_p_i.html" title="Applies collision attributes to a UsdGeomXformable prim.">UsdPhysicsCollisionAPI</a>. <a class="el" href="class_usd_geom_mesh.html" title="Encodes a mesh with optional subdivision properties and features.">UsdGeomMesh</a> is a bit tricky because the state of the art in simulating arbitrary meshes in real time comes with some tradeoffs that users generally want control over. To support this, we allow <a class="el" href="class_usd_physics_mesh_collision_a_p_i.html" title="Attributes to control how a Mesh is made into a collider.">UsdPhysicsMeshCollisionAPI</a> to be applied to <a class="el" href="class_usd_geom_mesh.html" title="Encodes a mesh with optional subdivision properties and features.">UsdGeomMesh(es)</a> only, alongside the <a class="el" href="class_usd_physics_collision_a_p_i.html" title="Applies collision attributes to a UsdGeomXformable prim.">UsdPhysicsCollisionAPI</a>. This API has an approximation attribute that lets the user choose between no approximation (generally lowest performance), a simplified mesh, a set of convex hulls, a single convex hull, a bounding box or a bounding sphere. If an implementation does not support a particular kind of approximation, it is recommended that it falls back to the most similar supported option.</p>
<p>Note that use of the subdivision attribute (<a class="el" href="class_usd_geom_mesh.html#a01c7ff0dc2e9b6be9f09db6cfafb7c0a">UsdGeomMesh::GetSubdivisionSchemeAttr()</a>) can cause features such as corners and edges to be removed from the graphical representation. In order to ensure the physics representation accurately matches the graphical representation, this attribute should be accounted for when generating physics colliders.</p>
<p>Collision meshes may be specified explicitly (for example one that was processed by a particular decimator) by adding the custom collider mesh as a sibling to the original graphics mesh, <a class="el" href="class_usd_geom_imageable.html" title="Base class for all prims that may require rendering or visualization of some sort.">UsdGeomImageable</a> <em>purpose</em> to "guide" so it does not render, and apply <a class="el" href="class_usd_physics_collision_a_p_i.html" title="Applies collision attributes to a UsdGeomXformable prim.">UsdPhysicsCollisionAPI</a> and <a class="el" href="class_usd_physics_mesh_collision_a_p_i.html" title="Attributes to control how a Mesh is made into a collider.">UsdPhysicsMeshCollisionAPI</a> to it specifying no approximation.</p>
<h3><a class="anchor" id="usdPhysics_physics_materials"></a>
Physics Materials</h3>
<p>Just like graphics, physics uses material properties. These are primarily used to inform friction and collision restitution behavior, in addition to being one of several ways to specify object density as discussed earlier. All these properties are stored in the <a class="el" href="class_usd_physics_material_a_p_i.html" title="Adds simulation material properties to a Material.">UsdPhysicsMaterialAPI</a>, which can be applied to a USDShadeMaterial prim as we believe it to be practical to add physics properties to an established USD material library.</p>
<p>USD Physics materials are bound in the same way as graphics materials using <a class="el" href="class_usd_shade_material_binding_a_p_i.html" title="UsdShadeMaterialBindingAPI is an API schema that provides an interface for binding materials to prims...">UsdShadeMaterialBindingAPI</a>, either wih no material purpose or with a specific "physics" purpose. Note that this approach also permits binding different materials to <a class="el" href="class_usd_geom_subset.html" title="Encodes a subset of a piece of geometry (i.e.">UsdGeomSubset(s)</a>. Not all physics simulations support different materials per <a class="el" href="class_usd_geom_subset.html" title="Encodes a subset of a piece of geometry (i.e.">UsdGeomSubset</a>, and it's possible that all but one subset per collider will be ignored by the implementation.</p>
<p>The unitless coefficients dynamicFriction and staticFriction are defined by the Coulomb friction model. The coefficient of restitution is the ratio of the final to initial relative velocity between two objects after they collide. These three properties actually should be defined for each combination of two materials, but this is generally considered impractical. Common practice in real time physics is to define them on each material and then to use a simple formula to combine them, for example by taking the product or the minimum. Currently the default behavior we propose is to average the values, which is the default behavior in popular real time game engines. In the future other combine modes should be exposed.</p>
<h3><a class="anchor" id="usdPhysics_plane_shapes"></a>
Plane Shapes</h3>
<p>Implicit plane shapes are a very common physics primitive used primarily for testing simple simulations. There are plans to add a Plane class to USD as a UsdGeomGPrim. We look forward to supporting such plane shapes as static colliders when they become available.</p>
<h3><a class="anchor" id="usdPhysics_collision_filtering"></a>
Collision Filtering</h3>
<p>Even in the simplest practical applications, the need to ignore some collisions occurs often. One might need the sword of a game character to pass through an enemy rather than to bounce off, while wanting it to bounce off walls, for example.</p>
<p>We define a CollisionGroup as an IsA schema with a <a class="el" href="class_usd_collection_a_p_i.html" title="This is a general purpose API schema, used to describe a collection of heterogeneous objects within t...">UsdCollectionAPI</a> applied, that defines the membership of colliders (objects with a <a class="el" href="class_usd_physics_collision_a_p_i.html" title="Applies collision attributes to a UsdGeomXformable prim.">UsdPhysicsCollisionAPI</a>) in the group. Each group also has a multi-target relationship to other groups (potentially including itself) with which it needs to not collide. Colliders not in any CollisionGroup collide with all other colliders in the scene, except for those colliders which have disabled collision by default.</p>
<p>For behavioral or performance reasons, it is sometimes useful to configure a collider whose collision is disabled by default. To support this, the CollisionGroup has an invertFilteredGroups option; when this value is set, an implementation should disable collisions against all other colliders except for those in the referenced filteredGroups. Note that the collisions which were not disabled may still be further restricted by additional collision groups or pair filters.</p>
<p>When composing a stage from multiple USD scenes, it may be desirable to merge CollisionGroups, particularly if the stage composition is not known ahead of time. For example, a stage composed of multiple characters, each with a ragdoll as well as a character "controller" - the character controllers should not collide with the ragdoll instances. A CollisionGroup contains an optional mergeGroupName, and all groups with matching name should be considered to be part of a single group, whose members and filter groups should be the union of the merged groups. This allows the character file to define a group which disables the controller-versus-ragdoll collisions; by assigning a mergeGroupName to this group, the controller can be filtered against ragdoll bodies in all other instances of the character.</p>
<p>Care should be taken when merging groups with differing invertFilteredGroups options; merging of groups should only ever cause collision pairs to become disabled - i.e. a filter cannot re-enable a pair that has been disabled by any other group. Consider an inverted group which references only GroupX (i.e. disables collisions with everything except those in GroupX). When merging this group with a non-inverting group referencing the same GroupX (i.e. disables collisions against GroupX) - the merged group will collide with nothing, since the combined rules of the merged groups will filter out any other body.</p>
<h3><a class="anchor" id="usdPhysics_pairwise_filtering"></a>
Pairwise Filtering</h3>
<p>Sometimes group based filtering is insufficiently powerful to take care of some filtering special cases. One would for example set up group based filtering such that bodies of human characters collide against extremities like arms and legs, generally assuming that these arms and legs belong to different humans than the bodies. One however often doesn't want the extremities of a particular human to collide with its own body, which is hard to avoid during a lot of constant close proximity movement. To cover this case we have the FilteringPairsAPI, which specifies a multi-target relationship to other objects with which collisions are explicitly disabled. This pairwise filtering has precedence over group based filtering.</p>
<p>The FilteringPairsAPI can be applied to objects with a <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a>, <a class="el" href="class_usd_physics_collision_a_p_i.html" title="Applies collision attributes to a UsdGeomXformable prim.">UsdPhysicsCollisionAPI</a>, or UsdPhysicsArticulationAPI.</p>
<p>It is sufficient to have a rel from an object A to an object B, to get the filtering behavior. In this case the backwards rel from B to A is implicit and not necessary.</p>
<h3><a class="anchor" id="usdPhysics_joints"></a>
Joints</h3>
<p>Joints are generally fixed attachments that can represent the way a drawer is attached to a cabinet, a wheel to a car, or links of a robot to each-other. Here we try to focus on a set of capabilities that are common to most simulation packages and sufficiently expressive for a large number of applications.</p>
<p>Mathematically, jointed assemblies can be modeled either in maximal (world space) or reduced (relative to other bodies) coordinates. Both representations have pros and cons. We are proposing a USD representation that will work with both approaches.</p>
<h3><a class="anchor" id="usdPhysics_joint_reference_frames"></a>
Joint Reference Frames</h3>
<p>The joint base type is the IsA class <a class="el" href="class_usd_physics_joint.html" title="A joint constrains the movement of rigid bodies.">UsdPhysicsJoint</a>. Joints don't necessarily have a single unique Xform in space, rather, they are defined by two distinct frames, one relative to each of the two bodies which they connect.</p>
<p>These two frames might not work out to be the same position and orientation in world space because of either the permitted relative movement of the joint (think of a car suspension moving up and down: the joint frame of the suspension is constant relative to both the car body and the car axle, yet the axle and undercarriage move relative to each other) or the error of approximate simulations that can permit the joint to slightly pull apart when subjected to significant forces or velocities.</p>
<p>It does not make sense to derive <a class="el" href="class_usd_physics_joint.html" title="A joint constrains the movement of rigid bodies.">UsdPhysicsJoint</a> from <a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable</a> because <a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable</a> has only a single Xform, and a joint has many. We could have created an asymmetrical solution where the secondary xform is added on, or split the joint object into two separate joint frames that are parented into the scene graph and are then somehow pairwise cross referenced, but we opted to go with an entirely new class that has all the information we need in a symmetrical fashion.</p>
<h3><a class="anchor" id="usdPhysics_jointed_bodies"></a>
Jointed Bodies</h3>
<p>A joint defines a pair of relationships to <a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable(s)</a>, to which we will refer as the 'bodies'. Simulation of the joint is possible if at least one of these has a <a class="el" href="class_usd_physics_rigid_body_a_p_i.html" title="Applies physics body attributes to any UsdGeomXformable prim and marks that prim to be driven by a si...">UsdPhysicsRigidBodyAPI</a> on it, or on an ancestor. If either rel is not defined, it is treated as equivalent to attaching to the static world frame, though it is recommended to always work with two well defined <a class="el" href="class_usd_geom_xformable.html" title="Base class for all transformable prims, which allows arbitrary sequences of component affine transfor...">UsdGeomXformable(s)</a>.</p>
<p>The joint space relative to each body is a translation and orientation only, scaling is not supported. (This is a general tension between graphics and physics. Real world objects cannot scale arbitrarily, and simulations therefore tend to not support scaling during rigid body simulation). For this reason we don't use a general USD xform that is too flexible for our needs, but rather a separate position and orientation quaternion. (Note however that this local joint space is fixed in the prim's local space, which of course CAN be scaled using the prim's own Xform scaling. This means that if a doorknob is attached to a door at a particular position, it will continue to appear in the same correct position on the door regardless of how the door is scaled, without having to adjust the joint position.)</p>
<p>We generally desire to have the two joint frames line up in world space, at least along their constrained degrees of freedom. This condition can be violated if either body is moved in world space, either by changing its own or one of its parents' transforms, or if either body rels is changed. As a result it is desirable to recompute the joint frames when the connected bodies or their world space transforms have changed.</p>
<h3><a class="anchor" id="usdPhysics_joint_collision_filtering"></a>
Joint Collision Filtering</h3>
<p>It is common practice to disable collisions between the jointed bodies so that their collision shapes don't interfere. It is therefore the default behavior that collisions between the two subtrees indicated by the two body rel-s are ignored. This default filtering behavior can be opted out of using the joint's collisionEnabled attribute. No filtering occurs if either rel is undefined.</p>
<h3><a class="anchor" id="usdPhysics_breaking_disabling_joints"></a>
Breaking and Disabling Joints</h3>
<p>Breaking force is a practical property useful for all joints; joints can break when sufficient force is applied. For example a door can be ripped off its hinges. This can be modeled using the breakForce and breakTorque attributes.</p>
<p>Joints can entirely be temporarily disabled just like rigid bodies or colliders. Contrary to breaking, which is a (within a simulation run irreversible) simulated behavior, disabling is a request to not simulate the joint at all.</p>
<h3><a class="anchor" id="usdPhysics_joint_subtypes"></a>
Joint Subtypes</h3>
<p>It is possible to derive a number of specific joint types, however the Joint API itself can represent a generic configurable joint, so in that sense it is not an abstract type.</p>
<p>The subtypes <a class="el" href="class_usd_physics_spherical_joint.html" title="Predefined spherical joint type (Removes linear degrees of freedom, cone limit may restrict the motio...">UsdPhysicsSphericalJoint</a>, <a class="el" href="class_usd_physics_revolute_joint.html" title="Predefined revolute joint type (rotation along revolute joint axis is permitted.)">UsdPhysicsRevoluteJoint</a> and <a class="el" href="class_usd_physics_prismatic_joint.html" title="Predefined prismatic joint type (translation along prismatic joint axis is permitted....">UsdPhysicsPrismaticJoint</a> both define a primary axis (Following the USD axis definition pattern established in e.g. <a class="el" href="class_usd_geom_capsule.html" title="Defines a primitive capsule, i.e.">UsdGeomCapsule</a> and <a class="el" href="class_usd_geom_cylinder.html" title="Defines a primitive cylinder with closed ends, centered at the origin, whose spine is along the speci...">UsdGeomCylinder</a>) and a top and bottom motion limit along it.</p>
<p><a class="el" href="class_usd_physics_distance_joint.html" title="Predefined distance joint type (Distance between rigid bodies may be limited to given minimum or maxi...">UsdPhysicsDistanceJoint</a> defines a min and max distance between the attachment points. The <a class="el" href="class_usd_physics_fixed_joint.html" title="Predefined fixed joint type (All degrees of freedom are removed.)">UsdPhysicsFixedJoint</a> has no additional properties and simply locks all relative degrees of freedom.</p>
<h3><a class="anchor" id="usdPhysics_limits_drives"></a>
Joint Limits and Drives</h3>
<p>Instead of using one of the predefined joint subtypes, it is also possible to compose a custom joint from a set of limits and drives. Limits and drives are multi-apply schemas, so one can apply multiple instances, one for each degree of freedom. The degree of freedom is specified via the <a class="el" href="class_tf_token.html" title="Token for efficient comparison, assignment, and hashing of known strings.">TfToken</a> (effectively a string, one of "transX", "transY", "transZ", "rotX", "rotY", "rotZ", "distance", that is postpended after the class name.)</p>
<p>The limit API further contains optional low and high limit attributes.</p>
<p>The drive API allows joints to be motorized along degrees of freedom. It may specify either a force or acceleration drive (The strength of force drives is impacted by the mass of the bodies attached to the joint, an acceleration drive is not). It also has a target value to reach, and one can specify if the target is a goal position or velocity. One can limit the maximum force the drive can apply, and one can specify a spring and damping coefficient.</p>
<p>The resulting drive force or acceleration is proportional to </p><div class="fragment"><div class="line">stiffness * (targetPosition - p) + damping * (targetVelocity - v)</div></div><!-- fragment --><p> where p is the relative pose space motion of the joint (the axial rotation of a revolute joint, or axial translation for a prismatic joint) and v is the rate of change of this motion.</p>
<p>For all limits that specify ranges, a "low" limit larger than the "high" limit means the joint motion along that axis is locked.</p>
<h3><a class="anchor" id="usdPhysics_articulations"></a>
Articulations</h3>
<p>Earlier we mentioned that we support reduced coordinate joints, which require some additional specification. We decided to do this with a minimal extension of the above maximal joints. Any prim of the USD scene graph hierarchy may be marked with an <a class="el" href="class_usd_physics_articulation_root_a_p_i.html" title="PhysicsArticulationRootAPI can be applied to a scene graph node, and marks the subtree rooted here fo...">UsdPhysicsArticulationRootAPI</a>. This informs the simulation that any joints found in the subtree should preferentially be simulated using a reduced coordinate approach. For floating articulations (robotics jargon for something not bolted down, e.g. a wheeled robot or a quadcopter), this API should be used on the root body (typically the central mass the wheels or rotors are attached to), or a direct or indirect parent prim. For fixed articulations (robotics jargon for e.g. a robot arm for welding that is bolted to the floor), this API can be on a direct or indirect parent of the root joint which is connected to the world, or on the joint itself. If there are multiple qualifying bodies or joints under an <a class="el" href="class_usd_physics_articulation_root_a_p_i.html" title="PhysicsArticulationRootAPI can be applied to a scene graph node, and marks the subtree rooted here fo...">UsdPhysicsArticulationRootAPI</a> prim, each is made into a separate articulation root.</p>
<p>This should in general make it possible to uniquely identify a distinguished root body or root joint for the articulation. From this root, a tree of bodies and joints is identified that is not to contain loops (which may be closed by joint collections). If loops are found, they may be broken at an arbitrary location. Alternatively, a joint in the loop may use its excludeFromArticulation attribute flag to denote that it wishes to remain a maximal joint, and at this point the loop is then broken.</p>
<h2><a class="anchor" id="usdPhysics_examples"></a>
Examples</h2>
<h3><a class="anchor" id="usdPhysics_box_on_box"></a>
Box on Box</h3>
<div class="fragment"></div><!-- fragment --><h3><a class="anchor" id="usdPhysics_box_on_quad"></a>
Box on Quad</h3>
<div class="fragment"><div class="line">#usda 1.0</div><div class="line">#More advanced example showing mesh collisions</div><div class="line">#and center of mass offset.  We expect to have the</div><div class="line">#quad be represented as a convex mesh and have the </div><div class="line">#cube come to rest on it, balanced on one of its corners.</div><div class="line">(</div><div class="line">    defaultPrim = &quot;World&quot;</div><div class="line">    endTimeCode = 100</div><div class="line">    metersPerUnit = 0.01</div><div class="line">    startTimeCode = 0</div><div class="line">    timeCodesPerSecond = 24</div><div class="line">    upAxis = &quot;Z&quot;</div><div class="line">    kilogramsPerUnit = 1</div><div class="line">)</div><div class="line">def Xform &quot;World&quot;</div><div class="line">{</div><div class="line">    def PhysicsScene &quot;PhysicsScene&quot;</div><div class="line">    {</div><div class="line">    }</div><div class="line">    #Added a mass API so we can offset the center of mass.</div><div class="line">    def Cube &quot;BoxActor&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;, &quot;PhysicsRigidBodyAPI&quot;, &quot;PhysicsMassAPI&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        #explicit mass</div><div class="line">        float physics:mass = 10.0</div><div class="line">        #Offset center of mass so the cube settles on its corner</div><div class="line">        point3f physics:centerOfMass = (40.0, 40.0, 40.0)</div><div class="line">        color3f[] primvars:displayColor = [(0.2784314, 0.4117647, 1)]</div><div class="line">        double size = 25</div><div class="line">        double3 xformOp:translate = (0, 0, 500)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;]</div><div class="line">    }</div><div class="line">    #A quad mesh that serves as the ground.</div><div class="line">    def Mesh &quot;Ground&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;, &quot;PhysicsMeshCollisionAPI&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        #Approximate with a convex hull, if we remove this, it will</div><div class="line">        #be used directly</div><div class="line">        uniform token physics:approximation = &quot;convexHull&quot;</div><div class="line">        uniform token subdivisionScheme = &quot;none&quot;</div><div class="line">        uniform bool doubleSided = 1</div><div class="line">        int[] faceVertexCounts = [4]</div><div class="line">        int[] faceVertexIndices = [0, 1, 2, 3]</div><div class="line">        normal3f[] normals = [(0, 0, 1), (0, 0, 1), (0, 0, 1), (0, 0, 1)]</div><div class="line">        point3f[] points = [(-1, 1, 0), (1, 1, 0), (1, -1, 0), (-1, -1, 0)]</div><div class="line">        color3f[] primvars:displayColor = [(0.5, 0.5, 0.5)]</div><div class="line">        texCoord2f[] primvars:st = [(0, 1), (1, 1), (1, 0), (0, 0)] (</div><div class="line">            interpolation = &quot;varying&quot;</div><div class="line">        )</div><div class="line">        float3 xformOp:scale = (750, 750, 750)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:scale&quot;]</div><div class="line">    }</div><div class="line">    def SphereLight &quot;SphereLight&quot;</div><div class="line">    {</div><div class="line">        float intensity = 30000</div><div class="line">        float radius = 150</div><div class="line">        double3 xformOp:translate = (650, 0, 1150)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="usdPhysics_spheres_with_material"></a>
Spheres with Materials</h3>
<div class="fragment"><div class="line">#usda 1.0</div><div class="line">#Shows two spheres, one with high</div><div class="line">#and one with low bounce, by using materials.</div><div class="line">#Also uses a trimesh ground quad.</div><div class="line">(</div><div class="line">    defaultPrim = &quot;World&quot;</div><div class="line">    endTimeCode = 100</div><div class="line">    metersPerUnit = 0.01</div><div class="line">    startTimeCode = 0</div><div class="line">    timeCodesPerSecond = 24</div><div class="line">    upAxis = &quot;Z&quot;</div><div class="line">    </div><div class="line">    #New mass scaling</div><div class="line">    kilogramsPerUnit = 1.0</div><div class="line">    </div><div class="line">)</div><div class="line">def Xform &quot;World&quot;</div><div class="line">{</div><div class="line">    def PhysicsScene &quot;PhysicsScene&quot;</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">    def Sphere &quot;RegularSphere&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;, &quot;PhysicsRigidBodyAPI&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        rel material:binding:physics = &lt;/World/Looks/RegularMaterial&gt;</div><div class="line"></div><div class="line">        color3f[] primvars:displayColor = [(0.2784314, 0.4117647, 1)]</div><div class="line">        double3 xformOp:translate = (0, 0, 500)</div><div class="line">        float3 xformOp:scale = (25, 25, 25)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;, &quot;xformOp:scale&quot;]</div><div class="line">    }</div><div class="line">    def Sphere &quot;BouncySphere&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;, &quot;PhysicsRigidBodyAPI&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        rel material:binding:physics = &lt;/World/Looks/BouncyMaterial&gt; (</div><div class="line">            bindMaterialAs = &quot;weakerThanDescendants&quot;</div><div class="line">        )</div><div class="line"></div><div class="line">        color3f[] primvars:displayColor = [(0.8784314, 0.2117647, 0.1)]</div><div class="line">        double3 xformOp:translate = (300, 0, 500)</div><div class="line">        float3 xformOp:scale = (25, 25, 25)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;, &quot;xformOp:scale&quot;]</div><div class="line">    }</div><div class="line">    def Mesh &quot;Ground&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        int[] faceVertexCounts = [4]</div><div class="line">        int[] faceVertexIndices = [3, 2, 1, 0]</div><div class="line">        uniform token subdivisionScheme = &quot;none&quot;</div><div class="line">        normal3f[] normals = [(0, 0, 1), (0, 0, 1), (0, 0, 1), (0, 0, 1)]</div><div class="line">        point3f[] points = [(-1, 1, 0), (1, 1, 0), (1, -1, 0), (-1, -1, 0)]</div><div class="line">        color3f[] primvars:displayColor = [(0.5, 0.5, 0.5)]</div><div class="line">        texCoord2f[] primvars:st = [(0, 1), (1, 1), (1, 0), (0, 0)] (</div><div class="line">            interpolation = &quot;varying&quot;</div><div class="line">        )</div><div class="line">        float3 xformOp:scale = (750, 750, 750)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:scale&quot;]</div><div class="line">    }</div><div class="line"></div><div class="line">    def Scope &quot;Looks&quot;</div><div class="line">    {</div><div class="line">        def Material &quot;RegularMaterial&quot; (</div><div class="line">            prepend apiSchemas = [&quot;PhysicsMaterialAPI&quot;]</div><div class="line">        )</div><div class="line">        {</div><div class="line">            double physics:density = 10</div><div class="line">            float physics:restitution = 0.1</div><div class="line">        }</div><div class="line">        def Material &quot;BouncyMaterial&quot; (</div><div class="line">            prepend apiSchemas = [&quot;PhysicsMaterialAPI&quot;]</div><div class="line">        )</div><div class="line">        {</div><div class="line">            double physics:density = 10</div><div class="line">            float physics:restitution = 0.8</div><div class="line">        }</div><div class="line">    }</div><div class="line">    def SphereLight &quot;SphereLight&quot;</div><div class="line">    {</div><div class="line">        float intensity = 30000</div><div class="line">        float radius = 150</div><div class="line">        double3 xformOp:translate = (650, 0, 1150)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="usdPhysics_group_filtering"></a>
Group Filtering</h3>
<div class="fragment"><div class="line">#usda 1.0</div><div class="line">#Shows two boxes that collide with a ground box</div><div class="line">#but do not collide with each other thanks to</div><div class="line">#group based filtering.</div><div class="line">(</div><div class="line">    defaultPrim = &quot;World&quot;</div><div class="line">    endTimeCode = 100</div><div class="line">    metersPerUnit = 0.01</div><div class="line">    startTimeCode = 0</div><div class="line">    timeCodesPerSecond = 24</div><div class="line">    upAxis = &quot;Z&quot;</div><div class="line">    kilogramsPerUnit = 1.0</div><div class="line">)</div><div class="line">def Xform &quot;World&quot;</div><div class="line">{</div><div class="line">    def PhysicsScene &quot;PhysicsScene&quot;</div><div class="line">    {</div><div class="line">    }</div><div class="line">    def Cube &quot;Box1&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;, &quot;PhysicsRigidBodyAPI&quot;]</div><div class="line">    )</div><div class="line">    {   </div><div class="line">        color3f[] primvars:displayColor = [(0.2784314, 0.4117647, 1)]</div><div class="line">        double size = 25</div><div class="line">        double3 xformOp:translate = (0, 0, 50)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;]</div><div class="line">    }</div><div class="line">    def Cube &quot;Box2&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;, &quot;PhysicsRigidBodyAPI&quot;]</div><div class="line">    )</div><div class="line">    {        </div><div class="line">        color3f[] primvars:displayColor = [(0.2784314, 0.4117647, 1)]</div><div class="line">        double size = 25</div><div class="line">        double3 xformOp:translate = (0, 0, 100)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;]</div><div class="line">    }</div><div class="line">    def PhysicsCollisionGroup &quot;DynamicGroup&quot; (</div><div class="line">    prepend apiSchemas = [&quot;CollectionAPI:colliders&quot;]</div><div class="line">    )</div><div class="line">    {     </div><div class="line">        prepend rel collection:colliders:includes = [</div><div class="line">            &lt;/World/Box1&gt;,</div><div class="line">            &lt;/World/Box2&gt;</div><div class="line">        ]</div><div class="line">        prepend rel physics:filteredGroups = [</div><div class="line">            &lt;/World/DynamicGroup&gt;</div><div class="line">        ]</div><div class="line">    }</div><div class="line">    def Cube &quot;Ground&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        color3f[] primvars:displayColor = [(0.5, 0.5, 0.5)]</div><div class="line">        float3 xformOp:scale = (750, 750, 10)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:scale&quot;]</div><div class="line">    }</div><div class="line">    def SphereLight &quot;SphereLight&quot;</div><div class="line">    {</div><div class="line">        float intensity = 30000</div><div class="line">        float radius = 150</div><div class="line">        double3 xformOp:translate = (650, 0, 1150)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="usdPhysics_pair_filtering"></a>
Pair Filtering</h3>
<div class="fragment"><div class="line">#usda 1.0</div><div class="line">(</div><div class="line">    defaultPrim = &quot;World&quot;</div><div class="line">    endTimeCode = 100</div><div class="line">    metersPerUnit = 0.01</div><div class="line">    startTimeCode = 0</div><div class="line">    timeCodesPerSecond = 24</div><div class="line">    upAxis = &quot;Z&quot;</div><div class="line">    kilogramsPerUnit = 1.0</div><div class="line">)</div><div class="line">def Xform &quot;World&quot;</div><div class="line">{</div><div class="line">    def PhysicsScene &quot;PhysicsScene&quot;</div><div class="line">    {</div><div class="line">    }</div><div class="line">    def Cube &quot;Box1&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;, &quot;PhysicsRigidBodyAPI&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        color3f[] primvars:displayColor = [(0.2784314, 0.4117647, 1)]</div><div class="line">        double size = 25</div><div class="line">        double3 xformOp:translate = (0, 0, 50)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;]</div><div class="line">    }</div><div class="line">    def Cube &quot;Box2&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;, &quot;PhysicsRigidBodyAPI&quot;, &quot;PhysicsFilteredPairsAPI&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        prepend rel physics:filteredPairs = &lt;/World/Box1&gt;</div><div class="line">        color3f[] primvars:displayColor = [(0.2784314, 0.4117647, 1)]</div><div class="line">        double size = 25</div><div class="line">        double3 xformOp:translate = (0, 0, 100)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;]</div><div class="line">    }</div><div class="line">    def Cube &quot;Ground&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        color3f[] primvars:displayColor = [(0.5, 0.5, 0.5)]</div><div class="line">        float3 xformOp:scale = (750, 750, 10)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:scale&quot;]</div><div class="line">    }</div><div class="line">    def SphereLight &quot;SphereLight&quot;</div><div class="line">    {</div><div class="line">        float intensity = 30000</div><div class="line">        float radius = 150</div><div class="line">        double3 xformOp:translate = (650, 0, 1150)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="usdPhysics_joint_example"></a>
Joint</h3>
<div class="fragment"><div class="line">#usda 1.0</div><div class="line">#Shows a joint which is driven to rotate</div><div class="line">#around the vertical axis with a constant</div><div class="line">#speed.</div><div class="line">(</div><div class="line">    defaultPrim = &quot;World&quot;</div><div class="line">    endTimeCode = 100</div><div class="line">    metersPerUnit = 0.01</div><div class="line">    startTimeCode = 0</div><div class="line">    timeCodesPerSecond = 24</div><div class="line">    upAxis = &quot;Z&quot;</div><div class="line">    </div><div class="line">    kilogramsPerUnit = 1.0</div><div class="line">)</div><div class="line">def Xform &quot;World&quot;</div><div class="line">{</div><div class="line">    def PhysicsScene &quot;physicsScene&quot;</div><div class="line">    {</div><div class="line">        float3 gravity = (0, 0, -1000)</div><div class="line">    }</div><div class="line">    def Cube &quot;StaticBox&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        color3f[] primvars:displayColor = [(0.64705884, 0.08235294, 0.08235294)]</div><div class="line">        double size = 100</div><div class="line">        quatf xformOp:orient = (1, 0, 0, 0)</div><div class="line">        float3 xformOp:scale = (0.1, 1, 0.1)</div><div class="line">        double3 xformOp:translate = (0, 0, 1000)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;, &quot;xformOp:orient&quot;, &quot;xformOp:scale&quot;]</div><div class="line">    }</div><div class="line">    def Cube &quot;DynamicBox&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;, &quot;PhysicsRigidBodyAPI&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        color3f[] primvars:displayColor = [(0.2784314, 0.64705884, 1)]</div><div class="line">        double size = 100</div><div class="line">        quatf xformOp:orient = (1, 0, 0, 0)</div><div class="line">        float3 xformOp:scale = (0.1, 1, 0.1)</div><div class="line">        double3 xformOp:translate = (0, 120, 1000)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;, &quot;xformOp:orient&quot;, &quot;xformOp:scale&quot;]</div><div class="line">    }</div><div class="line">    #Joint with 5 limits and one drive</div><div class="line">    def PhysicsJoint &quot;D6Joint&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsLimitAPI:transX&quot;, &quot;PhysicsLimitAPI:transY&quot;, &quot;PhysicsLimitAPI:transZ&quot;, &quot;PhysicsLimitAPI:rotX&quot;, &quot;PhysicsLimitAPI:rotY&quot;, &quot;PhysicsDriveAPI:rotZ&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        rel physics:body0 = &lt;/World/StaticBox&gt;</div><div class="line">        rel physics:body1 = &lt;/World/DynamicBox&gt;</div><div class="line">        float limit:rotX:physics:high = -1</div><div class="line">        float limit:rotX:physics:low = 1</div><div class="line">        float limit:rotY:physics:high = -1</div><div class="line">        float limit:rotY:physics:low = 1</div><div class="line">        float limit:transX:physics:high = -1</div><div class="line">        float limit:transX:physics:low = 1</div><div class="line">        float limit:transY:physics:high = -1</div><div class="line">        float limit:transY:physics:low = 1</div><div class="line">        float limit:transZ:physics:high = -1</div><div class="line">        float limit:transZ:physics:low = 1</div><div class="line">        float drive:rotZ:physics:targetVelocity = 10.0</div><div class="line">        float drive:rotZ:physics:damping = 9999.0</div><div class="line">        point3f physics:localPos0 = (0, 60, 0)</div><div class="line">        point3f physics:localPos1 = (0, -60, 0)</div><div class="line">        quatf physics:localRot0 = (1, 0, 0, 0)</div><div class="line">        quatf physics:localRot1 = (1, 0, 0, 0)</div><div class="line">    }</div><div class="line">    def SphereLight &quot;SphereLight&quot;</div><div class="line">    {</div><div class="line">        float intensity = 30000</div><div class="line">        float radius = 150</div><div class="line">        double3 xformOp:translate = (650, 0, 1150)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="usdPhysics_distance_joint_example"></a>
Distance Joint</h3>
<div class="fragment"><div class="line">#usda 1.0</div><div class="line">#Shows a dynamic box connected</div><div class="line">#to a fixed box with a distance joint.</div><div class="line">(</div><div class="line">    defaultPrim = &quot;World&quot;</div><div class="line">    endTimeCode = 100</div><div class="line">    metersPerUnit = 0.01</div><div class="line">    startTimeCode = 0</div><div class="line">    timeCodesPerSecond = 24</div><div class="line">    upAxis = &quot;Z&quot;</div><div class="line">    kilogramsPerUnit = 1.0</div><div class="line">)</div><div class="line">def Xform &quot;World&quot;</div><div class="line">{</div><div class="line">    def PhysicsScene &quot;physicsScene&quot;</div><div class="line">    {</div><div class="line">    }</div><div class="line">    def Cube &quot;StaticBox&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        color3f[] primvars:displayColor = [(0.64705884, 0.08235294, 0.08235294)]</div><div class="line">        double size = 100</div><div class="line">        quatf xformOp:orient = (1, 0, 0, 0)</div><div class="line">        float3 xformOp:scale = (0.1, 1, 0.1)</div><div class="line">        double3 xformOp:translate = (0, 0, 1000)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;, &quot;xformOp:orient&quot;, &quot;xformOp:scale&quot;]</div><div class="line">    }</div><div class="line">    def Cube &quot;DynamicBox&quot; (</div><div class="line">        prepend apiSchemas = [&quot;PhysicsCollisionAPI&quot;, &quot;PhysicsRigidBodyAPI&quot;]</div><div class="line">    )</div><div class="line">    {</div><div class="line">        color3f[] primvars:displayColor = [(0.2784314, 0.64705884, 1)]</div><div class="line">        double size = 100</div><div class="line">        float3 velocity = (0, 0, 0)</div><div class="line">        quatf xformOp:orient = (1, 0, 0, 0)</div><div class="line">        float3 xformOp:scale = (0.1, 1, 0.1)</div><div class="line">        double3 xformOp:translate = (0, 120, 1000)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;, &quot;xformOp:orient&quot;, &quot;xformOp:scale&quot;]</div><div class="line">    }</div><div class="line">    def DistancePhysicsJoint &quot;DistanceJoint&quot;</div><div class="line">    {</div><div class="line">        rel physics:body0 = &lt;/World/StaticBox&gt;</div><div class="line">        rel physics:body1 = &lt;/World/DynamicBox&gt;</div><div class="line">        float3 physics:localPos0 = (0, 60, 0)</div><div class="line">        float3 physics:localPos1 = (0, -60, 0)</div><div class="line">        quatf physics:localRot0 = (1, 0, 0, 0)</div><div class="line">        quatf physics:localRot1 = (1, 0, 0, 0)</div><div class="line">        float physics:maxDistance = 50</div><div class="line">        float physics:minDistance = 10</div><div class="line">    }</div><div class="line">    def SphereLight &quot;SphereLight&quot;</div><div class="line">    {</div><div class="line">        float intensity = 30000</div><div class="line">        float radius = 150</div><div class="line">        double3 xformOp:translate = (650, 0, 1150)</div><div class="line">        uniform token[] xformOpOrder = [&quot;xformOp:translate&quot;]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:57 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>