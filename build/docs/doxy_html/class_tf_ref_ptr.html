<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: TfRefPtr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_tf_ref_ptr.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_tf_ref_ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TfRefPtr&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__group__tf___memory.html">Memory Management</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Reference-counted smart pointer utility class.  
 <a href="class_tf_ref_ptr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afe400d3f662f42fab8f065a689ba9a4a"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#afe400d3f662f42fab8f065a689ba9a4a">DataType</a></td></tr>
<tr class="memdesc:afe400d3f662f42fab8f065a689ba9a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type accessor to underlying type <code>T</code> for template code.  <a href="#afe400d3f662f42fab8f065a689ba9a4a">More...</a><br /></td></tr>
<tr class="separator:afe400d3f662f42fab8f065a689ba9a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2fbc9f5fab0deca1d46de73896a484f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#ad2fbc9f5fab0deca1d46de73896a484f">TfRefPtr</a> ()</td></tr>
<tr class="memdesc:ad2fbc9f5fab0deca1d46de73896a484f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize pointer to nullptr.  <a href="#ad2fbc9f5fab0deca1d46de73896a484f">More...</a><br /></td></tr>
<tr class="separator:ad2fbc9f5fab0deca1d46de73896a484f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b016d2605e95703bb7fd61c4c4c730"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a37b016d2605e95703bb7fd61c4c4c730">TfRefPtr</a> (<a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;&amp;p)</td></tr>
<tr class="memdesc:a37b016d2605e95703bb7fd61c4c4c730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the pointer managed by <code>p</code> to <code>*this</code>.  <a href="#a37b016d2605e95703bb7fd61c4c4c730">More...</a><br /></td></tr>
<tr class="separator:a37b016d2605e95703bb7fd61c4c4c730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb607015dc6fd449caf6a77ce316445"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#aadb607015dc6fd449caf6a77ce316445">TfRefPtr</a> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:aadb607015dc6fd449caf6a77ce316445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <code>*this</code> to point at <code>p's</code> object.  <a href="#aadb607015dc6fd449caf6a77ce316445">More...</a><br /></td></tr>
<tr class="separator:aadb607015dc6fd449caf6a77ce316445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b14e349bbd7efe78f5e4d9394fd427f"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class X, class U &gt; </td></tr>
<tr class="memitem:a4b14e349bbd7efe78f5e4d9394fd427f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a4b14e349bbd7efe78f5e4d9394fd427f">TfRefPtr</a> (const TfWeakPtrFacade&lt; X, U &gt; &amp;p, typename std::enable_if&lt; std::is_convertible&lt; U *, T * &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a4b14e349bbd7efe78f5e4d9394fd427f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <code>*this</code> to point at <code>gp's</code> object.  <a href="#a4b14e349bbd7efe78f5e4d9394fd427f">More...</a><br /></td></tr>
<tr class="separator:a4b14e349bbd7efe78f5e4d9394fd427f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f00837444702c7ea589a7a96ec80fa"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a80f00837444702c7ea589a7a96ec80fa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a80f00837444702c7ea589a7a96ec80fa">TfRefPtr</a> (U *ptr, typename std::enable_if&lt; std::is_convertible&lt; U *, T * &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a80f00837444702c7ea589a7a96ec80fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes to point at <code>*ptr</code>.  <a href="#a80f00837444702c7ea589a7a96ec80fa">More...</a><br /></td></tr>
<tr class="separator:a80f00837444702c7ea589a7a96ec80fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa437dcac2e6393797505de3be6cbf010"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#aa437dcac2e6393797505de3be6cbf010">TfRefPtr</a> (TfNullPtrType)</td></tr>
<tr class="memdesc:aa437dcac2e6393797505de3be6cbf010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion from <em>TfNullPtr</em> to <a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a>.  <a href="#aa437dcac2e6393797505de3be6cbf010">More...</a><br /></td></tr>
<tr class="separator:aa437dcac2e6393797505de3be6cbf010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c8389306a23e6e828f44529c888c1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#af3c8389306a23e6e828f44529c888c1b">TfRefPtr</a> (std::nullptr_t)</td></tr>
<tr class="memdesc:af3c8389306a23e6e828f44529c888c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion from <em>nullptr</em> to <a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a>.  <a href="#af3c8389306a23e6e828f44529c888c1b">More...</a><br /></td></tr>
<tr class="separator:af3c8389306a23e6e828f44529c888c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ebd6e7db873f660498eae68f96528c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a58ebd6e7db873f660498eae68f96528c">operator=</a> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a58ebd6e7db873f660498eae68f96528c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns pointer to point at <code>p's</code> object, and increments reference count.  <a href="#a58ebd6e7db873f660498eae68f96528c">More...</a><br /></td></tr>
<tr class="separator:a58ebd6e7db873f660498eae68f96528c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79110afc36318a217b8747ddacd95bbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a79110afc36318a217b8747ddacd95bbb">operator=</a> (<a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;&amp;p)</td></tr>
<tr class="memdesc:a79110afc36318a217b8747ddacd95bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the pointer managed by <code>p</code> to <code>*this</code> and leaves <code>p</code> pointing at the NULL object.  <a href="#a79110afc36318a217b8747ddacd95bbb">More...</a><br /></td></tr>
<tr class="separator:a79110afc36318a217b8747ddacd95bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c127a68abb58485ca93cc93cbcbc315"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a4c127a68abb58485ca93cc93cbcbc315">~TfRefPtr</a> ()</td></tr>
<tr class="memdesc:a4c127a68abb58485ca93cc93cbcbc315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements reference count of object being pointed to.  <a href="#a4c127a68abb58485ca93cc93cbcbc315">More...</a><br /></td></tr>
<tr class="separator:a4c127a68abb58485ca93cc93cbcbc315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a72ffad18f4bd51d1b9c8359712a61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#ae2a72ffad18f4bd51d1b9c8359712a61">TfRefPtr</a> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;p)</td></tr>
<tr class="memdesc:ae2a72ffad18f4bd51d1b9c8359712a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes to point at <code>p's</code> object, and increments reference count.  <a href="#ae2a72ffad18f4bd51d1b9c8359712a61">More...</a><br /></td></tr>
<tr class="separator:ae2a72ffad18f4bd51d1b9c8359712a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59871465a56e3ba5751a0df193bfe78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#ad59871465a56e3ba5751a0df193bfe78">TfRefPtr</a> (<a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;&amp;p)</td></tr>
<tr class="memdesc:ad59871465a56e3ba5751a0df193bfe78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the pointer managed by <code>p</code> to <code>*this</code> and leaves <code>p</code> pointing at the NULL object.  <a href="#ad59871465a56e3ba5751a0df193bfe78">More...</a><br /></td></tr>
<tr class="separator:ad59871465a56e3ba5751a0df193bfe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac572a39d34606471f22108798561bc46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#ac572a39d34606471f22108798561bc46">operator=</a> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;p)</td></tr>
<tr class="memdesc:ac572a39d34606471f22108798561bc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns pointer to point at <code>p's</code> object, and increments reference count.  <a href="#ac572a39d34606471f22108798561bc46">More...</a><br /></td></tr>
<tr class="separator:ac572a39d34606471f22108798561bc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670f7f34961d6412ffa3888e5567c0ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a670f7f34961d6412ffa3888e5567c0ee">operator=</a> (<a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;&amp;p)</td></tr>
<tr class="memdesc:a670f7f34961d6412ffa3888e5567c0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the pointer managed by <code>p</code> to <code>*this</code> and leaves <code>p</code> pointing at the NULL object.  <a href="#a670f7f34961d6412ffa3888e5567c0ee">More...</a><br /></td></tr>
<tr class="separator:a670f7f34961d6412ffa3888e5567c0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf528f98b109e720fffdc2a273f7937"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a0cf528f98b109e720fffdc2a273f7937">operator==</a> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;p) const -&gt; decltype(std::declval&lt; T * &gt;()==std::declval&lt; U * &gt;(), bool())</td></tr>
<tr class="memdesc:a0cf528f98b109e720fffdc2a273f7937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>*this</code> and <code>p</code> point to the same object (or if they both point to NULL).  <a href="#a0cf528f98b109e720fffdc2a273f7937">More...</a><br /></td></tr>
<tr class="separator:a0cf528f98b109e720fffdc2a273f7937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3873f48a2806208484a4d39ca00c40"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#abf3873f48a2806208484a4d39ca00c40">operator!=</a> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;p) const -&gt; decltype(std::declval&lt; T * &gt;() !=std::declval&lt; U * &gt;(), bool())</td></tr>
<tr class="memdesc:abf3873f48a2806208484a4d39ca00c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>*this</code> and <code>p</code> do not point to the same object.  <a href="#abf3873f48a2806208484a4d39ca00c40">More...</a><br /></td></tr>
<tr class="separator:abf3873f48a2806208484a4d39ca00c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf71084107e6a32783cfe6c6f1d4fa3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#aeaf71084107e6a32783cfe6c6f1d4fa3">operator&lt;</a> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;p) const -&gt; decltype(std::declval&lt; T * &gt;()&lt; std::declval&lt; U * &gt;(), bool())</td></tr>
<tr class="memdesc:aeaf71084107e6a32783cfe6c6f1d4fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the address of the object pointed to by <code>*this</code> compares less than the address of the object pointed to by <code>p</code>.  <a href="#aeaf71084107e6a32783cfe6c6f1d4fa3">More...</a><br /></td></tr>
<tr class="separator:aeaf71084107e6a32783cfe6c6f1d4fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccee7073006a10421c5b9b1e6c45c82"><td class="memItemLeft" align="right" valign="top"><a id="acccee7073006a10421c5b9b1e6c45c82"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;p) const -&gt; decltype(std::declval&lt; T * &gt;() &gt; std::declval&lt; U * &gt;(), bool())</td></tr>
<tr class="separator:acccee7073006a10421c5b9b1e6c45c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c331d736d3dcb094e73e899f10eac43"><td class="memItemLeft" align="right" valign="top"><a id="a8c331d736d3dcb094e73e899f10eac43"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;p) const -&gt; decltype(std::declval&lt; T * &gt;()&lt;=std::declval&lt; U * &gt;(), bool())</td></tr>
<tr class="separator:a8c331d736d3dcb094e73e899f10eac43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb22d742a7dd7a7b2ad796b1818a1421"><td class="memItemLeft" align="right" valign="top"><a id="acb22d742a7dd7a7b2ad796b1818a1421"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;p) const -&gt; decltype(std::declval&lt; T * &gt;() &gt;=std::declval&lt; U * &gt;(), bool())</td></tr>
<tr class="separator:acb22d742a7dd7a7b2ad796b1818a1421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1735ebb61cb9b40f6d0ed30be8a288"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a5c1735ebb61cb9b40f6d0ed30be8a288">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:a5c1735ebb61cb9b40f6d0ed30be8a288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to <code>T's</code> public members.  <a href="#a5c1735ebb61cb9b40f6d0ed30be8a288">More...</a><br /></td></tr>
<tr class="separator:a5c1735ebb61cb9b40f6d0ed30be8a288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2477b013cf44492b54afd64d151de6aa"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a2477b013cf44492b54afd64d151de6aa">operator *</a> () const</td></tr>
<tr class="memdesc:a2477b013cf44492b54afd64d151de6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the stored pointer.  <a href="#a2477b013cf44492b54afd64d151de6aa">More...</a><br /></td></tr>
<tr class="separator:a2477b013cf44492b54afd64d151de6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c79bb09aeb8efbd9b01ee1fbde0061"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a10c79bb09aeb8efbd9b01ee1fbde0061">operator UnspecifiedBoolType</a> () const</td></tr>
<tr class="memdesc:a10c79bb09aeb8efbd9b01ee1fbde0061"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the pointer points to an object.  <a href="#a10c79bb09aeb8efbd9b01ee1fbde0061">More...</a><br /></td></tr>
<tr class="separator:a10c79bb09aeb8efbd9b01ee1fbde0061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a49470b17aeb71f23c5a2ca7bff5fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a45a49470b17aeb71f23c5a2ca7bff5fa">operator !</a> () const</td></tr>
<tr class="memdesc:a45a49470b17aeb71f23c5a2ca7bff5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the pointer points to <code>NULL</code>.  <a href="#a45a49470b17aeb71f23c5a2ca7bff5fa">More...</a><br /></td></tr>
<tr class="separator:a45a49470b17aeb71f23c5a2ca7bff5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720afd959893c637eb1aa2dfd879dcfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a720afd959893c637eb1aa2dfd879dcfd">swap</a> (<a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a> &amp;other)</td></tr>
<tr class="memdesc:a720afd959893c637eb1aa2dfd879dcfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this pointer with <em>other</em>.  <a href="#a720afd959893c637eb1aa2dfd879dcfd">More...</a><br /></td></tr>
<tr class="separator:a720afd959893c637eb1aa2dfd879dcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372de693ad40b3f42839c8ec6ac845f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a372de693ad40b3f42839c8ec6ac845f4">Reset</a> ()</td></tr>
<tr class="memdesc:a372de693ad40b3f42839c8ec6ac845f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this pointer to point to no object.  <a href="#a372de693ad40b3f42839c8ec6ac845f4">More...</a><br /></td></tr>
<tr class="separator:a372de693ad40b3f42839c8ec6ac845f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6dabafb6658409eebdd7195f7399443f"><td class="memItemLeft" align="right" valign="top"><a id="a6dabafb6658409eebdd7195f7399443f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TfWeakBase</b></td></tr>
<tr class="separator:a6dabafb6658409eebdd7195f7399443f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1f63452b7c862198d700ba3b8ad380"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a8a1f63452b7c862198d700ba3b8ad380">TfCreateRefPtr</a> (T *)</td></tr>
<tr class="memdesc:a8a1f63452b7c862198d700ba3b8ad380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a raw pointer to a reference-counted pointer.  <a href="#a8a1f63452b7c862198d700ba3b8ad380">More...</a><br /></td></tr>
<tr class="separator:a8a1f63452b7c862198d700ba3b8ad380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f0d82124c92cd519f85d940185053e"><td class="memTemplParams" colspan="2"><a id="a85f0d82124c92cd519f85d940185053e"></a>
template&lt;class HashState , class U &gt; </td></tr>
<tr class="memitem:a85f0d82124c92cd519f85d940185053e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TfHashAppend</b> (HashState &amp;, const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:a85f0d82124c92cd519f85d940185053e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0725681202e2f2dcb0838e36e6a293f6"><td class="memTemplParams" colspan="2"><a id="a0725681202e2f2dcb0838e36e6a293f6"></a>
template&lt;class U &gt; </td></tr>
<tr class="memitem:a0725681202e2f2dcb0838e36e6a293f6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hash_value</b> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:a0725681202e2f2dcb0838e36e6a293f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c21e26f246f8065aa1bd1dc5e0e262"><td class="memItemLeft" align="right" valign="top"><a id="ae4c21e26f246f8065aa1bd1dc5e0e262"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><b>get_pointer</b> (<a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a> const &amp;p)</td></tr>
<tr class="separator:ae4c21e26f246f8065aa1bd1dc5e0e262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33867ccc5d837124fb08eff87e027c80"><td class="memTemplParams" colspan="2">template&lt;class D &gt; </td></tr>
<tr class="memitem:a33867ccc5d837124fb08eff87e027c80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a33867ccc5d837124fb08eff87e027c80">TfDynamic_cast</a> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:a33867ccc5d837124fb08eff87e027c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows dynamic casting of a <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code>.  <a href="#a33867ccc5d837124fb08eff87e027c80">More...</a><br /></td></tr>
<tr class="separator:a33867ccc5d837124fb08eff87e027c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6d36e3754da224ba3f0093c0b64fa3"><td class="memTemplParams" colspan="2">template&lt;class D &gt; </td></tr>
<tr class="memitem:afe6d36e3754da224ba3f0093c0b64fa3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#afe6d36e3754da224ba3f0093c0b64fa3">TfStatic_cast</a> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:afe6d36e3754da224ba3f0093c0b64fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows static casting of a <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code>.  <a href="#afe6d36e3754da224ba3f0093c0b64fa3">More...</a><br /></td></tr>
<tr class="separator:afe6d36e3754da224ba3f0093c0b64fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae090e00181e4bc38bee64e5542c7e1d6"><td class="memTemplParams" colspan="2">template&lt;class D &gt; </td></tr>
<tr class="memitem:ae090e00181e4bc38bee64e5542c7e1d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#ae090e00181e4bc38bee64e5542c7e1d6">TfConst_cast</a> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; const D &gt; &amp;)</td></tr>
<tr class="memdesc:ae090e00181e4bc38bee64e5542c7e1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows const casting of a <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code>.  <a href="#ae090e00181e4bc38bee64e5542c7e1d6">More...</a><br /></td></tr>
<tr class="separator:ae090e00181e4bc38bee64e5542c7e1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928f24fab0d243b7270a2ce7f92f8921"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a928f24fab0d243b7270a2ce7f92f8921"><td class="memTemplItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tf_ref_ptr.html#a928f24fab0d243b7270a2ce7f92f8921">TfTypeid</a> (const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a928f24fab0d243b7270a2ce7f92f8921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>typeid</code> on the object pointed to by a <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code>.  <a href="#a928f24fab0d243b7270a2ce7f92f8921">More...</a><br /></td></tr>
<tr class="separator:a928f24fab0d243b7270a2ce7f92f8921"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class TfRefPtr&lt; T &gt;</h3>

<p>Reference-counted smart pointer utility class. </p>
<p>The <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code> class implements a reference counting on objects that inherit from <code><a class="el" href="class_tf_ref_base.html" title="Enable a concrete base class for use with TfRefPtr.">TfRefBase</a></code>.</p>
<p>For more information, see either the <a class="el" href="ref_ptr_8h.html#refPtr_QuickStart">Quick Start</a> example or read the <a class="el" href="ref_ptr_8h.html#refPtr_DetailedDiscussion">detailed discussion</a>. </p>

<p class="definition">Definition at line <a class="el" href="ref_base_8h_source.html#l00037">37</a> of file <a class="el" href="ref_base_8h_source.html">refBase.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afe400d3f662f42fab8f065a689ba9a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe400d3f662f42fab8f065a689ba9a4a">&#9670;&nbsp;</a></span>DataType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="class_tf_ref_ptr.html#afe400d3f662f42fab8f065a689ba9a4a">DataType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type accessor to underlying type <code>T</code> for template code. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00586">586</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad2fbc9f5fab0deca1d46de73896a484f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fbc9f5fab0deca1d46de73896a484f">&#9670;&nbsp;</a></span>TfRefPtr() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize pointer to nullptr. </p>
<p>The default constructor leaves the pointer initialized to point to the NULL object. Attempts to use the <code>-&gt;</code> operator will cause an abort until the pointer is given a value. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00598">598</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="a37b016d2605e95703bb7fd61c4c4c730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b016d2605e95703bb7fd61c4c4c730">&#9670;&nbsp;</a></span>TfRefPtr() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the pointer managed by <code>p</code> to <code>*this</code>. </p>
<p>After construction, <code>*this</code> will point to the object <code>p</code> had been pointing at and <code>p</code> will be pointing at the NULL object. The reference count of the object being pointed at does not change. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00608">608</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="aadb607015dc6fd449caf6a77ce316445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb607015dc6fd449caf6a77ce316445">&#9670;&nbsp;</a></span>TfRefPtr() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes <code>*this</code> to point at <code>p's</code> object. </p>
<p>Increments <code>p's</code> object's reference count. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00618">618</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="a4b14e349bbd7efe78f5e4d9394fd427f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b14e349bbd7efe78f5e4d9394fd427f">&#9670;&nbsp;</a></span>TfRefPtr() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const TfWeakPtrFacade&lt; X, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_convertible&lt; U *, T * &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes <code>*this</code> to point at <code>gp's</code> object. </p>
<p>Increments <code>gp's</code> object's reference count. </p>

<p class="definition">Definition at line <a class="el" href="weak_ptr_facade_8h_source.html#l00362">362</a> of file <a class="el" href="weak_ptr_facade_8h_source.html">weakPtrFacade.h</a>.</p>

</div>
</div>
<a id="a80f00837444702c7ea589a7a96ec80fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f00837444702c7ea589a7a96ec80fa">&#9670;&nbsp;</a></span>TfRefPtr() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a> </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_convertible&lt; U *, T * &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes to point at <code>*ptr</code>. </p>
<p>Increments <code>*ptr's</code> reference count. Note that newly constructed objects start with a reference count of one. Therefore, you should <em>NOT</em> use this constructor (either implicitly or explicitly) from within a <code>New()</code> function. Use <code><a class="el" href="class_tf_ref_ptr.html#a8a1f63452b7c862198d700ba3b8ad380" title="Transfer a raw pointer to a reference-counted pointer.">TfCreateRefPtr()</a></code> instead. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00678">678</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="aa437dcac2e6393797505de3be6cbf010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa437dcac2e6393797505de3be6cbf010">&#9670;&nbsp;</a></span>TfRefPtr() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a> </td>
          <td>(</td>
          <td class="paramtype">TfNullPtrType&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit conversion from <em>TfNullPtr</em> to <a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a>. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00688">688</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="af3c8389306a23e6e828f44529c888c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c8389306a23e6e828f44529c888c1b">&#9670;&nbsp;</a></span>TfRefPtr() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit conversion from <em>nullptr</em> to <a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a>. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00694">694</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="a4c127a68abb58485ca93cc93cbcbc315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c127a68abb58485ca93cc93cbcbc315">&#9670;&nbsp;</a></span>~TfRefPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements reference count of object being pointed to. </p>
<p>If the reference count of the object (if any) that was just pointed at reaches zero, the object will typically be destroyed at this point. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00764">764</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="ae2a72ffad18f4bd51d1b9c8359712a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a72ffad18f4bd51d1b9c8359712a61">&#9670;&nbsp;</a></span>TfRefPtr() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes to point at <code>p's</code> object, and increments reference count. </p>
<p>This initialization is legal only if </p><div class="fragment"><div class="line">U* uPtr;</div><div class="line">T* tPtr = uPtr;</div></div><!-- fragment --><p> is legal. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00780">780</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="ad59871465a56e3ba5751a0df193bfe78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59871465a56e3ba5751a0df193bfe78">&#9670;&nbsp;</a></span>TfRefPtr() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the pointer managed by <code>p</code> to <code>*this</code> and leaves <code>p</code> pointing at the NULL object. </p>
<p>The reference count of the object being pointed to is not changed.</p>
<p>This initialization is legal only if </p><div class="fragment"><div class="line">U* uPtr;</div><div class="line">T* tPtr = uPtr;</div></div><!-- fragment --><p> is legal. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00799">799</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a45a49470b17aeb71f23c5a2ca7bff5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a49470b17aeb71f23c5a2ca7bff5fa">&#9670;&nbsp;</a></span>operator !()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator ! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the pointer points to <code>NULL</code>. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00946">946</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="a2477b013cf44492b54afd64d151de6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2477b013cf44492b54afd64d151de6aa">&#9670;&nbsp;</a></span>operator *()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; operator * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereferences the stored pointer. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00932">932</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="a10c79bb09aeb8efbd9b01ee1fbde0061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c79bb09aeb8efbd9b01ee1fbde0061">&#9670;&nbsp;</a></span>operator UnspecifiedBoolType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operator UnspecifiedBoolType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the pointer points to an object. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00941">941</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="abf3873f48a2806208484a4d39ca00c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3873f48a2806208484a4d39ca00c40">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;T *&gt;() != std::declval&lt;U *&gt;(), bool()) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>*this</code> and <code>p</code> do not point to the same object. </p>
<p>The comparison is legal only if a <code>T*</code> and a <code>U*</code> are comparable. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00881">881</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="a5c1735ebb61cb9b40f6d0ed30be8a288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1735ebb61cb9b40f6d0ed30be8a288">&#9670;&nbsp;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor to <code>T's</code> public members. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00923">923</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="aeaf71084107e6a32783cfe6c6f1d4fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf71084107e6a32783cfe6c6f1d4fa3">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;T *&gt;() &lt; std::declval&lt;U *&gt;(), bool()) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the address of the object pointed to by <code>*this</code> compares less than the address of the object pointed to by <code>p</code>. </p>
<p>The comparison is legal only if a <code>T*</code> and a <code>U*</code> are comparable. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00893">893</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="a58ebd6e7db873f660498eae68f96528c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ebd6e7db873f660498eae68f96528c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt;T&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns pointer to point at <code>p's</code> object, and increments reference count. </p>
<p>The object (if any) pointed at before the assignment has its reference count decremented, while the object newly pointed at has its reference count incremented. If the object previously pointed to now has nobody left to point at it, the object will typically be destroyed at this point.</p>
<p>An assignment </p><div class="fragment"><div class="line">ptr = TfNullPtr;</div></div><!-- fragment --><p>can be used to make <code>ptr</code> "forget" where it is pointing; note however that this has an important side effect, since it decrements the reference count of the object previously pointed to by <code>ptr</code>, possibly triggering destruction of that object. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00717">717</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="a79110afc36318a217b8747ddacd95bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79110afc36318a217b8747ddacd95bbb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt;T&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the pointer managed by <code>p</code> to <code>*this</code> and leaves <code>p</code> pointing at the NULL object. </p>
<p>The object (if any) pointed at before the assignment has its reference count decremented, while the reference count of the object newly pointed at is not changed. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00745">745</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="ac572a39d34606471f22108798561bc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac572a39d34606471f22108798561bc46">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt;T&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns pointer to point at <code>p's</code> object, and increments reference count. </p>
<p>This assignment is legal only if </p><div class="fragment"><div class="line">U* uPtr;</div><div class="line">T* tPtr;</div><div class="line">tPtr = uPtr;</div></div><!-- fragment --><p> is legal. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00820">820</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="a670f7f34961d6412ffa3888e5567c0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670f7f34961d6412ffa3888e5567c0ee">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt;T&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the pointer managed by <code>p</code> to <code>*this</code> and leaves <code>p</code> pointing at the NULL object. </p>
<p>The reference count of the object being pointed to is not changed.</p>
<p>This assignment is legal only if </p><div class="fragment"><div class="line">U* uPtr;</div><div class="line">T* tPtr;</div><div class="line">tPtr = uPtr;</div></div><!-- fragment --><p> is legal. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00847">847</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="a0cf528f98b109e720fffdc2a273f7937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf528f98b109e720fffdc2a273f7937">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;T *&gt;() == std::declval&lt;U *&gt;(), bool()) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>*this</code> and <code>p</code> point to the same object (or if they both point to NULL). </p>
<p>The comparison is legal only if a <code>T*</code> and a <code>U*</code> are comparable. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00870">870</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="a372de693ad40b3f42839c8ec6ac845f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372de693ad40b3f42839c8ec6ac845f4">&#9670;&nbsp;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this pointer to point to no object. </p>
<p>Equivalent to assignment with TfNullPtr. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00964">964</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<a id="a720afd959893c637eb1aa2dfd879dcfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720afd959893c637eb1aa2dfd879dcfd">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap this pointer with <em>other</em>. </p>
<p>After this operation, this pointer will point to what <em>other</em> formerly pointed to, and <em>other</em> will point to what this pointer formerly pointed to. </p>

<p class="definition">Definition at line <a class="el" href="ref_ptr_8h_source.html#l00954">954</a> of file <a class="el" href="ref_ptr_8h_source.html">refPtr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ae090e00181e4bc38bee64e5542c7e1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae090e00181e4bc38bee64e5542c7e1d6">&#9670;&nbsp;</a></span>TfConst_cast</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt;D&gt; TfConst_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; const D &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows const casting of a <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code>. </p>
<p>The following is always legal: </p><div class="fragment"><div class="line"><a class="code" href="class_tf_ref_ptr.html">TfRefPtr&lt;const T&gt;</a> cPtr = ...;</div><div class="line"><a class="code" href="class_tf_ref_ptr.html">TfRefPtr&lt;T&gt;</a>       tPtr;</div><div class="line"></div><div class="line">tPtr = <a class="code" href="class_tf_ref_ptr.html#ae090e00181e4bc38bee64e5542c7e1d6">TfConst_cast</a>&lt; <a class="code" href="class_tf_ref_ptr.html">TfRefPtr&lt;T&gt;</a> &gt;(cPtr);</div></div><!-- fragment --><p> As with the C++ <code>const_cast</code> operator, use of this function is discouraged. </p>

</div>
</div>
<a id="a8a1f63452b7c862198d700ba3b8ad380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1f63452b7c862198d700ba3b8ad380">&#9670;&nbsp;</a></span>TfCreateRefPtr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a> TfCreateRefPtr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a raw pointer to a reference-counted pointer. </p>
<p>The <code><a class="el" href="class_tf_ref_ptr.html#a8a1f63452b7c862198d700ba3b8ad380" title="Transfer a raw pointer to a reference-counted pointer.">TfCreateRefPtr()</a></code> function should only be used from within a static <code>New()</code> function (or similarly, a <code>Clone()</code> function) of a reference-counted class. Reference-counted objects have their reference count initially set to one to account for the fact that a newly created object must always persist at least until its <code>New()</code> function returns. Therefore, the transfer of the pointer returned by <code>new</code> into a reference pointer must <em>not</em> increase the reference count. The transfer of the raw pointer returned by <code>new</code> into the object returned by <code>New()</code> is a "transfer of ownership" and does not represent an additional reference to the object.</p>
<p>In summary, this code is wrong, and will return an object that can never be destroyed:</p>
<div class="fragment"><div class="line">SimpleRefPtr Simple::New() {</div><div class="line">    <span class="keywordflow">return</span> SimpleRefPtr(<span class="keyword">new</span> Simple);      <span class="comment">// legal, but leaks memory: beware!!</span></div><div class="line">}</div></div><!-- fragment --><p>The correct form is</p>
<div class="fragment"><div class="line">SimpleRefPtr Simple::New() {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="class_tf_ref_ptr.html#a8a1f63452b7c862198d700ba3b8ad380">TfCreateRefPtr</a>(<span class="keyword">new</span> Simple);</div><div class="line">}</div></div><!-- fragment --><p>Note also that a function which is essentially like <code>New()</code>, for example <code>Clone()</code>, would also want to use <code><a class="el" href="class_tf_ref_ptr.html#a8a1f63452b7c862198d700ba3b8ad380" title="Transfer a raw pointer to a reference-counted pointer.">TfCreateRefPtr()</a></code>. </p>

</div>
</div>
<a id="a33867ccc5d837124fb08eff87e027c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33867ccc5d837124fb08eff87e027c80">&#9670;&nbsp;</a></span>TfDynamic_cast</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt;D&gt; TfDynamic_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows dynamic casting of a <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code>. </p>
<p>If it is legal to dynamically cast a <code>T*</code> to a <code>D*</code> , then the following is also legal: </p><div class="fragment"><div class="line"><a class="code" href="class_tf_ref_ptr.html">TfRefPtr&lt;T&gt;</a> tPtr = ... ;</div><div class="line"><a class="code" href="class_tf_ref_ptr.html">TfRefPtr&lt;D&gt;</a> dPtr;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (!(dPtr = <a class="code" href="class_tf_ref_ptr.html#a33867ccc5d837124fb08eff87e027c80">TfDynamic_cast</a>&lt; <a class="code" href="class_tf_ref_ptr.html">TfRefPtr&lt;D&gt;</a> &gt;(tPtr)))</div><div class="line">    ...;       <span class="comment">// cast failed</span></div></div><!-- fragment --><p> The runtime performance of this function is exactly the same as a <code>dynamic_cast</code> (i.e. one virtual function call). If the pointer being cast is NULL or does not point to an object of the requisite type, the result is a <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code> pointing to NULL. </p>

</div>
</div>
<a id="afe6d36e3754da224ba3f0093c0b64fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6d36e3754da224ba3f0093c0b64fa3">&#9670;&nbsp;</a></span>TfStatic_cast</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt;D&gt; TfStatic_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows static casting of a <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code>. </p>
<p>If it is legal to statically cast a <code>T*</code> to a <code>D*</code> , then the following is also legal: </p><div class="fragment"><div class="line"><a class="code" href="class_tf_ref_ptr.html">TfRefPtr&lt;T&gt;</a> tPtr = ... ;</div><div class="line"><a class="code" href="class_tf_ref_ptr.html">TfRefPtr&lt;D&gt;</a> dPtr;</div><div class="line"></div><div class="line">dPtr = <a class="code" href="class_tf_ref_ptr.html#afe6d36e3754da224ba3f0093c0b64fa3">TfStatic_cast</a>&lt; <a class="code" href="class_tf_ref_ptr.html">TfRefPtr&lt;D&gt;</a> &gt;(tPtr);</div></div><!-- fragment --><p> The runtime performance of this function is exactly the same as a regular <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code> initialization, since the cost of the underlying <code>static_cast</code> is zero. Of course, a <code>TfDynamic_cast</code> is preferred, assuming the underlying types are polymorphic (i.e. have virtual functions). </p>

</div>
</div>
<a id="a928f24fab0d243b7270a2ce7f92f8921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928f24fab0d243b7270a2ce7f92f8921">&#9670;&nbsp;</a></span>TfTypeid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; TfTypeid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call <code>typeid</code> on the object pointed to by a <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code>. </p>
<p>If <code>ptr</code> is a <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code>, <code>typeid(ptr)</code> will return type information about the <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code>. To access type information about the object pointed to by a <code><a class="el" href="class_tf_ref_ptr.html" title="Reference-counted smart pointer utility class.">TfRefPtr</a></code>, one can use <code>TfTypeid</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>pxr/base/tf/<a class="el" href="ref_base_8h_source.html">refBase.h</a></li>
<li>pxr/base/tf/<a class="el" href="ref_ptr_8h_source.html">refPtr.h</a></li>
<li>pxr/base/tf/<a class="el" href="weak_ptr_facade_8h_source.html">weakPtrFacade.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:05 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>