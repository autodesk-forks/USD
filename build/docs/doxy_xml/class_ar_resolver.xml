<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="class_ar_resolver" kind="class" language="C++" prot="public" abstract="yes">
    <compoundname>ArResolver</compoundname>
    <derivedcompoundref refid="class_ar_default_resolver" prot="public" virt="non-virtual">ArDefaultResolver</derivedcompoundref>
    <includes refid="ar_2resolver_8h" local="no">resolver.h</includes>
      <sectiondef kind="user-defined">
      <header>Identifiers</header>
      <description><para><anchor id="class_ar_resolver_1ArResolver_identifier"/></para>
<para>Identifiers are canonicalized asset paths that may be assigned to a logical asset to facilitate comparisons and lookups. They may be used to determine if different asset paths might refer to the same asset without performing resolution.</para>
<para>Since identifiers are just a form of asset path, they may be used with other functions on <ref refid="class_ar_resolver" kindref="compound">ArResolver</ref> that require an asset path, like Resolve.</para>
<para>If two asset paths produce the same identifier, those asset paths must refer to the same asset. However, in some cases comparing identifiers may not be sufficient to determine if assets are equal. For example, there could be two assets with the same identifier but whose contents were read from different resolved paths because different resolver contexts were bound when those assets were loaded. </para>
</description>
      <memberdef kind="function" id="class_ar_resolver_1a68e5ae6385d1733b79f734c59682ff61" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API std::string</type>
        <definition>AR_API std::string CreateIdentifier</definition>
        <argsstring>(const std::string &amp;assetPath, const ArResolvedPath &amp;anchorAssetPath=ArResolvedPath()) const</argsstring>
        <name>CreateIdentifier</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <param>
          <type>const <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> &amp;</type>
          <declname>anchorAssetPath</declname>
          <defval><ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref>()</defval>
        </param>
        <briefdescription>
<para>Returns an identifier for the asset specified by <computeroutput>assetPath</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>If <computeroutput>anchorAssetPath</computeroutput> is not empty, it is the resolved asset path that <computeroutput>assetPath</computeroutput> should be anchored to if it is a relative path. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="96" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1aabfb26c05d314299ddf596fc1defeb6c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API std::string</type>
        <definition>AR_API std::string CreateIdentifierForNewAsset</definition>
        <argsstring>(const std::string &amp;assetPath, const ArResolvedPath &amp;anchorAssetPath=ArResolvedPath()) const</argsstring>
        <name>CreateIdentifierForNewAsset</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <param>
          <type>const <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> &amp;</type>
          <declname>anchorAssetPath</declname>
          <defval><ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref>()</defval>
        </param>
        <briefdescription>
<para>Returns an identifier for a new asset specified by <computeroutput>assetPath</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>If <computeroutput>anchorAssetPath</computeroutput> is not empty, it is the resolved asset path that <computeroutput>assetPath</computeroutput> should be anchored to if it is a relative path. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="104" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Path Resolution Operations</header>
      <description><para><anchor id="class_ar_resolver_1ArResolver_resolution"/></para>
</description>
      <memberdef kind="function" id="class_ar_resolver_1a1b824f00c46b2a5001f492698fd8f5c1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref></type>
        <definition>AR_API ArResolvedPath Resolve</definition>
        <argsstring>(const std::string &amp;assetPath) const</argsstring>
        <name>Resolve</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <briefdescription>
<para>Returns the resolved path for the asset identified by the given <computeroutput>assetPath</computeroutput> if it exists. </para>
        </briefdescription>
        <detaileddescription>
<para>If the asset does not exist, returns an empty <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="121" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1ae9bdf8eab4d4ebf70a0d2df3727ff9b8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref></type>
        <definition>AR_API ArResolvedPath ResolveForNewAsset</definition>
        <argsstring>(const std::string &amp;assetPath) const</argsstring>
        <name>ResolveForNewAsset</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <briefdescription>
<para>Returns the resolved path for the given <computeroutput>assetPath</computeroutput> that may be used to create a new asset. </para>
        </briefdescription>
        <detaileddescription>
<para>If such a path cannot be computed for <computeroutput>assetPath</computeroutput>, returns an empty <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref>.</para>
<para>Note that an asset might or might not already exist at the returned resolved path. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="131" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Asset Resolver Context Operations</header>
      <description><para><anchor id="class_ar_resolver_1ArResolver_context"/></para>
</description>
      <memberdef kind="function" id="class_ar_resolver_1a85ae1972e7c5791b3155ec04c213d29d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API void</type>
        <definition>AR_API void BindContext</definition>
        <argsstring>(const ArResolverContext &amp;context, VtValue *bindingData)</argsstring>
        <name>BindContext</name>
        <param>
          <type>const <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> &amp;</type>
          <declname>context</declname>
        </param>
        <param>
          <type><ref refid="class_vt_value" kindref="compound">VtValue</ref> *</type>
          <declname>bindingData</declname>
        </param>
        <briefdescription>
<para>Binds the given context to this resolver. </para>
        </briefdescription>
        <detaileddescription>
<para>Clients should generally use <ref refid="class_ar_resolver_context_binder" kindref="compound">ArResolverContextBinder</ref> instead of calling this function directly.</para>
<para><simplesect kind="see"><para><ref refid="class_ar_resolver_context_binder" kindref="compound">ArResolverContextBinder</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="150" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a8aaa1f17eef5b4d8facae03cc70c54de" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API void</type>
        <definition>AR_API void UnbindContext</definition>
        <argsstring>(const ArResolverContext &amp;context, VtValue *bindingData)</argsstring>
        <name>UnbindContext</name>
        <param>
          <type>const <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> &amp;</type>
          <declname>context</declname>
        </param>
        <param>
          <type><ref refid="class_vt_value" kindref="compound">VtValue</ref> *</type>
          <declname>bindingData</declname>
        </param>
        <briefdescription>
<para>Unbind the given context from this resolver. </para>
        </briefdescription>
        <detaileddescription>
<para>Clients should generally use <ref refid="class_ar_resolver_context_binder" kindref="compound">ArResolverContextBinder</ref> instead of calling this function directly.</para>
<para><simplesect kind="see"><para><ref refid="class_ar_resolver_context_binder" kindref="compound">ArResolverContextBinder</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="161" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a1524962aa020859a589e786b1ad3c28f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref></type>
        <definition>AR_API ArResolverContext CreateDefaultContext</definition>
        <argsstring>() const</argsstring>
        <name>CreateDefaultContext</name>
        <briefdescription>
<para>Return an <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> that may be bound to this resolver to resolve assets when no other context is explicitly specified. </para>
        </briefdescription>
        <detaileddescription>
<para>The returned <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> will contain the default context returned by the primary resolver and all URI/IRI resolvers. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="171" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a0a174a99676ff983a183d391973c7ebe" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref></type>
        <definition>AR_API ArResolverContext CreateDefaultContextForAsset</definition>
        <argsstring>(const std::string &amp;assetPath) const</argsstring>
        <name>CreateDefaultContextForAsset</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <briefdescription>
<para>Return an <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> that may be bound to this resolver to resolve the asset located at <computeroutput>assetPath</computeroutput> or referenced by that asset when no other context is explicitly specified. </para>
        </briefdescription>
        <detaileddescription>
<para>The returned <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> will contain the default context for <computeroutput>assetPath</computeroutput> returned by the primary resolver and all URI/IRI resolvers. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="181" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a5b165aaf701119f4b3bc26cdebd38b93" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref></type>
        <definition>AR_API ArResolverContext CreateContextFromString</definition>
        <argsstring>(const std::string &amp;contextStr) const</argsstring>
        <name>CreateContextFromString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>contextStr</declname>
        </param>
        <briefdescription>
<para>Return an <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> created from the primary <ref refid="class_ar_resolver" kindref="compound">ArResolver</ref> implementation using the given <computeroutput>contextStr</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="187" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a6f01bf8462bf0ec118187e200df7e362" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref></type>
        <definition>AR_API ArResolverContext CreateContextFromString</definition>
        <argsstring>(const std::string &amp;uriScheme, const std::string &amp;contextStr) const</argsstring>
        <name>CreateContextFromString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>uriScheme</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>contextStr</declname>
        </param>
        <briefdescription>
<para>Return an <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> created from the <ref refid="class_ar_resolver" kindref="compound">ArResolver</ref> registered for the given <computeroutput>uriScheme</computeroutput> using the given <computeroutput>contextStr</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>An empty <computeroutput>uriScheme</computeroutput> indicates the primary resolver and is equivalent to CreateContextFromString(string).</para>
<para>If no resolver is registered for <computeroutput>uriScheme</computeroutput>, returns an empty <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref>.</para>
<para><simplesect kind="note"><para>&apos;uriScheme&apos; can be used to register IRI resolvers </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="201" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a37d32052831939332ecbff965ef94caf" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref></type>
        <definition>AR_API ArResolverContext CreateContextFromStrings</definition>
        <argsstring>(const std::vector&lt; std::pair&lt; std::string, std::string &gt;&gt; &amp;contextStrs) const</argsstring>
        <name>CreateContextFromStrings</name>
        <param>
          <type>const std::vector&lt; std::pair&lt; std::string, std::string &gt;&gt; &amp;</type>
          <declname>contextStrs</declname>
        </param>
        <briefdescription>
<para>Return an <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> created by combining the <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> objects created from the given <computeroutput>contextStrs</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>contextStrs</computeroutput> is a list of pairs of strings. The first element in the pair is the URI/IRI scheme for the <ref refid="class_ar_resolver" kindref="compound">ArResolver</ref> that will be used to create the <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> from the second element in the pair. An empty resource identifier scheme indicates the primary resolver.</para>
<para>For example:</para>
<para><programlisting><codeline><highlight class="normal">ArResolverContext<sp/>ctx<sp/>=<sp/>ArGetResolver().CreateContextFromStrings(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>{<sp/>{&quot;&quot;,<sp/>&quot;context<sp/>str<sp/>1&quot;},<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>{&quot;my-scheme&quot;,<sp/>&quot;context<sp/>str<sp/>2&quot;}<sp/>});</highlight></codeline>
</programlisting></para>
<para>This will use the primary resolver to create an <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> using the string &quot;context str 1&quot; and use the resolver registered for the &quot;my-scheme&quot; URI/IRI scheme to create an <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> using &quot;context str 2&quot;. These contexts will be combined into a single <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> and returned.</para>
<para>If no resolver is registered for a URI/IRI scheme in an entry in <computeroutput>contextStrs</computeroutput>, that entry will be ignored. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="229" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a6d9a29a4e375bbdafde5e6e3f836291a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API void</type>
        <definition>AR_API void RefreshContext</definition>
        <argsstring>(const ArResolverContext &amp;context)</argsstring>
        <name>RefreshContext</name>
        <param>
          <type>const <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> &amp;</type>
          <declname>context</declname>
        </param>
        <briefdescription>
<para>Refresh any caches associated with the given context. </para>
        </briefdescription>
        <detaileddescription>
<para>If doing so would invalidate asset paths that had previously been resolved, an <ref refid="class_ar_notice_1_1_resolver_changed" kindref="compound">ArNotice::ResolverChanged</ref> notice will be sent to inform clients of this.</para>
<para>Avoid calling <ref refid="class_ar_resolver_1a6d9a29a4e375bbdafde5e6e3f836291a" kindref="member">RefreshContext()</ref> on the same context from more than one thread concurrently as <ref refid="class_ar_notice_1_1_resolver_changed" kindref="compound">ArNotice::ResolverChanged</ref> notice listeners may mutate their state in response to receiving the notice.</para>
<para>Avoid calling <ref refid="class_ar_resolver_1a6d9a29a4e375bbdafde5e6e3f836291a" kindref="member">RefreshContext()</ref> with a context that is active (bound to a resolver). Unbind the context before refreshing it.</para>
<para><simplesect kind="see"><para><ref refid="_usd__page__multi_threading" kindref="compound">Threading Model and Performance Considerations</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="247" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a9e318a8e5693b4103d88443780c1fb5a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref></type>
        <definition>AR_API ArResolverContext GetCurrentContext</definition>
        <argsstring>() const</argsstring>
        <name>GetCurrentContext</name>
        <briefdescription>
<para>Returns the asset resolver context currently bound in this thread. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ref refid="class_ar_resolver_1a85ae1972e7c5791b3155ec04c213d29d" kindref="member">ArResolver::BindContext</ref>, <ref refid="class_ar_resolver_1a8aaa1f17eef5b4d8facae03cc70c54de" kindref="member">ArResolver::UnbindContext</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="254" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1ad616f0a0fc1e5dce08929604f3b95f8f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API bool</type>
        <definition>AR_API bool IsContextDependentPath</definition>
        <argsstring>(const std::string &amp;assetPath) const</argsstring>
        <name>IsContextDependentPath</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <briefdescription>
<para>Returns true if <computeroutput>assetPath</computeroutput> is a context-dependent path, false otherwise. </para>
        </briefdescription>
        <detaileddescription>
<para>A context-dependent path may result in different resolved paths depending on what asset resolver context is bound when Resolve is called. Assets located at the same context-dependent path may not be the same since those assets may have been loaded from different resolved paths. In this case, the assets&apos; resolved paths must be consulted to determine if they are the same. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="266" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>File/asset-specific Operations</header>
      <description><para><anchor id="class_ar_resolver_1ArResolver_files"/></para>
</description>
      <memberdef kind="enum" id="class_ar_resolver_1a61d23b393fdc35f2f0e30a1ed566c76d" prot="public" static="no" strong="yes">
        <type></type>
        <name>WriteMode</name>
        <enumvalue id="class_ar_resolver_1a61d23b393fdc35f2f0e30a1ed566c76da06933067aafd48425d67bcb01bba5cb6" prot="public">
          <name>Update</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>Open asset for in-place updates. </para>
          </briefdescription>
          <detaileddescription>
<para>If the asset exists, its contents will not be discarded and writes may overwrite existing data. Otherwise, the asset will be created. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="class_ar_resolver_1a61d23b393fdc35f2f0e30a1ed566c76da0ebe6df8a3ac338e0512acc741823fdb" prot="public">
          <name>Replace</name>
          <briefdescription>
<para>Open asset for replacement. </para>
          </briefdescription>
          <detaileddescription>
<para>If the asset exists, its contents will be discarded by the time the <ref refid="class_ar_writable_asset" kindref="compound">ArWritableAsset</ref> is destroyed. Otherwise, the asset will be created. </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumeration of write modes for OpenAssetForWrite. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="312" column="1" bodyfile="pxr/usd/ar/resolver.h" bodystart="311" bodyend="322"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1ab8e1e7ab9dc4e2a390019b3b6384a504" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API std::string</type>
        <definition>AR_API std::string GetExtension</definition>
        <argsstring>(const std::string &amp;assetPath) const</argsstring>
        <name>GetExtension</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <briefdescription>
<para>Returns the file extension for the given <computeroutput>assetPath</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The returned extension does not include a &quot;.&quot; at the beginning. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="281" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a6078df1f5f1d1f4cf4d5b1411b7b88c8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API <ref refid="class_ar_asset_info" kindref="compound">ArAssetInfo</ref></type>
        <definition>AR_API ArAssetInfo GetAssetInfo</definition>
        <argsstring>(const std::string &amp;assetPath, const ArResolvedPath &amp;resolvedPath) const</argsstring>
        <name>GetAssetInfo</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <param>
          <type>const <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> &amp;</type>
          <declname>resolvedPath</declname>
        </param>
        <briefdescription>
<para>Returns an <ref refid="class_ar_asset_info" kindref="compound">ArAssetInfo</ref> populated with additional metadata (if any) about the asset at the given <computeroutput>assetPath</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>resolvedPath</computeroutput> is the resolved path computed for the given <computeroutput>assetPath</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="288" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1af0820bb01d47be4f215a661f061e2200" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API <ref refid="class_ar_timestamp" kindref="compound">ArTimestamp</ref></type>
        <definition>AR_API ArTimestamp GetModificationTimestamp</definition>
        <argsstring>(const std::string &amp;assetPath, const ArResolvedPath &amp;resolvedPath) const</argsstring>
        <name>GetModificationTimestamp</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <param>
          <type>const <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> &amp;</type>
          <declname>resolvedPath</declname>
        </param>
        <briefdescription>
<para>Returns an <ref refid="class_ar_timestamp" kindref="compound">ArTimestamp</ref> representing the last time the asset at <computeroutput>assetPath</computeroutput> was modified. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>resolvedPath</computeroutput> is the resolved path computed for the given <computeroutput>assetPath</computeroutput>. If a timestamp cannot be retrieved, return an invalid <ref refid="class_ar_timestamp" kindref="compound">ArTimestamp</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="297" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1aa3a964db701e93c26fc8365ac98fb758" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API std::shared_ptr&lt; <ref refid="class_ar_asset" kindref="compound">ArAsset</ref> &gt;</type>
        <definition>AR_API std::shared_ptr&lt;ArAsset&gt; OpenAsset</definition>
        <argsstring>(const ArResolvedPath &amp;resolvedPath) const</argsstring>
        <name>OpenAsset</name>
        <param>
          <type>const <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> &amp;</type>
          <declname>resolvedPath</declname>
        </param>
        <briefdescription>
<para>Returns an <ref refid="class_ar_asset" kindref="compound">ArAsset</ref> object for the asset located at <computeroutput>resolvedPath</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns an invalid std::shared_ptr if object could not be created.</para>
<para>The returned <ref refid="class_ar_asset" kindref="compound">ArAsset</ref> object provides functions for accessing the contents of the specified asset. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="307" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a91c07b55b6807adb47805ff0037b6c44" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API std::shared_ptr&lt; <ref refid="class_ar_writable_asset" kindref="compound">ArWritableAsset</ref> &gt;</type>
        <definition>AR_API std::shared_ptr&lt;ArWritableAsset&gt; OpenAssetForWrite</definition>
        <argsstring>(const ArResolvedPath &amp;resolvedPath, WriteMode writeMode) const</argsstring>
        <name>OpenAssetForWrite</name>
        <param>
          <type>const <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> &amp;</type>
          <declname>resolvedPath</declname>
        </param>
        <param>
          <type><ref refid="class_ar_resolver_1a61d23b393fdc35f2f0e30a1ed566c76d" kindref="member">WriteMode</ref></type>
          <declname>writeMode</declname>
        </param>
        <briefdescription>
<para>Returns an <ref refid="class_ar_writable_asset" kindref="compound">ArWritableAsset</ref> object for the asset located at <computeroutput>resolvedPath</computeroutput> using the specified <computeroutput>writeMode</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns an invalid std::shared_ptr if object could not be created.</para>
<para>The returned <ref refid="class_ar_writable_asset" kindref="compound">ArWritableAsset</ref> object provides functions for writing data to the specified asset.</para>
<para>Note that support for reading an asset through other APIs while it is open for write is implementation-specific. For example, writes to an asset may or may not be immediately visible to other threads or processes depending on the implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="336" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a843b3ef2aacbedf6fe6f9deeb01696d7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API bool</type>
        <definition>AR_API bool CanWriteAssetToPath</definition>
        <argsstring>(const ArResolvedPath &amp;resolvedPath, std::string *whyNot=nullptr) const</argsstring>
        <name>CanWriteAssetToPath</name>
        <param>
          <type>const <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> &amp;</type>
          <declname>resolvedPath</declname>
        </param>
        <param>
          <type>std::string *</type>
          <declname>whyNot</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
<para>Returns true if an asset may be written to the given <computeroutput>resolvedPath</computeroutput>, false otherwise. </para>
        </briefdescription>
        <detaileddescription>
<para>If this function returns false and <computeroutput>whyNot</computeroutput> is not <computeroutput>nullptr</computeroutput>, it may be filled with an explanation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="344" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Scoped Resolution Cache</header>
      <description><para><anchor id="class_ar_resolver_1ArResolver_scopedCache"/></para>
<para>A scoped resolution cache indicates to the resolver that results of calls to Resolve should be cached for a certain scope. This is important for performance and also for consistency <ndash/> it ensures that repeated calls to Resolve with the same parameters will return the same result.</para>
<para>A resolution cache scope is opened by a call to BeginCacheScope and must be closed with a matching call to EndCacheScope. The resolver must cache the results of Resolve until the scope is closed. Note that these calls may be nested.</para>
<para>Cache scopes are thread-specific: if multiple threads are running and a cache scope is opened in one of those threads, caching should be enabled in that thread only.</para>
<para>When opening a scope, a resolver may return additional data for implementation-specific purposes. This data may be shared across threads, so long as it is safe to access this data concurrently.</para>
<para><ref refid="class_ar_resolver_scoped_cache" kindref="compound">ArResolverScopedCache</ref> is an RAII object for managing cache scope lifetimes and data. Clients should generally use that class rather than calling the BeginCacheScope and EndCacheScope functions manually.</para>
<para><simplesect kind="see"><para><ref refid="class_ar_resolver_scoped_cache" kindref="compound">ArResolverScopedCache</ref> </para>
</simplesect>
</para>
</description>
      <memberdef kind="function" id="class_ar_resolver_1a522ae6b8a14dc87c9116109e619f062b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API void</type>
        <definition>AR_API void BeginCacheScope</definition>
        <argsstring>(VtValue *cacheScopeData)</argsstring>
        <name>BeginCacheScope</name>
        <param>
          <type><ref refid="class_vt_value" kindref="compound">VtValue</ref> *</type>
          <declname>cacheScopeData</declname>
        </param>
        <briefdescription>
<para>Mark the start of a resolution caching scope. </para>
        </briefdescription>
        <detaileddescription>
<para>Clients should generally use <ref refid="class_ar_resolver_scoped_cache" kindref="compound">ArResolverScopedCache</ref> instead of calling this function directly.</para>
<para>Resolvers may fill <computeroutput>cacheScopeData</computeroutput> with arbitrary data. Clients may also pass in a <computeroutput>cacheScopeData</computeroutput> populated by an earlier call to BeginCacheScope to allow the resolver access to that information.</para>
<para><simplesect kind="see"><para><ref refid="class_ar_resolver_scoped_cache" kindref="compound">ArResolverScopedCache</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="392" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a266aaced9fc6decb4ae2ad884bd46517" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API void</type>
        <definition>AR_API void EndCacheScope</definition>
        <argsstring>(VtValue *cacheScopeData)</argsstring>
        <name>EndCacheScope</name>
        <param>
          <type><ref refid="class_vt_value" kindref="compound">VtValue</ref> *</type>
          <declname>cacheScopeData</declname>
        </param>
        <briefdescription>
<para>Mark the end of a resolution caching scope. </para>
        </briefdescription>
        <detaileddescription>
<para>Clients should generally use <ref refid="class_ar_resolver_scoped_cache" kindref="compound">ArResolverScopedCache</ref> instead of calling this function directly.</para>
<para><computeroutput>cacheScopeData</computeroutput> should contain the data that was populated by the previous corresponding call to BeginCacheScope.</para>
<para><simplesect kind="see"><para><ref refid="class_ar_resolver_scoped_cache" kindref="compound">ArResolverScopedCache</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="405" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Deprecated APIs</header>
      <description><para><anchor id="class_ar_resolver_1ArResolver_deprecated"/></para>
<para>The functions in this section are deprecated in Ar 2.0 and slated for removal. Most have default implementations to allow subclasses to ignore them completely. </para>
</description>
      <memberdef kind="function" id="class_ar_resolver_1a966c6fe671e427a7d8a01f9d068879a7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API bool</type>
        <definition>AR_API bool IsRepositoryPath</definition>
        <argsstring>(const std::string &amp;path) const</argsstring>
        <name>IsRepositoryPath</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>path</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000059"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Returns true if the given path is a repository path.</para>
</xrefdescription></xrefsect></para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="424" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Implementation</header>
      <description><para><anchor id="class_ar_resolver_1ArResolver_implementation"/></para>
</description>
      <memberdef kind="variable" id="class_ar_resolver_1a50c0a0a7bc7b939f4a44fd4baf26a7b5" prot="protected" static="no" mutable="no">
        <type>abs path to model</type>
        <definition>abs path to model usd</definition>
        <argsstring></argsstring>
        <name>usd</name>
        <briefdescription>
<para>Return an identifier for the asset at the given <computeroutput>assetPath</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>See <ref refid="class_ar_resolver_1ArResolver_identifier" kindref="member">Identifiers</ref> for more information.</para>
<para>If <computeroutput>anchorAssetPath</computeroutput> is non-empty, it should be used as the anchoring asset if <computeroutput>assetPath</computeroutput> is relative. For example, for a filesystem-based implementation _CreateIdentifier might return:</para>
<para>_CreateIdentifier( /* assetPath = </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="446" column="1" bodyfile="pxr/usd/ar/resolver.h" bodystart="446" bodyend="-1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a806b3bf4dc93af8cdde3e3e2a3d5e1e7" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>abs path to model *</type>
        <definition>abs path to model * ArResolvedPath</definition>
        <argsstring>(&quot;/abs/path/to/shot.usd&quot;)) *</argsstring>
        <name>ArResolvedPath</name>
        <param>
          <type>&quot;/abs/path/to/shot.usd&quot;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="447" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a8eac0ab4acfa5276713bee14b8e11308" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>std::string</type>
        <definition>virtual std::string _CreateIdentifierForNewAsset</definition>
        <argsstring>(const std::string &amp;assetPath, const ArResolvedPath &amp;anchorAssetPath) const =0</argsstring>
        <name>_CreateIdentifierForNewAsset</name>
        <reimplementedby refid="class_ar_default_resolver_1a155d071d5f25a65b0a51eb8a8c9f40ac">_CreateIdentifierForNewAsset</reimplementedby>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <param>
          <type>const <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> &amp;</type>
          <declname>anchorAssetPath</declname>
        </param>
        <briefdescription>
<para>Return an identifier for a new asset at the given <computeroutput>assetPath</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>This is similar to _CreateIdentifier but is used to create identifiers for assets that may not exist yet and are being created.</para>
<para>Example uses:<itemizedlist>
<listitem><para>When creating a new layer via <ref refid="class_sdf_layer_1aad57cd44403a4f95a2bb6c730fa1b0f5" kindref="member">SdfLayer::CreateNew</ref>, CreateIdentifierForNewAsset will be called with the asset path given to the function. The result will be used as the new layer&apos;s identifier. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="488" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a3b0b5d475de0d5fb0d17756b07696014" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type><ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref></type>
        <definition>virtual ArResolvedPath _Resolve</definition>
        <argsstring>(const std::string &amp;assetPath) const =0</argsstring>
        <name>_Resolve</name>
        <reimplementedby refid="class_ar_default_resolver_1a378ebf9b021b95783ddb7a2bcf236f29">_Resolve</reimplementedby>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <briefdescription>
<para>Return the resolved path for the given <computeroutput>assetPath</computeroutput> or an empty <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> if no asset exists at that path. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="494" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a66bbf8128c2c2253eff9b34ba9d5baae" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type><ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref></type>
        <definition>virtual ArResolvedPath _ResolveForNewAsset</definition>
        <argsstring>(const std::string &amp;assetPath) const =0</argsstring>
        <name>_ResolveForNewAsset</name>
        <reimplementedby refid="class_ar_default_resolver_1ad085f592a3d0a31d2a388906f9f6e735">_ResolveForNewAsset</reimplementedby>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <briefdescription>
<para>Return the resolved path for the given <computeroutput>assetPath</computeroutput> that may be used to create a new asset or an empty <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> if such a path cannot be computed. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="500" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Context Operations Implementation</header>
      <description><para><anchor id="class_ar_resolver_1ArResolver_contextImplementation"/></para>
<para>If any of these functions are implemented in a subclass, the plugin metadata for that subclass in the plugin library&apos;s plugInfo.json must specify: <programlisting><codeline><highlight class="normal">&quot;implementsContexts&quot;<sp/>:<sp/>true.</highlight></codeline>
</programlisting></para>
<para>If a subclass indicates that it implements any of these functions, its plugin library will be loaded and these functions will be called when the corresponding public <ref refid="class_ar_resolver" kindref="compound">ArResolver</ref> API is called. Otherwise, these functions will not be called. </para>
</description>
      <memberdef kind="function" id="class_ar_resolver_1aea5ca0e868d149785b777baf8cfcde5e" prot="protected" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>AR_API void</type>
        <definition>virtual AR_API void _BindContext</definition>
        <argsstring>(const ArResolverContext &amp;context, VtValue *bindingData)</argsstring>
        <name>_BindContext</name>
        <param>
          <type>const <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> &amp;</type>
          <declname>context</declname>
        </param>
        <param>
          <type><ref refid="class_vt_value" kindref="compound">VtValue</ref> *</type>
          <declname>bindingData</declname>
        </param>
        <briefdescription>
<para>Bind the given <computeroutput>context</computeroutput> to this resolver. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>bindingData</computeroutput> may be populated with additional information that will be kept alive while <computeroutput>context</computeroutput> is bound. Both <computeroutput>context</computeroutput> and <computeroutput>bindingData</computeroutput> will be passed to UnbindContext when the context is being unbound.</para>
<para>Contexts may be nested; if multiple contexts are bound, the context that was most recently bound must take precedence and block all previously bound contexts.</para>
<para>Context binding is thread-specific; contexts bound in a thread must only affect other resolver calls in the same thread.</para>
<para><ref refid="class_ar_resolver" kindref="compound">ArResolver</ref> itself manages thread-local stacks of bound contexts. Subclasses can retrieve the most recent context object which was passed to BindContext using _GetCurrentContextObject. Because of this, subclasses typically do not need to implement this function unless they need to be informed when a context object is bound. For example, this may be needed if the context needs to be passed on to another subsystem that manages these bindings itself.</para>
<para>The default implementation does nothing. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="545" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a060c4070673ae89cb680d2f544de5557" prot="protected" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>AR_API void</type>
        <definition>virtual AR_API void _UnbindContext</definition>
        <argsstring>(const ArResolverContext &amp;context, VtValue *bindingData)</argsstring>
        <name>_UnbindContext</name>
        <param>
          <type>const <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> &amp;</type>
          <declname>context</declname>
        </param>
        <param>
          <type><ref refid="class_vt_value" kindref="compound">VtValue</ref> *</type>
          <declname>bindingData</declname>
        </param>
        <briefdescription>
<para>Unbind the given <computeroutput>context</computeroutput> from this resolver. </para>
        </briefdescription>
        <detaileddescription>
<para>It is an error if the context being unbound is not the currently bound context.</para>
<para>Subclasses typically do not need to implement this function since <ref refid="class_ar_resolver" kindref="compound">ArResolver</ref> itself keeps track of the contexts that are bound via calls to BindContext. However, subclasses may need to implement this function if they are managing these bindings itself.</para>
<para>The default implementation does nothing. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="561" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a8ea0d703db16ed156b942bb7e1b130ea" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>AR_API <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref></type>
        <definition>virtual AR_API ArResolverContext _CreateDefaultContext</definition>
        <argsstring>() const</argsstring>
        <name>_CreateDefaultContext</name>
        <reimplementedby refid="class_ar_default_resolver_1acbd76d7592de831df1d894066dd7295f">_CreateDefaultContext</reimplementedby>
        <briefdescription>
<para>Return a default <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> that may be bound to this resolver to resolve assets when no other context is explicitly specified. </para>
        </briefdescription>
        <detaileddescription>
<para>When CreateDefaultContext is called on the configured asset resolver, Ar will call this method on the primary resolver and all URI/IRI resolvers and merge the results into a single <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> that will be returned to the consumer.</para>
<para>This function should not automatically bind this context, but should create one that may be used later.</para>
<para>The default implementation returns a default-constructed <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref>.</para>
<para>Example uses:<itemizedlist>
<listitem><para><ref refid="class_usd_stage" kindref="compound">UsdStage</ref> will call CreateDefaultContext when creating a new stage with an anonymous root layer and without a given context. The returned context will be bound when resolving asset paths on that stage. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="584" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a5b0e0ea52ac80bb4a4b6d1f881331df1" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>AR_API <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref></type>
        <definition>virtual AR_API ArResolverContext _CreateDefaultContextForAsset</definition>
        <argsstring>(const std::string &amp;assetPath) const</argsstring>
        <name>_CreateDefaultContextForAsset</name>
        <reimplementedby refid="class_ar_default_resolver_1aa21e74d0ce1ccc62fde8b26f90db16e1">_CreateDefaultContextForAsset</reimplementedby>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <briefdescription>
<para>Return an <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> that may be bound to this resolver to resolve the asset located at <computeroutput>assetPath</computeroutput> or referenced by that asset when no other context is explicitly specified. </para>
        </briefdescription>
        <detaileddescription>
<para>When CreateDefaultContextForAsset is called on the configured asset resolver, Ar will call this method on the primary resolver and all URI/IRI resolvers and merge the results into a single <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> that will be returned to the consumer.</para>
<para>Note that this means this method may be called with asset paths that are not associated with this resolver. For example, this method may be called on a URI/IRI resolver with a non-URI/IRI asset path. This is to support cases where the asset at <computeroutput>assetPath</computeroutput> references other assets with URI/IRI schemes that differ from the URI/IRI scheme (if any) in <computeroutput>assetPath</computeroutput>.</para>
<para>This function should not automatically bind this context, but should create one that may be used later.</para>
<para>The default implementation returns a default-constructed <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref>.</para>
<para>Example uses:<itemizedlist>
<listitem><para><ref refid="class_usd_stage" kindref="compound">UsdStage</ref> will call CreateDefaultContextForAsset when creating a new stage with a non-anonymous root layer and without a given context. The resolved path of the root layer will be passed in as the <computeroutput>assetPath</computeroutput>. The returned context will be bound when resolving asset paths on that stage. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="615" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1ab67c369f100fd0488e74c3293c688156" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>AR_API <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref></type>
        <definition>virtual AR_API ArResolverContext _CreateContextFromString</definition>
        <argsstring>(const std::string &amp;contextStr) const</argsstring>
        <name>_CreateContextFromString</name>
        <reimplementedby refid="class_ar_default_resolver_1a88bd7f9112c7f5dfaced947b22336340">_CreateContextFromString</reimplementedby>
        <param>
          <type>const std::string &amp;</type>
          <declname>contextStr</declname>
        </param>
        <briefdescription>
<para>Return an <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> created from the given <computeroutput>contextStr</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The default implementation returns a default-constructed <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="623" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1af454d5a00d4dd1c2b1022d8b38d36bef" prot="protected" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>AR_API void</type>
        <definition>virtual AR_API void _RefreshContext</definition>
        <argsstring>(const ArResolverContext &amp;context)</argsstring>
        <name>_RefreshContext</name>
        <param>
          <type>const <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> &amp;</type>
          <declname>context</declname>
        </param>
        <briefdescription>
<para>Refresh any caches associated with the given context. </para>
        </briefdescription>
        <detaileddescription>
<para>If doing so would invalidate asset paths that had previously been resolved, this function should send an <ref refid="class_ar_notice_1_1_resolver_changed" kindref="compound">ArNotice::ResolverChanged</ref> notice to inform clients of this. See documentation on that class for more details.</para>
<para>The default implementation does nothing. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="634" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a111e120876d4dd8f717c7bdccffd86d5" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>AR_API <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref></type>
        <definition>virtual AR_API ArResolverContext _GetCurrentContext</definition>
        <argsstring>() const</argsstring>
        <name>_GetCurrentContext</name>
        <briefdescription>
<para>Return the currently bound context. </para>
        </briefdescription>
        <detaileddescription>
<para>Since context binding is thread-specific, this should return the context that was most recently bound in this thread.</para>
<para>Subclasses typically do not need to implement this function since <ref refid="class_ar_resolver" kindref="compound">ArResolver</ref> itself keeps track of the contexts that are bound via calls to BindContext. However, if a subclass is managing bound contexts itself and allows clients to bind context objects via other API outside of BindContext, this function should return the context object as described above. This typically happens with subclasses that are wrappers around other resolution subsystems. <simplesect kind="see"><para><ref refid="class_ar_resolver_1aea5ca0e868d149785b777baf8cfcde5e" kindref="member">_BindContext</ref> for more information.</para>
</simplesect>
The default implementation returns a default-constructed <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="652" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a618cc648520d613dbebadc1eaa57d688" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>AR_API bool</type>
        <definition>virtual AR_API bool _IsContextDependentPath</definition>
        <argsstring>(const std::string &amp;assetPath) const</argsstring>
        <name>_IsContextDependentPath</name>
        <reimplementedby refid="class_ar_default_resolver_1a0b256bacb573a7f7150157c31112d135">_IsContextDependentPath</reimplementedby>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <briefdescription>
<para>Return true if the result of resolving the given <computeroutput>assetPath</computeroutput> may differ depending on the asset resolver context that is bound when Resolve is called, false otherwise. </para>
        </briefdescription>
        <detaileddescription>
<para>The default implementation returns false.</para>
<para>Example uses:<itemizedlist>
<listitem><para><ref refid="class_sdf_layer" kindref="compound">SdfLayer</ref> will call this function to check if the identifier given to <ref refid="class_sdf_layer_1acc4e19f5c2bf0bab57804acee65ebb78" kindref="member">SdfLayer::Find</ref> or <ref refid="class_sdf_layer_1aa01062bf4dde3f28c1fc617a1acaf35e" kindref="member">SdfLayer::FindOrOpen</ref> is context-dependent. If it is and a layer exists with the same identifier, <ref refid="class_sdf_layer" kindref="compound">SdfLayer</ref> can return it without resolving the identifier. If it is not, <ref refid="class_sdf_layer" kindref="compound">SdfLayer</ref> must resolve the identifier and search for a layer with the same resolved path, even if a layer exists with the same identifier. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="669" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Asset Operations Implementation</header>
      <description><para><anchor id="class_ar_resolver_1ArResolver_assetImplementation"/></para>
</description>
      <memberdef kind="function" id="class_ar_resolver_1a754a31a6d1ab02063db5c9b9f312c737" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>AR_API std::string</type>
        <definition>virtual AR_API std::string _GetExtension</definition>
        <argsstring>(const std::string &amp;assetPath) const</argsstring>
        <name>_GetExtension</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <briefdescription>
<para>Return the file extension for the given <computeroutput>assetPath</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>This extension should not include a &quot;.&quot; at the beginning of the string.</para>
<para>The default implementation returns the string after the last &quot;.&quot; in <computeroutput>assetPath</computeroutput>. If <computeroutput>assetPath</computeroutput> begins with a &quot;.&quot;, the extension will be empty unless there is another &quot;.&quot; in the path. If <computeroutput>assetPath</computeroutput> has components separated by &apos;/&apos; (or &apos;\&apos; on Windows), only the last component will be considered. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="689" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1adc0f04bf685974a9d41d1503d3ce8e0d" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>AR_API <ref refid="class_ar_asset_info" kindref="compound">ArAssetInfo</ref></type>
        <definition>virtual AR_API ArAssetInfo _GetAssetInfo</definition>
        <argsstring>(const std::string &amp;assetPath, const ArResolvedPath &amp;resolvedPath) const</argsstring>
        <name>_GetAssetInfo</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <param>
          <type>const <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> &amp;</type>
          <declname>resolvedPath</declname>
        </param>
        <briefdescription>
<para>Return an <ref refid="class_ar_asset_info" kindref="compound">ArAssetInfo</ref> populated with additional metadata (if any) about the asset at the given <computeroutput>assetPath</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>resolvedPath</computeroutput> is the resolved path computed for the given <computeroutput>assetPath</computeroutput>. The default implementation returns a default-constructed <ref refid="class_ar_asset_info" kindref="compound">ArAssetInfo</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="697" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a51c771ddc5d3882b3ece763fbb60e507" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>AR_API <ref refid="class_ar_timestamp" kindref="compound">ArTimestamp</ref></type>
        <definition>virtual AR_API ArTimestamp _GetModificationTimestamp</definition>
        <argsstring>(const std::string &amp;assetPath, const ArResolvedPath &amp;resolvedPath) const</argsstring>
        <name>_GetModificationTimestamp</name>
        <reimplementedby refid="class_ar_default_resolver_1a98cefaf82c98c23f4024fb5d21bb55c2">_GetModificationTimestamp</reimplementedby>
        <param>
          <type>const std::string &amp;</type>
          <declname>assetPath</declname>
        </param>
        <param>
          <type>const <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> &amp;</type>
          <declname>resolvedPath</declname>
        </param>
        <briefdescription>
<para>Return an <ref refid="class_ar_timestamp" kindref="compound">ArTimestamp</ref> representing the last time the asset at <computeroutput>assetPath</computeroutput> was modified. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>resolvedPath</computeroutput> is the resolved path computed for the given <computeroutput>assetPath</computeroutput>. If a timestamp cannot be retrieved, return an invalid <ref refid="class_ar_timestamp" kindref="compound">ArTimestamp</ref>.</para>
<para>The default implementation returns an invalid <ref refid="class_ar_timestamp" kindref="compound">ArTimestamp</ref>.</para>
<para>Example uses:<itemizedlist>
<listitem><para><ref refid="class_sdf_layer" kindref="compound">SdfLayer</ref> will call GetModificationTimestamp when opening a layer and store the returned timestamp. When <ref refid="class_sdf_layer_1aadc795502e58ced5fec2a00cf282f27a" kindref="member">SdfLayer::Reload</ref> is called on that layer, this method will be called again. If the returned timestamp differs from the stored timestamp, or if it is invalid, the layer will be reloaded. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="715" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1ac2b5b770ce42d1d20b638eeb231c86eb" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>AR_API std::shared_ptr&lt; <ref refid="class_ar_asset" kindref="compound">ArAsset</ref> &gt;</type>
        <definition>virtual AR_API std::shared_ptr&lt;ArAsset&gt; _OpenAsset</definition>
        <argsstring>(const ArResolvedPath &amp;resolvedPath) const =0</argsstring>
        <name>_OpenAsset</name>
        <reimplementedby refid="class_ar_default_resolver_1a9b798d003cedb668f9c45e135692a879">_OpenAsset</reimplementedby>
        <param>
          <type>const <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> &amp;</type>
          <declname>resolvedPath</declname>
        </param>
        <briefdescription>
<para>Return an <ref refid="class_ar_asset" kindref="compound">ArAsset</ref> object for the asset located at <computeroutput>resolvedPath</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Return an invalid std::shared_ptr if object could not be created (for example, if the asset at the given path could not be opened).</para>
<para>Note that clients may still be using the data associated with this object even after the last shared_ptr has been destroyed. For example, a client may have created a memory mapping using the FILE* presented in the <ref refid="class_ar_asset" kindref="compound">ArAsset</ref> object; this would preclude truncating or overwriting any of the contents of that file. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="729" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1aa9be097a3054cd75a38ff68030bf9c67" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>AR_API bool</type>
        <definition>virtual AR_API bool _CanWriteAssetToPath</definition>
        <argsstring>(const ArResolvedPath &amp;resolvedPath, std::string *whyNot) const</argsstring>
        <name>_CanWriteAssetToPath</name>
        <param>
          <type>const <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> &amp;</type>
          <declname>resolvedPath</declname>
        </param>
        <param>
          <type>std::string *</type>
          <declname>whyNot</declname>
        </param>
        <briefdescription>
<para>Return true if an asset may be written to the given <computeroutput>resolvedPath</computeroutput>, false otherwise. </para>
        </briefdescription>
        <detaileddescription>
<para>If this function returns false and <computeroutput>whyNot</computeroutput> is not <computeroutput>nullptr</computeroutput>, it may be filled with an explanation. The default implementation returns true. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="737" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a8a70fbd567fd56d9567f8ab9796a4d69" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>AR_API std::shared_ptr&lt; <ref refid="class_ar_writable_asset" kindref="compound">ArWritableAsset</ref> &gt;</type>
        <definition>virtual AR_API std::shared_ptr&lt;ArWritableAsset&gt; _OpenAssetForWrite</definition>
        <argsstring>(const ArResolvedPath &amp;resolvedPath, WriteMode writeMode) const =0</argsstring>
        <name>_OpenAssetForWrite</name>
        <reimplementedby refid="class_ar_default_resolver_1ad7c9c5831bede022a807f77838208c64">_OpenAssetForWrite</reimplementedby>
        <param>
          <type>const <ref refid="class_ar_resolved_path" kindref="compound">ArResolvedPath</ref> &amp;</type>
          <declname>resolvedPath</declname>
        </param>
        <param>
          <type><ref refid="class_ar_resolver_1a61d23b393fdc35f2f0e30a1ed566c76d" kindref="member">WriteMode</ref></type>
          <declname>writeMode</declname>
        </param>
        <briefdescription>
<para>Return an <ref refid="class_ar_writable_asset" kindref="compound">ArWritableAsset</ref> object for the asset at <computeroutput>resolvedPath</computeroutput> using the specified <computeroutput>writeMode</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Return an invalid std::shared_ptr if object could not be created (for example, if writing to the given path is not allowed).</para>
<para>Implementations should create any parent paths that are necessary to write this asset. The returned <ref refid="class_ar_writable_asset" kindref="compound">ArWritableAsset</ref> must obey the behaviors for the given <computeroutput>writeMode</computeroutput>, see the documentation for the WriteMode enum for more details. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="752" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Scoped Resolution Cache Implementation</header>
      <description><para><anchor id="class_ar_resolver_1ArResolver_scopedCacheImplementation"/></para>
<para>If any of these functions are implemented in a subclass, the plugin metadata for that subclass in the plugin library&apos;s plugInfo.json must specify: <programlisting><codeline><highlight class="normal">&quot;implementsScopedCaches&quot;<sp/>:<sp/>true.</highlight></codeline>
</programlisting></para>
<para>If a subclass indicates that it implements these functions, <ref refid="class_ar_resolver" kindref="compound">ArResolver</ref> will assume the subclass is handling all caching of resolved paths and will call these functions when a caching scope is opened and closed. Otherwise, these functions will not be called. Instead, <ref refid="class_ar_resolver" kindref="compound">ArResolver</ref> itself will handle caching and returning resolved paths as needed. </para>
</description>
      <memberdef kind="function" id="class_ar_resolver_1a02b1f3d70b0771e0e399af8625edeb15" prot="protected" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>AR_API void</type>
        <definition>virtual AR_API void _BeginCacheScope</definition>
        <argsstring>(VtValue *cacheScopeData)</argsstring>
        <name>_BeginCacheScope</name>
        <param>
          <type><ref refid="class_vt_value" kindref="compound">VtValue</ref> *</type>
          <declname>cacheScopeData</declname>
        </param>
        <briefdescription>
<para>Mark the start of a resolution caching scope. </para>
        </briefdescription>
        <detaileddescription>
<para>Resolvers may fill <computeroutput>cacheScopeData</computeroutput> with arbitrary data. Clients may also pass in a <computeroutput>cacheScopeData</computeroutput> populated by an earlier call to BeginCacheScope to allow the resolver access to that information.</para>
<para>See <ref refid="class_ar_resolver_1ArResolver_scopedCacheImplementation" kindref="member">Scoped Resolution Cache Implementation</ref> for more implementation details. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="786" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1ab36e690e66b26c1cea5268ff2bef5400" prot="protected" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>AR_API void</type>
        <definition>virtual AR_API void _EndCacheScope</definition>
        <argsstring>(VtValue *cacheScopeData)</argsstring>
        <name>_EndCacheScope</name>
        <param>
          <type><ref refid="class_vt_value" kindref="compound">VtValue</ref> *</type>
          <declname>cacheScopeData</declname>
        </param>
        <briefdescription>
<para>Mark the end of a resolution caching scope. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>cacheScopeData</computeroutput> should contain the data that was populated by the previous corresponding call to BeginCacheScope.</para>
<para>See <ref refid="class_ar_resolver_1ArResolver_scopedCacheImplementation" kindref="member">Scoped Resolution Cache Implementation</ref> for more implementation details. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="797" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Implementation Utilities</header>
      <description><para><anchor id="class_ar_resolver_1ArResolver_implementationUtils"/></para>
<para>Utility functions for implementations. </para>
</description>
      <memberdef kind="function" id="class_ar_resolver_1ab93ccf0957571994e79ade8bf4d5f793" prot="protected" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ContextObj</type>
          </param>
        </templateparamlist>
        <type>const ContextObj *</type>
        <definition>const ContextObj* _GetCurrentContextObject</definition>
        <argsstring>() const</argsstring>
        <name>_GetCurrentContextObject</name>
        <briefdescription>
<para>Returns a pointer to the context object of type <computeroutput>ContextObj</computeroutput> from the last <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> that was bound via a call to BindContext, or <computeroutput>NULL</computeroutput> if no context object of that type exists. </para>
        </briefdescription>
        <detaileddescription>
<para>Typically, a subclass might use this in their _Resolve function to get the currently bound context to drive their resolution behavior.</para>
<para><programlisting><codeline><highlight class="normal">if<sp/>(const<sp/>MyContextObject*<sp/>ctx<sp/>=<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_GetCurrentContextObject&lt;MyContextObject&gt;())<sp/>{</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Use<sp/>information<sp/>in<sp/>ctx<sp/>to<sp/>resolve<sp/>given<sp/>path</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Resolve<sp/>given<sp/>path<sp/>with<sp/>no<sp/>context<sp/>object</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This is the same as <ref refid="class_ar_resolver_1a9e318a8e5693b4103d88443780c1fb5a" kindref="member">GetCurrentContext()</ref>.Get&lt;ContextObj&gt;() but more efficient, since it does not make a copy of the <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref>. However, it is <emphasis>not</emphasis> the same as <ref refid="class_ar_resolver_1a111e120876d4dd8f717c7bdccffd86d5" kindref="member">_GetCurrentContext()</ref>.Get&lt;ContextObj&gt;(). Subclasses that manage context binding themselves may have overridden _GetCurrentContext to return a context that was bound without calling BindContext. These subclasses should not use this function and should retrieve the current context from their own internal data structures. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="843" column="1" bodyfile="pxr/usd/ar/resolver.h" bodystart="843" bodyend="847"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="class_ar_resolver_1a4cb563dabaaca8a54b670bc7391f131e" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>AR_API</type>
        <definition>virtual AR_API ~ArResolver</definition>
        <argsstring>()</argsstring>
        <name>~ArResolver</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="63" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a20af16c992f11c3e462ca6f2d5a159a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ArResolver</definition>
        <argsstring>(const ArResolver &amp;)=delete</argsstring>
        <name>ArResolver</name>
        <param>
          <type>const <ref refid="class_ar_resolver" kindref="compound">ArResolver</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="66" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1ac49212b5cc74bd2d2d5345120cd17e89" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="class_ar_resolver" kindref="compound">ArResolver</ref> &amp;</type>
        <definition>ArResolver&amp; operator=</definition>
        <argsstring>(const ArResolver &amp;)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="class_ar_resolver" kindref="compound">ArResolver</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="67" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-func">
      <memberdef kind="function" id="class_ar_resolver_1a4e83c618c120b7dbc488ead3b0f8075c" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API</type>
        <definition>AR_API ArResolver</definition>
        <argsstring>()</argsstring>
        <name>ArResolver</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="430" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_ar_resolver_1a9758cb2f1e4bf228ad8f9c47fa38adf9" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>AR_API bool</type>
        <definition>virtual AR_API bool _IsRepositoryPath</definition>
        <argsstring>(const std::string &amp;path) const</argsstring>
        <name>_IsRepositoryPath</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>path</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000060"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Return true if the given path is a repository path, false otherwise.</para>
</xrefdescription></xrefsect>Default implementation returns false. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="806" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="class_ar_resolver_1aa50a3ce5ce41721758d306bcd3b9e655" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>AR_API const <ref refid="class_ar_resolver_context" kindref="compound">ArResolverContext</ref> *</type>
        <definition>AR_API const ArResolverContext* _GetInternallyManagedCurrentContext</definition>
        <argsstring>() const</argsstring>
        <name>_GetInternallyManagedCurrentContext</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/ar/resolver.h" line="857" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Interface for the asset resolution system. </para>
    </briefdescription>
    <detaileddescription>
<para>An asset resolver is responsible for resolving asset information (including the asset&apos;s physical path) from a logical path.</para>
<para>See ar_implementing_resolver for information on how to customize asset resolution behavior by implementing a subclass of <ref refid="class_ar_resolver" kindref="compound">ArResolver</ref>. Clients may use <ref refid="ar_2resolver_8h_1ab0913ebfd579684add6b59b44983a633" kindref="member">ArGetResolver</ref> to access the configured asset resolver. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="735">
        <label>ArResolver</label>
        <link refid="class_ar_resolver"/>
      </node>
      <node id="736">
        <label>ArDefaultResolver</label>
        <link refid="class_ar_default_resolver"/>
        <childnode refid="735" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <location file="pxr/usd/ar/resolver.h" line="60" column="1" bodyfile="pxr/usd/ar/resolver.h" bodystart="59" bodyend="859"/>
    <listofallmembers>
      <member refid="class_ar_resolver_1a02b1f3d70b0771e0e399af8625edeb15" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_BeginCacheScope</name></member>
      <member refid="class_ar_resolver_1aea5ca0e868d149785b777baf8cfcde5e" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_BindContext</name></member>
      <member refid="class_ar_resolver_1aa9be097a3054cd75a38ff68030bf9c67" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_CanWriteAssetToPath</name></member>
      <member refid="class_ar_resolver_1ab67c369f100fd0488e74c3293c688156" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_CreateContextFromString</name></member>
      <member refid="class_ar_resolver_1a8ea0d703db16ed156b942bb7e1b130ea" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_CreateDefaultContext</name></member>
      <member refid="class_ar_resolver_1a5b0e0ea52ac80bb4a4b6d1f881331df1" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_CreateDefaultContextForAsset</name></member>
      <member refid="class_ar_resolver_1a8eac0ab4acfa5276713bee14b8e11308" prot="protected" virt="pure-virtual"><scope>ArResolver</scope><name>_CreateIdentifierForNewAsset</name></member>
      <member refid="class_ar_resolver_1ab36e690e66b26c1cea5268ff2bef5400" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_EndCacheScope</name></member>
      <member refid="class_ar_resolver_1adc0f04bf685974a9d41d1503d3ce8e0d" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_GetAssetInfo</name></member>
      <member refid="class_ar_resolver_1a111e120876d4dd8f717c7bdccffd86d5" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_GetCurrentContext</name></member>
      <member refid="class_ar_resolver_1ab93ccf0957571994e79ade8bf4d5f793" prot="protected" virt="non-virtual"><scope>ArResolver</scope><name>_GetCurrentContextObject</name></member>
      <member refid="class_ar_resolver_1a754a31a6d1ab02063db5c9b9f312c737" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_GetExtension</name></member>
      <member refid="class_ar_resolver_1aa50a3ce5ce41721758d306bcd3b9e655" prot="private" virt="non-virtual"><scope>ArResolver</scope><name>_GetInternallyManagedCurrentContext</name></member>
      <member refid="class_ar_resolver_1a51c771ddc5d3882b3ece763fbb60e507" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_GetModificationTimestamp</name></member>
      <member refid="class_ar_resolver_1a618cc648520d613dbebadc1eaa57d688" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_IsContextDependentPath</name></member>
      <member refid="class_ar_resolver_1a9758cb2f1e4bf228ad8f9c47fa38adf9" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_IsRepositoryPath</name></member>
      <member refid="class_ar_resolver_1ac2b5b770ce42d1d20b638eeb231c86eb" prot="protected" virt="pure-virtual"><scope>ArResolver</scope><name>_OpenAsset</name></member>
      <member refid="class_ar_resolver_1a8a70fbd567fd56d9567f8ab9796a4d69" prot="protected" virt="pure-virtual"><scope>ArResolver</scope><name>_OpenAssetForWrite</name></member>
      <member refid="class_ar_resolver_1af454d5a00d4dd1c2b1022d8b38d36bef" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_RefreshContext</name></member>
      <member refid="class_ar_resolver_1a3b0b5d475de0d5fb0d17756b07696014" prot="protected" virt="pure-virtual"><scope>ArResolver</scope><name>_Resolve</name></member>
      <member refid="class_ar_resolver_1a66bbf8128c2c2253eff9b34ba9d5baae" prot="protected" virt="pure-virtual"><scope>ArResolver</scope><name>_ResolveForNewAsset</name></member>
      <member refid="class_ar_resolver_1a060c4070673ae89cb680d2f544de5557" prot="protected" virt="virtual"><scope>ArResolver</scope><name>_UnbindContext</name></member>
      <member refid="class_ar_resolver_1a806b3bf4dc93af8cdde3e3e2a3d5e1e7" prot="protected" virt="non-virtual"><scope>ArResolver</scope><name>ArResolvedPath</name></member>
      <member refid="class_ar_resolver_1a20af16c992f11c3e462ca6f2d5a159a9" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>ArResolver</name></member>
      <member refid="class_ar_resolver_1a4e83c618c120b7dbc488ead3b0f8075c" prot="protected" virt="non-virtual"><scope>ArResolver</scope><name>ArResolver</name></member>
      <member refid="class_ar_resolver_1a522ae6b8a14dc87c9116109e619f062b" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>BeginCacheScope</name></member>
      <member refid="class_ar_resolver_1a85ae1972e7c5791b3155ec04c213d29d" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>BindContext</name></member>
      <member refid="class_ar_resolver_1a843b3ef2aacbedf6fe6f9deeb01696d7" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>CanWriteAssetToPath</name></member>
      <member refid="class_ar_resolver_1a5b165aaf701119f4b3bc26cdebd38b93" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>CreateContextFromString</name></member>
      <member refid="class_ar_resolver_1a6f01bf8462bf0ec118187e200df7e362" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>CreateContextFromString</name></member>
      <member refid="class_ar_resolver_1a37d32052831939332ecbff965ef94caf" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>CreateContextFromStrings</name></member>
      <member refid="class_ar_resolver_1a1524962aa020859a589e786b1ad3c28f" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>CreateDefaultContext</name></member>
      <member refid="class_ar_resolver_1a0a174a99676ff983a183d391973c7ebe" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>CreateDefaultContextForAsset</name></member>
      <member refid="class_ar_resolver_1a68e5ae6385d1733b79f734c59682ff61" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>CreateIdentifier</name></member>
      <member refid="class_ar_resolver_1aabfb26c05d314299ddf596fc1defeb6c" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>CreateIdentifierForNewAsset</name></member>
      <member refid="class_ar_resolver_1a266aaced9fc6decb4ae2ad884bd46517" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>EndCacheScope</name></member>
      <member refid="class_ar_resolver_1a6078df1f5f1d1f4cf4d5b1411b7b88c8" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>GetAssetInfo</name></member>
      <member refid="class_ar_resolver_1a9e318a8e5693b4103d88443780c1fb5a" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>GetCurrentContext</name></member>
      <member refid="class_ar_resolver_1ab8e1e7ab9dc4e2a390019b3b6384a504" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>GetExtension</name></member>
      <member refid="class_ar_resolver_1af0820bb01d47be4f215a661f061e2200" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>GetModificationTimestamp</name></member>
      <member refid="class_ar_resolver_1ad616f0a0fc1e5dce08929604f3b95f8f" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>IsContextDependentPath</name></member>
      <member refid="class_ar_resolver_1a966c6fe671e427a7d8a01f9d068879a7" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>IsRepositoryPath</name></member>
      <member refid="class_ar_resolver_1aa3a964db701e93c26fc8365ac98fb758" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>OpenAsset</name></member>
      <member refid="class_ar_resolver_1a91c07b55b6807adb47805ff0037b6c44" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>OpenAssetForWrite</name></member>
      <member refid="class_ar_resolver_1ac49212b5cc74bd2d2d5345120cd17e89" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>operator=</name></member>
      <member refid="class_ar_resolver_1a6d9a29a4e375bbdafde5e6e3f836291a" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>RefreshContext</name></member>
      <member refid="class_ar_resolver_1a1b824f00c46b2a5001f492698fd8f5c1" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>Resolve</name></member>
      <member refid="class_ar_resolver_1ae9bdf8eab4d4ebf70a0d2df3727ff9b8" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>ResolveForNewAsset</name></member>
      <member refid="class_ar_resolver_1a8aaa1f17eef5b4d8facae03cc70c54de" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>UnbindContext</name></member>
      <member refid="class_ar_resolver_1a50c0a0a7bc7b939f4a44fd4baf26a7b5" prot="protected" virt="non-virtual"><scope>ArResolver</scope><name>usd</name></member>
      <member refid="class_ar_resolver_1a61d23b393fdc35f2f0e30a1ed566c76d" prot="public" virt="non-virtual"><scope>ArResolver</scope><name>WriteMode</name></member>
      <member refid="class_ar_resolver_1a4cb563dabaaca8a54b670bc7391f131e" prot="public" virt="virtual"><scope>ArResolver</scope><name>~ArResolver</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
