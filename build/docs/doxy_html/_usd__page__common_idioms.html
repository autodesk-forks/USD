<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: Common Idioms and Examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_usd__page__common_idioms.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Common Idioms and Examples </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Usd_StageTraversal"></a>
Traversing a Stage</h1>
<p>The Usd API provides a number of methods for fast, configurable traversal of a stage or sub-trees of prims on a stage. The two categories of traversal are recursion and iteration. Common to both is the ability to specify a "predicate" that governs which prims will actually be yielded by the API during a traversal, and which will be skipped. Predicates are conjunctions, disjunctions, and negations of a set of tests of core properties of <a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> that are cached for speedy access during stage population. See <a class="el" href="prim_flags_8h.html#Usd_PrimFlags">Prim Flags</a> for more detail and examples.</p>
<h2><a class="anchor" id="Usd_StageTraversal_Recursion"></a>
Traversing with Recursion</h2>
<p><a class="el" href="class_usd_prim.html" title="UsdPrim is the sole persistent scenegraph object on a UsdStage, and is the embodiment of a &quot;Prim&quot; as ...">UsdPrim</a> provides a number of methods for accessing its direct children via a "range", with which one can construct very efficient recursive functions. The standard <a class="el" href="class_usd_prim.html#a2619563fc9180d8ead597944fd7f6ec7" title="Return this prim&#39;s active, loaded, defined, non-abstract children as an iterable range.">UsdPrim::GetChildren()</a> uses the "canonical traversal predicate," which implies all active, loaded, defined, non-abstract children. <a class="el" href="class_usd_prim.html#a41fba977a56f9a6c1c8e2ed1e98c337d" title="Return a subset of all of this prim&#39;s children filtered by predicate as an iterable range.">UsdPrim::GetFilteredChildren()</a> allows specification of a custom predicate.</p>
<h2><a class="anchor" id="Usd_StageTraversal_Ieration"></a>
Traversing with Iteration</h2>
<p><a class="el" href="class_usd_prim.html#a2c7f60d23da06f334e0d298c82eb4a5d" title="Return this prim&#39;s active, loaded, defined, non-abstract descendants as an iterable range.">UsdPrim::GetDescendants()</a> returns a range for all of a prim's "canonical" decendants, and <a class="el" href="class_usd_prim.html#a35097b9294275723ef886d39f12d0546" title="Return a subset of all of this prim&#39;s descendants filtered by predicate as an iterable range.">UsdPrim::GetFilteredDescendants()</a> allows the range's predicate to be specified.</p>
<p><a class="el" href="class_usd_prim_range.html" title="An forward-iterable range that traverses a subtree of prims rooted at a given prim in depth-first ord...">UsdPrimRange</a> enables highly customized iterations, adding the ability to perform pre-and-post-order traversals, and to prune subtrees.</p>
<p>The convenience method <a class="el" href="class_usd_stage.html#adba675b55f41cc1b305bed414fc4f178" title="Traverse the active, loaded, defined, non-abstract prims on this stage depth-first.">UsdStage::Traverse()</a> returns a <a class="el" href="class_usd_prim_range.html" title="An forward-iterable range that traverses a subtree of prims rooted at a given prim in depth-first ord...">UsdPrimRange</a> that visits all descendants of the pseudo-root, but not the pseudo-root itself.</p>
<h1><a class="anchor" id="Usd_WorkingWithSchemas"></a>
Working With Schema Classes</h1>
<p>Later we'll talk about how to create new schema classes...</p>
<h2><a class="anchor" id="Usd_Create_Or_Get_Property"></a>
Create vs Get Property Methods</h2>
<p>For a <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> named "points" defined in a schema class, you will find two access methods in the schema class in C++ and python: </p><ul>
<li>GetPointsAttr() </li>
<li>CreatePointsAttr()</li>
</ul>
<p>What is the difference between these two methods, and when should you use each? GetPointsAttr() simply returns a <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> object, without authoring any scene description. It is therefore threadsafe, and it should be your choice in any code that may be executed in a multithreaded, "multiple readers" section. Of course, the <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> it returns has an API that includes mutating methods that <b>will</b> author scene description, and those methods should be avoided in multi-threaded sections. However, there is no guarantee that the <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> returned by GetPointsAttr() will be <em>valid</em> for use in authoring scene description, because there may not be any definition available for the attribute in the Stage's scene description, which means (for example) the Set() method might not know what the attribute's datatype is. CreatePointsAttr(), by contrast, will actually create a typed definition for the attribute in the current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget</a> if no definition for the attribute yet exists - it follows that it is legal and safe to call CreatePointsAttr() even if the attribute is already defined in the current <a class="el" href="class_usd_edit_target.html" title="Defines a mapping from scene graph paths to Sdf spec paths in a SdfLayer where edits should be direct...">UsdEditTarget()</a>.</p>
<p>In general, you should use CreateXXXAttr() when authoring scene description, and GetXXXAttr() when reading/importing scene description. CreateXXXAttr() also allows you to specify a default value to assign to the attribute, which you can specify to author sparsely, which means that we will refrain from authoring the provided value iff: </p><ul>
<li>there is currently no authored value for the attribute on the composed prim </li>
<li>the attribute has a fallback value on the composed prim, and the fallback value matches the provided value. If the prim has no composed typeName (i.e. in the authoring context, the prim is a pure override), then <em>no</em> attribute on the prim will possess a fallback, since fallbacks apply via the prim's typeName.</li>
</ul>
<p>The same pattern holds for relationships, except that CreateXXXRel() does not allow specification of a default target, because relationships are <em>list-edited</em>, and it would be unclear whether to <em>add</em> or <em>set</em> the target when there are already authored target opinions.</p>
<dl class="section note"><dt>Note</dt><dd><b>USDeeper: Schema Registry of IsA Schemas.</b> <em>IsA</em> schemas are registered in the <a class="el" href="class_usd_schema_registry.html">UsdSchemaRegistry</a>, which provides automatic (also directly queryable) access to the typed definition of each property listed in a schema's definition in its originating schema.usda file. The properties defined in each <em>IsA</em> schema are called "builtins", which means they are considered present on prims of that type even when unauthored, and builtin attributes can be provided a <em>fallback</em> value that will be returned by <a class="el" href="class_usd_attribute.html#a9d41bc223be86408ba7d7f74df7c35a9" title="Perform value resolution to fetch the value of this attribute at the requested UsdTimeCode time,...">UsdAttribute::Get()</a> when the attribute possesses no authored scene description. Therefore, when authoring builtin properties on a defined, typed prim, one is technically not required to use the CreateXXXAttr() method, because the core consults the schema registry using the prim typeName and the property name to define the property, if no definition has yet been authored. Note also that when querying the typeName of a builtin, <a class="el" href="class_usd_attribute.html" title="Scenegraph object for authoring and retrieving numeric, string, and array valued data,...">UsdAttribute</a> will always consult only the property definition in the schema registry, even if one has attempted to change the attribute's type in a stringer layer. However, <em>HasA</em> schemas record no typename on prims, nor are they present in the schema registry. So one <em>must</em> use CreateXXXAttr() when authoring scene description using <em>HasA</em> schemas. CreateXXXAttr() is also useful with <em>IsA</em> schemas for authoring onto an untyped, "pure override" prim that the author knows will later compose onto a typed prim of a compatible schema type (though of course, care should be exercised). However, code that consistently uses CreateXXXAttr() for authoring will be easier to maintain since it will help distinguish reader sections from writer sections.</dd></dl>
<h1><a class="anchor" id="Usd_BoolReturns"></a>
Bool Return Values and Safe Operator Bool</h1>
<h1><a class="anchor" id="Usd_ErrorReporting"></a>
Error Reporting Policy and Control</h1>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="usd_page_front.html">Usd : Universal Scene Description (Core)</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:57 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>