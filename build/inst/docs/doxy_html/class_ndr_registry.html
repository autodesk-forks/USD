<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: NdrRegistry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ndr_registry.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_ndr_registry-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NdrRegistry Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The registry provides access to node information.  
 <a href="class_ndr_registry.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for NdrRegistry:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_ndr_registry__inherit__graph.png" border="0" usemap="#_ndr_registry_inherit__map" alt="Inheritance graph"/></div>
<map name="_ndr_registry_inherit__map" id="_ndr_registry_inherit__map">
<area shape="rect"  title="The registry provides access to node information." alt="" coords="7,80,105,107"/>
<area shape="rect"  href="class_sdr_registry.html" title="The shading&#45;specialized version of NdrRegistry." alt="" coords="8,155,104,181"/>
<area shape="rect"  href="class_tf_weak_base.html" title="Enable a concrete base class for use with TfWeakPtr." alt="" coords="5,5,107,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4d86409a818ebd4d0025e3eee6925c55"><td class="memItemLeft" align="right" valign="top"><a id="a4d86409a818ebd4d0025e3eee6925c55"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DiscoveryPluginRefPtrVec</b> = NdrDiscoveryPluginRefPtrVector</td></tr>
<tr class="separator:a4d86409a818ebd4d0025e3eee6925c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab111939c2df38b3e33afd43acc018249"><td class="memItemLeft" align="right" valign="top">NDR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#ab111939c2df38b3e33afd43acc018249">SetExtraDiscoveryPlugins</a> (DiscoveryPluginRefPtrVec plugins)</td></tr>
<tr class="memdesc:ab111939c2df38b3e33afd43acc018249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the client to set any additional discovery plugins that would otherwise NOT be found through the plugin system.  <a href="#ab111939c2df38b3e33afd43acc018249">More...</a><br /></td></tr>
<tr class="separator:ab111939c2df38b3e33afd43acc018249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb836b69c5e2612564e9711017099d4"><td class="memItemLeft" align="right" valign="top">NDR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#a1eb836b69c5e2612564e9711017099d4">SetExtraDiscoveryPlugins</a> (const std::vector&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt; &amp;pluginTypes)</td></tr>
<tr class="memdesc:a1eb836b69c5e2612564e9711017099d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the client to set any additional discovery plugins that would otherwise NOT be found through the plugin system.  <a href="#a1eb836b69c5e2612564e9711017099d4">More...</a><br /></td></tr>
<tr class="separator:a1eb836b69c5e2612564e9711017099d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b5a0d433c3c1150ee638cc1c814121"><td class="memItemLeft" align="right" valign="top">NDR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#a18b5a0d433c3c1150ee638cc1c814121">AddDiscoveryResult</a> (<a class="el" href="struct_ndr_node_discovery_result.html">NdrNodeDiscoveryResult</a> &amp;&amp;discoveryResult)</td></tr>
<tr class="memdesc:a18b5a0d433c3c1150ee638cc1c814121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the client to explicitly set additional discovery results that would otherwise NOT be found through the plugin system.  <a href="#a18b5a0d433c3c1150ee638cc1c814121">More...</a><br /></td></tr>
<tr class="separator:a18b5a0d433c3c1150ee638cc1c814121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b678bc03a457dbfb3773001b80b3d3"><td class="memItemLeft" align="right" valign="top">NDR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#a36b678bc03a457dbfb3773001b80b3d3">AddDiscoveryResult</a> (const <a class="el" href="struct_ndr_node_discovery_result.html">NdrNodeDiscoveryResult</a> &amp;discoveryResult)</td></tr>
<tr class="memdesc:a36b678bc03a457dbfb3773001b80b3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy version of the method above.  <a href="#a36b678bc03a457dbfb3773001b80b3d3">More...</a><br /></td></tr>
<tr class="separator:a36b678bc03a457dbfb3773001b80b3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b6226c83cb2a771d18b8e3b46603e8"><td class="memItemLeft" align="right" valign="top">NDR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#ad6b6226c83cb2a771d18b8e3b46603e8">SetExtraParserPlugins</a> (const std::vector&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt; &amp;pluginTypes)</td></tr>
<tr class="memdesc:ad6b6226c83cb2a771d18b8e3b46603e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the client to set any additional parser plugins that would otherwise NOT be found through the plugin system.  <a href="#ad6b6226c83cb2a771d18b8e3b46603e8">More...</a><br /></td></tr>
<tr class="separator:ad6b6226c83cb2a771d18b8e3b46603e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadbd8fe1df4f30bb9dd2e2bb0b4970f"><td class="memItemLeft" align="right" valign="top">NDR_API NdrNodeConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#aaadbd8fe1df4f30bb9dd2e2bb0b4970f">GetNodeFromAsset</a> (const <a class="el" href="class_sdf_asset_path.html">SdfAssetPath</a> &amp;asset, const NdrTokenMap &amp;metadata, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;subIdentifier=<a class="el" href="class_tf_token.html">TfToken</a>(), const <a class="el" href="class_tf_token.html">TfToken</a> &amp;sourceType=<a class="el" href="class_tf_token.html">TfToken</a>())</td></tr>
<tr class="memdesc:aaadbd8fe1df4f30bb9dd2e2bb0b4970f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given <code>asset</code>, constructs a <a class="el" href="class_ndr_node.html" title="Represents an abstract node.">NdrNode</a> from it and adds it to the registry.  <a href="#aaadbd8fe1df4f30bb9dd2e2bb0b4970f">More...</a><br /></td></tr>
<tr class="separator:aaadbd8fe1df4f30bb9dd2e2bb0b4970f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391e8cb4eeb3223aff3d725920830564"><td class="memItemLeft" align="right" valign="top">NDR_API NdrNodeConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#a391e8cb4eeb3223aff3d725920830564">GetNodeFromSourceCode</a> (const std::string &amp;sourceCode, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;sourceType, const NdrTokenMap &amp;metadata)</td></tr>
<tr class="memdesc:a391e8cb4eeb3223aff3d725920830564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given <code>sourceCode</code> string, constructs a <a class="el" href="class_ndr_node.html" title="Represents an abstract node.">NdrNode</a> from it and adds it to the registry.  <a href="#a391e8cb4eeb3223aff3d725920830564">More...</a><br /></td></tr>
<tr class="separator:a391e8cb4eeb3223aff3d725920830564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ca010b4493ec6ed866619be7984023"><td class="memItemLeft" align="right" valign="top">NDR_API NdrStringVec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#a51ca010b4493ec6ed866619be7984023">GetSearchURIs</a> () const</td></tr>
<tr class="memdesc:a51ca010b4493ec6ed866619be7984023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locations where the registry is searching for nodes.  <a href="#a51ca010b4493ec6ed866619be7984023">More...</a><br /></td></tr>
<tr class="separator:a51ca010b4493ec6ed866619be7984023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ea47727622f4f5cb677b487bbcfa64"><td class="memItemLeft" align="right" valign="top">NDR_API NdrIdentifierVec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#ad9ea47727622f4f5cb677b487bbcfa64">GetNodeIdentifiers</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;family=<a class="el" href="class_tf_token.html">TfToken</a>(), <a class="el" href="usd_2ndr_2declare_8h.html#a9991becacf778d59c7ff155f24383a21">NdrVersionFilter</a> filter=NdrVersionFilterDefaultOnly) const</td></tr>
<tr class="memdesc:ad9ea47727622f4f5cb677b487bbcfa64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the identifiers of all the nodes that the registry is aware of.  <a href="#ad9ea47727622f4f5cb677b487bbcfa64">More...</a><br /></td></tr>
<tr class="separator:ad9ea47727622f4f5cb677b487bbcfa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5c6eb89c893e959d6e66620945295e"><td class="memItemLeft" align="right" valign="top">NDR_API NdrStringVec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#aad5c6eb89c893e959d6e66620945295e">GetNodeNames</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;family=<a class="el" href="class_tf_token.html">TfToken</a>()) const</td></tr>
<tr class="memdesc:aad5c6eb89c893e959d6e66620945295e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the names of all the nodes that the registry is aware of.  <a href="#aad5c6eb89c893e959d6e66620945295e">More...</a><br /></td></tr>
<tr class="separator:aad5c6eb89c893e959d6e66620945295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bacc6de8683232867fa5a45121e3780"><td class="memItemLeft" align="right" valign="top">NDR_API NdrNodeConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#a5bacc6de8683232867fa5a45121e3780">GetNodeByIdentifier</a> (const <a class="el" href="class_tf_token.html">NdrIdentifier</a> &amp;identifier, const NdrTokenVec &amp;sourceTypePriority=NdrTokenVec())</td></tr>
<tr class="memdesc:a5bacc6de8683232867fa5a45121e3780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node with the specified <code>identifier</code>, and an optional <code>sourceTypePriority</code> list specifying the set of node SOURCE types (see <code><a class="el" href="class_ndr_node.html#a552a651875e4dbe319770af335913253" title="Gets the type of source that this node originated from.">NdrNode::GetSourceType()</a></code>) that should be searched.  <a href="#a5bacc6de8683232867fa5a45121e3780">More...</a><br /></td></tr>
<tr class="separator:a5bacc6de8683232867fa5a45121e3780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302de2b47bdf8af387d9273bc797f9a7"><td class="memItemLeft" align="right" valign="top">NDR_API NdrNodeConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#a302de2b47bdf8af387d9273bc797f9a7">GetNodeByIdentifierAndType</a> (const <a class="el" href="class_tf_token.html">NdrIdentifier</a> &amp;identifier, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;sourceType)</td></tr>
<tr class="memdesc:a302de2b47bdf8af387d9273bc797f9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node with the specified <code>identifier</code> and <code>sourceType</code>.  <a href="#a302de2b47bdf8af387d9273bc797f9a7">More...</a><br /></td></tr>
<tr class="separator:a302de2b47bdf8af387d9273bc797f9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b78ea888fcb8cb1fd755d62d551f285"><td class="memItemLeft" align="right" valign="top">NDR_API NdrNodeConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#a2b78ea888fcb8cb1fd755d62d551f285">GetNodeByName</a> (const std::string &amp;name, const NdrTokenVec &amp;sourceTypePriority=NdrTokenVec(), <a class="el" href="usd_2ndr_2declare_8h.html#a9991becacf778d59c7ff155f24383a21">NdrVersionFilter</a> filter=NdrVersionFilterDefaultOnly)</td></tr>
<tr class="memdesc:a2b78ea888fcb8cb1fd755d62d551f285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node with the specified name.  <a href="#a2b78ea888fcb8cb1fd755d62d551f285">More...</a><br /></td></tr>
<tr class="separator:a2b78ea888fcb8cb1fd755d62d551f285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c7d46e4adecc575c28ab686c46ff27"><td class="memItemLeft" align="right" valign="top">NDR_API NdrNodeConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#aa2c7d46e4adecc575c28ab686c46ff27">GetNodeByNameAndType</a> (const std::string &amp;name, const <a class="el" href="class_tf_token.html">TfToken</a> &amp;sourceType, <a class="el" href="usd_2ndr_2declare_8h.html#a9991becacf778d59c7ff155f24383a21">NdrVersionFilter</a> filter=NdrVersionFilterDefaultOnly)</td></tr>
<tr class="memdesc:aa2c7d46e4adecc575c28ab686c46ff27"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper around <code><a class="el" href="class_ndr_registry.html#a2b78ea888fcb8cb1fd755d62d551f285" title="Get the node with the specified name.">GetNodeByName()</a></code>.  <a href="#aa2c7d46e4adecc575c28ab686c46ff27">More...</a><br /></td></tr>
<tr class="separator:aa2c7d46e4adecc575c28ab686c46ff27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db1bd9c3d178aaba60718cbaba66486"><td class="memItemLeft" align="right" valign="top">NDR_API NdrNodeConstPtrVec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#a3db1bd9c3d178aaba60718cbaba66486">GetNodesByIdentifier</a> (const <a class="el" href="class_tf_token.html">NdrIdentifier</a> &amp;identifier)</td></tr>
<tr class="memdesc:a3db1bd9c3d178aaba60718cbaba66486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all nodes matching the specified identifier (multiple nodes of the same identifier, but different source types, may exist).  <a href="#a3db1bd9c3d178aaba60718cbaba66486">More...</a><br /></td></tr>
<tr class="separator:a3db1bd9c3d178aaba60718cbaba66486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d61c1cf418e9034439ea95681e22323"><td class="memItemLeft" align="right" valign="top">NDR_API NdrNodeConstPtrVec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#a5d61c1cf418e9034439ea95681e22323">GetNodesByName</a> (const std::string &amp;name, <a class="el" href="usd_2ndr_2declare_8h.html#a9991becacf778d59c7ff155f24383a21">NdrVersionFilter</a> filter=NdrVersionFilterDefaultOnly)</td></tr>
<tr class="memdesc:a5d61c1cf418e9034439ea95681e22323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all nodes matching the specified name.  <a href="#a5d61c1cf418e9034439ea95681e22323">More...</a><br /></td></tr>
<tr class="separator:a5d61c1cf418e9034439ea95681e22323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9a9d1947c1ba283161fc8a8121c3d5"><td class="memItemLeft" align="right" valign="top">NDR_API NdrNodeConstPtrVec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#a5e9a9d1947c1ba283161fc8a8121c3d5">GetNodesByFamily</a> (const <a class="el" href="class_tf_token.html">TfToken</a> &amp;family=<a class="el" href="class_tf_token.html">TfToken</a>(), <a class="el" href="usd_2ndr_2declare_8h.html#a9991becacf778d59c7ff155f24383a21">NdrVersionFilter</a> filter=NdrVersionFilterDefaultOnly)</td></tr>
<tr class="memdesc:a5e9a9d1947c1ba283161fc8a8121c3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all nodes from the registry, optionally restricted to the nodes that fall under a specified family and/or the default version.  <a href="#a5e9a9d1947c1ba283161fc8a8121c3d5">More...</a><br /></td></tr>
<tr class="separator:a5e9a9d1947c1ba283161fc8a8121c3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c451ef8b27fb5858d714b2614d1df93"><td class="memItemLeft" align="right" valign="top">NDR_API NdrTokenVec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ndr_registry.html#a7c451ef8b27fb5858d714b2614d1df93">GetAllNodeSourceTypes</a> () const</td></tr>
<tr class="memdesc:a7c451ef8b27fb5858d714b2614d1df93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sorted list of all node source types that may be present on the nodes in the registry.  <a href="#a7c451ef8b27fb5858d714b2614d1df93">More...</a><br /></td></tr>
<tr class="separator:a7c451ef8b27fb5858d714b2614d1df93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_tf_weak_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_tf_weak_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_tf_weak_base.html">TfWeakBase</a></td></tr>
<tr class="memitem:affc4c00d0bbfdfe4f9e6a8b2e81be368 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="affc4c00d0bbfdfe4f9e6a8b2e81be368"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TfWeakBase</b> (const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;)</td></tr>
<tr class="separator:affc4c00d0bbfdfe4f9e6a8b2e81be368 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aa4c4b93df067f2ec9b9e5fa4c35b3 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a01aa4c4b93df067f2ec9b9e5fa4c35b3"></a>
const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>__GetTfWeakBase__</b> () const</td></tr>
<tr class="separator:a01aa4c4b93df067f2ec9b9e5fa4c35b3 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af890ac314073e903458bf6b2397566b5 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="af890ac314073e903458bf6b2397566b5"></a>
const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_tf_weak_base.html">TfWeakBase</a> &amp;)</td></tr>
<tr class="separator:af890ac314073e903458bf6b2397566b5 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f1e27cc0c7c606ffb397b7d970ed10 inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a16f1e27cc0c7c606ffb397b7d970ed10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EnableNotification2</b> () const</td></tr>
<tr class="separator:a16f1e27cc0c7c606ffb397b7d970ed10 inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3241c32a82fbed0716a77049f6134e1e inherit pub_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a3241c32a82fbed0716a77049f6134e1e"></a>
TF_API void const  *&#160;</td><td class="memItemRight" valign="bottom"><b>GetUniqueIdentifier</b> () const</td></tr>
<tr class="separator:a3241c32a82fbed0716a77049f6134e1e inherit pub_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a174ebee0e92922ae7256125beec8ec77"><td class="memItemLeft" align="right" valign="top"><a id="a174ebee0e92922ae7256125beec8ec77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NdrRegistry</b> (const <a class="el" href="class_ndr_registry.html">NdrRegistry</a> &amp;)=delete</td></tr>
<tr class="separator:a174ebee0e92922ae7256125beec8ec77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52beb5118749a199b34a1196e4f38b3c"><td class="memItemLeft" align="right" valign="top"><a id="a52beb5118749a199b34a1196e4f38b3c"></a>
<a class="el" href="class_ndr_registry.html">NdrRegistry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_ndr_registry.html">NdrRegistry</a> &amp;)=delete</td></tr>
<tr class="separator:a52beb5118749a199b34a1196e4f38b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_tf_weak_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_tf_weak_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_tf_weak_base.html">TfWeakBase</a></td></tr>
<tr class="memitem:a95139d2f4d04eb706664a4f47eb93918 inherit pro_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a95139d2f4d04eb706664a4f47eb93918"></a>
<a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; Tf_Remnant &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_Register</b> () const</td></tr>
<tr class="separator:a95139d2f4d04eb706664a4f47eb93918 inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memTemplParams" colspan="2"><a id="ac1312732482c8a286522f703f2cf90d1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tf_ref_ptr.html">TfRefPtr</a>&lt; Tf_Remnant &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_Register</b> (T *tempRmnt) const</td></tr>
<tr class="separator:ac1312732482c8a286522f703f2cf90d1 inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5533162e8efab1be47acd6ccd5254c inherit pro_methods_class_tf_weak_base"><td class="memItemLeft" align="right" valign="top"><a id="a6a5533162e8efab1be47acd6ccd5254c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_HasRemnant</b> () const</td></tr>
<tr class="separator:a6a5533162e8efab1be47acd6ccd5254c inherit pro_methods_class_tf_weak_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a046d72a3ef13be4806ba4cfde566a5c9"><td class="memItemLeft" align="right" valign="top"><a id="a046d72a3ef13be4806ba4cfde566a5c9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>_DiscoveryContext</b></td></tr>
<tr class="separator:a046d72a3ef13be4806ba4cfde566a5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The registry provides access to node information. </p>
<p>"Discovery Plugins" are responsible for finding the nodes that should be included in the registry.</p>
<p>Discovery plugins are found through the plugin system. If additional discovery plugins need to be specified, a client can pass them to <code><a class="el" href="class_ndr_registry.html#ab111939c2df38b3e33afd43acc018249" title="Allows the client to set any additional discovery plugins that would otherwise NOT be found through t...">SetExtraDiscoveryPlugins()</a></code>.</p>
<p>When the registry is first told about the discovery plugins, the plugins will be asked to discover nodes. These plugins will generate <code><a class="el" href="struct_ndr_node_discovery_result.html" title="Represents the raw data of a node, and some other bits of metadata, that were determined via a NdrDis...">NdrNodeDiscoveryResult</a></code> instances, which only contain basic metadata. Once the client asks for information that would require the node's contents to be parsed (eg, what its inputs and outputs are), the registry will begin the parsing process on an as-needed basis. See <code><a class="el" href="struct_ndr_node_discovery_result.html" title="Represents the raw data of a node, and some other bits of metadata, that were determined via a NdrDis...">NdrNodeDiscoveryResult</a></code> for the information that can be retrieved without triggering a parse.</p>
<p>Some methods in this library may allow for a "family" to be provided. A family is simply a generic grouping which is optional. </p>

<p class="definition">Definition at line <a class="el" href="usd_2ndr_2registry_8h_source.html#l00064">64</a> of file <a class="el" href="usd_2ndr_2registry_8h_source.html">registry.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a18b5a0d433c3c1150ee638cc1c814121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b5a0d433c3c1150ee638cc1c814121">&#9670;&nbsp;</a></span>AddDiscoveryResult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API void AddDiscoveryResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ndr_node_discovery_result.html">NdrNodeDiscoveryResult</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>discoveryResult</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the client to explicitly set additional discovery results that would otherwise NOT be found through the plugin system. </p>
<p>For example to support lazily-loaded plugins which cannot be easily discovered in advance.</p>
<p>This method will not immediately spawn a parse call which will be deferred until a GetNode*() method is called. </p>

</div>
</div>
<a id="a36b678bc03a457dbfb3773001b80b3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b678bc03a457dbfb3773001b80b3d3">&#9670;&nbsp;</a></span>AddDiscoveryResult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API void AddDiscoveryResult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ndr_node_discovery_result.html">NdrNodeDiscoveryResult</a> &amp;&#160;</td>
          <td class="paramname"><em>discoveryResult</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy version of the method above. </p>
<p>For performance reasons, one should prefer to use the rvalue reference form. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a7c451ef8b27fb5858d714b2614d1df93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c451ef8b27fb5858d714b2614d1df93">&#9670;&nbsp;</a></span>GetAllNodeSourceTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API NdrTokenVec GetAllNodeSourceTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a sorted list of all node source types that may be present on the nodes in the registry. </p>
<p>Source types originate from the discovery process, but there is no guarantee that the discovered source types will also have a registered parser plugin. The actual supported source types here depend on the parsers that are available. Also note that some parser plugins may not advertise a source type.</p>
<p>See the documentation for <code><a class="el" href="class_ndr_parser_plugin.html" title="Interface for parser plugins.">NdrParserPlugin</a></code> and <code><a class="el" href="class_ndr_node.html#a552a651875e4dbe319770af335913253" title="Gets the type of source that this node originated from.">NdrNode::GetSourceType()</a></code> for more information. </p>

</div>
</div>
<a id="a5bacc6de8683232867fa5a45121e3780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bacc6de8683232867fa5a45121e3780">&#9670;&nbsp;</a></span>GetNodeByIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API NdrNodeConstPtr GetNodeByIdentifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">NdrIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NdrTokenVec &amp;&#160;</td>
          <td class="paramname"><em>sourceTypePriority</em> = <code>NdrTokenVec()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the node with the specified <code>identifier</code>, and an optional <code>sourceTypePriority</code> list specifying the set of node SOURCE types (see <code><a class="el" href="class_ndr_node.html#a552a651875e4dbe319770af335913253" title="Gets the type of source that this node originated from.">NdrNode::GetSourceType()</a></code>) that should be searched. </p>
<p>If no sourceTypePriority is specified, the first encountered node with the specified identifier will be returned (first is arbitrary) if found.</p>
<p>If a sourceTypePriority list is specified, then this will iterate through each source type and try to find a node matching by identifier. This is equivalent to calling <a class="el" href="class_ndr_registry.html#a302de2b47bdf8af387d9273bc797f9a7" title="Get the node with the specified identifier and sourceType.">NdrRegistry::GetNodeByIdentifierAndType</a> for each source type until a node is found.</p>
<p>Nodes of the same identifier but different source type can exist in the registry. If a node 'Foo' with source types 'abc' and 'xyz' exist in the registry, and you want to make sure the 'abc' version is fetched before the 'xyz' version, the priority list would be specified as ['abc', 'xyz']. If the 'abc' version did not exist in the registry, then the 'xyz' version would be returned.</p>
<p>Returns <code>nullptr</code> if a node matching the arguments can't be found. </p>

</div>
</div>
<a id="a302de2b47bdf8af387d9273bc797f9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302de2b47bdf8af387d9273bc797f9a7">&#9670;&nbsp;</a></span>GetNodeByIdentifierAndType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API NdrNodeConstPtr GetNodeByIdentifierAndType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">NdrIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>identifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the node with the specified <code>identifier</code> and <code>sourceType</code>. </p>
<p>If there is no matching node for the sourceType, nullptr is returned. </p>

</div>
</div>
<a id="a2b78ea888fcb8cb1fd755d62d551f285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b78ea888fcb8cb1fd755d62d551f285">&#9670;&nbsp;</a></span>GetNodeByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API NdrNodeConstPtr GetNodeByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NdrTokenVec &amp;&#160;</td>
          <td class="paramname"><em>sourceTypePriority</em> = <code>NdrTokenVec()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="usd_2ndr_2declare_8h.html#a9991becacf778d59c7ff155f24383a21">NdrVersionFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>NdrVersionFilterDefaultOnly</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the node with the specified name. </p>
<p>An optional priority list specifies the set of node SOURCE types (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ndr_node.html#a552a651875e4dbe319770af335913253" title="Gets the type of source that this node originated from.">NdrNode::GetSourceType()</a>) that should be searched and in what order.</dd></dl>
<p>Optionally, a filter can be specified to consider just the default versions of nodes matching <code>name</code> (the default) or all versions of the nodes.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ndr_registry.html#a5bacc6de8683232867fa5a45121e3780" title="Get the node with the specified identifier, and an optional sourceTypePriority list specifying the se...">GetNodeByIdentifier()</a>. </dd></dl>

</div>
</div>
<a id="aa2c7d46e4adecc575c28ab686c46ff27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c7d46e4adecc575c28ab686c46ff27">&#9670;&nbsp;</a></span>GetNodeByNameAndType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API NdrNodeConstPtr GetNodeByNameAndType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="usd_2ndr_2declare_8h.html#a9991becacf778d59c7ff155f24383a21">NdrVersionFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>NdrVersionFilterDefaultOnly</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience wrapper around <code><a class="el" href="class_ndr_registry.html#a2b78ea888fcb8cb1fd755d62d551f285" title="Get the node with the specified name.">GetNodeByName()</a></code>. </p>
<p>Instead of providing a priority list, an exact type is specified, and <code>nullptr</code> is returned if a node with the exact identifier and type does not exist.</p>
<p>Optionally, a filter can be specified to consider just the default versions of nodes matching <code>name</code> (the default) or all versions of the nodes. </p>

</div>
</div>
<a id="aaadbd8fe1df4f30bb9dd2e2bb0b4970f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadbd8fe1df4f30bb9dd2e2bb0b4970f">&#9670;&nbsp;</a></span>GetNodeFromAsset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API NdrNodeConstPtr GetNodeFromAsset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sdf_asset_path.html">SdfAssetPath</a> &amp;&#160;</td>
          <td class="paramname"><em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NdrTokenMap &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>subIdentifier</em> = <code><a class="el" href="class_tf_token.html">TfToken</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceType</em> = <code><a class="el" href="class_tf_token.html">TfToken</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given <code>asset</code>, constructs a <a class="el" href="class_ndr_node.html" title="Represents an abstract node.">NdrNode</a> from it and adds it to the registry. </p>
<p>Nodes created from an asset using this API can be looked up by the unique identifier and sourceType of the returned node, or by URI, which will be set to the unresolved asset path value.</p>
<p><code>metadata</code> contains additional metadata needed for parsing and compiling the source code in the file pointed to by <code>asset</code> correctly. This metadata supplements the metadata available in the asset and overrides it in cases where there are key collisions.</p>
<p><code>subidentifier</code> is optional, and it would be used to indicate a particular definition in the asset file if the asset contains multiple node definitions.</p>
<p><code>sourceType</code> is optional, and it is only needed to indicate a particular type if the asset file is capable of representing a node definition of multiple source types.</p>
<p>Returns a valid node if the asset is parsed successfully using one of the registered parser plugins. </p>

</div>
</div>
<a id="a391e8cb4eeb3223aff3d725920830564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391e8cb4eeb3223aff3d725920830564">&#9670;&nbsp;</a></span>GetNodeFromSourceCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API NdrNodeConstPtr GetNodeFromSourceCode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sourceCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NdrTokenMap &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given <code>sourceCode</code> string, constructs a <a class="el" href="class_ndr_node.html" title="Represents an abstract node.">NdrNode</a> from it and adds it to the registry. </p>
<p>The parser to be used is determined by the specified <code>sourceType</code>.</p>
<p>Nodes created from source code using this API can be looked up by the unique identifier and sourceType of the returned node.</p>
<p><code>metadata</code> contains additional metadata needed for parsing and compiling the source code correctly. This metadata supplements the metadata available in <code>sourceCode</code> and overrides it cases where there are key collisions.</p>
<p>Returns a valid node if the given source code is parsed successfully using the parser plugins that is registered for the specified <code>sourceType</code>. </p>

</div>
</div>
<a id="ad9ea47727622f4f5cb677b487bbcfa64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ea47727622f4f5cb677b487bbcfa64">&#9670;&nbsp;</a></span>GetNodeIdentifiers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API NdrIdentifierVec GetNodeIdentifiers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>family</em> = <code><a class="el" href="class_tf_token.html">TfToken</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="usd_2ndr_2declare_8h.html#a9991becacf778d59c7ff155f24383a21">NdrVersionFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>NdrVersionFilterDefaultOnly</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the identifiers of all the nodes that the registry is aware of. </p>
<p>This will not run the parsing plugins on the nodes that have been discovered, so this method is relatively quick. Optionally, a "family" name can be specified to only get the identifiers of nodes that belong to that family and a filter can be specified to get just the default version (the default) or all versions of the node. </p>

</div>
</div>
<a id="aad5c6eb89c893e959d6e66620945295e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5c6eb89c893e959d6e66620945295e">&#9670;&nbsp;</a></span>GetNodeNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API NdrStringVec GetNodeNames </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>family</em> = <code><a class="el" href="class_tf_token.html">TfToken</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the names of all the nodes that the registry is aware of. </p>
<p>This will not run the parsing plugins on the nodes that have been discovered, so this method is relatively quick. Optionally, a "family" name can be specified to only get the names of nodes that belong to that family. </p>

</div>
</div>
<a id="a5e9a9d1947c1ba283161fc8a8121c3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9a9d1947c1ba283161fc8a8121c3d5">&#9670;&nbsp;</a></span>GetNodesByFamily()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API NdrNodeConstPtrVec GetNodesByFamily </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">TfToken</a> &amp;&#160;</td>
          <td class="paramname"><em>family</em> = <code><a class="el" href="class_tf_token.html">TfToken</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="usd_2ndr_2declare_8h.html#a9991becacf778d59c7ff155f24383a21">NdrVersionFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>NdrVersionFilterDefaultOnly</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all nodes from the registry, optionally restricted to the nodes that fall under a specified family and/or the default version. </p>
<p>Note that this will parse <em>all</em> nodes that the registry is aware of (unless a family is specified), so this may take some time to run the first time it is called. </p>

</div>
</div>
<a id="a3db1bd9c3d178aaba60718cbaba66486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db1bd9c3d178aaba60718cbaba66486">&#9670;&nbsp;</a></span>GetNodesByIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API NdrNodeConstPtrVec GetNodesByIdentifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tf_token.html">NdrIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>identifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all nodes matching the specified identifier (multiple nodes of the same identifier, but different source types, may exist). </p>
<p>If no nodes match the identifier, an empty vector is returned. </p>

</div>
</div>
<a id="a5d61c1cf418e9034439ea95681e22323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d61c1cf418e9034439ea95681e22323">&#9670;&nbsp;</a></span>GetNodesByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API NdrNodeConstPtrVec GetNodesByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="usd_2ndr_2declare_8h.html#a9991becacf778d59c7ff155f24383a21">NdrVersionFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>NdrVersionFilterDefaultOnly</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all nodes matching the specified name. </p>
<p>Only nodes matching the specified name will be parsed. Optionally, a filter can be specified to get just the default version (the default) or all versions of the node. If no nodes match an empty vector is returned. </p>

</div>
</div>
<a id="a51ca010b4493ec6ed866619be7984023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ca010b4493ec6ed866619be7984023">&#9670;&nbsp;</a></span>GetSearchURIs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API NdrStringVec GetSearchURIs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the locations where the registry is searching for nodes. </p>
<p>Depending on which discovery plugins were used, this may include non-filesystem paths. </p>

</div>
</div>
<a id="ab111939c2df38b3e33afd43acc018249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab111939c2df38b3e33afd43acc018249">&#9670;&nbsp;</a></span>SetExtraDiscoveryPlugins() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API void SetExtraDiscoveryPlugins </td>
          <td>(</td>
          <td class="paramtype">DiscoveryPluginRefPtrVec&#160;</td>
          <td class="paramname"><em>plugins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the client to set any additional discovery plugins that would otherwise NOT be found through the plugin system. </p>
<p>Runs the discovery process for the specified plugins immediately.</p>
<p>Note that this method cannot be called after any nodes in the registry have been parsed (eg, through GetNode*()), otherwise an error will result. </p>

</div>
</div>
<a id="a1eb836b69c5e2612564e9711017099d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb836b69c5e2612564e9711017099d4">&#9670;&nbsp;</a></span>SetExtraDiscoveryPlugins() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API void SetExtraDiscoveryPlugins </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pluginTypes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the client to set any additional discovery plugins that would otherwise NOT be found through the plugin system. </p>
<p>Runs the discovery process for the specified plugins immediately.</p>
<p>Note that this method cannot be called after any nodes in the registry have been parsed (eg, through GetNode*()), otherwise an error will result. </p>

</div>
</div>
<a id="ad6b6226c83cb2a771d18b8e3b46603e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b6226c83cb2a771d18b8e3b46603e8">&#9670;&nbsp;</a></span>SetExtraParserPlugins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NDR_API void SetExtraParserPlugins </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_tf_type.html">TfType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pluginTypes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the client to set any additional parser plugins that would otherwise NOT be found through the plugin system. </p>
<p>Note that this method cannot be called after any nodes in the registry have been parsed (eg, through GetNode*()), otherwise an error will result. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pxr/usd/ndr/<a class="el" href="usd_2ndr_2registry_8h_source.html">registry.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_ndr_registry.html">NdrRegistry</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:07:03 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>