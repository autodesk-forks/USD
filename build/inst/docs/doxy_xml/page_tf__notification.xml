<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="page_tf__notification" kind="page">
    <compoundname>page_tf_Notification</compoundname>
    <title>The TfNotice Notification System</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<sect1 id="page_tf__notification_1sec_tf_Notification_Contents">
<title>Contents</title>
<para><itemizedlist>
<listitem><para><ref refid="page_tf__notification_1sec_tf_Notification_Overview" kindref="member">Overview</ref> </para>
</listitem>
<listitem><para><ref refid="page_tf__notification_1sec_tf_Notification_NotificationClasses" kindref="member">Notification Classes</ref> </para>
</listitem>
<listitem><para><ref refid="page_tf__notification_1sec_tf_Notification_DeliveryMechanism" kindref="member">Delivery Mechanism</ref> </para>
</listitem>
<listitem><para><ref refid="page_tf__notification_1sec_tf_Notification_SimpleExample" kindref="member">Simple Example</ref> </para>
</listitem>
<listitem><para><ref refid="page_tf__notification_1sec_tf_Notification_ThreadSafety" kindref="member">Thread Safety</ref></para>
</listitem>
</itemizedlist>
</para>
</sect1>
<sect1 id="page_tf__notification_1sec_tf_Notification_Overview">
<title>Overview</title>
<para>The notification subsystem notifies interested objects that some important event has occurred somewhere in the application. Notices can be thought of as anonymous function calls. They are function calls in the sense that they are synchronous and efficient; they are anonymous in the sense that senders aren&apos;t aware of listeners (although listeners can choose to be aware of senders if they wish).</para>
<para>A common use of notification is for a model to notify a view that the model has changed and the view needs to be updated. (The terms model and view are used here as in the Model-View-Controller paradigm). For example, a cue sheet might send a cue-changed notification to inform an mdt-like spread sheet view to update itself. Notifications are synchronous broadcasts. The sender doesn&apos;t know who is interested in the notification and there can be many listeners for each notification. Another use of notification is in the Tf error handling mechanism. See <ref refid="class_tf_error" kindref="compound">TfError</ref> for more details.</para>
</sect1>
<sect1 id="page_tf__notification_1sec_tf_Notification_NotificationClasses">
<title>Notification Classes</title>
<para>The notification subsystem exports one class, named <ref refid="class_tf_notice" kindref="compound">TfNotice</ref>. This class is used to represent the arguments to the anonymous function call. The <ref refid="class_tf_notice" kindref="compound">TfNotice</ref> base class is the class from which all notifications are derived. Notifications are intended to encapsulate information about some event that is important to the application. Each derived notification class should provide the most specific information possible that describes the event. For example, a cue-changed notification class should contain a pointer to the avar that changed.</para>
<para>As the example below indicates, notices associated with changes to a model are part of the model&apos;s public interface. Accordingly, these types of notices should be designed carefully and changed infrequently.</para>
</sect1>
<sect1 id="page_tf__notification_1sec_tf_Notification_DeliveryMechanism">
<title>Delivery Mechanism</title>
<para>A sender issues a notice by constructing a new notice object (derived from the <ref refid="class_tf_notice" kindref="compound">TfNotice</ref> class) and invoking the Send() method to have the notice delivered to all interested listeners. The notification system synchronously invokes each interested listener (in arbitrary order), then returns control to the sender. An implication of synchronicity is that the listeners are run in the sender&apos;s thread. Another implication is that listeners should be as efficient as possible to avoid unnecessary slowdowns.</para>
</sect1>
<sect1 id="page_tf__notification_1sec_tf_Notification_SimpleExample">
<title>Simple Example</title>
<para>The following code sample illustrates the use of notification where a cue-changed notice is received by a listener associated with the user interface of an interactive application. The cue library defines the CueAvarChangedNotice class in cue.h:</para>
<para><programlisting><codeline><highlight class="normal">class<sp/>CueAvarChangedNotice<sp/>:<sp/>public<sp/>TfNotice<sp/></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CueAvarChangedNotice(const<sp/>Cue<sp/>*whichCue,<sp/>const<sp/>std::string<sp/>&amp;whichAvar);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Cue<sp/>*GetCue()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>std::string<sp/>GetAvar()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::string<sp/>_avar;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Cue<sp/>*_cue;<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>Observe that the new notice class registers itself with the <ref refid="class_tf_type" kindref="compound">TfType</ref> type-system; this is required so that registration of interest in a class N results in a listener receiving notice of type N as well as notices of any type derived from N.</para>
<para>Let us say that you define a class that needs to know when the cue changes. In the following example, this class is interested in all notices, and in particular is interested in cue change notices.</para>
<para><programlisting><codeline><highlight class="normal">class<sp/>UIListener<sp/>:<sp/>public<sp/>TfWeakBase<sp/></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>UIListener()<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TfWeakPtr&lt;UIListener&gt;<sp/>me(this);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TfNotice::Register(me,<sp/>&amp;UIListener::ProcessCueChange);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TfNotice::Register(me,<sp/>&amp;UIListener::ProcessAllNotices);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>ProcessCueChange(const<sp/>CueChangeNotice<sp/>&amp;n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>ProcessAllNotices(const<sp/>TfNotice<sp/>&amp;n);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>When this listener class is initialized, it uses the templated free function <ref refid="class_tf_notice_1a68c24dba64e7a7135f62d1bdab33ca7f" kindref="member">TfNotice::Register</ref> to register interest in any notice class derived from CueChangeNotice. When such a notice is sent, the ProcessCueChange() method should be called. In this example, <ref refid="class_tf_notice_1a68c24dba64e7a7135f62d1bdab33ca7f" kindref="member">TfNotice::Register</ref> is used a second time to indicate that the ProcessAllNotices() method should be called whenever a notice derived from <ref refid="class_tf_notice" kindref="compound">TfNotice</ref> (that is, any kind of notice at all) is sent.</para>
<para>Note that a UIListener has no way of indicating that it no longer wishes to receive messages. If your class needs the ability to turn listening on and off, see <ref refid="class_tf_notice_1ab183e05189affeabc78270a9c1be4241" kindref="member">TfNotice::Revoke()</ref> for more information. However, note that it is always safe for a listener to simply be deleted without informing the <ref refid="class_tf_notice" kindref="compound">TfNotice</ref> system (but see also <ref refid="page_tf__notification_1sec_tf_Notification_ThreadSafety" kindref="member">Thread Safety</ref> below).</para>
<para>Now that every thing is initialized you can get down to changing the cue. The cue class member function that changes the avar sends the notice as follows (in cue.cpp):</para>
<para><programlisting><codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Tell<sp/>the<sp/>Tf<sp/>type<sp/>system<sp/>to<sp/>instanciate<sp/>the<sp/>type.<sp/>This</highlight></codeline>
<codeline><highlight class="normal">//<sp/>must<sp/>be<sp/>done<sp/>in<sp/>a<sp/>single<sp/>.cpp<sp/>file.</highlight></codeline>
<codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">TF_INSTANTIATE_TYPE(CueChangedNotice,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TfType::CONCRETE,<sp/>TF_1_PARENT(TfNotice));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">Cue::_ChangeAvar(const<sp/>string<sp/>&amp;avarName,<sp/>double<sp/>t,<sp/>double<sp/>v)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>the<sp/>avar<sp/>changing<sp/>code<sp/>goes<sp/>here</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>notify<sp/>listeners<sp/>that<sp/>this<sp/>avar<sp/>has<sp/>changed</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CueChangedNotice(this,<sp/>avar).Send();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<sect2 id="page_tf__notification_1sec_tf_Notification_ThreadSafety">
<title>Thread Safety</title>
<para>A listening object receives notices in the same thread that a notice is sent from. Thus, a listener object might call <ref refid="class_tf_notice_1a68c24dba64e7a7135f62d1bdab33ca7f" kindref="member">TfNotice::Register()</ref> in thread A, but have its notice-receiving method called in threads B and C, possibly even simultaneously. Finally, if a listening object receives a notice while being deleted, bad things can (and will) happen.</para>
<para>If you know that thread-safety is not a concern (that is, your listening object will only receive notices in one thread, and your listening object will only be deleted in that thread), then your listener object can simply derive off of <ref refid="class_tf_weak_base" kindref="compound">TfWeakBase</ref>. However, if thread-safety is a concern, there are two issues to worry about.</para>
<para>First, if your listening object receives more than one notice at the same time and that is a problem, you will need to add locking behavior into your object&apos;s method calls.</para>
<para>Second, if you are worried that your listener object might be deleted while in the middle of receiving a notice call, then you need to make your listening object support both <ref refid="class_tf_ref_ptr" kindref="compound">TfRefPtr</ref> and <ref refid="class_tf_weak_ptr" kindref="compound">TfWeakPtr</ref>. That is, your object must derive from <ref refid="class_tf_weak_base" kindref="compound">TfWeakBase</ref> <emphasis>and</emphasis> <ref refid="class_tf_ref_base" kindref="compound">TfRefBase</ref> (one of the rarely allowed cases on concrete multiple inheritance) and should only be accessed through these smart pointers. Additionally, you must register your listener using TfNotice::RegisterDeletionSafe().</para>
<para>The above actions furnish a guarantee against untimely deletion, because the notification center prevents a listener from being destroyed while receiving a notice, by temporarily creating a <ref refid="class_tf_ref_ptr" kindref="compound">TfRefPtr</ref> pointing to the object. (In between notices, the notification center points to the listener only by a <ref refid="class_tf_weak_ptr" kindref="compound">TfWeakPtr</ref>, which allows the listener to destruct when not in use). </para>
</sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
