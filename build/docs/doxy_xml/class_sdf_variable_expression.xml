<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="class_sdf_variable_expression" kind="class" language="C++" prot="public">
    <compoundname>SdfVariableExpression</compoundname>
    <includes refid="variable_expression_8h" local="no">variableExpression.h</includes>
    <innerclass refid="class_sdf_variable_expression_1_1_empty_list" prot="public">SdfVariableExpression::EmptyList</innerclass>
    <innerclass refid="class_sdf_variable_expression_1_1_result" prot="public">SdfVariableExpression::Result</innerclass>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_sdf_variable_expression_1adf34becd04edb23d3dedc330b8e561bf" prot="private" static="no" mutable="no">
        <type>std::vector&lt; std::string &gt;</type>
        <definition>std::vector&lt;std::string&gt; _errors</definition>
        <argsstring></argsstring>
        <name>_errors</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/variableExpression.h" line="231" column="1" bodyfile="pxr/usd/sdf/variableExpression.h" bodystart="231" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_sdf_variable_expression_1a62f3ca0e01d73e72368bad77a76490c1" prot="private" static="no" mutable="no">
        <type>std::shared_ptr&lt; Sdf_VariableExpressionImpl::Node &gt;</type>
        <definition>std::shared_ptr&lt;Sdf_VariableExpressionImpl::Node&gt; _expression</definition>
        <argsstring></argsstring>
        <name>_expression</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/variableExpression.h" line="232" column="1" bodyfile="pxr/usd/sdf/variableExpression.h" bodystart="232" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_sdf_variable_expression_1a86b17b001f122af6fb99c98da60b9aa4" prot="private" static="no" mutable="no">
        <type>std::string</type>
        <definition>std::string _expressionStr</definition>
        <argsstring></argsstring>
        <name>_expressionStr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/variableExpression.h" line="233" column="1" bodyfile="pxr/usd/sdf/variableExpression.h" bodystart="233" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="class_sdf_variable_expression_1abb2b7a05988d9d40a3a00cb52bc79b45" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type>SDF_API</type>
        <definition>SDF_API SdfVariableExpression</definition>
        <argsstring>(const std::string &amp;expr)</argsstring>
        <name>SdfVariableExpression</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
<para>Construct using the expression <computeroutput>expr</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>If the expression cannot be parsed, this object represents an invalid expression. Parsing errors will be accessible via GetErrors. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/variableExpression.h" line="87" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_variable_expression_1a14e2aaea26d7ad91fb4173ab2b0b0517" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API</type>
        <definition>SDF_API SdfVariableExpression</definition>
        <argsstring>()</argsstring>
        <name>SdfVariableExpression</name>
        <briefdescription>
<para>Construct an object representing an invalid expression. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/variableExpression.h" line="91" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_variable_expression_1a1a1c93c30dda6c015187c7cf7d84e3e0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API</type>
        <definition>SDF_API ~SdfVariableExpression</definition>
        <argsstring>()</argsstring>
        <name>~SdfVariableExpression</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/variableExpression.h" line="94" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_variable_expression_1acab00c9d46b75026bd44343da9e738bd" prot="public" static="no" const="yes" explicit="yes" inline="no" virt="non-virtual">
        <type>SDF_API</type>
        <definition>SDF_API operator bool</definition>
        <argsstring>() const</argsstring>
        <name>operator bool</name>
        <briefdescription>
<para>Returns true if this object represents a valid expression, false if it represents an invalid expression. </para>
        </briefdescription>
        <detaileddescription>
<para>A return value of true does not mean that evaluation of this expression is guaranteed to succeed. For example, an expression may refer to a variable whose value is an invalid expression. Errors like this can only be discovered by calling Evaluate. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/variableExpression.h" line="123" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_variable_expression_1af4d60b0568603a696ac239b362d25417" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API const std::string &amp;</type>
        <definition>SDF_API const std::string&amp; GetString</definition>
        <argsstring>() const</argsstring>
        <name>GetString</name>
        <briefdescription>
<para>Returns the expression string used to construct this object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/variableExpression.h" line="127" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_variable_expression_1aec398850f058d0e98b2e489c371aaf7d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API const std::vector&lt; std::string &gt; &amp;</type>
        <definition>SDF_API const std::vector&lt;std::string&gt;&amp; GetErrors</definition>
        <argsstring>() const</argsstring>
        <name>GetErrors</name>
        <briefdescription>
<para>Returns a list of errors encountered when parsing this expression. </para>
        </briefdescription>
        <detaileddescription>
<para>If the expression was parsed successfully, this list will be empty. However, additional errors may be encountered when evaluating the e expression. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/variableExpression.h" line="135" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_variable_expression_1a7bd4db31fe75b7f86888f4e5d7250b0f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API Result</type>
        <definition>SDF_API Result Evaluate</definition>
        <argsstring>(const VtDictionary &amp;variables) const</argsstring>
        <name>Evaluate</name>
        <param>
          <type>const <ref refid="class_vt_dictionary" kindref="compound">VtDictionary</ref> &amp;</type>
          <declname>variables</declname>
        </param>
        <briefdescription>
<para>Evaluates this expression using the variables in <computeroutput>variables</computeroutput> and returns a Result object with the final value. </para>
        </briefdescription>
        <detaileddescription>
<para>If an error occurs during evaluation, the value field in the Result object will be an empty <ref refid="class_vt_value" kindref="compound">VtValue</ref> and error messages will be added to the errors field.</para>
<para>If the expression evaluates to an empty list, the value field in the Result object will contain an <ref refid="class_sdf_variable_expression_1_1_empty_list" kindref="compound">EmptyList</ref> object instead of an empty VtArray&lt;T&gt;, as the expression language does not provide syntax for specifying the expected element types in an empty list.</para>
<para>If this object represents an invalid expression, calling this function will return a Result object with an empty value and the errors from <ref refid="class_sdf_variable_expression_1aec398850f058d0e98b2e489c371aaf7d" kindref="member">GetErrors()</ref>.</para>
<para>If any values in <computeroutput>variables</computeroutput> used by this expression are themselves expressions, they will be parsed and evaluated. If an error occurs while evaluating any of these subexpressions, evaluation of this expression fails and the encountered errors will be added in the Result&apos;s list of errors. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/variableExpression.h" line="190" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_variable_expression_1a98283c527aabeb8cd67ae2fa765aa3c6" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ResultType</type>
          </param>
        </templateparamlist>
        <type>Result</type>
        <definition>Result EvaluateTyped</definition>
        <argsstring>(const VtDictionary &amp;variables) const</argsstring>
        <name>EvaluateTyped</name>
        <param>
          <type>const <ref refid="class_vt_dictionary" kindref="compound">VtDictionary</ref> &amp;</type>
          <declname>variables</declname>
        </param>
        <briefdescription>
<para>Evaluates this expression using the variables in <computeroutput>variables</computeroutput> and returns a Result object with the final value. </para>
        </briefdescription>
        <detaileddescription>
<para>This is a convenience function that calls Evaluate and ensures that the value in the Result object is either an empty <ref refid="class_vt_value" kindref="compound">VtValue</ref> or is holding the specified ResultType. If this is not the case, the Result value will be set to an empty <ref refid="class_vt_value" kindref="compound">VtValue</ref> an error message indicating the unexpected type will be added to the Result&apos;s error list. Otherwise, the Result will be returned as-is.</para>
<para>If the expression evaluates to an empty list and the ResultType is a VtArray&lt;T&gt;, the value in the Result object will be an empty VtArray&lt;T&gt;. This differs from Evaluate, which would return an untyped <ref refid="class_sdf_variable_expression_1_1_empty_list" kindref="compound">EmptyList</ref> object instead.</para>
<para>ResultType must be one of the supported types listed in the class documentation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/variableExpression.h" line="211" column="1" bodyfile="pxr/usd/sdf/variableExpression.h" bodystart="211" bodyend="224"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="class_sdf_variable_expression_1a11fbe441f835692840dd82089b121c20" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API bool</type>
        <definition>static SDF_API bool IsExpression</definition>
        <argsstring>(const std::string &amp;s)</argsstring>
        <name>IsExpression</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>Returns true if <computeroutput>s</computeroutput> is a variable expression, false otherwise. </para>
        </briefdescription>
        <detaileddescription>
<para>A variable expression is a string surrounded by backticks (`).</para>
<para>A return value of true does not guarantee that <computeroutput>s</computeroutput> is a valid expression. This function is meant to be used as an initial check to determine if a string should be considered as an expression. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/variableExpression.h" line="103" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sdf_variable_expression_1a5905a88fba9c8ff1b1dc2d71583ee84c" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API bool</type>
        <definition>static SDF_API bool IsValidVariableType</definition>
        <argsstring>(const VtValue &amp;value)</argsstring>
        <name>IsValidVariableType</name>
        <param>
          <type>const <ref refid="class_vt_value" kindref="compound">VtValue</ref> &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Returns true if <computeroutput>value</computeroutput> holds a type that is supported by variable expressions, false otherwise. </para>
        </briefdescription>
        <detaileddescription>
<para>If this function returns true, <computeroutput>value</computeroutput> may be used for an expression variable supplied to the Evaluate function. <computeroutput>value</computeroutput> may also be authored into the &apos;expressionVariables&apos; dictionary, unless it is an empty <ref refid="class_vt_value" kindref="compound">VtValue</ref> representing the None value. See class documentation for list of supported types. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/variableExpression.h" line="113" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-static-func">
      <memberdef kind="function" id="class_sdf_variable_expression_1ab2561f3cddeb1768b5dff68fb9c2287e" prot="private" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>SDF_API std::string</type>
        <definition>static SDF_API std::string _FormatUnexpectedTypeError</definition>
        <argsstring>(const VtValue &amp;got, const VtValue &amp;expected)</argsstring>
        <name>_FormatUnexpectedTypeError</name>
        <param>
          <type>const <ref refid="class_vt_value" kindref="compound">VtValue</ref> &amp;</type>
          <declname>got</declname>
        </param>
        <param>
          <type>const <ref refid="class_vt_value" kindref="compound">VtValue</ref> &amp;</type>
          <declname>expected</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/usd/sdf/variableExpression.h" line="229" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Class responsible for parsing and evaluating variable expressions. </para>
    </briefdescription>
    <detaileddescription>
<para>Variable expressions are written in a custom language and represented in scene description as a string surrounded by backticks (`). These expressions may refer to &quot;expression variables&quot;, which are key-value pairs provided by clients. For example, when evaluating an expression like:</para>
<para><programlisting><codeline><highlight class="normal">`&quot;a_${NAME}_string&quot;`</highlight></codeline>
</programlisting></para>
<para>The &quot;${NAME}&quot; portion of the string with the value of expression variable &quot;NAME&quot;.</para>
<para>Expression variables may be any of these supported types:</para>
<para><itemizedlist>
<listitem><para>std::string</para>
</listitem><listitem><para>int64_t (int is accepted but coerced to int64_t)</para>
</listitem><listitem><para>bool</para>
</listitem><listitem><para>VtArrays containing any of the above types.</para>
</listitem><listitem><para>None (represented by an empty <ref refid="class_vt_value" kindref="compound">VtValue</ref>)</para>
</listitem></itemizedlist>
</para>
<para>Expression variables are typically authored in scene description as layer metadata under the &apos;expressionVariables&apos; field. Higher levels of the system (e.g., composition) are responsible for examining fields that support variable expressions, evaluating them with the appropriate variables (via this class) and consuming the results.</para>
<para>See <ref refid="_sdf__page__variable_expressions" kindref="compound">Variable Expressions</ref> or more information on the expression language and areas of the system where expressions may be used. </para>
    </detaileddescription>
    <location file="pxr/usd/sdf/variableExpression.h" line="81" column="1" bodyfile="pxr/usd/sdf/variableExpression.h" bodystart="80" bodyend="234"/>
    <listofallmembers>
      <member refid="class_sdf_variable_expression_1adf34becd04edb23d3dedc330b8e561bf" prot="private" virt="non-virtual"><scope>SdfVariableExpression</scope><name>_errors</name></member>
      <member refid="class_sdf_variable_expression_1a62f3ca0e01d73e72368bad77a76490c1" prot="private" virt="non-virtual"><scope>SdfVariableExpression</scope><name>_expression</name></member>
      <member refid="class_sdf_variable_expression_1a86b17b001f122af6fb99c98da60b9aa4" prot="private" virt="non-virtual"><scope>SdfVariableExpression</scope><name>_expressionStr</name></member>
      <member refid="class_sdf_variable_expression_1ab2561f3cddeb1768b5dff68fb9c2287e" prot="private" virt="non-virtual"><scope>SdfVariableExpression</scope><name>_FormatUnexpectedTypeError</name></member>
      <member refid="class_sdf_variable_expression_1a7bd4db31fe75b7f86888f4e5d7250b0f" prot="public" virt="non-virtual"><scope>SdfVariableExpression</scope><name>Evaluate</name></member>
      <member refid="class_sdf_variable_expression_1a98283c527aabeb8cd67ae2fa765aa3c6" prot="public" virt="non-virtual"><scope>SdfVariableExpression</scope><name>EvaluateTyped</name></member>
      <member refid="class_sdf_variable_expression_1aec398850f058d0e98b2e489c371aaf7d" prot="public" virt="non-virtual"><scope>SdfVariableExpression</scope><name>GetErrors</name></member>
      <member refid="class_sdf_variable_expression_1af4d60b0568603a696ac239b362d25417" prot="public" virt="non-virtual"><scope>SdfVariableExpression</scope><name>GetString</name></member>
      <member refid="class_sdf_variable_expression_1a11fbe441f835692840dd82089b121c20" prot="public" virt="non-virtual"><scope>SdfVariableExpression</scope><name>IsExpression</name></member>
      <member refid="class_sdf_variable_expression_1a5905a88fba9c8ff1b1dc2d71583ee84c" prot="public" virt="non-virtual"><scope>SdfVariableExpression</scope><name>IsValidVariableType</name></member>
      <member refid="class_sdf_variable_expression_1acab00c9d46b75026bd44343da9e738bd" prot="public" virt="non-virtual"><scope>SdfVariableExpression</scope><name>operator bool</name></member>
      <member refid="class_sdf_variable_expression_1abb2b7a05988d9d40a3a00cb52bc79b45" prot="public" virt="non-virtual"><scope>SdfVariableExpression</scope><name>SdfVariableExpression</name></member>
      <member refid="class_sdf_variable_expression_1a14e2aaea26d7ad91fb4173ab2b0b0517" prot="public" virt="non-virtual"><scope>SdfVariableExpression</scope><name>SdfVariableExpression</name></member>
      <member refid="class_sdf_variable_expression_1a1a1c93c30dda6c015187c7cf7d84e3e0" prot="public" virt="non-virtual"><scope>SdfVariableExpression</scope><name>~SdfVariableExpression</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
