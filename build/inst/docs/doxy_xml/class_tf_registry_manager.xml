<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="class_tf_registry_manager" kind="class" language="C++" prot="public">
    <compoundname>TfRegistryManager</compoundname>
    <includes refid="registry_manager_8h" local="no">registryManager.h</includes>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="class_tf_registry_manager_1a35db78dfafacd6c0a8541239d3bf0488" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* RegistrationFunctionType) (void *, void *)</definition>
        <argsstring>)(void *, void *)</argsstring>
        <name>RegistrationFunctionType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/registryManager.h" line="54" column="1" bodyfile="pxr/base/tf/registryManager.h" bodystart="54" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="class_tf_registry_manager_1a8f9ec3a813130c640cd6bba2a45bbf04" prot="public" static="no">
        <type>std::function&lt; void()&gt;</type>
        <definition>typedef std::function&lt;void ()&gt; UnloadFunctionType</definition>
        <argsstring></argsstring>
        <name>UnloadFunctionType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/registryManager.h" line="55" column="1" bodyfile="pxr/base/tf/registryManager.h" bodystart="55" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="class_tf_registry_manager_1a737770f6a3af1712995d9949da01dbb2" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>TfRegistryManager</definition>
        <argsstring>(const TfRegistryManager &amp;)=delete</argsstring>
        <name>TfRegistryManager</name>
        <param>
          <type>const <ref refid="class_tf_registry_manager" kindref="compound">TfRegistryManager</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/registryManager.h" line="49" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_registry_manager_1a9abe0a818afafa1c922b333084f7b295" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="class_tf_registry_manager" kindref="compound">TfRegistryManager</ref> &amp;</type>
        <definition>TfRegistryManager&amp; operator=</definition>
        <argsstring>(const TfRegistryManager &amp;)=delete</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="class_tf_registry_manager" kindref="compound">TfRegistryManager</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/registryManager.h" line="50" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_registry_manager_1a649bc653359990ca516804b9fc13d36b" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API</type>
        <definition>TF_API TfRegistryManager</definition>
        <argsstring>()</argsstring>
        <name>TfRegistryManager</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/registryManager.h" line="116" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_registry_manager_1a58689f4bc23a866092183561ef30414b" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API</type>
        <definition>TF_API ~TfRegistryManager</definition>
        <argsstring>()</argsstring>
        <name>~TfRegistryManager</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/registryManager.h" line="117" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_registry_manager_1a41584089581b95ab90ee1debe1b819f9" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API void</type>
        <definition>TF_API void _SubscribeTo</definition>
        <argsstring>(const std::type_info &amp;)</argsstring>
        <name>_SubscribeTo</name>
        <param>
          <type>const std::type_info &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/registryManager.h" line="119" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_registry_manager_1a67e1c3ea30d14f6161d6ddd8e5564cfe" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API void</type>
        <definition>TF_API void _UnsubscribeFrom</definition>
        <argsstring>(const std::type_info &amp;)</argsstring>
        <name>_UnsubscribeFrom</name>
        <param>
          <type>const std::type_info &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/registryManager.h" line="120" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="class_tf_registry_manager_1a0c26566e590d0fefdbb5c1d6470e0244" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API <ref refid="class_tf_registry_manager" kindref="compound">TfRegistryManager</ref> &amp;</type>
        <definition>static TF_API TfRegistryManager&amp; GetInstance</definition>
        <argsstring>()</argsstring>
        <name>GetInstance</name>
        <briefdescription>
<para>Return the singleton <computeroutput><ref refid="class_tf_registry_manager" kindref="compound">TfRegistryManager</ref></computeroutput> instance. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/registryManager.h" line="58" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_registry_manager_1a87f673d669eddee8aca258a70104c81d" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API void</type>
        <definition>static TF_API void RunUnloadersAtExit</definition>
        <argsstring>()</argsstring>
        <name>RunUnloadersAtExit</name>
        <briefdescription>
<para>Run unload functions program exit time. </para>
        </briefdescription>
        <detaileddescription>
<para>The functions added by <computeroutput><ref refid="class_tf_registry_manager_1a73d6da3ea581776ba21c307e463cc23f" kindref="member">AddFunctionForUnload()</ref></computeroutput> are normally not run when a program exits. For debugging purposes (e.g. checking for memory leaks) it may be desirable to run the functions even at program exit time. This call will force functions to be run at program exit time.</para>
<para>Note that this call does not cause construction of the singleton <computeroutput><ref refid="class_tf_registry_manager" kindref="compound">TfRegistryManager</ref></computeroutput> object if it does not already exist. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/registryManager.h" line="113" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="class_tf_registry_manager_1aa8dae7698202454aac66be4be3c21a5f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void SubscribeTo</definition>
        <argsstring>()</argsstring>
        <name>SubscribeTo</name>
        <briefdescription>
<para>Request that any initialization for service <computeroutput>T</computeroutput> be performed. </para>
        </briefdescription>
        <detaileddescription>
<para>Calling <computeroutput><ref refid="class_tf_registry_manager_1aa8dae7698202454aac66be4be3c21a5f" kindref="member">SubscribeTo&lt;T&gt;()</ref></computeroutput> causes all existing <computeroutput><ref refid="registry_manager_8h_1ab1604c7efa4277ed6ee17fddaf70075f" kindref="member">TF_REGISTRY_FUNCTION()</ref></computeroutput> functions of type <computeroutput>T</computeroutput> to be run. Once this call is made, when new code is dynamically loaded then any <computeroutput><ref refid="registry_manager_8h_1ab1604c7efa4277ed6ee17fddaf70075f" kindref="member">TF_REGISTRY_FUNCTION()</ref></computeroutput> functions of type <computeroutput>T</computeroutput> in the new code will automatically be run when the code is loaded. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/registryManager.h" line="68" column="1" bodyfile="pxr/base/tf/registryManager.h" bodystart="68" bodyend="70"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_registry_manager_1ab10386b343e3b59e339a477d7da75a84" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void UnsubscribeFrom</definition>
        <argsstring>()</argsstring>
        <name>UnsubscribeFrom</name>
        <briefdescription>
<para>Cancel any previous subscriptions to service <computeroutput>T</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>After this call, newly added code will no longer have <computeroutput><ref refid="registry_manager_8h_1ab1604c7efa4277ed6ee17fddaf70075f" kindref="member">TF_REGISTRY_FUNCTION()</ref></computeroutput> functions of type <computeroutput>T</computeroutput> run. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/registryManager.h" line="77" column="1" bodyfile="pxr/base/tf/registryManager.h" bodystart="77" bodyend="79"/>
      </memberdef>
      <memberdef kind="function" id="class_tf_registry_manager_1a73d6da3ea581776ba21c307e463cc23f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_API bool</type>
        <definition>TF_API bool AddFunctionForUnload</definition>
        <argsstring>(const UnloadFunctionType &amp;)</argsstring>
        <name>AddFunctionForUnload</name>
        <param>
          <type>const UnloadFunctionType &amp;</type>
        </param>
        <briefdescription>
<para>Add an action to be performed at code unload time. </para>
        </briefdescription>
        <detaileddescription>
<para>When a <computeroutput><ref refid="registry_manager_8h_1ab1604c7efa4277ed6ee17fddaf70075f" kindref="member">TF_REGISTRY_FUNCTION()</ref></computeroutput> is run, it often needs to register an inverse action to be taken when the code containing that function is unloaded. For example, a plugin that adds information to a registry will typically want to remove that information when the registry is unloaded.</para>
<para>Calling <computeroutput><ref refid="class_tf_registry_manager_1a73d6da3ea581776ba21c307e463cc23f" kindref="member">AddFunctionForUnload()</ref></computeroutput> requests that the given function be run if the code from which the function is called is unloaded. However, this is detectable only if this call is made from within the call chain of some <computeroutput><ref refid="registry_manager_8h_1ab1604c7efa4277ed6ee17fddaf70075f" kindref="member">TF_REGISTRY_FUNCTION()</ref></computeroutput> function. In this case, <computeroutput><ref refid="class_tf_registry_manager_1a73d6da3ea581776ba21c307e463cc23f" kindref="member">AddFunctionForUnload()</ref></computeroutput> returns true. Otherwise, false is returned and the function is never run.</para>
<para>Note however that by default, no unload functions are run when code is being unloaded because exit() has been called. This is an optimization, because most registries don&apos;t need to be deconstructed at exit time. This behavior can be changed by calling <computeroutput><ref refid="class_tf_registry_manager_1a87f673d669eddee8aca258a70104c81d" kindref="member">RunUnloadersAtExit()</ref></computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="pxr/base/tf/registryManager.h" line="101" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Manage initialization of registries. </para>
    </briefdescription>
    <detaileddescription>
<para>See <ref refid="page_tf__registry_manager" kindref="compound">The TfRegistryManager Registry Initialization System</ref> for a detailed description. </para>
    </detaileddescription>
    <location file="pxr/base/tf/registryManager.h" line="48" column="1" bodyfile="pxr/base/tf/registryManager.h" bodystart="48" bodyend="121"/>
    <listofallmembers>
      <member refid="class_tf_registry_manager_1a41584089581b95ab90ee1debe1b819f9" prot="private" virt="non-virtual"><scope>TfRegistryManager</scope><name>_SubscribeTo</name></member>
      <member refid="class_tf_registry_manager_1a67e1c3ea30d14f6161d6ddd8e5564cfe" prot="private" virt="non-virtual"><scope>TfRegistryManager</scope><name>_UnsubscribeFrom</name></member>
      <member refid="class_tf_registry_manager_1a73d6da3ea581776ba21c307e463cc23f" prot="public" virt="non-virtual"><scope>TfRegistryManager</scope><name>AddFunctionForUnload</name></member>
      <member refid="class_tf_registry_manager_1a0c26566e590d0fefdbb5c1d6470e0244" prot="public" virt="non-virtual"><scope>TfRegistryManager</scope><name>GetInstance</name></member>
      <member refid="class_tf_registry_manager_1a9abe0a818afafa1c922b333084f7b295" prot="private" virt="non-virtual"><scope>TfRegistryManager</scope><name>operator=</name></member>
      <member refid="class_tf_registry_manager_1a35db78dfafacd6c0a8541239d3bf0488" prot="public" virt="non-virtual"><scope>TfRegistryManager</scope><name>RegistrationFunctionType</name></member>
      <member refid="class_tf_registry_manager_1a87f673d669eddee8aca258a70104c81d" prot="public" virt="non-virtual"><scope>TfRegistryManager</scope><name>RunUnloadersAtExit</name></member>
      <member refid="class_tf_registry_manager_1aa8dae7698202454aac66be4be3c21a5f" prot="public" virt="non-virtual"><scope>TfRegistryManager</scope><name>SubscribeTo</name></member>
      <member refid="class_tf_registry_manager_1a737770f6a3af1712995d9949da01dbb2" prot="private" virt="non-virtual"><scope>TfRegistryManager</scope><name>TfRegistryManager</name></member>
      <member refid="class_tf_registry_manager_1a649bc653359990ca516804b9fc13d36b" prot="private" virt="non-virtual"><scope>TfRegistryManager</scope><name>TfRegistryManager</name></member>
      <member refid="class_tf_registry_manager_1a8f9ec3a813130c640cd6bba2a45bbf04" prot="public" virt="non-virtual"><scope>TfRegistryManager</scope><name>UnloadFunctionType</name></member>
      <member refid="class_tf_registry_manager_1ab10386b343e3b59e339a477d7da75a84" prot="public" virt="non-virtual"><scope>TfRegistryManager</scope><name>UnsubscribeFrom</name></member>
      <member refid="class_tf_registry_manager_1a58689f4bc23a866092183561ef30414b" prot="private" virt="non-virtual"><scope>TfRegistryManager</scope><name>~TfRegistryManager</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
