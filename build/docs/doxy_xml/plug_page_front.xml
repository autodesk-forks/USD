<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="plug_page_front" kind="page">
    <compoundname>plug_page_front</compoundname>
    <title>Plug: Plugin Framework</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<sect1 id="plug_page_front_1Overview">
<title>Overview</title>
<para>Provides a plug-in framework implementation. The <ref refid="class_plug_plugin" kindref="compound">PlugPlugin</ref> class defines the interface to plug-in modules. The <ref refid="class_plug_registry" kindref="compound">PlugRegistry</ref> class defines a mechanism for discovering and registering plug-in modules both automatically upon first use and manually at run-time by client calls to <ref refid="class_plug_registry_1ada54bcdd334de360eddab430894dd5ac" kindref="member">PlugRegistry::RegisterPlugins</ref>. <ref refid="class_plug_registry" kindref="compound">PlugRegistry</ref> sends the <ref refid="class_plug_notice_1_1_did_register_plugins" kindref="compound">PlugNotice::DidRegisterPlugins</ref> notice when new plug-ins are registered (both when Plug is first used and again for subsequent calls to <ref refid="class_plug_registry_1ada54bcdd334de360eddab430894dd5ac" kindref="member">PlugRegistry::RegisterPlugins</ref>).</para>
<para><ref refid="class_plug_registry" kindref="compound">PlugRegistry</ref> also provides a mechanism to find <ref refid="class_tf_type" kindref="compound">TfType</ref> objects for types defined in plug-ins, then find the plug-ins that provide those types, and read metadata related to those plug-ins and the contained types, and load the plug-ins.</para>
<para>The <ref refid="class_plug_plugin" kindref="compound">PlugPlugin</ref> class contains properties that indicate whether or not a plug-in is currently loaded and whether a plug-in is a Python module or a C++ shared library. It also includes functions that return a plug-in&apos;s name, location in the file system, the names of its base classes, its metadata, and any existing dependencies.</para>
</sect1>
<sect1 id="plug_page_front_1Plug_Discovery">
<title>Plug-In Discovery &amp; Registration</title>
<para>The <ref refid="class_plug_registry" kindref="compound">PlugRegistry</ref> class discovers plug-ins both on first use and in response to calls to <ref refid="class_plug_registry_1ada54bcdd334de360eddab430894dd5ac" kindref="member">PlugRegistry::RegisterPlugins</ref>. This means that plugin-dependent code should listen to the <ref refid="class_plug_notice_1_1_did_register_plugins" kindref="compound">PlugNotice::DidRegisterPlugins</ref> notification in order to update appropriately if new plugins are registered during the course of a running program.</para>
</sect1>
<sect1 id="plug_page_front_1Usage">
<title>Usage</title>
<para>For information on how to add concrete plug-in types to applications like Presto, see the API documentation for the libraries that implement functionality for those types of components. For example, the Mf library includes functions for registering prim plug-ins; the Wd library includes functions for registering GUI components such as editor plug-ins.</para>
</sect1>
<sect1 id="plug_page_front_1Plug-In">
<title>Metadata</title>
<para>Plug-ins are found and described using plugInfo.json files that may be read without loading the plugin. The structure of a plugInfo.json file is described in detail in the <ref refid="class_plug_registry_1plug_plugInfo" kindref="member">PlugRegistry class</ref>. </para>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
