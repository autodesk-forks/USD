<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="_usd_skel__intro" kind="page">
    <compoundname>UsdSkel_Intro</compoundname>
    <title>UsdSkel Introduction</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<sect1 id="_usd_skel__intro_1UsdSkel_ScopeAndIntent">
<title>Overview and Purpose</title>
<para>UsdSkel provides an encoding of simple skeletons and blend shapes, with the goal of interchanging basic skeletons and skinned models, both for game studios as well for the performant, scalable interchange of large-scale crowds. This encoding supports both interchanging skinnable rigs, as well as the interchange of skeletal control rigs on their own.</para>
<sect2 id="_usd_skel__intro_1UsdSkel_Motivation">
<title>Motivation &amp; Trade-Offs</title>
<para>UsdSkel was designed with the goal in mind of both being able to represent small numbers of characters, while also being efficient enough to be able to scale up to encoding crowds, consisting of hundreds of thousands of agents.</para>
<para>Towards this end, some expressibility trade-offs have been made in the name of scalability:</para>
<para><orderedlist>
<listitem><para>In order to enable UsdSkel to efficiently encode very large numbers of characters, joint animations are stored using a compact, vectorized encoding on each Skeleton. This avoids both excess prim and property bloat, while also greatly improving both read and write performance. Although these factors are negligible on a small number of characters, this provides <emphasis>substantial</emphasis> performance improvements when interchanging large numbers of characters.</para>
<para>As a consequence of this, although UsdSkel allows a sparse skeletal animation to be defined, sparse <emphasis>layering</emphasis> of joint transforms is not supported. Sparse animation-layering capabilities may eventually be introduced as part of an encoding of animation blending.</para>
</listitem><listitem><para>UsdSkel leverages <ulink url="https://openusd.org/release/glossary.html#usdglossary-instancing">scene graph instancing</ulink> to describe <emphasis>rest state</emphasis> instancing, by which the rest state of characters may be shared across multiple instances of a character, each of which has been assigned a unique animation <ndash/> <emphasis>without deinstancing</emphasis>. This is a critical encoding feature for dealing with large numbers of characters. For the sake of enabling this feature, the encoding of a skeleton has been broken into two parts: The <ref refid="_usd_skel__schemas_1UsdSkel_Skeleton" kindref="member">Skeleton</ref> itself, and an <ref refid="_usd_skel__schemas_1UsdSkel_SkelAnimation" kindref="member">Animation</ref> associated with that skeleton.</para>
</listitem></orderedlist>
</para>
</sect2>
<sect2 id="_usd_skel__intro_1UsdSkel_IsNot">
<title>What UsdSkel Is Not</title>
<para>UsdSkel does <emphasis>not</emphasis> signal an intent to provide general rigging and execution behaviors as core USD features. We strongly believe that such features are beyond the scope of USD&apos;s core concerns.</para>
</sect2>
</sect1>
<sect1 id="_usd_skel__intro_1UsdSkel_Term">
<title>Terminology</title>
<para>Before discussing any concepts in detail, it&apos;s important to establish some common terminology:</para>
<para><itemizedlist>
<listitem><para><anchor id="_usd_skel__intro_1UsdSkel_Term_Skeleton"/><bold>Skeleton</bold>:</para>
<para>An encoding of an animated joint hierarchy. A Skeleton may additionally hold other properties that affect deformations, such as weights for a set of blend shapes.</para>
</listitem><listitem><para><anchor id="_usd_skel__intro_1UsdSkel_Term_SkeletonTopology"/><bold>Skeleton Topology</bold>:</para>
<para>The topology is the description of the parent&lt;-&gt;child relationships of all joints in a joint hierarchy.</para>
</listitem><listitem><para><bold>Skel Animation</bold>:</para>
<para>An encoding of animation for a <emphasis>Skeleton&apos;s</emphasis> joints and blendshapes.</para>
</listitem><listitem><para><bold>Binding</bold>:</para>
<para>An encoding of the binding of a <emphasis>Skeleton</emphasis> to a geometry hierarchy, describing which geometric primitives the <emphasis>Skeleton</emphasis> deforms (if any), and how.</para>
</listitem><listitem><para><anchor id="_usd_skel__intro_1UsdSkel_Term_JointInfluences"/><bold>Joint Influences</bold>:</para>
<para>The set of joint weights and indices used by skinning algorithms to describe how each point is influenced by the change in joint transformations.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="_usd_skel__intro_1UsdSkel_SkinnablePrims">
<title>What Can Be Skinned?</title>
<para>UsdSkel makes an attempt at encoding skinning information in a way that generalizes to many types of prims, rather than targeting a strict subset of known types.</para>
<para>As a general rule, if a primitive&apos;s type inherits from <ref refid="class_usd_geom_boundable" kindref="compound">UsdGeomBoundable</ref>, and if that primitive is not itself a <emphasis><ref refid="class_usd_skel_skeleton" kindref="compound">UsdSkelSkeleton</ref></emphasis>, then that primitive is considered by UsdSkel to be a valid <emphasis>candidate</emphasis> for skinning. The utility method <ref refid="group___usd_skel___utils_1ga28314cc43d8e862313fd01231d893e9e" kindref="member">UsdSkelIsSkinnablePrim</ref> can be used to test this rule.</para>
<para>When clients iterate over the set of skinnable primitives <ndash/> for example, when traversing the skinning targets of a <ref refid="class_usd_skel_binding" kindref="compound">UsdSkelBinding</ref> <ndash/> it is the client&apos;s responsibility to check prim types to determine whether or not they know how to skin each candidate primitive.</para>
</sect1>
<sect1 id="_usd_skel__intro_1UsdSkel_TransformSpaces">
<title>Transforms and Transform Spaces</title>
<para>There are a few special transform spaces and transforms that will frequently be referenced:</para>
<para><itemizedlist>
<listitem><para><bold>Joint-Local Space</bold>:</para>
<para>The local transform space of each joint.</para>
</listitem><listitem><para><bold>Skeleton Space</bold>:</para>
<para>The object space of a <emphasis>Skeleton</emphasis>. This space does not contain the transformation that positions the root of the <emphasis>Skeleton</emphasis> in the world, and therefore serves as the canonical space in which to apply joint animations.</para>
<para>A <emphasis>Skeleton</emphasis> is transformed into world space using the world space transform of the Skeleton primitive.</para>
</listitem><listitem><para><anchor id="_usd_skel__intro_1UsdSkel_Transforms_GeomBindTransform"/><bold>Geom Bind Transform</bold>:</para>
<para>The transform that positions a skinned primitive in its binding state in <emphasis>world space</emphasis>.</para>
</listitem><listitem><para><bold>Skinning Transform</bold>:</para>
<para>The transform that describes a joint&apos;s change in transformation from its <emphasis>world space</emphasis> bind pose, to its animated, <emphasis>skeleton space</emphasis> pose.</para>
<para>I.e., <computeroutput>inv(jointWorldSpaceBindTransform)*jointSkelSpaceTransform</computeroutput>.</para>
</listitem></itemizedlist>
</para>
<para>For the sake of planned animation blending capabilities, UsdSkel stores all joint transforms in <emphasis>Joint Local Space</emphasis>.</para>
<para>To clarify the description of these spaces, a <emphasis>Skeleton Space</emphasis> joint transform is computed from a <emphasis>Joint Local</emphasis> transform as follows:</para>
<para><programlisting><codeline><highlight class="normal">jointSkelSpaceTransform<sp/>=<sp/>jointLocalSpaceTransform<sp/>*<sp/>parentJointSkelSpaceTransform</highlight></codeline>
</programlisting></para>
<para>Where the <emphasis>parentJointSkelSpaceTransform</emphasis> is an identity matrix for root joints, or <emphasis>jointSkelSpaceTransform</emphasis> of the parent joint otherwise.</para>
<para>The <emphasis>World Space</emphasis> transform of a joint is computed as:</para>
<para><programlisting><codeline><highlight class="normal">jointWorldSpaceTransform<sp/>=<sp/>jointLocalSpaceTransform<sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>parentJointSkelSpaceTransform<sp/>*<sp/>skelLocalToWorldTransform</highlight></codeline>
</programlisting></para>
<para>Where <emphasis>skelLocalToWorldTransform</emphasis> is the world space transform of the Skeleton primitive.</para>
</sect1>
<sect1 id="_usd_skel__intro_1UsdSkel_PointSkinning">
<title>Skinning a Point (Linear Blend Skinning)</title>
<para>Using the terminology established above, in linear blend skinning, the <emphasis>Skeleton Space</emphasis> position of a skinned point is computed as:</para>
<para><programlisting><codeline><highlight class="normal">skelSpacePoint<sp/>=<sp/>geomBindTransform.Transform(localSpacePoint)</highlight></codeline>
<codeline><highlight class="normal">p<sp/>=<sp/>(0,0,0)</highlight></codeline>
<codeline><highlight class="normal">for<sp/>jointIndex,jointWeight<sp/>in<sp/>jointInfluencesForPoint:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>p<sp/>+=<sp/>skinningTransforms[jointIndex].Transform(skelSpacePoint)*jointWeight</highlight></codeline>
</programlisting></para>
<para>Where <emphasis>localSpacePoint</emphasis> is a point of a skinned primitive, given in the local space of that primitive. </para>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
