<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: ArResolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ar_resolver.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_ar_resolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ArResolver Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface for the asset resolution system.  
 <a href="class_ar_resolver.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for ArResolver:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_ar_resolver__inherit__graph.png" border="0" usemap="#_ar_resolver_inherit__map" alt="Inheritance graph"/></div>
<map name="_ar_resolver_inherit__map" id="_ar_resolver_inherit__map">
<area shape="rect"  title="Interface for the asset resolution system." alt="" coords="29,5,120,32"/>
<area shape="rect"  href="class_ar_default_resolver.html" title="Default asset resolution implementation used when no plugin implementation is provided." alt="" coords="5,80,144,107"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a20af16c992f11c3e462ca6f2d5a159a9"><td class="memItemLeft" align="right" valign="top"><a id="a20af16c992f11c3e462ca6f2d5a159a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ArResolver</b> (const <a class="el" href="class_ar_resolver.html">ArResolver</a> &amp;)=delete</td></tr>
<tr class="separator:a20af16c992f11c3e462ca6f2d5a159a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49212b5cc74bd2d2d5345120cd17e89"><td class="memItemLeft" align="right" valign="top"><a id="ac49212b5cc74bd2d2d5345120cd17e89"></a>
<a class="el" href="class_ar_resolver.html">ArResolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_ar_resolver.html">ArResolver</a> &amp;)=delete</td></tr>
<tr class="separator:ac49212b5cc74bd2d2d5345120cd17e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Identifiers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="ArResolver_identifier"></a></p>
<p>Identifiers are canonicalized asset paths that may be assigned to a logical asset to facilitate comparisons and lookups. They may be used to determine if different asset paths might refer to the same asset without performing resolution.</p>
<p>Since identifiers are just a form of asset path, they may be used with other functions on <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> that require an asset path, like Resolve.</p>
<p>If two asset paths produce the same identifier, those asset paths must refer to the same asset. However, in some cases comparing identifiers may not be sufficient to determine if assets are equal. For example, there could be two assets with the same identifier but whose contents were read from different resolved paths because different resolver contexts were bound when those assets were loaded. </p>
</div></td></tr>
<tr class="memitem:a68e5ae6385d1733b79f734c59682ff61"><td class="memItemLeft" align="right" valign="top">AR_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a68e5ae6385d1733b79f734c59682ff61">CreateIdentifier</a> (const std::string &amp;assetPath, const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;anchorAssetPath=<a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a>()) const</td></tr>
<tr class="memdesc:a68e5ae6385d1733b79f734c59682ff61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an identifier for the asset specified by <code>assetPath</code>.  <a href="#a68e5ae6385d1733b79f734c59682ff61">More...</a><br /></td></tr>
<tr class="separator:a68e5ae6385d1733b79f734c59682ff61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfb26c05d314299ddf596fc1defeb6c"><td class="memItemLeft" align="right" valign="top">AR_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#aabfb26c05d314299ddf596fc1defeb6c">CreateIdentifierForNewAsset</a> (const std::string &amp;assetPath, const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;anchorAssetPath=<a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a>()) const</td></tr>
<tr class="memdesc:aabfb26c05d314299ddf596fc1defeb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an identifier for a new asset specified by <code>assetPath</code>.  <a href="#aabfb26c05d314299ddf596fc1defeb6c">More...</a><br /></td></tr>
<tr class="separator:aabfb26c05d314299ddf596fc1defeb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Path Resolution Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="ArResolver_resolution"></a></p>
</div></td></tr>
<tr class="memitem:a1b824f00c46b2a5001f492698fd8f5c1"><td class="memItemLeft" align="right" valign="top">AR_API <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a1b824f00c46b2a5001f492698fd8f5c1">Resolve</a> (const std::string &amp;assetPath) const</td></tr>
<tr class="memdesc:a1b824f00c46b2a5001f492698fd8f5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the resolved path for the asset identified by the given <code>assetPath</code> if it exists.  <a href="#a1b824f00c46b2a5001f492698fd8f5c1">More...</a><br /></td></tr>
<tr class="separator:a1b824f00c46b2a5001f492698fd8f5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bdf8eab4d4ebf70a0d2df3727ff9b8"><td class="memItemLeft" align="right" valign="top">AR_API <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#ae9bdf8eab4d4ebf70a0d2df3727ff9b8">ResolveForNewAsset</a> (const std::string &amp;assetPath) const</td></tr>
<tr class="memdesc:ae9bdf8eab4d4ebf70a0d2df3727ff9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the resolved path for the given <code>assetPath</code> that may be used to create a new asset.  <a href="#ae9bdf8eab4d4ebf70a0d2df3727ff9b8">More...</a><br /></td></tr>
<tr class="separator:ae9bdf8eab4d4ebf70a0d2df3727ff9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Asset Resolver Context Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="ArResolver_context"></a></p>
</div></td></tr>
<tr class="memitem:a85ae1972e7c5791b3155ec04c213d29d"><td class="memItemLeft" align="right" valign="top">AR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a85ae1972e7c5791b3155ec04c213d29d">BindContext</a> (const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;context, <a class="el" href="class_vt_value.html">VtValue</a> *bindingData)</td></tr>
<tr class="memdesc:a85ae1972e7c5791b3155ec04c213d29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the given context to this resolver.  <a href="#a85ae1972e7c5791b3155ec04c213d29d">More...</a><br /></td></tr>
<tr class="separator:a85ae1972e7c5791b3155ec04c213d29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaa1f17eef5b4d8facae03cc70c54de"><td class="memItemLeft" align="right" valign="top">AR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a8aaa1f17eef5b4d8facae03cc70c54de">UnbindContext</a> (const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;context, <a class="el" href="class_vt_value.html">VtValue</a> *bindingData)</td></tr>
<tr class="memdesc:a8aaa1f17eef5b4d8facae03cc70c54de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind the given context from this resolver.  <a href="#a8aaa1f17eef5b4d8facae03cc70c54de">More...</a><br /></td></tr>
<tr class="separator:a8aaa1f17eef5b4d8facae03cc70c54de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1524962aa020859a589e786b1ad3c28f"><td class="memItemLeft" align="right" valign="top">AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a1524962aa020859a589e786b1ad3c28f">CreateDefaultContext</a> () const</td></tr>
<tr class="memdesc:a1524962aa020859a589e786b1ad3c28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> that may be bound to this resolver to resolve assets when no other context is explicitly specified.  <a href="#a1524962aa020859a589e786b1ad3c28f">More...</a><br /></td></tr>
<tr class="separator:a1524962aa020859a589e786b1ad3c28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a174a99676ff983a183d391973c7ebe"><td class="memItemLeft" align="right" valign="top">AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a0a174a99676ff983a183d391973c7ebe">CreateDefaultContextForAsset</a> (const std::string &amp;assetPath) const</td></tr>
<tr class="memdesc:a0a174a99676ff983a183d391973c7ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> that may be bound to this resolver to resolve the asset located at <code>assetPath</code> or referenced by that asset when no other context is explicitly specified.  <a href="#a0a174a99676ff983a183d391973c7ebe">More...</a><br /></td></tr>
<tr class="separator:a0a174a99676ff983a183d391973c7ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b165aaf701119f4b3bc26cdebd38b93"><td class="memItemLeft" align="right" valign="top">AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a5b165aaf701119f4b3bc26cdebd38b93">CreateContextFromString</a> (const std::string &amp;contextStr) const</td></tr>
<tr class="memdesc:a5b165aaf701119f4b3bc26cdebd38b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> created from the primary <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> implementation using the given <code>contextStr</code>.  <a href="#a5b165aaf701119f4b3bc26cdebd38b93">More...</a><br /></td></tr>
<tr class="separator:a5b165aaf701119f4b3bc26cdebd38b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f01bf8462bf0ec118187e200df7e362"><td class="memItemLeft" align="right" valign="top">AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a6f01bf8462bf0ec118187e200df7e362">CreateContextFromString</a> (const std::string &amp;uriScheme, const std::string &amp;contextStr) const</td></tr>
<tr class="memdesc:a6f01bf8462bf0ec118187e200df7e362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> created from the <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> registered for the given <code>uriScheme</code> using the given <code>contextStr</code>.  <a href="#a6f01bf8462bf0ec118187e200df7e362">More...</a><br /></td></tr>
<tr class="separator:a6f01bf8462bf0ec118187e200df7e362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d32052831939332ecbff965ef94caf"><td class="memItemLeft" align="right" valign="top">AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a37d32052831939332ecbff965ef94caf">CreateContextFromStrings</a> (const std::vector&lt; std::pair&lt; std::string, std::string &gt;&gt; &amp;contextStrs) const</td></tr>
<tr class="memdesc:a37d32052831939332ecbff965ef94caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> created by combining the <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> objects created from the given <code>contextStrs</code>.  <a href="#a37d32052831939332ecbff965ef94caf">More...</a><br /></td></tr>
<tr class="separator:a37d32052831939332ecbff965ef94caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9a29a4e375bbdafde5e6e3f836291a"><td class="memItemLeft" align="right" valign="top">AR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a6d9a29a4e375bbdafde5e6e3f836291a">RefreshContext</a> (const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;context)</td></tr>
<tr class="memdesc:a6d9a29a4e375bbdafde5e6e3f836291a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh any caches associated with the given context.  <a href="#a6d9a29a4e375bbdafde5e6e3f836291a">More...</a><br /></td></tr>
<tr class="separator:a6d9a29a4e375bbdafde5e6e3f836291a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e318a8e5693b4103d88443780c1fb5a"><td class="memItemLeft" align="right" valign="top">AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a9e318a8e5693b4103d88443780c1fb5a">GetCurrentContext</a> () const</td></tr>
<tr class="memdesc:a9e318a8e5693b4103d88443780c1fb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the asset resolver context currently bound in this thread.  <a href="#a9e318a8e5693b4103d88443780c1fb5a">More...</a><br /></td></tr>
<tr class="separator:a9e318a8e5693b4103d88443780c1fb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad616f0a0fc1e5dce08929604f3b95f8f"><td class="memItemLeft" align="right" valign="top">AR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#ad616f0a0fc1e5dce08929604f3b95f8f">IsContextDependentPath</a> (const std::string &amp;assetPath) const</td></tr>
<tr class="memdesc:ad616f0a0fc1e5dce08929604f3b95f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>assetPath</code> is a context-dependent path, false otherwise.  <a href="#ad616f0a0fc1e5dce08929604f3b95f8f">More...</a><br /></td></tr>
<tr class="separator:ad616f0a0fc1e5dce08929604f3b95f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scoped Resolution Cache</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="ArResolver_scopedCache"></a></p>
<p>A scoped resolution cache indicates to the resolver that results of calls to Resolve should be cached for a certain scope. This is important for performance and also for consistency &ndash; it ensures that repeated calls to Resolve with the same parameters will return the same result.</p>
<p>A resolution cache scope is opened by a call to BeginCacheScope and must be closed with a matching call to EndCacheScope. The resolver must cache the results of Resolve until the scope is closed. Note that these calls may be nested.</p>
<p>Cache scopes are thread-specific: if multiple threads are running and a cache scope is opened in one of those threads, caching should be enabled in that thread only.</p>
<p>When opening a scope, a resolver may return additional data for implementation-specific purposes. This data may be shared across threads, so long as it is safe to access this data concurrently.</p>
<p><a class="el" href="class_ar_resolver_scoped_cache.html" title="Helper object for managing asset resolver cache scopes.">ArResolverScopedCache</a> is an RAII object for managing cache scope lifetimes and data. Clients should generally use that class rather than calling the BeginCacheScope and EndCacheScope functions manually.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ar_resolver_scoped_cache.html" title="Helper object for managing asset resolver cache scopes.">ArResolverScopedCache</a> </dd></dl>
</div></td></tr>
<tr class="memitem:a522ae6b8a14dc87c9116109e619f062b"><td class="memItemLeft" align="right" valign="top">AR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a522ae6b8a14dc87c9116109e619f062b">BeginCacheScope</a> (<a class="el" href="class_vt_value.html">VtValue</a> *cacheScopeData)</td></tr>
<tr class="memdesc:a522ae6b8a14dc87c9116109e619f062b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the start of a resolution caching scope.  <a href="#a522ae6b8a14dc87c9116109e619f062b">More...</a><br /></td></tr>
<tr class="separator:a522ae6b8a14dc87c9116109e619f062b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266aaced9fc6decb4ae2ad884bd46517"><td class="memItemLeft" align="right" valign="top">AR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a266aaced9fc6decb4ae2ad884bd46517">EndCacheScope</a> (<a class="el" href="class_vt_value.html">VtValue</a> *cacheScopeData)</td></tr>
<tr class="memdesc:a266aaced9fc6decb4ae2ad884bd46517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the end of a resolution caching scope.  <a href="#a266aaced9fc6decb4ae2ad884bd46517">More...</a><br /></td></tr>
<tr class="separator:a266aaced9fc6decb4ae2ad884bd46517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Deprecated APIs</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="ArResolver_deprecated"></a></p>
<p>The functions in this section are deprecated in Ar 2.0 and slated for removal. Most have default implementations to allow subclasses to ignore them completely. </p>
</div></td></tr>
<tr class="memitem:a966c6fe671e427a7d8a01f9d068879a7"><td class="memItemLeft" align="right" valign="top">AR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a966c6fe671e427a7d8a01f9d068879a7">IsRepositoryPath</a> (const std::string &amp;path) const</td></tr>
<tr class="separator:a966c6fe671e427a7d8a01f9d068879a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9758cb2f1e4bf228ad8f9c47fa38adf9"><td class="memItemLeft" align="right" valign="top">virtual AR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a9758cb2f1e4bf228ad8f9c47fa38adf9">_IsRepositoryPath</a> (const std::string &amp;path) const</td></tr>
<tr class="separator:a9758cb2f1e4bf228ad8f9c47fa38adf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Context Operations Implementation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="ArResolver_contextImplementation"></a></p>
<p>If any of these functions are implemented in a subclass, the plugin metadata for that subclass in the plugin library's plugInfo.json must specify: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;implementsContexts&quot;</span> : <span class="keyword">true</span>.</div></div><!-- fragment --><p>If a subclass indicates that it implements any of these functions, its plugin library will be loaded and these functions will be called when the corresponding public <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> API is called. Otherwise, these functions will not be called. </p>
</div></td></tr>
<tr class="memitem:aea5ca0e868d149785b777baf8cfcde5e"><td class="memItemLeft" align="right" valign="top">virtual AR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#aea5ca0e868d149785b777baf8cfcde5e">_BindContext</a> (const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;context, <a class="el" href="class_vt_value.html">VtValue</a> *bindingData)</td></tr>
<tr class="memdesc:aea5ca0e868d149785b777baf8cfcde5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the given <code>context</code> to this resolver.  <a href="#aea5ca0e868d149785b777baf8cfcde5e">More...</a><br /></td></tr>
<tr class="separator:aea5ca0e868d149785b777baf8cfcde5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060c4070673ae89cb680d2f544de5557"><td class="memItemLeft" align="right" valign="top">virtual AR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a060c4070673ae89cb680d2f544de5557">_UnbindContext</a> (const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;context, <a class="el" href="class_vt_value.html">VtValue</a> *bindingData)</td></tr>
<tr class="memdesc:a060c4070673ae89cb680d2f544de5557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind the given <code>context</code> from this resolver.  <a href="#a060c4070673ae89cb680d2f544de5557">More...</a><br /></td></tr>
<tr class="separator:a060c4070673ae89cb680d2f544de5557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea0d703db16ed156b942bb7e1b130ea"><td class="memItemLeft" align="right" valign="top">virtual AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a8ea0d703db16ed156b942bb7e1b130ea">_CreateDefaultContext</a> () const</td></tr>
<tr class="memdesc:a8ea0d703db16ed156b942bb7e1b130ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a default <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> that may be bound to this resolver to resolve assets when no other context is explicitly specified.  <a href="#a8ea0d703db16ed156b942bb7e1b130ea">More...</a><br /></td></tr>
<tr class="separator:a8ea0d703db16ed156b942bb7e1b130ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0e0ea52ac80bb4a4b6d1f881331df1"><td class="memItemLeft" align="right" valign="top">virtual AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a5b0e0ea52ac80bb4a4b6d1f881331df1">_CreateDefaultContextForAsset</a> (const std::string &amp;assetPath) const</td></tr>
<tr class="memdesc:a5b0e0ea52ac80bb4a4b6d1f881331df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> that may be bound to this resolver to resolve the asset located at <code>assetPath</code> or referenced by that asset when no other context is explicitly specified.  <a href="#a5b0e0ea52ac80bb4a4b6d1f881331df1">More...</a><br /></td></tr>
<tr class="separator:a5b0e0ea52ac80bb4a4b6d1f881331df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67c369f100fd0488e74c3293c688156"><td class="memItemLeft" align="right" valign="top">virtual AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#ab67c369f100fd0488e74c3293c688156">_CreateContextFromString</a> (const std::string &amp;contextStr) const</td></tr>
<tr class="memdesc:ab67c369f100fd0488e74c3293c688156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> created from the given <code>contextStr</code>.  <a href="#ab67c369f100fd0488e74c3293c688156">More...</a><br /></td></tr>
<tr class="separator:ab67c369f100fd0488e74c3293c688156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af454d5a00d4dd1c2b1022d8b38d36bef"><td class="memItemLeft" align="right" valign="top">virtual AR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#af454d5a00d4dd1c2b1022d8b38d36bef">_RefreshContext</a> (const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;context)</td></tr>
<tr class="memdesc:af454d5a00d4dd1c2b1022d8b38d36bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh any caches associated with the given context.  <a href="#af454d5a00d4dd1c2b1022d8b38d36bef">More...</a><br /></td></tr>
<tr class="separator:af454d5a00d4dd1c2b1022d8b38d36bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111e120876d4dd8f717c7bdccffd86d5"><td class="memItemLeft" align="right" valign="top">virtual AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a111e120876d4dd8f717c7bdccffd86d5">_GetCurrentContext</a> () const</td></tr>
<tr class="memdesc:a111e120876d4dd8f717c7bdccffd86d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the currently bound context.  <a href="#a111e120876d4dd8f717c7bdccffd86d5">More...</a><br /></td></tr>
<tr class="separator:a111e120876d4dd8f717c7bdccffd86d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618cc648520d613dbebadc1eaa57d688"><td class="memItemLeft" align="right" valign="top">virtual AR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a618cc648520d613dbebadc1eaa57d688">_IsContextDependentPath</a> (const std::string &amp;assetPath) const</td></tr>
<tr class="memdesc:a618cc648520d613dbebadc1eaa57d688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the result of resolving the given <code>assetPath</code> may differ depending on the asset resolver context that is bound when Resolve is called, false otherwise.  <a href="#a618cc648520d613dbebadc1eaa57d688">More...</a><br /></td></tr>
<tr class="separator:a618cc648520d613dbebadc1eaa57d688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Asset Operations Implementation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="ArResolver_assetImplementation"></a></p>
</div></td></tr>
<tr class="memitem:a754a31a6d1ab02063db5c9b9f312c737"><td class="memItemLeft" align="right" valign="top">virtual AR_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a754a31a6d1ab02063db5c9b9f312c737">_GetExtension</a> (const std::string &amp;assetPath) const</td></tr>
<tr class="memdesc:a754a31a6d1ab02063db5c9b9f312c737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the file extension for the given <code>assetPath</code>.  <a href="#a754a31a6d1ab02063db5c9b9f312c737">More...</a><br /></td></tr>
<tr class="separator:a754a31a6d1ab02063db5c9b9f312c737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0f04bf685974a9d41d1503d3ce8e0d"><td class="memItemLeft" align="right" valign="top">virtual AR_API <a class="el" href="class_ar_asset_info.html">ArAssetInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#adc0f04bf685974a9d41d1503d3ce8e0d">_GetAssetInfo</a> (const std::string &amp;assetPath, const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;resolvedPath) const</td></tr>
<tr class="memdesc:adc0f04bf685974a9d41d1503d3ce8e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="class_ar_asset_info.html" title="Contains information about a resolved asset.">ArAssetInfo</a> populated with additional metadata (if any) about the asset at the given <code>assetPath</code>.  <a href="#adc0f04bf685974a9d41d1503d3ce8e0d">More...</a><br /></td></tr>
<tr class="separator:adc0f04bf685974a9d41d1503d3ce8e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c771ddc5d3882b3ece763fbb60e507"><td class="memItemLeft" align="right" valign="top">virtual AR_API <a class="el" href="class_ar_timestamp.html">ArTimestamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a51c771ddc5d3882b3ece763fbb60e507">_GetModificationTimestamp</a> (const std::string &amp;assetPath, const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;resolvedPath) const</td></tr>
<tr class="memdesc:a51c771ddc5d3882b3ece763fbb60e507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="class_ar_timestamp.html" title="Represents a timestamp for an asset.">ArTimestamp</a> representing the last time the asset at <code>assetPath</code> was modified.  <a href="#a51c771ddc5d3882b3ece763fbb60e507">More...</a><br /></td></tr>
<tr class="separator:a51c771ddc5d3882b3ece763fbb60e507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b5b770ce42d1d20b638eeb231c86eb"><td class="memItemLeft" align="right" valign="top">virtual AR_API std::shared_ptr&lt; <a class="el" href="class_ar_asset.html">ArAsset</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#ac2b5b770ce42d1d20b638eeb231c86eb">_OpenAsset</a> (const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;resolvedPath) const =0</td></tr>
<tr class="memdesc:ac2b5b770ce42d1d20b638eeb231c86eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="class_ar_asset.html" title="Interface for accessing the contents of an asset.">ArAsset</a> object for the asset located at <code>resolvedPath</code>.  <a href="#ac2b5b770ce42d1d20b638eeb231c86eb">More...</a><br /></td></tr>
<tr class="separator:ac2b5b770ce42d1d20b638eeb231c86eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9be097a3054cd75a38ff68030bf9c67"><td class="memItemLeft" align="right" valign="top">virtual AR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#aa9be097a3054cd75a38ff68030bf9c67">_CanWriteAssetToPath</a> (const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;resolvedPath, std::string *whyNot) const</td></tr>
<tr class="memdesc:aa9be097a3054cd75a38ff68030bf9c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if an asset may be written to the given <code>resolvedPath</code>, false otherwise.  <a href="#aa9be097a3054cd75a38ff68030bf9c67">More...</a><br /></td></tr>
<tr class="separator:aa9be097a3054cd75a38ff68030bf9c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a70fbd567fd56d9567f8ab9796a4d69"><td class="memItemLeft" align="right" valign="top">virtual AR_API std::shared_ptr&lt; <a class="el" href="class_ar_writable_asset.html">ArWritableAsset</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a8a70fbd567fd56d9567f8ab9796a4d69">_OpenAssetForWrite</a> (const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;resolvedPath, <a class="el" href="class_ar_resolver.html#a61d23b393fdc35f2f0e30a1ed566c76d">WriteMode</a> writeMode) const =0</td></tr>
<tr class="memdesc:a8a70fbd567fd56d9567f8ab9796a4d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="class_ar_writable_asset.html" title="Interface for writing data to an asset.">ArWritableAsset</a> object for the asset at <code>resolvedPath</code> using the specified <code>writeMode</code>.  <a href="#a8a70fbd567fd56d9567f8ab9796a4d69">More...</a><br /></td></tr>
<tr class="separator:a8a70fbd567fd56d9567f8ab9796a4d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scoped Resolution Cache Implementation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="ArResolver_scopedCacheImplementation"></a></p>
<p>If any of these functions are implemented in a subclass, the plugin metadata for that subclass in the plugin library's plugInfo.json must specify: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;implementsScopedCaches&quot;</span> : <span class="keyword">true</span>.</div></div><!-- fragment --><p>If a subclass indicates that it implements these functions, <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> will assume the subclass is handling all caching of resolved paths and will call these functions when a caching scope is opened and closed. Otherwise, these functions will not be called. Instead, <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> itself will handle caching and returning resolved paths as needed. </p>
</div></td></tr>
<tr class="memitem:a02b1f3d70b0771e0e399af8625edeb15"><td class="memItemLeft" align="right" valign="top">virtual AR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a02b1f3d70b0771e0e399af8625edeb15">_BeginCacheScope</a> (<a class="el" href="class_vt_value.html">VtValue</a> *cacheScopeData)</td></tr>
<tr class="memdesc:a02b1f3d70b0771e0e399af8625edeb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the start of a resolution caching scope.  <a href="#a02b1f3d70b0771e0e399af8625edeb15">More...</a><br /></td></tr>
<tr class="separator:a02b1f3d70b0771e0e399af8625edeb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36e690e66b26c1cea5268ff2bef5400"><td class="memItemLeft" align="right" valign="top">virtual AR_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#ab36e690e66b26c1cea5268ff2bef5400">_EndCacheScope</a> (<a class="el" href="class_vt_value.html">VtValue</a> *cacheScopeData)</td></tr>
<tr class="memdesc:ab36e690e66b26c1cea5268ff2bef5400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the end of a resolution caching scope.  <a href="#ab36e690e66b26c1cea5268ff2bef5400">More...</a><br /></td></tr>
<tr class="separator:ab36e690e66b26c1cea5268ff2bef5400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implementation Utilities</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="ArResolver_implementationUtils"></a></p>
<p>Utility functions for implementations. </p>
</div></td></tr>
<tr class="memitem:ab93ccf0957571994e79ade8bf4d5f793"><td class="memTemplParams" colspan="2">template&lt;class ContextObj &gt; </td></tr>
<tr class="memitem:ab93ccf0957571994e79ade8bf4d5f793"><td class="memTemplItemLeft" align="right" valign="top">const ContextObj *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#ab93ccf0957571994e79ade8bf4d5f793">_GetCurrentContextObject</a> () const</td></tr>
<tr class="memdesc:ab93ccf0957571994e79ade8bf4d5f793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the context object of type <code>ContextObj</code> from the last <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> that was bound via a call to BindContext, or <code>NULL</code> if no context object of that type exists.  <a href="#ab93ccf0957571994e79ade8bf4d5f793">More...</a><br /></td></tr>
<tr class="separator:ab93ccf0957571994e79ade8bf4d5f793"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
File/asset-specific Operations</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8b67d6a1c6bbdd51b2a520fecf78d479"></a><a class="anchor" id="ArResolver_files"></a></p>
</td></tr>
<tr class="memitem:a61d23b393fdc35f2f0e30a1ed566c76d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a61d23b393fdc35f2f0e30a1ed566c76d">WriteMode</a> { <a class="el" href="class_ar_resolver.html#a61d23b393fdc35f2f0e30a1ed566c76da06933067aafd48425d67bcb01bba5cb6">Update</a> = 0, 
<a class="el" href="class_ar_resolver.html#a61d23b393fdc35f2f0e30a1ed566c76da0ebe6df8a3ac338e0512acc741823fdb">Replace</a>
 }</td></tr>
<tr class="memdesc:a61d23b393fdc35f2f0e30a1ed566c76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of write modes for OpenAssetForWrite.  <a href="class_ar_resolver.html#a61d23b393fdc35f2f0e30a1ed566c76d">More...</a><br /></td></tr>
<tr class="separator:a61d23b393fdc35f2f0e30a1ed566c76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e1e7ab9dc4e2a390019b3b6384a504"><td class="memItemLeft" align="right" valign="top">AR_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#ab8e1e7ab9dc4e2a390019b3b6384a504">GetExtension</a> (const std::string &amp;assetPath) const</td></tr>
<tr class="memdesc:ab8e1e7ab9dc4e2a390019b3b6384a504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the file extension for the given <code>assetPath</code>.  <a href="#ab8e1e7ab9dc4e2a390019b3b6384a504">More...</a><br /></td></tr>
<tr class="separator:ab8e1e7ab9dc4e2a390019b3b6384a504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6078df1f5f1d1f4cf4d5b1411b7b88c8"><td class="memItemLeft" align="right" valign="top">AR_API <a class="el" href="class_ar_asset_info.html">ArAssetInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a6078df1f5f1d1f4cf4d5b1411b7b88c8">GetAssetInfo</a> (const std::string &amp;assetPath, const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;resolvedPath) const</td></tr>
<tr class="memdesc:a6078df1f5f1d1f4cf4d5b1411b7b88c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="class_ar_asset_info.html" title="Contains information about a resolved asset.">ArAssetInfo</a> populated with additional metadata (if any) about the asset at the given <code>assetPath</code>.  <a href="#a6078df1f5f1d1f4cf4d5b1411b7b88c8">More...</a><br /></td></tr>
<tr class="separator:a6078df1f5f1d1f4cf4d5b1411b7b88c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0820bb01d47be4f215a661f061e2200"><td class="memItemLeft" align="right" valign="top">AR_API <a class="el" href="class_ar_timestamp.html">ArTimestamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#af0820bb01d47be4f215a661f061e2200">GetModificationTimestamp</a> (const std::string &amp;assetPath, const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;resolvedPath) const</td></tr>
<tr class="memdesc:af0820bb01d47be4f215a661f061e2200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="class_ar_timestamp.html" title="Represents a timestamp for an asset.">ArTimestamp</a> representing the last time the asset at <code>assetPath</code> was modified.  <a href="#af0820bb01d47be4f215a661f061e2200">More...</a><br /></td></tr>
<tr class="separator:af0820bb01d47be4f215a661f061e2200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a964db701e93c26fc8365ac98fb758"><td class="memItemLeft" align="right" valign="top">AR_API std::shared_ptr&lt; <a class="el" href="class_ar_asset.html">ArAsset</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#aa3a964db701e93c26fc8365ac98fb758">OpenAsset</a> (const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;resolvedPath) const</td></tr>
<tr class="memdesc:aa3a964db701e93c26fc8365ac98fb758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="class_ar_asset.html" title="Interface for accessing the contents of an asset.">ArAsset</a> object for the asset located at <code>resolvedPath</code>.  <a href="#aa3a964db701e93c26fc8365ac98fb758">More...</a><br /></td></tr>
<tr class="separator:aa3a964db701e93c26fc8365ac98fb758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c07b55b6807adb47805ff0037b6c44"><td class="memItemLeft" align="right" valign="top">AR_API std::shared_ptr&lt; <a class="el" href="class_ar_writable_asset.html">ArWritableAsset</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a91c07b55b6807adb47805ff0037b6c44">OpenAssetForWrite</a> (const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;resolvedPath, <a class="el" href="class_ar_resolver.html#a61d23b393fdc35f2f0e30a1ed566c76d">WriteMode</a> writeMode) const</td></tr>
<tr class="memdesc:a91c07b55b6807adb47805ff0037b6c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="class_ar_writable_asset.html" title="Interface for writing data to an asset.">ArWritableAsset</a> object for the asset located at <code>resolvedPath</code> using the specified <code>writeMode</code>.  <a href="#a91c07b55b6807adb47805ff0037b6c44">More...</a><br /></td></tr>
<tr class="separator:a91c07b55b6807adb47805ff0037b6c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843b3ef2aacbedf6fe6f9deeb01696d7"><td class="memItemLeft" align="right" valign="top">AR_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a843b3ef2aacbedf6fe6f9deeb01696d7">CanWriteAssetToPath</a> (const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;resolvedPath, std::string *whyNot=nullptr) const</td></tr>
<tr class="memdesc:a843b3ef2aacbedf6fe6f9deeb01696d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if an asset may be written to the given <code>resolvedPath</code>, false otherwise.  <a href="#a843b3ef2aacbedf6fe6f9deeb01696d7">More...</a><br /></td></tr>
<tr class="separator:a843b3ef2aacbedf6fe6f9deeb01696d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Implementation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb672f52ade975e864ae6b58722c03689"></a><a class="anchor" id="ArResolver_implementation"></a></p>
</td></tr>
<tr class="memitem:a50c0a0a7bc7b939f4a44fd4baf26a7b5"><td class="memItemLeft" align="right" valign="top">abs path to model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a50c0a0a7bc7b939f4a44fd4baf26a7b5">usd</a></td></tr>
<tr class="memdesc:a50c0a0a7bc7b939f4a44fd4baf26a7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an identifier for the asset at the given <code>assetPath</code>.  <a href="#a50c0a0a7bc7b939f4a44fd4baf26a7b5">More...</a><br /></td></tr>
<tr class="separator:a50c0a0a7bc7b939f4a44fd4baf26a7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806b3bf4dc93af8cdde3e3e2a3d5e1e7"><td class="memItemLeft" align="right" valign="top"><a id="a806b3bf4dc93af8cdde3e3e2a3d5e1e7"></a>
abs path to model *&#160;</td><td class="memItemRight" valign="bottom"><b>ArResolvedPath</b> (&quot;/abs/path/to/shot.usd&quot;)) *</td></tr>
<tr class="separator:a806b3bf4dc93af8cdde3e3e2a3d5e1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eac0ab4acfa5276713bee14b8e11308"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a8eac0ab4acfa5276713bee14b8e11308">_CreateIdentifierForNewAsset</a> (const std::string &amp;assetPath, const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;anchorAssetPath) const =0</td></tr>
<tr class="memdesc:a8eac0ab4acfa5276713bee14b8e11308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an identifier for a new asset at the given <code>assetPath</code>.  <a href="#a8eac0ab4acfa5276713bee14b8e11308">More...</a><br /></td></tr>
<tr class="separator:a8eac0ab4acfa5276713bee14b8e11308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0b5d475de0d5fb0d17756b07696014"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a3b0b5d475de0d5fb0d17756b07696014">_Resolve</a> (const std::string &amp;assetPath) const =0</td></tr>
<tr class="memdesc:a3b0b5d475de0d5fb0d17756b07696014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the resolved path for the given <code>assetPath</code> or an empty <a class="el" href="class_ar_resolved_path.html" title="Represents a resolved asset path.">ArResolvedPath</a> if no asset exists at that path.  <a href="#a3b0b5d475de0d5fb0d17756b07696014">More...</a><br /></td></tr>
<tr class="separator:a3b0b5d475de0d5fb0d17756b07696014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bbf8128c2c2253eff9b34ba9d5baae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_resolver.html#a66bbf8128c2c2253eff9b34ba9d5baae">_ResolveForNewAsset</a> (const std::string &amp;assetPath) const =0</td></tr>
<tr class="memdesc:a66bbf8128c2c2253eff9b34ba9d5baae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the resolved path for the given <code>assetPath</code> that may be used to create a new asset or an empty <a class="el" href="class_ar_resolved_path.html" title="Represents a resolved asset path.">ArResolvedPath</a> if such a path cannot be computed.  <a href="#a66bbf8128c2c2253eff9b34ba9d5baae">More...</a><br /></td></tr>
<tr class="separator:a66bbf8128c2c2253eff9b34ba9d5baae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for the asset resolution system. </p>
<p>An asset resolver is responsible for resolving asset information (including the asset's physical path) from a logical path.</p>
<p>See ar_implementing_resolver for information on how to customize asset resolution behavior by implementing a subclass of <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a>. Clients may use <a class="el" href="ar_2resolver_8h.html#ab0913ebfd579684add6b59b44983a633" title="Returns the configured asset resolver.">ArGetResolver</a> to access the configured asset resolver. </p>

<p class="definition">Definition at line <a class="el" href="ar_2resolver_8h_source.html#l00059">59</a> of file <a class="el" href="ar_2resolver_8h_source.html">resolver.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a61d23b393fdc35f2f0e30a1ed566c76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d23b393fdc35f2f0e30a1ed566c76d">&#9670;&nbsp;</a></span>WriteMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ar_resolver.html#a61d23b393fdc35f2f0e30a1ed566c76d">WriteMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of write modes for OpenAssetForWrite. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a61d23b393fdc35f2f0e30a1ed566c76da06933067aafd48425d67bcb01bba5cb6"></a>Update&#160;</td><td class="fielddoc"><p>Open asset for in-place updates. </p>
<p>If the asset exists, its contents will not be discarded and writes may overwrite existing data. Otherwise, the asset will be created. </p>
</td></tr>
<tr><td class="fieldname"><a id="a61d23b393fdc35f2f0e30a1ed566c76da0ebe6df8a3ac338e0512acc741823fdb"></a>Replace&#160;</td><td class="fielddoc"><p>Open asset for replacement. </p>
<p>If the asset exists, its contents will be discarded by the time the <a class="el" href="class_ar_writable_asset.html" title="Interface for writing data to an asset.">ArWritableAsset</a> is destroyed. Otherwise, the asset will be created. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ar_2resolver_8h_source.html#l00311">311</a> of file <a class="el" href="ar_2resolver_8h_source.html">resolver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a02b1f3d70b0771e0e399af8625edeb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b1f3d70b0771e0e399af8625edeb15">&#9670;&nbsp;</a></span>_BeginCacheScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API void _BeginCacheScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> *&#160;</td>
          <td class="paramname"><em>cacheScopeData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the start of a resolution caching scope. </p>
<p>Resolvers may fill <code>cacheScopeData</code> with arbitrary data. Clients may also pass in a <code>cacheScopeData</code> populated by an earlier call to BeginCacheScope to allow the resolver access to that information.</p>
<p>See <a class="el" href="class_ar_resolver.html#ArResolver_scopedCacheImplementation">Scoped Resolution Cache Implementation</a> for more implementation details. </p>

</div>
</div>
<a id="aea5ca0e868d149785b777baf8cfcde5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5ca0e868d149785b777baf8cfcde5e">&#9670;&nbsp;</a></span>_BindContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API void _BindContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> *&#160;</td>
          <td class="paramname"><em>bindingData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the given <code>context</code> to this resolver. </p>
<p><code>bindingData</code> may be populated with additional information that will be kept alive while <code>context</code> is bound. Both <code>context</code> and <code>bindingData</code> will be passed to UnbindContext when the context is being unbound.</p>
<p>Contexts may be nested; if multiple contexts are bound, the context that was most recently bound must take precedence and block all previously bound contexts.</p>
<p>Context binding is thread-specific; contexts bound in a thread must only affect other resolver calls in the same thread.</p>
<p><a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> itself manages thread-local stacks of bound contexts. Subclasses can retrieve the most recent context object which was passed to BindContext using _GetCurrentContextObject. Because of this, subclasses typically do not need to implement this function unless they need to be informed when a context object is bound. For example, this may be needed if the context needs to be passed on to another subsystem that manages these bindings itself.</p>
<p>The default implementation does nothing. </p>

</div>
</div>
<a id="aa9be097a3054cd75a38ff68030bf9c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9be097a3054cd75a38ff68030bf9c67">&#9670;&nbsp;</a></span>_CanWriteAssetToPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API bool _CanWriteAssetToPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>whyNot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if an asset may be written to the given <code>resolvedPath</code>, false otherwise. </p>
<p>If this function returns false and <code>whyNot</code> is not <code>nullptr</code>, it may be filled with an explanation. The default implementation returns true. </p>

</div>
</div>
<a id="ab67c369f100fd0488e74c3293c688156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67c369f100fd0488e74c3293c688156">&#9670;&nbsp;</a></span>_CreateContextFromString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> _CreateContextFromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>contextStr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> created from the given <code>contextStr</code>. </p>
<p>The default implementation returns a default-constructed <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a>. </p>

<p>Reimplemented in <a class="el" href="class_ar_default_resolver.html#a88bd7f9112c7f5dfaced947b22336340">ArDefaultResolver</a>.</p>

</div>
</div>
<a id="a8ea0d703db16ed156b942bb7e1b130ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea0d703db16ed156b942bb7e1b130ea">&#9670;&nbsp;</a></span>_CreateDefaultContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> _CreateDefaultContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a default <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> that may be bound to this resolver to resolve assets when no other context is explicitly specified. </p>
<p>When CreateDefaultContext is called on the configured asset resolver, Ar will call this method on the primary resolver and all URI/IRI resolvers and merge the results into a single <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> that will be returned to the consumer.</p>
<p>This function should not automatically bind this context, but should create one that may be used later.</p>
<p>The default implementation returns a default-constructed <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a>.</p>
<p>Example uses:</p><ul>
<li><a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> will call CreateDefaultContext when creating a new stage with an anonymous root layer and without a given context. The returned context will be bound when resolving asset paths on that stage. </li>
</ul>

<p>Reimplemented in <a class="el" href="class_ar_default_resolver.html#acbd76d7592de831df1d894066dd7295f">ArDefaultResolver</a>.</p>

</div>
</div>
<a id="a5b0e0ea52ac80bb4a4b6d1f881331df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0e0ea52ac80bb4a4b6d1f881331df1">&#9670;&nbsp;</a></span>_CreateDefaultContextForAsset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> _CreateDefaultContextForAsset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> that may be bound to this resolver to resolve the asset located at <code>assetPath</code> or referenced by that asset when no other context is explicitly specified. </p>
<p>When CreateDefaultContextForAsset is called on the configured asset resolver, Ar will call this method on the primary resolver and all URI/IRI resolvers and merge the results into a single <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> that will be returned to the consumer.</p>
<p>Note that this means this method may be called with asset paths that are not associated with this resolver. For example, this method may be called on a URI/IRI resolver with a non-URI/IRI asset path. This is to support cases where the asset at <code>assetPath</code> references other assets with URI/IRI schemes that differ from the URI/IRI scheme (if any) in <code>assetPath</code>.</p>
<p>This function should not automatically bind this context, but should create one that may be used later.</p>
<p>The default implementation returns a default-constructed <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a>.</p>
<p>Example uses:</p><ul>
<li><a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> will call CreateDefaultContextForAsset when creating a new stage with a non-anonymous root layer and without a given context. The resolved path of the root layer will be passed in as the <code>assetPath</code>. The returned context will be bound when resolving asset paths on that stage. </li>
</ul>

<p>Reimplemented in <a class="el" href="class_ar_default_resolver.html#aa21e74d0ce1ccc62fde8b26f90db16e1">ArDefaultResolver</a>.</p>

</div>
</div>
<a id="a8eac0ab4acfa5276713bee14b8e11308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eac0ab4acfa5276713bee14b8e11308">&#9670;&nbsp;</a></span>_CreateIdentifierForNewAsset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string _CreateIdentifierForNewAsset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>anchorAssetPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an identifier for a new asset at the given <code>assetPath</code>. </p>
<p>This is similar to _CreateIdentifier but is used to create identifiers for assets that may not exist yet and are being created.</p>
<p>Example uses:</p><ul>
<li>When creating a new layer via <a class="el" href="class_sdf_layer.html#aad57cd44403a4f95a2bb6c730fa1b0f5" title="Creates a new empty layer with the given identifier.">SdfLayer::CreateNew</a>, CreateIdentifierForNewAsset will be called with the asset path given to the function. The result will be used as the new layer's identifier. </li>
</ul>

<p>Implemented in <a class="el" href="class_ar_default_resolver.html#a155d071d5f25a65b0a51eb8a8c9f40ac">ArDefaultResolver</a>.</p>

</div>
</div>
<a id="ab36e690e66b26c1cea5268ff2bef5400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36e690e66b26c1cea5268ff2bef5400">&#9670;&nbsp;</a></span>_EndCacheScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API void _EndCacheScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> *&#160;</td>
          <td class="paramname"><em>cacheScopeData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the end of a resolution caching scope. </p>
<p><code>cacheScopeData</code> should contain the data that was populated by the previous corresponding call to BeginCacheScope.</p>
<p>See <a class="el" href="class_ar_resolver.html#ArResolver_scopedCacheImplementation">Scoped Resolution Cache Implementation</a> for more implementation details. </p>

</div>
</div>
<a id="adc0f04bf685974a9d41d1503d3ce8e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0f04bf685974a9d41d1503d3ce8e0d">&#9670;&nbsp;</a></span>_GetAssetInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API <a class="el" href="class_ar_asset_info.html">ArAssetInfo</a> _GetAssetInfo </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an <a class="el" href="class_ar_asset_info.html" title="Contains information about a resolved asset.">ArAssetInfo</a> populated with additional metadata (if any) about the asset at the given <code>assetPath</code>. </p>
<p><code>resolvedPath</code> is the resolved path computed for the given <code>assetPath</code>. The default implementation returns a default-constructed <a class="el" href="class_ar_asset_info.html" title="Contains information about a resolved asset.">ArAssetInfo</a>. </p>

</div>
</div>
<a id="a111e120876d4dd8f717c7bdccffd86d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111e120876d4dd8f717c7bdccffd86d5">&#9670;&nbsp;</a></span>_GetCurrentContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> _GetCurrentContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the currently bound context. </p>
<p>Since context binding is thread-specific, this should return the context that was most recently bound in this thread.</p>
<p>Subclasses typically do not need to implement this function since <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> itself keeps track of the contexts that are bound via calls to BindContext. However, if a subclass is managing bound contexts itself and allows clients to bind context objects via other API outside of BindContext, this function should return the context object as described above. This typically happens with subclasses that are wrappers around other resolution subsystems. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ar_resolver.html#aea5ca0e868d149785b777baf8cfcde5e" title="Bind the given context to this resolver.">_BindContext</a> for more information.</dd></dl>
<p>The default implementation returns a default-constructed <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a>. </p>

</div>
</div>
<a id="ab93ccf0957571994e79ade8bf4d5f793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93ccf0957571994e79ade8bf4d5f793">&#9670;&nbsp;</a></span>_GetCurrentContextObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ContextObj* _GetCurrentContextObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the context object of type <code>ContextObj</code> from the last <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> that was bound via a call to BindContext, or <code>NULL</code> if no context object of that type exists. </p>
<p>Typically, a subclass might use this in their _Resolve function to get the currently bound context to drive their resolution behavior.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<span class="keyword">const</span> MyContextObject* ctx = </div><div class="line">       _GetCurrentContextObject&lt;MyContextObject&gt;()) {</div><div class="line"></div><div class="line">    <span class="comment">// Use information in ctx to resolve given path</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">    <span class="comment">// Resolve given path with no context object</span></div><div class="line">}</div></div><!-- fragment --><p>This is the same as <a class="el" href="class_ar_resolver.html#a9e318a8e5693b4103d88443780c1fb5a" title="Returns the asset resolver context currently bound in this thread.">GetCurrentContext()</a>.Get&lt;ContextObj&gt;() but more efficient, since it does not make a copy of the <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a>. However, it is <em>not</em> the same as <a class="el" href="class_ar_resolver.html#a111e120876d4dd8f717c7bdccffd86d5" title="Return the currently bound context.">_GetCurrentContext()</a>.Get&lt;ContextObj&gt;(). Subclasses that manage context binding themselves may have overridden _GetCurrentContext to return a context that was bound without calling BindContext. These subclasses should not use this function and should retrieve the current context from their own internal data structures. </p>

<p class="definition">Definition at line <a class="el" href="ar_2resolver_8h_source.html#l00843">843</a> of file <a class="el" href="ar_2resolver_8h_source.html">resolver.h</a>.</p>

</div>
</div>
<a id="a754a31a6d1ab02063db5c9b9f312c737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754a31a6d1ab02063db5c9b9f312c737">&#9670;&nbsp;</a></span>_GetExtension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API std::string _GetExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the file extension for the given <code>assetPath</code>. </p>
<p>This extension should not include a "." at the beginning of the string.</p>
<p>The default implementation returns the string after the last "." in <code>assetPath</code>. If <code>assetPath</code> begins with a ".", the extension will be empty unless there is another "." in the path. If <code>assetPath</code> has components separated by '/' (or '\' on Windows), only the last component will be considered. </p>

</div>
</div>
<a id="a51c771ddc5d3882b3ece763fbb60e507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c771ddc5d3882b3ece763fbb60e507">&#9670;&nbsp;</a></span>_GetModificationTimestamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API <a class="el" href="class_ar_timestamp.html">ArTimestamp</a> _GetModificationTimestamp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an <a class="el" href="class_ar_timestamp.html" title="Represents a timestamp for an asset.">ArTimestamp</a> representing the last time the asset at <code>assetPath</code> was modified. </p>
<p><code>resolvedPath</code> is the resolved path computed for the given <code>assetPath</code>. If a timestamp cannot be retrieved, return an invalid <a class="el" href="class_ar_timestamp.html" title="Represents a timestamp for an asset.">ArTimestamp</a>.</p>
<p>The default implementation returns an invalid <a class="el" href="class_ar_timestamp.html" title="Represents a timestamp for an asset.">ArTimestamp</a>.</p>
<p>Example uses:</p><ul>
<li><a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> will call GetModificationTimestamp when opening a layer and store the returned timestamp. When <a class="el" href="class_sdf_layer.html#aadc795502e58ced5fec2a00cf282f27a" title="Reloads the layer from its persistent representation.">SdfLayer::Reload</a> is called on that layer, this method will be called again. If the returned timestamp differs from the stored timestamp, or if it is invalid, the layer will be reloaded. </li>
</ul>

<p>Reimplemented in <a class="el" href="class_ar_default_resolver.html#a98cefaf82c98c23f4024fb5d21bb55c2">ArDefaultResolver</a>.</p>

</div>
</div>
<a id="a618cc648520d613dbebadc1eaa57d688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618cc648520d613dbebadc1eaa57d688">&#9670;&nbsp;</a></span>_IsContextDependentPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API bool _IsContextDependentPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the result of resolving the given <code>assetPath</code> may differ depending on the asset resolver context that is bound when Resolve is called, false otherwise. </p>
<p>The default implementation returns false.</p>
<p>Example uses:</p><ul>
<li><a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> will call this function to check if the identifier given to <a class="el" href="class_sdf_layer.html#acc4e19f5c2bf0bab57804acee65ebb78" title="Return an existing layer with the given identifier and args.">SdfLayer::Find</a> or <a class="el" href="class_sdf_layer.html#aa01062bf4dde3f28c1fc617a1acaf35e" title="Return an existing layer with the given identifier and args, or else load it.">SdfLayer::FindOrOpen</a> is context-dependent. If it is and a layer exists with the same identifier, <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> can return it without resolving the identifier. If it is not, <a class="el" href="class_sdf_layer.html" title="A scene description container that can combine with other such containers to form simple component as...">SdfLayer</a> must resolve the identifier and search for a layer with the same resolved path, even if a layer exists with the same identifier. </li>
</ul>

<p>Reimplemented in <a class="el" href="class_ar_default_resolver.html#a0b256bacb573a7f7150157c31112d135">ArDefaultResolver</a>.</p>

</div>
</div>
<a id="a9758cb2f1e4bf228ad8f9c47fa38adf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9758cb2f1e4bf228ad8f9c47fa38adf9">&#9670;&nbsp;</a></span>_IsRepositoryPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API bool _IsRepositoryPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000060">Deprecated:</a></b></dt><dd>Return true if the given path is a repository path, false otherwise.</dd></dl>
<p>Default implementation returns false. </p>

</div>
</div>
<a id="ac2b5b770ce42d1d20b638eeb231c86eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b5b770ce42d1d20b638eeb231c86eb">&#9670;&nbsp;</a></span>_OpenAsset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API std::shared_ptr&lt;<a class="el" href="class_ar_asset.html">ArAsset</a>&gt; _OpenAsset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an <a class="el" href="class_ar_asset.html" title="Interface for accessing the contents of an asset.">ArAsset</a> object for the asset located at <code>resolvedPath</code>. </p>
<p>Return an invalid std::shared_ptr if object could not be created (for example, if the asset at the given path could not be opened).</p>
<p>Note that clients may still be using the data associated with this object even after the last shared_ptr has been destroyed. For example, a client may have created a memory mapping using the FILE* presented in the <a class="el" href="class_ar_asset.html" title="Interface for accessing the contents of an asset.">ArAsset</a> object; this would preclude truncating or overwriting any of the contents of that file. </p>

<p>Implemented in <a class="el" href="class_ar_default_resolver.html#a9b798d003cedb668f9c45e135692a879">ArDefaultResolver</a>.</p>

</div>
</div>
<a id="a8a70fbd567fd56d9567f8ab9796a4d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a70fbd567fd56d9567f8ab9796a4d69">&#9670;&nbsp;</a></span>_OpenAssetForWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API std::shared_ptr&lt;<a class="el" href="class_ar_writable_asset.html">ArWritableAsset</a>&gt; _OpenAssetForWrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ar_resolver.html#a61d23b393fdc35f2f0e30a1ed566c76d">WriteMode</a>&#160;</td>
          <td class="paramname"><em>writeMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an <a class="el" href="class_ar_writable_asset.html" title="Interface for writing data to an asset.">ArWritableAsset</a> object for the asset at <code>resolvedPath</code> using the specified <code>writeMode</code>. </p>
<p>Return an invalid std::shared_ptr if object could not be created (for example, if writing to the given path is not allowed).</p>
<p>Implementations should create any parent paths that are necessary to write this asset. The returned <a class="el" href="class_ar_writable_asset.html" title="Interface for writing data to an asset.">ArWritableAsset</a> must obey the behaviors for the given <code>writeMode</code>, see the documentation for the WriteMode enum for more details. </p>

<p>Implemented in <a class="el" href="class_ar_default_resolver.html#ad7c9c5831bede022a807f77838208c64">ArDefaultResolver</a>.</p>

</div>
</div>
<a id="af454d5a00d4dd1c2b1022d8b38d36bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af454d5a00d4dd1c2b1022d8b38d36bef">&#9670;&nbsp;</a></span>_RefreshContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API void _RefreshContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refresh any caches associated with the given context. </p>
<p>If doing so would invalidate asset paths that had previously been resolved, this function should send an <a class="el" href="class_ar_notice_1_1_resolver_changed.html" title="Notice sent when asset paths may resolve to a different path than before due to a change in the resol...">ArNotice::ResolverChanged</a> notice to inform clients of this. See documentation on that class for more details.</p>
<p>The default implementation does nothing. </p>

</div>
</div>
<a id="a3b0b5d475de0d5fb0d17756b07696014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0b5d475de0d5fb0d17756b07696014">&#9670;&nbsp;</a></span>_Resolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> _Resolve </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the resolved path for the given <code>assetPath</code> or an empty <a class="el" href="class_ar_resolved_path.html" title="Represents a resolved asset path.">ArResolvedPath</a> if no asset exists at that path. </p>

<p>Implemented in <a class="el" href="class_ar_default_resolver.html#a378ebf9b021b95783ddb7a2bcf236f29">ArDefaultResolver</a>.</p>

</div>
</div>
<a id="a66bbf8128c2c2253eff9b34ba9d5baae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bbf8128c2c2253eff9b34ba9d5baae">&#9670;&nbsp;</a></span>_ResolveForNewAsset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> _ResolveForNewAsset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the resolved path for the given <code>assetPath</code> that may be used to create a new asset or an empty <a class="el" href="class_ar_resolved_path.html" title="Represents a resolved asset path.">ArResolvedPath</a> if such a path cannot be computed. </p>

<p>Implemented in <a class="el" href="class_ar_default_resolver.html#ad085f592a3d0a31d2a388906f9f6e735">ArDefaultResolver</a>.</p>

</div>
</div>
<a id="a060c4070673ae89cb680d2f544de5557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060c4070673ae89cb680d2f544de5557">&#9670;&nbsp;</a></span>_UnbindContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AR_API void _UnbindContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> *&#160;</td>
          <td class="paramname"><em>bindingData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unbind the given <code>context</code> from this resolver. </p>
<p>It is an error if the context being unbound is not the currently bound context.</p>
<p>Subclasses typically do not need to implement this function since <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> itself keeps track of the contexts that are bound via calls to BindContext. However, subclasses may need to implement this function if they are managing these bindings itself.</p>
<p>The default implementation does nothing. </p>

</div>
</div>
<a id="a522ae6b8a14dc87c9116109e619f062b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522ae6b8a14dc87c9116109e619f062b">&#9670;&nbsp;</a></span>BeginCacheScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API void BeginCacheScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> *&#160;</td>
          <td class="paramname"><em>cacheScopeData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the start of a resolution caching scope. </p>
<p>Clients should generally use <a class="el" href="class_ar_resolver_scoped_cache.html" title="Helper object for managing asset resolver cache scopes.">ArResolverScopedCache</a> instead of calling this function directly.</p>
<p>Resolvers may fill <code>cacheScopeData</code> with arbitrary data. Clients may also pass in a <code>cacheScopeData</code> populated by an earlier call to BeginCacheScope to allow the resolver access to that information.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ar_resolver_scoped_cache.html" title="Helper object for managing asset resolver cache scopes.">ArResolverScopedCache</a> </dd></dl>

</div>
</div>
<a id="a85ae1972e7c5791b3155ec04c213d29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ae1972e7c5791b3155ec04c213d29d">&#9670;&nbsp;</a></span>BindContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API void BindContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> *&#160;</td>
          <td class="paramname"><em>bindingData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the given context to this resolver. </p>
<p>Clients should generally use <a class="el" href="class_ar_resolver_context_binder.html" title="Helper object for managing the binding and unbinding of ArResolverContext objects with the asset reso...">ArResolverContextBinder</a> instead of calling this function directly.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ar_resolver_context_binder.html" title="Helper object for managing the binding and unbinding of ArResolverContext objects with the asset reso...">ArResolverContextBinder</a> </dd></dl>

</div>
</div>
<a id="a843b3ef2aacbedf6fe6f9deeb01696d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843b3ef2aacbedf6fe6f9deeb01696d7">&#9670;&nbsp;</a></span>CanWriteAssetToPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API bool CanWriteAssetToPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>whyNot</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if an asset may be written to the given <code>resolvedPath</code>, false otherwise. </p>
<p>If this function returns false and <code>whyNot</code> is not <code>nullptr</code>, it may be filled with an explanation. </p>

</div>
</div>
<a id="a5b165aaf701119f4b3bc26cdebd38b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b165aaf701119f4b3bc26cdebd38b93">&#9670;&nbsp;</a></span>CreateContextFromString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> CreateContextFromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>contextStr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> created from the primary <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> implementation using the given <code>contextStr</code>. </p>

</div>
</div>
<a id="a6f01bf8462bf0ec118187e200df7e362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f01bf8462bf0ec118187e200df7e362">&#9670;&nbsp;</a></span>CreateContextFromString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> CreateContextFromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uriScheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>contextStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> created from the <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> registered for the given <code>uriScheme</code> using the given <code>contextStr</code>. </p>
<p>An empty <code>uriScheme</code> indicates the primary resolver and is equivalent to CreateContextFromString(string).</p>
<p>If no resolver is registered for <code>uriScheme</code>, returns an empty <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a>.</p>
<dl class="section note"><dt>Note</dt><dd>'uriScheme' can be used to register IRI resolvers </dd></dl>

</div>
</div>
<a id="a37d32052831939332ecbff965ef94caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d32052831939332ecbff965ef94caf">&#9670;&nbsp;</a></span>CreateContextFromStrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> CreateContextFromStrings </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string, std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>contextStrs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> created by combining the <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> objects created from the given <code>contextStrs</code>. </p>
<p><code>contextStrs</code> is a list of pairs of strings. The first element in the pair is the URI/IRI scheme for the <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> that will be used to create the <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> from the second element in the pair. An empty resource identifier scheme indicates the primary resolver.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ar_resolver_context.html">ArResolverContext</a> ctx = <a class="code" href="ar_2resolver_8h.html#ab0913ebfd579684add6b59b44983a633">ArGetResolver</a>().<a class="code" href="class_ar_resolver.html#a37d32052831939332ecbff965ef94caf">CreateContextFromStrings</a>(</div><div class="line">   { {<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;context str 1&quot;</span>}, </div><div class="line">     {<span class="stringliteral">&quot;my-scheme&quot;</span>, <span class="stringliteral">&quot;context str 2&quot;</span>} });</div></div><!-- fragment --><p>This will use the primary resolver to create an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> using the string "context str 1" and use the resolver registered for the "my-scheme" URI/IRI scheme to create an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> using "context str 2". These contexts will be combined into a single <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> and returned.</p>
<p>If no resolver is registered for a URI/IRI scheme in an entry in <code>contextStrs</code>, that entry will be ignored. </p>

</div>
</div>
<a id="a1524962aa020859a589e786b1ad3c28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1524962aa020859a589e786b1ad3c28f">&#9670;&nbsp;</a></span>CreateDefaultContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> CreateDefaultContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> that may be bound to this resolver to resolve assets when no other context is explicitly specified. </p>
<p>The returned <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> will contain the default context returned by the primary resolver and all URI/IRI resolvers. </p>

</div>
</div>
<a id="a0a174a99676ff983a183d391973c7ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a174a99676ff983a183d391973c7ebe">&#9670;&nbsp;</a></span>CreateDefaultContextForAsset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> CreateDefaultContextForAsset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> that may be bound to this resolver to resolve the asset located at <code>assetPath</code> or referenced by that asset when no other context is explicitly specified. </p>
<p>The returned <a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a> will contain the default context for <code>assetPath</code> returned by the primary resolver and all URI/IRI resolvers. </p>

</div>
</div>
<a id="a68e5ae6385d1733b79f734c59682ff61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e5ae6385d1733b79f734c59682ff61">&#9670;&nbsp;</a></span>CreateIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API std::string CreateIdentifier </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>anchorAssetPath</em> = <code><a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an identifier for the asset specified by <code>assetPath</code>. </p>
<p>If <code>anchorAssetPath</code> is not empty, it is the resolved asset path that <code>assetPath</code> should be anchored to if it is a relative path. </p>

</div>
</div>
<a id="aabfb26c05d314299ddf596fc1defeb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfb26c05d314299ddf596fc1defeb6c">&#9670;&nbsp;</a></span>CreateIdentifierForNewAsset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API std::string CreateIdentifierForNewAsset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>anchorAssetPath</em> = <code><a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an identifier for a new asset specified by <code>assetPath</code>. </p>
<p>If <code>anchorAssetPath</code> is not empty, it is the resolved asset path that <code>assetPath</code> should be anchored to if it is a relative path. </p>

</div>
</div>
<a id="a266aaced9fc6decb4ae2ad884bd46517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266aaced9fc6decb4ae2ad884bd46517">&#9670;&nbsp;</a></span>EndCacheScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API void EndCacheScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> *&#160;</td>
          <td class="paramname"><em>cacheScopeData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the end of a resolution caching scope. </p>
<p>Clients should generally use <a class="el" href="class_ar_resolver_scoped_cache.html" title="Helper object for managing asset resolver cache scopes.">ArResolverScopedCache</a> instead of calling this function directly.</p>
<p><code>cacheScopeData</code> should contain the data that was populated by the previous corresponding call to BeginCacheScope.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ar_resolver_scoped_cache.html" title="Helper object for managing asset resolver cache scopes.">ArResolverScopedCache</a> </dd></dl>

</div>
</div>
<a id="a6078df1f5f1d1f4cf4d5b1411b7b88c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6078df1f5f1d1f4cf4d5b1411b7b88c8">&#9670;&nbsp;</a></span>GetAssetInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API <a class="el" href="class_ar_asset_info.html">ArAssetInfo</a> GetAssetInfo </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="class_ar_asset_info.html" title="Contains information about a resolved asset.">ArAssetInfo</a> populated with additional metadata (if any) about the asset at the given <code>assetPath</code>. </p>
<p><code>resolvedPath</code> is the resolved path computed for the given <code>assetPath</code>. </p>

</div>
</div>
<a id="a9e318a8e5693b4103d88443780c1fb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e318a8e5693b4103d88443780c1fb5a">&#9670;&nbsp;</a></span>GetCurrentContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> GetCurrentContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the asset resolver context currently bound in this thread. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ar_resolver.html#a85ae1972e7c5791b3155ec04c213d29d" title="Binds the given context to this resolver.">ArResolver::BindContext</a>, <a class="el" href="class_ar_resolver.html#a8aaa1f17eef5b4d8facae03cc70c54de" title="Unbind the given context from this resolver.">ArResolver::UnbindContext</a> </dd></dl>

</div>
</div>
<a id="ab8e1e7ab9dc4e2a390019b3b6384a504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e1e7ab9dc4e2a390019b3b6384a504">&#9670;&nbsp;</a></span>GetExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API std::string GetExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the file extension for the given <code>assetPath</code>. </p>
<p>The returned extension does not include a "." at the beginning. </p>

</div>
</div>
<a id="af0820bb01d47be4f215a661f061e2200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0820bb01d47be4f215a661f061e2200">&#9670;&nbsp;</a></span>GetModificationTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API <a class="el" href="class_ar_timestamp.html">ArTimestamp</a> GetModificationTimestamp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="class_ar_timestamp.html" title="Represents a timestamp for an asset.">ArTimestamp</a> representing the last time the asset at <code>assetPath</code> was modified. </p>
<p><code>resolvedPath</code> is the resolved path computed for the given <code>assetPath</code>. If a timestamp cannot be retrieved, return an invalid <a class="el" href="class_ar_timestamp.html" title="Represents a timestamp for an asset.">ArTimestamp</a>. </p>

</div>
</div>
<a id="ad616f0a0fc1e5dce08929604f3b95f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad616f0a0fc1e5dce08929604f3b95f8f">&#9670;&nbsp;</a></span>IsContextDependentPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API bool IsContextDependentPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>assetPath</code> is a context-dependent path, false otherwise. </p>
<p>A context-dependent path may result in different resolved paths depending on what asset resolver context is bound when Resolve is called. Assets located at the same context-dependent path may not be the same since those assets may have been loaded from different resolved paths. In this case, the assets' resolved paths must be consulted to determine if they are the same. </p>

</div>
</div>
<a id="a966c6fe671e427a7d8a01f9d068879a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966c6fe671e427a7d8a01f9d068879a7">&#9670;&nbsp;</a></span>IsRepositoryPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API bool IsRepositoryPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000059">Deprecated:</a></b></dt><dd>Returns true if the given path is a repository path.</dd></dl>

</div>
</div>
<a id="aa3a964db701e93c26fc8365ac98fb758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a964db701e93c26fc8365ac98fb758">&#9670;&nbsp;</a></span>OpenAsset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API std::shared_ptr&lt;<a class="el" href="class_ar_asset.html">ArAsset</a>&gt; OpenAsset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="class_ar_asset.html" title="Interface for accessing the contents of an asset.">ArAsset</a> object for the asset located at <code>resolvedPath</code>. </p>
<p>Returns an invalid std::shared_ptr if object could not be created.</p>
<p>The returned <a class="el" href="class_ar_asset.html" title="Interface for accessing the contents of an asset.">ArAsset</a> object provides functions for accessing the contents of the specified asset. </p>

</div>
</div>
<a id="a91c07b55b6807adb47805ff0037b6c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c07b55b6807adb47805ff0037b6c44">&#9670;&nbsp;</a></span>OpenAssetForWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API std::shared_ptr&lt;<a class="el" href="class_ar_writable_asset.html">ArWritableAsset</a>&gt; OpenAssetForWrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ar_resolver.html#a61d23b393fdc35f2f0e30a1ed566c76d">WriteMode</a>&#160;</td>
          <td class="paramname"><em>writeMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="class_ar_writable_asset.html" title="Interface for writing data to an asset.">ArWritableAsset</a> object for the asset located at <code>resolvedPath</code> using the specified <code>writeMode</code>. </p>
<p>Returns an invalid std::shared_ptr if object could not be created.</p>
<p>The returned <a class="el" href="class_ar_writable_asset.html" title="Interface for writing data to an asset.">ArWritableAsset</a> object provides functions for writing data to the specified asset.</p>
<p>Note that support for reading an asset through other APIs while it is open for write is implementation-specific. For example, writes to an asset may or may not be immediately visible to other threads or processes depending on the implementation. </p>

</div>
</div>
<a id="a6d9a29a4e375bbdafde5e6e3f836291a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9a29a4e375bbdafde5e6e3f836291a">&#9670;&nbsp;</a></span>RefreshContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API void RefreshContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refresh any caches associated with the given context. </p>
<p>If doing so would invalidate asset paths that had previously been resolved, an <a class="el" href="class_ar_notice_1_1_resolver_changed.html" title="Notice sent when asset paths may resolve to a different path than before due to a change in the resol...">ArNotice::ResolverChanged</a> notice will be sent to inform clients of this.</p>
<p>Avoid calling <a class="el" href="class_ar_resolver.html#a6d9a29a4e375bbdafde5e6e3f836291a" title="Refresh any caches associated with the given context.">RefreshContext()</a> on the same context from more than one thread concurrently as <a class="el" href="class_ar_notice_1_1_resolver_changed.html" title="Notice sent when asset paths may resolve to a different path than before due to a change in the resol...">ArNotice::ResolverChanged</a> notice listeners may mutate their state in response to receiving the notice.</p>
<p>Avoid calling <a class="el" href="class_ar_resolver.html#a6d9a29a4e375bbdafde5e6e3f836291a" title="Refresh any caches associated with the given context.">RefreshContext()</a> with a context that is active (bound to a resolver). Unbind the context before refreshing it.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_usd__page__multi_threading.html">Threading Model and Performance Considerations</a> </dd></dl>

</div>
</div>
<a id="a1b824f00c46b2a5001f492698fd8f5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b824f00c46b2a5001f492698fd8f5c1">&#9670;&nbsp;</a></span>Resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> Resolve </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the resolved path for the asset identified by the given <code>assetPath</code> if it exists. </p>
<p>If the asset does not exist, returns an empty <a class="el" href="class_ar_resolved_path.html" title="Represents a resolved asset path.">ArResolvedPath</a>. </p>

</div>
</div>
<a id="ae9bdf8eab4d4ebf70a0d2df3727ff9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bdf8eab4d4ebf70a0d2df3727ff9b8">&#9670;&nbsp;</a></span>ResolveForNewAsset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API <a class="el" href="class_ar_resolved_path.html">ArResolvedPath</a> ResolveForNewAsset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assetPath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the resolved path for the given <code>assetPath</code> that may be used to create a new asset. </p>
<p>If such a path cannot be computed for <code>assetPath</code>, returns an empty <a class="el" href="class_ar_resolved_path.html" title="Represents a resolved asset path.">ArResolvedPath</a>.</p>
<p>Note that an asset might or might not already exist at the returned resolved path. </p>

</div>
</div>
<a id="a8aaa1f17eef5b4d8facae03cc70c54de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aaa1f17eef5b4d8facae03cc70c54de">&#9670;&nbsp;</a></span>UnbindContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AR_API void UnbindContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ar_resolver_context.html">ArResolverContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vt_value.html">VtValue</a> *&#160;</td>
          <td class="paramname"><em>bindingData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unbind the given context from this resolver. </p>
<p>Clients should generally use <a class="el" href="class_ar_resolver_context_binder.html" title="Helper object for managing the binding and unbinding of ArResolverContext objects with the asset reso...">ArResolverContextBinder</a> instead of calling this function directly.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ar_resolver_context_binder.html" title="Helper object for managing the binding and unbinding of ArResolverContext objects with the asset reso...">ArResolverContextBinder</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a50c0a0a7bc7b939f4a44fd4baf26a7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c0a0a7bc7b939f4a44fd4baf26a7b5">&#9670;&nbsp;</a></span>usd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abs path to model usd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an identifier for the asset at the given <code>assetPath</code>. </p>
<p>See <a class="el" href="class_ar_resolver.html#ArResolver_identifier">Identifiers</a> for more information.</p>
<p>If <code>anchorAssetPath</code> is non-empty, it should be used as the anchoring asset if <code>assetPath</code> is relative. For example, for a filesystem-based implementation _CreateIdentifier might return:</p>
<p>_CreateIdentifier( /* assetPath = </p>

<p class="definition">Definition at line <a class="el" href="ar_2resolver_8h_source.html#l00446">446</a> of file <a class="el" href="ar_2resolver_8h_source.html">resolver.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pxr/usd/ar/<a class="el" href="ar_2resolver_8h_source.html">resolver.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_ar_resolver.html">ArResolver</a></li>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:58 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>