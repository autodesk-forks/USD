<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="_usd__page__value_clips" kind="page">
    <compoundname>Usd_Page_ValueClips</compoundname>
    <title>Sequencable, Re-timable Animated &quot;Value Clips&quot;</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<sect1 id="_usd__page__value_clips_1Usd_ValueClips_Overview">
<title>Overview</title>
<para>USD&apos;s <ulink url="http://openusd.org/docs/USD-Glossary.html#USDGlossary-CompositionArcs">composition arcs</ulink> allow timeSampled animation to be assembled from a variety of sources into a single composition. However, because stage composition must not (for scalability) take time into account when &quot;indexing&quot; layers, the value resolution behavior we are able to provide for layers reached through composition arcs stipulates that the first (strongest) layer that contains <emphasis>any</emphasis> timeSample for an attribute is the source of <emphasis>all</emphasis> timeSamples for the attribute. For many uses of USD this is sufficient, and additionally flexible because each Reference and SubLayer can specify a constant <ref refid="class_sdf_layer_offset" kindref="compound">time offset and scale</ref> to be applied to the referenced or sublayered timeSamples. However, sometimes more flexibility is required!</para>
<para>The USD Value Clips feature allows users to decompose time-varying data across many layers that can then be sequenced and re-sequenced back together in flexible ways. This feature is purely a <ref refid="_usd__page__properties_of_scene_description_1Usd_ValueResolution" kindref="member">value resolution</ref> -level feature, not a composition-level feature. Value clips allow users to retime sequences in various ways. This allows users to reuse a set of value clips in different scenarios, with only the sequencing metadata changing. At Pixar, we have found value clips useful for efficiently animating medium to large crowds, and for representing very large, simulated effects. For more detail on these use cases, see the <ulink url="http://openusd.org/docs/USD-Glossary.html#USDGlossary-ValueClips">glossary entry for Value Clips</ulink>.</para>
<para>At a very high level, value clips consume special metadata on a <ref refid="class_usd_prim" kindref="compound">prim</ref>, indicating:<itemizedlist>
<listitem><para>the targeted &quot;clip&quot; layers (which are <ulink url="http://openusd.org/docs/USD-Glossary.html#USDGlossary-Asset">assets</ulink>) to be sequenced</para>
</listitem><listitem><para>the intervals over which each clip is active</para>
</listitem><listitem><para>how &quot;stage time&quot; maps into each clip</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="_usd__page__value_clips_1Usd_ValueClips_Terminology">
<title>Terminology</title>
<para>Before going further, let&apos;s establish some terminology:</para>
<para><itemizedlist>
<listitem><para><bold>Value Clip</bold>: An individual <ref refid="class_sdf_layer" kindref="compound">layer</ref> containing time varying data over some interval. <bold>All metadata, relationships, and <ulink url="http://openusd.org/docs/USD-Glossary.html#USDGlossary-DefaultValue">default values</ulink> present in a layer are ignored when the layer is consumed as a Value Clip.</bold></para>
</listitem><listitem><para><bold>Clip Set</bold>: A named set of value clips defined by a group of clip metadata. A prim may have multiple clip sets.</para>
</listitem><listitem><para><bold>Clip Metadata</bold>: A set of prim-level metadata which control USD&apos;s value resolution semantics.</para>
</listitem><listitem><para><bold>Clip Manifest</bold>: An individual layer that declares the attributes that have time samples in a clip set&apos;s value clips. An attribute must be declared in the manifest in order for value clips to be considered when resolving values for that attribute.</para>
</listitem><listitem><para><anchor id="_usd__page__value_clips_1Usd_ValueClips_AnchorPoint"/><bold>Anchor Point</bold>: The strongest layer in which either <emphasis>assetPaths</emphasis> or <emphasis>templateAssetPath</emphasis> is authored for a given clip set. This determines the strength of clips with respect to value resolution, see <ref refid="_usd__page__value_clips_1Usd_ValueClips_ClipValueResolution" kindref="member">Value Resolution Semantics</ref> for details.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="_usd__page__value_clips_1Usd_ValueClips_ClipSets">
<title>Clip Sets</title>
<para>A &quot;clip set&quot; is a named group of value clips. The set of value clips along with sequencing and timing information and other value resolution behaviors are specified in the clip set&apos;s definition metadata.</para>
<para>In this example, the prim &quot;Prim&quot; has two clip sets, &quot;clip_set_1&quot; and &quot;clip_set_2&quot;, each with a different definition:</para>
<para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;Prim&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>clips<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dictionary<sp/>clip_set_1<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double2[]<sp/>active<sp/>=<sp/>[(101,<sp/>0),<sp/>(102,<sp/>1),<sp/>(103,<sp/>2)]<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>asset[]<sp/>assetPaths<sp/>=<sp/>[@./clip1.usda@,<sp/>@./clip2.usda@,<sp/>@./clip3.usda@]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>asset<sp/>manifestAssetPath<sp/>=<sp/>@./clipset1.manifest.usda@</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>string<sp/>primPath<sp/>=<sp/>&quot;/ClipSet1&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double2[]<sp/>times<sp/>=<sp/>[(101,<sp/>101),<sp/>(102,<sp/>102),<sp/>(103,<sp/>103)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dictionary<sp/>clip_set_2<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>string<sp/>templateAssetPath<sp/>=<sp/>&quot;clipset2.#.usd&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>templateStartTime<sp/>=<sp/>101</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>templateEndTime<sp/>=<sp/>103</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>templateStride<sp/>=<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>asset<sp/>manifestAssetPath<sp/>=<sp/>@./clipset2.manifest.usda@</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>string<sp/>primPath<sp/>=<sp/>&quot;/ClipSet2&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>clipSets<sp/>=<sp/>[&quot;clip_set_2&quot;,<sp/>&quot;clip_set_1&quot;]</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The clip set definitions are stored in a dictionary-valued metadata field named &quot;clips&quot;, which is composed according to the rules in <ref refid="_usd__page__datatypes_1Usd_Dictionary_Type" kindref="member">Dictionary-valued Metadata</ref>. This allows users to define clip sets in various layers and have them compose together, or sparsely override metadata in clip sets non-destructively.</para>
<para>Users can specify the clip set to author to when using the <ref refid="class_usd_clips_a_p_i" kindref="compound">UsdClipsAPI</ref> schema to author clip metadata. If no clip set is specified, <ref refid="class_usd_clips_a_p_i" kindref="compound">UsdClipsAPI</ref> will author to a clip set named &quot;default&quot;.</para>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_ClipSetOrdering">
<title>Strength Ordering</title>
<para>Clip sets authored on multiple prims are ordered by distance from the attribute. Clip sets authored on an attribute&apos;s owning prim are strongest, followed by those authored on the owning prim&apos;s parent, and so on.</para>
<para>Clip sets authored on a single prim are ordered lexicographically by name. However, users can control the strength ordering or even remove a clip set from consideration by specifying the ordering/membership in the <emphasis>clipSets</emphasis> list-op metadata field via <ref refid="class_usd_clips_a_p_i_1ac37319b58182e22e3839308377cf9155" kindref="member">UsdClipsAPI::SetClipSets</ref>.</para>
</sect2>
</sect1>
<sect1 id="_usd__page__value_clips_1Usd_ValueClips_Metadata">
<title>Clip Set Definitions</title>
<para>Clip sets may be defined using one of two possible forms: <emphasis>template</emphasis> and <emphasis>explicit</emphasis> metadata. Explicit metadata encodes the exact assets and sequence timings. Template metadata, on the other hand, authors a regex-style asset path template, and infers the explicit metadata when a <ref refid="class_usd_stage" kindref="compound">UsdStage</ref> is opened. Template metadata is strictly less powerful than explicit metadata (it can&apos;t achieve behaviors such as looping, reversing, or holding clip data), but provides an extremely compact and easy to debug encoding for situations in which animation is broken up into a large number of regularly named files. Regardless of which form a value clip application takes, there are also a set of &quot;universal&quot; metadata common to both.</para>
<para><itemizedlist>
<listitem><para>Universal Clip Metadata<itemizedlist>
<listitem><para><emphasis>primPath</emphasis> <itemizedlist>
<listitem><para>A prim path (<ref refid="class_sdf_path" kindref="compound">SdfPath</ref>) that will be substituted for the stage prim&apos;s path when querying data in the clips. For instance, let&apos;s say clip metadata is authored on prim &apos;/Prim_1&apos;, and <emphasis>primPath</emphasis> is &apos;/Prim&apos;. If we want to get values for the attribute &apos;/Prim_1.size&apos;, we will substitute &apos;/Prim&apos; for &apos;/Prim_1&apos;, yielding &apos;/Prim.size&apos;. This is the path that will be used to look for values in each clip.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><emphasis>manifestAssetPath</emphasis> <itemizedlist>
<listitem><para>An asset path (<ref refid="class_sdf_asset_path" kindref="compound">SdfAssetPath</ref>) representing the path to a layer that contains an index of the attributes with time samples authored in the set of clips. See <ref refid="_usd__page__value_clips_1Usd_ValueClips_ClipManifest" kindref="member">Clip Manifest</ref> for more details.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><emphasis>interpolateMissingClipValues</emphasis> <itemizedlist>
<listitem><para>A boolean flag indicating whether values for clips that do not have authored time samples for attributes in the manifest should be interpolated from surrounding clips. See <ref refid="_usd__page__value_clips_1Usd_ValueClips_ClipValueResolution_InterpolatingGaps" kindref="member">Interpolating Missing Values in Clip Set</ref> for more details.</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>Explicit Clip Metadata<itemizedlist>
<listitem><para><emphasis>assetPaths</emphasis> <itemizedlist>
<listitem><para>An ordered list of asset paths to the clips holding time varying data.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><emphasis>active</emphasis> <itemizedlist>
<listitem><para>A list of pairs of the form (stageTime, assetIndex) representing when a particular clip in <emphasis>assetPaths</emphasis> is active and should be considered during value resolution. See <ref refid="_usd__page__value_clips_1Usd_ValueClips_ActiveClips" kindref="member">Active Clips</ref> for more details.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><emphasis>times</emphasis> <itemizedlist>
<listitem><para>A list of pairs of the form (stageTime, clipTime) representing the mapping from stage time to clip time, for whichever clip is active at the given stage time. Note that every unique stageTime in this list will be in the list of time samples obtained by calling <ref refid="class_usd_attribute_1a0aba275933a77f28ab44b750964aa9a2" kindref="member">UsdAttribute::GetTimeSamples()</ref> . See <ref refid="_usd__page__value_clips_1Usd_ValueClips_TimeMapping" kindref="member">Stage Times and Clip Times</ref> for more details.</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>Template Clip Metadata<itemizedlist>
<listitem><para><emphasis>templateAssetPath</emphasis> <itemizedlist>
<listitem><para>A regex-esque template string representing the form of our asset paths&apos; names. This can be of two forms: &apos;path/basename.###.usd&apos; and &apos;path/basename.###.###.usd&apos;. These represent integer stage times and sub-integer stage times respectively. In both cases the number of hashes in each section is variable, and indicates to USD how much padding to apply when looking for asset paths. Note that USD is strict about the format of this string: there must be exactly one or two groups of hashes, and if there are two, they must be adjacent, separated by a dot.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><emphasis>templateStartTime</emphasis> <itemizedlist>
<listitem><para>The (double precision float) first number to substitute into our template asset path. For example, given &apos;path/basename.###.usd&apos; as a template string, and 12 as a template start time, USD will populate the internal asset path list with &apos;path/basename.012.usd&apos; as its first element, if it resolves to a valid identifier through the active <ref refid="class_ar_resolver" kindref="compound">ArResolver</ref> . If the template asset path represents integer frames and the start time has a fractional component, USD will truncate this to an integer.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><emphasis>templateEndTime</emphasis> <itemizedlist>
<listitem><para>The (double precision float) last number to substitute into our template string. If the template asset path represents integer frames and the end time has a fractional component, USD will truncate this to an integer.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><emphasis>templateStride</emphasis> <itemizedlist>
<listitem><para>A (double precision float) number indicating the stride at which USD will increment when looking for files to resolve. For example, given a start time of 12, an end time of 25, a template string of &apos;path/basename.#.usd&apos;, and a stride of 6, USD will look to resolve the following paths: &apos;path/basename.12.usd&apos;, &apos;path/basename.18.usd&apos; and &apos;path/basename.24.usd&apos;.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><emphasis>templateActiveOffset</emphasis> <itemizedlist>
<listitem><para>An optional (double precision float) number indicating the offset USD will use when calculating the clipActive value.</para>
</listitem><listitem><para>Given a start time of 101, an endTime of 103, a stride of 1, and an offset of 0.5, USD will generate the following:<itemizedlist>
<listitem><para>times = [(100.5,100.5), (101,101), (102,102), (103,103), (103.5,103.5)]</para>
</listitem><listitem><para>active = [(101.5, 0), (102.5, 1), (103.5, 2)]</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>Note that USD generates two additional clip time &apos;knots&apos; on the ends of the clipTime array. This allows users to query time samples outside the start/end range based on the absolute value of their offset.</para>
</listitem><listitem><para>Note that templateActiveOffset cannot exceed the absolute value of templateStride.</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
<para><simplesect kind="warning"><para>In the case where both explicit clip metadata and template clip metadata are authored, USD will prefer the explicit metadata for composition.</para>
</simplesect>
USD provides schema level support for authoring this metadata via <ref refid="class_usd_clips_a_p_i" kindref="compound">UsdClipsAPI</ref>. This gives a typesafe way to interact with the relevant metadata as well as various helper functions.</para>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_Metadata_TemplateClips">
<title>Template Clip Metadata</title>
<para>If a clip set is defined using template clip metadata, USD will use that data to derive the explicit clip metadata with the following logic:</para>
<para><itemizedlist>
<listitem><para>The set of explicit asset paths (<emphasis>assetPaths</emphasis>) is derived by taking the template pattern (<emphasis>templateAssetPath</emphasis>) and substituting times from <emphasis>templateStartTime</emphasis> to <emphasis>templateEndTime</emphasis>, incrementing by <emphasis>templateStride</emphasis>.</para>
</listitem><listitem><para>Once the set of relevant asset paths has been determined. The <emphasis>times</emphasis> and <emphasis>active</emphasis> metadata can be derived. For each time t specified in each derived assetPath, the time (t, t) will be authored; similarly, the active (t, n) will be authored, where n represents the index of the derived assetPath. If <emphasis>templateActiveOffset</emphasis> is specified, it will be applied to the <emphasis>times</emphasis> and <emphasis>active</emphasis> derivation as described in the previous section.</para>
</listitem></itemizedlist>
</para>
</sect2>
</sect1>
<sect1 id="_usd__page__value_clips_1Usd_ValueClips_ActiveClips">
<title>Active Clips</title>
<para>The entries in the <emphasis>active</emphasis> metadata determine when a particular clip is active. Value resolution will retrieve values from the active clip at a given time.</para>
<para>A (stageTime, assetIndex) entry indicates that the clip in the <emphasis>assetPaths</emphasis> metadata at position <emphasis>assetIndex</emphasis> is active from time <emphasis>stageTime</emphasis> up to the <emphasis>stageTime</emphasis> of the next entry in the list. As special cases, the first clip in the <emphasis>active</emphasis> metadata is also considered active for all earlier times, and the last clip is considered active for all later times.</para>
<para>For example, given: <programlisting><codeline><highlight class="normal">asset[]<sp/>assetPaths<sp/>=<sp/>[<sp/>\@foo.usd\@,<sp/>\@bar.usd\@,<sp/>\@baz.usd\@<sp/>]</highlight></codeline>
<codeline><highlight class="normal">double2[]<sp/>active<sp/>=<sp/>[<sp/>(101,<sp/>0),<sp/>(105,<sp/>1),<sp/>(110,<sp/>2)<sp/>]</highlight></codeline>
</programlisting></para>
<para>Clip &quot;foo.usd&quot; is considered active in the time range [-inf, 105), &quot;bar.usd&quot; is active in the time range [105, 110), and baz.usd is active in the time range [110, +inf).</para>
</sect1>
<sect1 id="_usd__page__value_clips_1Usd_ValueClips_TimeMapping">
<title>Stage Times and Clip Times</title>
<para>Conceptually, the (stageTime, clipTime) entries in the <emphasis>times</emphasis> metadata define a timing curve that specifies the time in the active clip to retrieve samples from when requesting an attribute&apos;s value at a given stage time. This timing curve is made up of linear segments whose endpoints are specified by the entries in <emphasis>times</emphasis>, sorted by stageTime. (see <ref refid="_usd__page__value_clips_1Usd_ValueClips_TimeOrdering" kindref="member">Ordering</ref>)</para>
<para>For example, given this <emphasis>times</emphasis> metadata:</para>
<para><programlisting><codeline><highlight class="normal">double2[]<sp/>times<sp/>=<sp/>[(0,<sp/>5),<sp/>(10,<sp/>15)]</highlight></codeline>
</programlisting></para>
<para>When an attribute value at time 0 is requested, <ref refid="class_usd_stage" kindref="compound">UsdStage</ref> will retrieve the time sample value authored at time 5 in the active clip, and at time 10 <ref refid="class_usd_stage" kindref="compound">UsdStage</ref> will ask for the value authored at time 15. As mentioned above, these entries are the endpoints for a linear segment in the timing curve, so times between these entries will be linearly interpolated. For example, requesting an attribute value at time 3 will cause <ref refid="class_usd_stage" kindref="compound">UsdStage</ref> to ask for the value authored at time 8 in the active clip.</para>
<para>The <emphasis>times</emphasis> metadata can be used to offset and scale animation from clips, providing flexibility in how they are applied to the stage.</para>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_Discontinuities">
<title>Jump Discontinuities</title>
<para>Jump discontinuities in the timing curve can be represented in the <emphasis>times</emphasis> metadata by authoring two entries with the same stage time, but different clip times. The clip time in the left-most entry is used for time mappings up to the specified stage time, while the clip time in the right-most entry is used for time mappings at that stage time and afterwards.</para>
<para>For example, let&apos;s say you had two clips and wanted to use animation from times 0 to 10 in the first clip followed by times 25 to 35 in the second clip. This could be specified with the <emphasis>active</emphasis> and <emphasis>times</emphasis> metadata like this:</para>
<para><programlisting><codeline><highlight class="normal">double2[]<sp/>active<sp/>=<sp/>[(0,<sp/>0),<sp/>(10,<sp/>1)]</highlight></codeline>
<codeline><highlight class="normal">double2[]<sp/>times<sp/>=<sp/>[(0,<sp/>0),<sp/>(10,<sp/>10),<sp/>(10,<sp/>25),<sp/>(20,<sp/>35)]</highlight></codeline>
</programlisting></para>
<para>A jump discontinuity has been specified at stage time 10. For times in the range [0, 10), <ref refid="class_usd_stage" kindref="compound">UsdStage</ref> will retrieve values from the first clip at times [0, 10). For times in the range [10, 20], <ref refid="class_usd_stage" kindref="compound">UsdStage</ref> will retrieve values from the second clip at times [25, 35].</para>
<para>See <ref refid="_usd__page__value_clips_1Usd_ValueClips_ClipBehaviorsLooping" kindref="member">Looping</ref> for a common use-case for this functionality.</para>
</sect2>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_TimeOrdering">
<title>Ordering</title>
<para>A given stageTime may appear at most twice in the <emphasis>times</emphasis> metadata. In the typical case, a stageTime will only appear once; the only time it may appear twice is to specify a jump discontinuity (see <ref refid="_usd__page__value_clips_1Usd_ValueClips_Discontinuities" kindref="member">Jump Discontinuities</ref>).</para>
<para>USD will perform a stable sort of the <emphasis>times</emphasis> metadata by stageTime to establish the timing curve described above. This means the order of the entries authored in <emphasis>times</emphasis> does not matter, except for jump discontinuities: the left-most entry with a given stageTime represents the left side of the discontinuity and the right-most entry represents the right side.</para>
</sect2>
</sect1>
<sect1 id="_usd__page__value_clips_1Usd_ValueClips_ClipManifest">
<title>Clip Manifest</title>
<para>The clip manifest is a <ref refid="class_sdf_layer" kindref="compound">layer</ref> that declares the attributes that have time samples in the value clips for the associated clip set. This serves as an index that allows value resolution to determine whether an attribute has time samples in a clip set without having to examine every value clip.</para>
<para>If a clip set&apos;s value clips contain data for an attribute, that attribute <emphasis>must</emphasis> be declared in the manifest. Otherwise, that data will be ignored.</para>
<para>Each clip set has one manifest which may be specified via the <emphasis>manifestAssetPath</emphasis> metadata. If no manifest is specified, USD will generate one automatically at runtime. See <ref refid="_usd__page__value_clips_1Usd_ValueClips_GeneratingManifest" kindref="member">Generating a Manifest</ref> for more details.</para>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_ManifestFormat">
<title>What Data Is In a Manifest?</title>
<para>In its simplest form, the clip manifest just contains declarations for attributes. For example,</para>
<para><table rows="4" cols="2"><row>
<entry thead="yes"><para>Clip 1 </para>
</entry><entry thead="yes"><para>Clip 2  </para>
</entry></row>
<row>
<entry thead="no"><para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;Model&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>attr.timeSamples<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0:<sp/>100</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>&quot;Child&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>childAttr.timeSamples<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0:<sp/>200</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>  </para>
</entry><entry thead="no"><para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;Model&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>attr.timeSamples<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1:<sp/>200</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>&quot;Child&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>childAttr.timeSamples<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1:<sp/>300</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>   </para>
</entry></row>
<row>
<entry thead="yes"><para>Manifest  </para>
</entry></row>
<row>
<entry thead="no"><para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;Model&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>attr</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>&quot;Child&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>childAttr</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>  </para>
<para></para>
</entry></row>
</table>
</para>
<para>Like value clips, metadata, relationships, and composition arcs in the manifest are ignored. Attributes in the manifest may have default values or time samples containing value blocks. See <ref refid="_usd__page__value_clips_1Usd_ValueClips_ClipValueResolution" kindref="member">Value Resolution Semantics</ref> for how these values may be used.</para>
</sect2>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_GeneratingManifest">
<title>Generating a Manifest</title>
<para>The Usd and Sdf authoring APIs can be used to manually create a manifest. For convenience, clients can use <ref refid="class_usd_clips_a_p_i_1a308ef3fe936c3a5ac968082041c10370" kindref="member">UsdClipsAPI::GenerateClipManifest</ref> or <ref refid="class_usd_clips_a_p_i_1a674432c0e7a2771436d5f4c55aa5e45d" kindref="member">UsdClipsAPI::GenerateClipManifestFromLayers</ref> to generate a manifest from a given clip set or set of clip layers.</para>
<para>If a clip set does not have a manifest specified, USD will automatically generate a manifest at runtime from the value clips in the clip set using the methods described above. This is convenient but imposes the extra cost of opening and traversing every clip layer. To avoid this cost, you can use the <ref refid="class_usd_clips_a_p_i" kindref="compound">UsdClipsAPI</ref> methods above to generate a clip manifest, save it out, and then set that as the clip set&apos;s manifest via UsdClipsAPI::SetManifestAssetPath.</para>
</sect2>
</sect1>
<sect1 id="_usd__page__value_clips_1Usd_ValueClips_ClipValueResolution">
<title>Value Resolution Semantics</title>
<para>A clip set may provide values for attributes on the prim on which the clip set is defined and any attributes on descendants of that prim. It is important to note that value clips do <emphasis>not</emphasis> define attributes on a <ref refid="class_usd_stage" kindref="compound">UsdStage</ref>, they just provide values. If a clip set has values for an attribute but that attribute is not defined on the <ref refid="class_usd_stage" kindref="compound">UsdStage</ref> (for example, the attribute is not a built-in attribute of a schema), the clip set will not cause the attribute to come into existence.</para>
<para>The <emphasis>strength</emphasis> of data in a set of value clips is based on the <ref refid="_usd__page__value_clips_1Usd_ValueClips_AnchorPoint" kindref="member">anchor point</ref>. The clip data is just weaker than the &quot;Local&quot; (L in <ulink url="http://openusd.org/docs/USD-Glossary.html#USDGlossary-LIVRPSStrengthOrdering">LIVRPS</ulink>) data of the anchoring layer. Clip data can be overridden by adding overrides to a stronger layer or in a local opinion, just as for any other kind of data.</para>
<para>During attribute value resolution, if clip sets are defined on the attribute&apos;s owning prim or any ancestors, USD will do the following:</para>
<para><itemizedlist>
<listitem><para>Determine the path we will consult within clip layers when looking for values. The path will be constructed using the attribute&apos;s path within the local LayerStack, with a prefix substitution based on the clipset&apos;s <emphasis>primPath</emphasis> metadata. <bold>Please note that this implies that composition arcs are ignored within clip files, i.e. all data must be recorded directly, not inside variants or across reference arcs.</bold></para>
</listitem><listitem><para>Find the strongest clip set that has the attribute at the above path declared in the manifest. This involves looking at the clip sets authored on the attribute&apos;s owning prim as well as that prim&apos;s ancestors. See <ref refid="_usd__page__value_clips_1Usd_ValueClips_ClipSetOrdering" kindref="member">Strength Ordering</ref> for more details.</para>
</listitem><listitem><para>If no clip set is found, end clip value resolution and move to the next data source in the LIVRPS strength ordering.</para>
</listitem><listitem><para>Query the clip set for the attribute value at the specified time. This &quot;external&quot; time will be mapped to the &quot;internal&quot; time of the clip set using the <emphasis>times</emphasis> metadata. The active clip will be opened and queried using this &quot;internal&quot; time. See <ref refid="_usd__page__value_clips_1Usd_ValueClips_ActiveClips" kindref="member">Active Clips</ref> and <ref refid="_usd__page__value_clips_1Usd_ValueClips_TimeMapping" kindref="member">Stage Times and Clip Times</ref> for more details.</para>
</listitem><listitem><para>If an authored time sample at the &quot;internal&quot; time is found in the active clip, that is the final value. If there is no sample at that time, but there are other samples in the active time range of the clip, the final value will be interpolated from those samples. See <ref refid="_usd__page__value_clips_1Usd_ValueClips_ClipValueResolution_Gaps" kindref="member">Missing Values in Clip Set</ref> and <ref refid="_usd__page__value_clips_1Usd_ValueClips_ClipValueResolution_InterpolatingGaps" kindref="member">Interpolating Missing Values in Clip Set</ref> for the behavior when the active clip does not have any authored time samples.</para>
</listitem></itemizedlist>
</para>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_ClipValueResolution_Gaps">
<title>Missing Values in Clip Set</title>
<para>A clip set has &quot;gaps&quot; if some of the value clips in the set do not contain authored time samples for an attribute that has been declared in the manifest.</para>
<para>By default, if a value clip does not contain time samples for an attribute, a time sample at the clip&apos;s <emphasis>active</emphasis> time will be generated using the default value for the attribute authored in the clip manifest. If no default value has been authored, the fallback value for the attribute&apos;s data type will be a value block.</para>
<para>In the example below, the value for /TestModel.a at time 2 will be 10.0 since clip2.usd does not have time samples for this attribute and 10.0 is the default value authored in the manifest. The value for /TestModel.b at time 2 will be a value block, since no default is authored in the manifest.</para>
<para><table rows="6" cols="3"><row>
<entry thead="yes"><para>clip1.usd </para>
</entry><entry thead="yes"><para>clip2.usd </para>
</entry><entry thead="yes"><para>clip3.usd  </para>
</entry></row>
<row>
<entry thead="no"><para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;Model&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>a.timeSamples<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1:<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>b.timeSamples<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1:<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>  </para>
</entry><entry thead="no"><para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;Model&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>  </para>
</entry><entry thead="no"><para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;Model&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>a.timeSamples<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>3:<sp/>3</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>b.timeSamples<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>3:<sp/>3</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>   </para>
</entry></row>
<row>
<entry thead="yes"><para>manifest.usd  </para>
</entry></row>
<row>
<entry thead="no"><para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;Model&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>a<sp/>=<sp/>10.0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>b</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>   </para>
</entry></row>
<row>
<entry thead="yes"><para>stage.usd  </para>
</entry></row>
<row>
<entry thead="no"><para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;TestModel&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>clips<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dictionary<sp/>default<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double2[]<sp/>active<sp/>=<sp/>[(1,<sp/>0),<sp/>(2,<sp/>1),<sp/>(3,<sp/>2)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>asset[]<sp/>assetPaths<sp/>=<sp/>[@./clip1.usd@,<sp/>@./clip2.usd@,<sp/>@./clip3.usd@]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>asset<sp/>manifestAssetPath<sp/>=<sp/>@./manifest.usd@</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>string<sp/>primPath<sp/>=<sp/>&quot;/Model&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>a</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>b</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>   </para>
</entry></row>
</table>
</para>
</sect2>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_ClipValueResolution_InterpolatingGaps">
<title>Interpolating Missing Values in Clip Set</title>
<para>The above behavior allows USD to avoid opening an arbitrary number of clips if a gap is encountered in the clip set and can be useful in some situations. For example, see <ref refid="_usd__page__value_clips_1Usd_ValueClips_AnimatedVisibility" kindref="member">Animated Visibility</ref>. However, in these cases USD can also optionally interpolate values based on the surrounding clips. This makes value clips behave like time samples split up into different files, which is more intuitive but comes at a performance cost.</para>
<para>This feature can be enabled for a clip set by setting <emphasis>interpolateMissingClipValues</emphasis> to true in a clip set definition. When enabled, if a query is made at a time when the clip set has a gap, and the attribute does not have a default value specified in the manifest, USD will search forward and backwards from the active clip at that time to find the nearest clips that contain authored time sample values. The final value will be interpolated from these time samples.</para>
<para>Note that in the pessimal case, this may wind up opening and querying all clips in the set. To accelerate this search, users can author time sample blocks in the manifest at the active time for each clip that does not have time samples for a given attribute. Value resolution will use this information to determine what clips have time samples without actually opening the clips themselves.</para>
<para>In the example below, the value for /TestModel.a at time 2 will be 2.0, which is interpolated from the time sample in clip1.usd at time 1 and the time sample in clip4.usd at time 4. Similarly, the value at time 3 will be 3.0. If <emphasis>interpolateMissingClipValues</emphasis> was not set to true, these values would be a value block instead.</para>
<para><table rows="6" cols="3"><row>
<entry thead="yes"><para>clip1.usd </para>
</entry><entry thead="yes"><para>clip2.usd / clip3.usd </para>
</entry><entry thead="yes"><para>clip4.usd  </para>
</entry></row>
<row>
<entry thead="no"><para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;Model&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>a.timeSamples<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1:<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>  </para>
</entry><entry thead="no"><para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;Model&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>  </para>
</entry><entry thead="no"><para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;Model&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>a.timeSamples<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>4:<sp/>4</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>   </para>
</entry></row>
<row>
<entry thead="yes"><para>manifest.usd  </para>
</entry></row>
<row>
<entry thead="no"><para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;Model&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>a.timeSamples<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>2:<sp/>None,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>3:<sp/>None</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>   </para>
</entry></row>
<row>
<entry thead="yes"><para>stage.usd  </para>
</entry></row>
<row>
<entry thead="no"><para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;TestModel&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>clips<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dictionary<sp/>default<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double2[]<sp/>active<sp/>=<sp/>[(1,<sp/>0),<sp/>(2,<sp/>1),<sp/>(3,<sp/>2),<sp/>(4,<sp/>3)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>asset[]<sp/>assetPaths<sp/>=<sp/>[@./clip1.usd@,<sp/>@./clip2.usd@,<sp/>@./clip3.usd@,<sp/>@./clip4.usd@]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>asset<sp/>manifestAssetPath<sp/>=<sp/>@./manifest.usd@</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>string<sp/>primPath<sp/>=<sp/>&quot;/Model&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>interpolateMissingClipValues<sp/>=<sp/>true</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>a</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>   </para>
</entry></row>
</table>
</para>
</sect2>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_ClipValueResolution_LayerOffsets">
<title>Layer Offsets</title>
<para>Layer offsets affect value clips in the following ways:</para>
<para><itemizedlist>
<listitem><para>If using template metadata encoding:<itemizedlist>
<listitem><para>Layer offsets are applied to generated times and active metadata relative to the <ref refid="_usd__page__value_clips_1Usd_ValueClips_AnchorPoint" kindref="member">anchor point</ref>. Note that layer offsets will <emphasis>not</emphasis> affect the generated set of asset paths, as they are not applied to <emphasis>templateStartTime</emphasis>, <emphasis>templateEndTime</emphasis> and <emphasis>templateStride</emphasis>.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>If using explicit metadata encoding:<itemizedlist>
<listitem><para>Layer offsets are applied to <emphasis>times</emphasis> and <emphasis>active</emphasis> metadata relative to the strongest layer in which they were authored. Note that this layer may be different from the <ref refid="_usd__page__value_clips_1Usd_ValueClips_AnchorPoint" kindref="member">anchor point</ref>.</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
</sect2>
</sect1>
<sect1 id="_usd__page__value_clips_1Usd_ValueClips_AdditionalNotes">
<title>Additional Notes</title>
<para>The flexibility and reuse of animated data that clips provides does come with some performance characteristics with which pipeline builders may want to be familiar.</para>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_ClipDeferredLoading">
<title>Clip Layers Opened On-Demand</title>
<para>In Pixar use of clips, it is not uncommon for a single <ref refid="class_usd_stage" kindref="compound">UsdStage</ref> to consume thousands to tens of thousands of clip layers. If the act of opening a stage were to discover and open all of the layers consumed by clips, it would, in these cases, add considerable time and memory to the cost. Further, many clients of the stage (such as a single-frame render) only require data from a small time range, which generally translates to a small fraction of the total number of clip layers. Therefore, clip layers are opened lazily, <emphasis>only</emphasis> when value resolution must interrogate a particular clip. Of course, since USD supports value resolution in multiple threads concurrently, it means that resolving attributes affected by clips may require acquiring a lock that is unnecessary during &quot;normal&quot; value resolution, so there is some performance penalty.</para>
<para>Further, the broader the time interval over which an application extracts attribute values, the more layers that will be opened and cached (until the stage is closed). We deem this an acceptable cost since it is in keeping with our general principle of paying for what you use. The alternative would be adding a more sophisticated caching strategy to clip-layer retention that limits the number of cached layers; however, since the most memory-conscious clients (renderers) are generally unaffected, and the applications that do want to stream through time generally prioritize highest performance over memory consumption, we are satisfied with the caching strategy for now.</para>
</sect2>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_Flattening">
<title>Flattening</title>
<para>Flattening a <ref refid="class_usd_stage" kindref="compound">UsdStage</ref> with value clips will merge the appropriate time samples from the value clips into the time samples on the attribute on the flattened stage and remove the clip set definitions. Querying for time samples and values on the flattened stage should always give the same result as on the unflattened stage.</para>
</sect2>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_usdview">
<title>usdview</title>
<para><itemizedlist>
<listitem><para>Usdview supports value clip debugging through the layer stack viewer(lower left). When a particular attribute(who&apos;s value is held in a clip layer) is highlighted, the layer stack viewer will show which clip the value is coming from.</para>
</listitem><listitem><para>The metadata tab will display the value of each piece of metadata authored on the prim introducing clips.</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_usdstitchclips">
<title>usdstitchclips</title>
<para>The usdstitchclips utility will generate a stage that uses value clips to stitch together the time samples in a given set of clip layers. This utility will generate the necessary clip set definitions (using either explicit or template metadata) and also generate a topology layer defining the attributes and a manifest layer.</para>
<para>For example, given a directory containing three clip files clip.101.usd, clip.102.usd and clip.103.usd:</para>
<para><programlisting><codeline><highlight class="normal">$<sp/>usdstitchclips<sp/>--clipPath<sp/>/World/model<sp/>--out<sp/>result.usda<sp/>clip*</highlight></codeline>
</programlisting></para>
<para>Will generate the following result.usda: <programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal">(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>endTimeCode<sp/>=<sp/>103</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>startTimeCode<sp/>=<sp/>101</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>subLayers<sp/>=<sp/>[</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>@./result.topology.usda@</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>]</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">over<sp/>&quot;World&quot;<sp/></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>over<sp/>&quot;model&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clips<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dictionary<sp/>default<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double2[]<sp/>active<sp/>=<sp/>[(101,<sp/>0),<sp/>(102,<sp/>1),<sp/>(103,<sp/>2)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>asset[]<sp/>assetPaths<sp/>=<sp/>[@./101.usd@,<sp/>@./102.usd@,<sp/>@./103.usd@]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>asset<sp/>manifestAssetPath<sp/>=<sp/>@./result.topology.usda@</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>string<sp/>primPath<sp/>=<sp/>&quot;/World/model&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double2[]<sp/>times<sp/>=<sp/>[(101,<sp/>101),<sp/>(102,<sp/>102),<sp/>(103,<sp/>103)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>and the following result.topology.usd: <programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal">(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>endTimeCode<sp/>=<sp/>103</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>startTimeCode<sp/>=<sp/>101</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>upAxis<sp/>=<sp/>&quot;Z&quot;</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;World&quot;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>def<sp/>&quot;model&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>x</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>For generating template metadata:</para>
<para><programlisting><codeline><highlight class="normal">$<sp/>usdstitchclips<sp/>--clipPath<sp/>/World/model<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--templateMetadata</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--startTimeCode<sp/>101</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--endTimeCode<sp/>103</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--stride<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--templatePath<sp/>clip.#.usd</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--out<sp/>result.usda<sp/>clip*<sp/></highlight></codeline>
</programlisting></para>
<para>Will generate the following result.usda: <programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal">(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>endTimeCode<sp/>=<sp/>103</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>startTimeCode<sp/>=<sp/>101</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>subLayers<sp/>=<sp/>[</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>@./result.topology.usda@</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>]</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">def<sp/>&quot;World&quot;<sp/></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>over<sp/>&quot;model&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clips<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dictionary<sp/>default<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>string<sp/>templateAssetPath<sp/>=<sp/>&quot;clip.#.usd&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>templateStartTime<sp/>=<sp/>101</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>templateEndTime<sp/>=<sp/>103</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>templateStride<sp/>=<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>asset<sp/>manifestAssetPath<sp/>=<sp/>@./result.topology.usda@</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>string<sp/>primPath<sp/>=<sp/>&quot;/World/model&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_UsdUtils">
<title>UsdUtils Utility Functions</title>
<para>The UsdUtils library contains several utility functions for stitching together multiple layers using value clips in <ref refid="stitch_clips_8h" kindref="compound">usdUtils/stitchClips.h</ref>.</para>
</sect2>
</sect1>
<sect1 id="_usd__page__value_clips_1Usd_ValueClips_Examples">
<title>Examples</title>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_ClipBehaviorsLooping">
<title>Looping</title>
<para>A common use case is to loop over animation authored in a clip or set of clips. For example, at Pixar clips containing a handful of frames of keep-alive animation are applied to background characters with looping so they remain in motion throughout an entire shot.</para>
<para>Looping can be specified using the <emphasis>times</emphasis> metadata and jump discontinuities (see <ref refid="_usd__page__value_clips_1Usd_ValueClips_TimeMapping" kindref="member">Stage Times and Clip Times</ref>) This example shows 25 frames of animation from a clip being looped on the <ref refid="class_usd_stage" kindref="compound">UsdStage</ref> from time 0 to 25, then 25 to 50.</para>
<para><programlisting><codeline><highlight class="normal">#usda<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal">(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>endTimeCode<sp/>=<sp/>50</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>startTimeCode<sp/>=<sp/>1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>subLayers<sp/>=<sp/>[</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>@./shot.topology.usd@</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>]</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">over<sp/>&quot;World&quot;<sp/></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>over<sp/>&quot;Model&quot;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clips<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dictionary<sp/>default<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>asset<sp/>manifestAssetPath<sp/>=<sp/>@./shot.manifest.usd@</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>string<sp/>primPath<sp/>=<sp/>&quot;/World/Model&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>asset[]<sp/>assetPaths<sp/>=<sp/>[@./clip1.usd@]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double2[]<sp/>active<sp/>=<sp/>[(0,<sp/>0]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double2[]<sp/>times<sp/>=<sp/>[(0,<sp/>0),<sp/>(25,<sp/>25),<sp/>(25,<sp/>0),<sp/>(50,<sp/>25)]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>For proper looping, we want the <ref refid="class_usd_stage" kindref="compound">UsdStage</ref> to retrieve animation at all times in the range [0, 25) from the clip at times [0, 25). However, at exactly time 25 we want the <ref refid="class_usd_stage" kindref="compound">UsdStage</ref> to jump back to using animation in the clip at time 0. This is represented by a jump discontinuity at time 25. (See <ref refid="_usd__page__value_clips_1Usd_ValueClips_Discontinuities" kindref="member">Jump Discontinuities</ref> for more details.)</para>
<para>Note that we were able to achieve this solely through the metadata. No additional asset loads or restructuring needed to happen.</para>
<para><simplesect kind="warning"><para>Note that this supposes that the final frame and the first frame of the clip transitions smoothly.</para>
</simplesect>
</para>
</sect2>
<sect2 id="_usd__page__value_clips_1Usd_ValueClips_AnimatedVisibility">
<title>Animated Visibility</title>
<para>Value clips are used at Pixar to stitch together the results of simulators or procedural generation tools like Houdini that are run in parallel for each frame of a shot or effect. There are often situations where geometry data (e.g. points) are generated for some of the frames but not others. In these cases we would like to set the &quot;visibility&quot; attribute to &quot;invisible&quot; at the times where no geometry was generated. However, since the processes for these times didn&apos;t generate any geometry and are being run independently from the other times, they don&apos;t know where to author the &quot;visibility&quot; attribute to achieve this.</para>
<para>To solve this, we use the fact that value clips will use the default value authored in the manifest if no value is authored in a clip. (See <ref refid="_usd__page__value_clips_1Usd_ValueClips_ClipValueResolution_Gaps" kindref="member">Missing Values in Clip Set</ref>). In the manifest, we author a default value of &quot;invisible&quot; for the &quot;visibility&quot; attribute. Then, if the processes that generate the value clips write out any geometry data, they also write out a time sample for the &quot;visibility&quot; attribute making the prim visible at that time. If they do not write out geometry, they don&apos;t write out the &quot;visibility&quot; attribute. This makes value resolution use the &quot;invisible&quot; value for &quot;visibility&quot; at times when the clips have no geometry. </para>
</sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
